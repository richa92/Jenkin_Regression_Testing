*** Settings ***
Library				BuiltIn
Library		        SSHLibrary        
Library             String
Library             RoboGalaxyLibrary
Library             FusionLibrary
Library		        robot.api.logger
Library             Dialogs
Library				String
Library             copy

*** Variables ***
#${X-API-VERSION}              "300"              # X-API-VERSION
${APP_SSH_USERNAME}           root             
${APP_SSH_PASSWORD}           hpvse1
${APP_TIMEOUT}                600
${APP_PROMPT}                 #
${SERVER_SSH_USERNAME}        root
${SERVER_SSH_PASSWORD}        imageMgmt123


*** Keywords ***
# -----------------------------------------------------------------------------
#   FUSION BASH SHELL INTERFACE KEYWORDS
# -----------------------------------------------------------------------------
Login to Appliance via SSH
    [Documentation]             Connect to Appliance CIM Bash via SSH
    ...                         Example:\n| Login to Appliance Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}      ${USERNAME}=${APP_SSH_USERNAME}
    ...                         ${PASSWORD}=${APP_SSH_PASSWORD}    
    ...                         ${TIMEOUT}=${APP_TIMEOUT}    ${ALIAS}=APP_SSH
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}    
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    [Return]                    ${Id}
	
Login to Build Server via SSH
    [Documentation]             Connect to Appliance CIM Bash via SSH
    ...                         Example:\n| Login to Appliance Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}      ${USERNAME}=${SERVER_SSH_USERNAME}
    ...                         ${PASSWORD}=${SERVER_SSH_PASSWORD}    
    ...                         ${TIMEOUT}=${APP_TIMEOUT}    ${ALIAS}=APP_SSH
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}    
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    [Return]                    ${Id}
	
Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}={IP}	${timeout}=1 min	${interval}=5 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	setup-bringup-keywords.Appliance is pingable 	${appliance}

Appliance is pingable
	[Arguments]		${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	setup-bringup-keywords.Windows ping	${appliance}
	...	ELSE	Unix ping	${appliance}

Appliance is unreachable
    [Documentation]	Waits for an appliance to become unreachable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	 Windows ping unreachable check 	${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	Windows ping unreachable check	${appliance}
	
Windows ping
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    #setup-bringup-keywords.Log to console and logfile    ${Output}
    Should Contain    ${Output}    Reply from ${host}
	[Return]	${Output}
	
Windows ping unreachable check
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    #setup-bringup-keywords.Log to console and logfile    ${Output}
    Should Contain    ${Output}    unreachable
	[Return]	${Output}
	
Wait for appliance webapps to startup
    [Arguments]		${IP} 
    Set Log Level  TRACE
    Login to Appliance via SSH  ${IP}
	${output} =   Execute Command  /ci/bin/wait-for-cic
	Should Contain	${output}    done
	[Return]	${Output}
 
Is usb mounted on appliance
   [Arguments]		${IP} 
   Set Log Level  TRACE
   Login to Appliance via SSH  ${IP}
   ${output} =   Execute Command  cd /mnt/usb;echo $?
   Should Contain	${output}    0
   [Return]	 ${Output}
  
Do Dictionary copy
	[Documentation]   Override the Builtin.Copy Dictionary with deep copy
	[Arguments]	${obj}
	Log        Deep copy version!!!
	${obj} =   copy.deepcopy   ${obj}
    [Return]	${obj}

Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	Log to console and logfile  	\nAdding LICENSES
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}
	\		Run keyword if 		${resp['status_code']} != ${201}	    Log     Error adding License Key:${license['key']}   WARN

Add Racks from variable
	[Documentation]	Adds racks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${racks}
	Log to console and logfile  	\nAdding Racks
	:FOR	${rack}	IN	@{racks}
	\		${resp} = 	Fusion Api Add Rack		body=${rack}

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	Log to console and logfile  	\nAdding USERS
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	\nAdding ETHERNET NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	\nAdding FC NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	\nAdding FCOE NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	\nAdding NETWORK SETS
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}
	\		${nativeNetworkUri} = 	Run Keyword If 	'${net['nativeNetworkUri']}' != 'None'		Get Ethernet URI	${net['nativeNetworkUri']}
	\		Set To Dictionary 	${net}	nativeNetworkUri	${nativeNetworkUri}
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}   ${status_code}=${200}
	Log to console and logfile  	\nAdding RANGES
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
        \       ...                    ELSE IF 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	...                    ELSE IF 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range	body=${range}
        \       ...                    ELSE   Log     Invalid or unsupported category was found from range dictionary (category: ${category}).   WARN
	\	Run Keyword If 		${resp['status_code']} != ${status_code}	Log     Failed adding ranges for category ${category}   WARN
	[Return]	${resp}

Process InterconnectMapTemplate
    [Documentation]    Process InterconnectMapTemplate
	[Arguments]		${icmap}
	${l} = 	Get Length	${icmap['interconnectMapEntryTemplates']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	${permittedInterconnectTypeUri} = 	Get Interconnect Type URI	${permittedInterconnectTypeUri}
	\	Set to dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri		${permittedInterconnectTypeUri}
	[Return]	${icmap}

Add LIG from variable
	[Documentation]	Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ligx}    ${timeout}=60s    ${interval}=2s
	Log to console and logfile  	\nAdding LIG ${ligx['name']}
	${ligx} = 	Do Dictionary copy	${ligx}

    ${name} =                       Get Variable Value  ${ligx['name']}
	${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${ligx['fcoeSettings']}
	${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
	${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
	${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
	${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
	${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
	#${uplinkSets} = 	Copy List	${ligx['uplinkSets']}

	${l} = 	Get Length	${uplinkSets}
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	    ${networkUris}
	\   ${nativeNetworkUri} = 	Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri	${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}	nativeNetworkUri     ${nativeNetworkUri}

    # Process Internal URIs
	${internalNetworkUris} = 	Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris	${internalNetworkUris}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         fcoeSettings=${fcoeSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
	${resp} = 	Fusion Api Create LIG	${body}
	${task} =	Wait For Task	${resp}    ${timeout}	${interval}
	[Return]   ${task}

Add Enclosure Group from variable
	[Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${enc_group}
	Log to console and logfile  	\nAdding ENCLOSURE GROUP ${enc_group['name']}
	${l} = 	Get Length	${enc_group['interconnectBayMappings']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${liguri} = 	Get From Dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
	\   Continue For Loop If    '${liguri}' == 'None'
	\	@{words} = 	Split String	${liguri}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${liguri} = 	setup-bringup-keywords.Get LIG URI	${eg}
	\	Set to dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}
	${resp} =	Fusion Api Create Enclosure Group	${enc_group}
	[Return]   ${resp}
        
Common URI lookup by name
	[Documentation]	Takes a string containing URI type + : + resource name, performs a lookup and returns URI
	...				Ex:    ${uri} = 	Common Lookup by name	LIG:LIG1
	[Arguments]		${uri}
	@{words} = 	Split String	${uri}	:
	${type} = 	Get From List	${words}	0
	${name} = 	Get From List	${words}	1
	${uri} = 	Run Keyword If 	'${type}' == 'EG'		setup-bringup-keywords.Get Enclosure Group URI		${name}
	...         ELSE IF         '${type}' == 'ENC'		setup-bringup-keywords.Get Enclosure URI		    ${name}
	...			ELSE IF			'${type}' == 'ETH'		setup-bringup-keywords.Get Ethernet URI			${name}
	...			ELSE IF			'${type}' == 'FC'		setup-bringup-keywords.Get FC URI					${name}
	...			ELSE IF			'${type}' == 'FCOE'		setup-bringup-keywords.Get FCoE URI				${name}
	...			ELSE IF			'${type}' == 'LI'		setup-bringup-keywords.Get LI URI					${name}
	...			ELSE IF			'${type}' == 'LIG'		setup-bringup-keywords.Get LIG URI					${name}
	...         ELSE IF         '${type}' == 'LS'       setup-bringup-keywords.Get LS URI                  ${name}
	...         ELSE IF         '${type}' == 'LSG'      setup-bringup-keywords.Get LSG URI                 ${name}
	...			ELSE IF			'${type}' == 'NS'		setup-bringup-keywords.Get Network Set URI			${name}
	...			ELSE IF			'${type}' == 'SH'		setup-bringup-keywords.Get Server Hardware URI		${name}
	...         ELSE IF         '${type}' == 'SWT'      setup-bringup-keywords.Get Switch Type URI         ${name}
	...			ELSE IF			'${type}' == 'US'		setup-bringup-keywords.Get Uplink Set URI			${name}
	...			ELSE			Set variable			ResourceTypeNotFound:${type}

	[Return]	${uri}

Add Enclosures from variable
	[Documentation]	Adds Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${encs}   ${timeout}=15m    ${interval}=10s
	Log to console and logfile  	\nAdding ENCLOSURES
	:FOR	${enc}	IN	@{encs}
	\	${encuri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	\	@{words} = 	Split String	${encuri}	:
	\	${type} = 	Get From List	${words}	0
	\	${e} = 		Get From List	${words}	1
	\	${encuri} = 	Get Enclosure Group URI	${e}
	\	Set to dictionary	${enc}	enclosureGroupUri		${encuri}
	\	${resp} =	Fusion Api Add Enclosure 	${enc}
	\	${task} =	Wait For Task	${resp} 	${timeout}	 ${interval}

Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}
	Log to console and logfile  	\nAdding LOGICAL ENCLOSURE
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	@{words} = 	Split String	${eguri}	:
	${type} = 	Get From List	${words}	0
	${e} = 		Get From List	${words}	1
	${eguri} = 	Get Enclosure Group URI	${e}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
    ${xenc} =   fusion_api_appliance_setup.copy dictionary   ${enc}
	Set to dictionary	${xenc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\   	@{words} = 	Split String	${encuri}	:
	\       ${type} = 	Get From List	${words}	0
	\       ${e} = 		Get From List	${words}	1
	\       ${encuri} = 	setup-bringup-keywords.Get Enclosure URI	${e}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${xenc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Create Logical Enclosure 	${xenc}
	${task} =	Wait For Task	${resp} 	120min	1min
	[Return]  ${task}

Add Logical Switch Group from variable
	[Documentation]	Adds a Logical Switch Group to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${lsg}
	Log to console and logfile  	\nAdding LOGICAL SWITCH GROUPS
	log variables   level=DEBUG
	${swmap} = 	Get From Dictionary	   ${lsg['switchMapTemplate']}    switchMapEntryTemplates
    :FOR    ${sw}   IN  @{swmap}
    \       ${swuri} =   Get From Dictionary   ${sw}   permittedSwitchTypeUri
	\       ${swuri} =   setup-bringup-keywords.Common URI lookup by name	${swuri}
    \       Set to dictionary   ${sw}  permittedSwitchTypeUri   ${swuri}
    Set to dictionary   ${lsg['switchMapTemplate']}   switchMapEntryTemplates    ${swmap}
	${resp} =	Fusion Api Create LSG  	${lsg}
	${task} =	Wait For Task	${resp} 	5min	15s
	[Return]  ${task}

Add Logical Switch from variable
	[Documentation]	Adds a Logical Switch to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ls}
	Log to console and logfile  	\nAdding LOGICAL SWITCH
	${lsguri} = 	Get From Dictionary	   ${ls['logicalSwitch']}    logicalSwitchGroupUri
    ${lsguri} =     setup-bringup-keywords.Common URI Lookup by name   ${lsguri}
    Set to dictionary   ${ls['logicalSwitch']}  logicalSwitchGroupUri   ${lsguri}
	${resp} =	Fusion Api Create LS  	${ls}
	${task} =	Wait For Task	${resp} 	5min	15s
	[Return]  ${task}

Add Server Profiles from variable no hardware
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}   ${server_profile_to_bay_map}
	Log to console and logfile  	Adding SERVER PROFILES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    fusion_api_appliance_setup.Copy Dictionary     ${profile}
        \       ${space} =   Check For Whitespace From String   ${profile['name']}
        \       Run Keyword If   ${space} is ${True}   Fail   msg=Profile name contains whitespace. This is not allowed in CI-FIT naming convention.
        \       ${resp} =   Run Keyword If   '${server_profile_to_bay_map['${profile['name']}']}' == '${null}'   Fusion Api Get Server Hardware
        \       ${shUri} =   Run Keyword If   ${resp} == ${null}   Get Server Hardware URI    ${server_profile_to_bay_map['${profile['name']}']}
        \       ...                    ELSE   Set Variable   ${resp['members'][0]['uri']}
        \       ${serverHW} =    Fusion Api Get Resource    uri=${shUri}
	\       Set To Dictionary    ${profile}   serverHardwareTypeUri=${serverHW['serverHardwareTypeUri']}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	${task} =   Wait For Task	${resp}		timeout=8 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)

Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}   ${timeout}=15m    ${interval}=10s   ${endstate}=((?i)Warning|Completed)
	Log to console and logfile  	Adding SERVER PROFILES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    fusion_api_appliance_setup.Copy Dictionary     ${profile}
        \       ${space} =   Check For Whitespace From String   ${profile['name']}
        \       Run Keyword If   ${space} is ${True}   Fail   msg=Profile name contains whitespace. This is not allowed in CI-FIT naming convention.
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri
	\	@{words} = 	Split String	${enc}	:
	\	${type} = 	Get From List	${words}	0
	\	${enc} = 	Get From List	${words}	1
	\	${uri} = 	setup-bringup-keywords.Get Enclosure URI	${enc}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	${task} =   Wait For Task	${resp}		timeout=${timeout}		interval=${interval}
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	 ${endstate}

Add Server Profile Templates from variable
	[Documentation]	Adds Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILE TEMPLATES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Do Dictionary copy     ${profile}
	\	${sht} = 	Get from Dictionary	${profile}	serverHardwareTypeUri
	\	@{words} = 	Split String	${sht}	:
	\	${type} = 	Get From List	${words}	0
	\	${sht} = 	Get From List	${words}	1
	\	${uri} = 	Get Server Hardware Type URI		${sht}
	\	Set to Dictionary	${profile}	serverHardwareTypeUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile template		body=${profile}
	\   # TODO: Change timeout!
	\	${task} =   Wait For Task	${resp}		timeout=1 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)

Assign Server Hardware To Existing Profiles From Variable
	[Documentation]	Update Server Profiles from a variable with server hardware assigned to profile from mapping variable
        ...             NOTE: If ${waitForTask} is false, ${parallelAssign} and ${validate} becomes moot. Just fork the process and exit.
	[Arguments]		${profiles}   ${server_profile_to_bay_map}   ${timeout}=60m   ${interval}=15s  ${waitForTask}=${True}  ${parallelAssign}=${True}   ${validate}=${True}
	${existing_profiles} =  	Fusion Api Get Server Profiles
	${profile_members}	Get From Dictionary	${existing_profiles}	members
	${Count} =	Get From Dictionary	${existing_profiles}	count
        ${valDict} =    Create Dictionary   status_code=${200}
        ...                                 taskState=Completed
        ${respList} =   Create List
	:FOR 	${Index}	IN RANGE	0	${Count}
	\	${sp}		Get From List	${profile_members}	${Index}
        \       Continue For Loop If   '${server_profile_to_bay_map['${sp['name']}']}' == '${null}'
	\	${shUri} = 	Get Server Hardware URI    ${server_profile_to_bay_map['${sp['name']}']}
        \       ${profile} =    Fusion Api Get Resource    uri=${sp['uri']}
	\       Set To Dictionary    ${profile}   serverHardwareUri=${shUri}
        \       Remove From Dictionary    ${profile}   status_code    headers
        \	Log to console and logfile  	Assigning server hardware URI \"${shUri}\" to profile \"${sp['name']}\"
        \       ${resp} =   Fusion Api Edit Server Profile    uri=${sp['uri']}   body=${profile}
        \       Continue For Loop If   ${waitForTask} != ${True}
        \       Run Keyword If   ${parallelAssign} == ${True}   Append To List   ${respList}   ${resp}
        \       ...       ELSE   Wait For Task And Validate Response   ${resp}   ${valDict}   ${timeout}   ${interval}   ${validate}
        Run Keyword If   ${parallelAssign} == ${True} and ${waitForTask} is ${True}   Wait For Forked Tasks   ${respList}   ${valDict}   ${timeout}   ${interval}   ${validate}

Assign Server Profiles
        [Documentation]   Update server profiles in OneView by assigning the server hardware's valid uri. Argument requires list of dictionary of profiles that contains a valid server profile uri and serverHardwareUri (e.g: [{'uri': '/rest/server-profiles/8e2ec303-1274-4b9e-9871-b08f77bcc675', 'serverHardwareUri': '/rest/server-hardware/36343537-3338-4A48-3542-4E5030303533'}]).
        ...               NOTE: See robustness' LE-add-remove.txt script for example.
        [Arguments]     ${profiles}   ${timeout}=60m   ${interval}=15s  ${waitForTask}=${True}  ${parallelAssign}=${True}   ${validate}=${True}
	Set Log Level	TRACE
        ${valDict} =    Create Dictionary   status_code=${200}
        ...                                 taskState=Completed
        ${respList} =   Create List
	:FOR	${p}	IN    @{profiles}
        \   ${profile} =    Fusion Api Get Resource    uri=${p['uri']}
        \   set to dictionary    ${profile}   serverHardwareUri=${p['serverHardwareUri']}
        \   remove from dictionary    ${profile}   status_code    headers
        \   Log to console and logfile  	Assigning server hardware URI \"${p['uri']}\" to profile \"${p['name']}\"
        \   ${resp} =   fusion api edit server profile    uri=${p['uri']}   body=${profile}
        \   Continue For Loop If   ${waitForTask} != ${True}
        \   Run Keyword If   ${parallelAssign} == ${True}   Append To List   ${respList}   ${resp}
        \   ...       ELSE   setup-bringup-keywords.Wait For Task And Validate Response   ${resp}   ${valDict}   ${timeout}   ${interval}   ${validate}
        Run Keyword If   ${parallelAssign} == ${True} and ${waitForTask} is ${True}   Wait For Forked Tasks   ${respList}   ${valDict}   ${timeout}   ${interval}   ${validate}

Unassign Server Profiles
        [Documentation]   Update server profiles in OneView by unassigning the server hardware from it. Argument requires list of dictionary of profiles that contains a valid server profile uri (e.g.: [{'uri': '/rest/server-profiles/8e2ec303-1274-4b9e-9871-b08f77bcc675'}]).
        ...               NOTE: See robustness' LE-add-remove.txt script for example.
        [Arguments]     ${profiles}    ${timeout}=60m   ${interval}=15s  ${waitForTask}=${True}  ${parallelAssign}=${True}   ${validate}=${True}
        Set Log Level	TRACE
        ${valDict} =    Create Dictionary   status_code=${200}
        ...                                 taskState=Completed
        ${respList} =   Create List
        :FOR   ${p}   IN   @{profiles}
        \   ${profile} =    Fusion Api Get Resource    uri=${p['uri']}
        \   Log to console and logfile  	Unassigning server hardware URI \"${profile['serverHardwareUri']}\" from profile \"${p['name']}\"
        \   set to dictionary    ${profile}   serverHardwareUri=${None}
        \   set to dictionary    ${profile}   enclosureBay=${None}
        \   set to dictionary    ${profile}   enclosureUri=${None}
        \   remove from dictionary    ${profile}   status_code    headers
        \   ${resp} =   fusion api edit server profile    uri=${p['uri']}   body=${profile}
        \   Continue For Loop If   ${waitForTask} != ${True}
        \   Run Keyword If   ${parallelAssign} == ${True}   Append To List   ${respList}   ${resp}
        \   ...       ELSE   Wait For Task And Validate Response   ${resp}   ${valDict}   ${timeout}   ${interval}   ${validate}
        Run Keyword If   ${parallelAssign} == ${True} and ${waitForTask} is ${True}   Wait For Forked Tasks   ${respList}   ${valDict}   ${timeout}   ${interval}   ${validate}

Lookup volumeAttachments uris
    [Documentation]    Processes a list of volume attachments
    [Arguments]     ${vol_attachments}    ${enclosure}    ${server_bay}
    ${volume_attachments} =  Create List
    :FOR    ${vol_attachment}    IN    @{vol_attachments}
    \    ${vol_attachment} =     fusion_api_appliance_setup.Copy dictionary     ${vol_attachment}
    \    ${volumeName}=    Catenate  SEPARATOR=_  ${enclosure}  Bay  ${server_bay}
    \    Set to Dictionary   ${vol_attachment}  volumeName    ${volumeName}
    \    ${volumeStoragePoolUri_name}=    Get From Dictionary    ${vol_attachment}    volumeStoragePoolUri
    \    ${volumeStorageSystemUri_name}=    Get From Dictionary    ${vol_attachment}    volumeStorageSystemUri
    \    ${volumeStoragePoolUri} =  Get Storage Pool URI    ${volumeStoragePoolUri_name}    ${volumeStorageSystemUri_name}
    \    ${volumeStorageSystemUri} =   Get Storage System URI    ${volumeStorageSystemUri_name}
    \    Set to Dictionary   ${vol_attachment}    volumeStoragePoolUri    ${volumeStoragePoolUri}
    \    Set to Dictionary   ${vol_attachment}    volumeStorageSystemUri    ${volumeStorageSystemUri}
    \    append to list  ${volume_attachments}    ${vol_attachment}
    [Return]    ${volume_attachments}

Lookup volume uris
    [Documentation]    Processes a list of volumes
    [Arguments]     ${vol_attachments}    ${enclosure}    ${server_bay}    ${target_wwpn}
    ${volumes} =  Create List
    :FOR    ${vol_attachment}    IN    @{vol_attachments}
    \    ${vol_attachment} =     fusion_api_appliance_setup.Copy dictionary     ${vol_attachment}
    \    ${volumeName}=    Catenate  SEPARATOR=_  ${enclosure}  Bay  ${server_bay}
    \    ${volumeUri}=    Get Storage Volume URI    ${volumeName}
    \    Set to Dictionary   ${vol_attachment}  volumeUri    ${volumeUri}
    \    Set to Dictionary   ${vol_attachment}  lun    0
    \    ${storage_Paths}=    Get From Dictionary    ${vol_attachment}    storagePaths
    \    ${storagePaths} =    Lookup storagePaths    ${storage_Paths}    ${target_wwpn}
    \    Set to Dictionary    ${vol_attachment}    storagePaths    ${storagePaths}
    \    Remove From Dictionary    ${vol_attachment}    volumeName
    \    Remove From Dictionary    ${vol_attachment}    volumeDescription
    \    Remove From Dictionary    ${vol_attachment}    volumeStoragePoolUri
    \    Remove From Dictionary    ${vol_attachment}    volumeStorageSystemUri
    \    Remove From Dictionary    ${vol_attachment}    volumeProvisionType
    \    Remove From Dictionary    ${vol_attachment}    volumeProvisionedCapacityBytes
    \    Remove From Dictionary    ${vol_attachment}    volumeShareable
    \    Remove From Dictionary    ${vol_attachment}    permanent
    \    append to list    ${volumes}    ${vol_attachment}
    [Return]    ${volumes}

Lookup storagePaths
    [Documentation]    Processes a list of storagePaths
    [Arguments]     ${paths}    ${target_wwpn}
    ${storage_Paths} =  Create List
    :FOR    ${storage_path}    IN    @{paths}
    \    ${storage_path} =    fusion_api_appliance_setup.Copy dictionary     ${storage_path}
    \    ${storageTargets_list}=    Get From Dictionary    ${storage_path}    targets
    \    append to list    ${storageTargets_list}    ${target_wwpn}
    \    append to list    ${storage_Paths}    ${storage_path}
    [Return]    ${storagePaths}

Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	${conns} =  Create List
	:FOR	${connection}	IN	@{connections}
	\   ${connection} =     fusion_api_appliance_setup.Copy dictionary     ${connection}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1
	\	${net} = 	Create List	${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Set to Dictionary	${connection}	networkUri	${uri}
	\   append to list  ${conns}    ${connection}
	[Return]	${conns}

Lookup connection uris Change RequestedBW
    [Documentation]    Processes a list of connections, getting the uris for networks
    [Arguments]    ${connections}    ${bandwidth}
    ${conns} =    Create List
    :FOR    ${connection}    IN    @{connections}
    \    ${connection} =    fusion_api_appliance_setup.Copy dictionary    ${connection}
    \    ${functionType} =    Get from Dictionary    ${connection}    functionType
    \    ${net} =    Get From Dictionary    ${connection}    networkUri
    \    @{words} =    Split String    ${net}    :
    \    ${type} =    Get From List    ${words}    0
    \    ${net} =    Get From List    ${words}    1
    \    ${net} =    Create List    ${net}
    \    ${uri} =    Run Keyword If    '${type}' == 'FC'    Get FC URIs    ${net}
    \    ...    ELSE IF    '${type}' == 'ETH'    Get Ethernet URIs    ${net}
    \    ...    ELSE IF    '${type}' == 'NS'    Get Network Set URIs    ${net}
    \    ...    ELSE IF    '${type}' == 'FCOE'    Get FCoE URIs    ${net}
    \    ${uri} =    Get From List    ${uri}    0
    \    Set to Dictionary    ${connection}    networkUri    ${uri}
    \    Run Keyword If    '${functionType}' == 'Ethernet'    Set to Dictionary    ${connection}    requestedMbps    ${bandwidth}
    \   append to list  ${conns}    ${connection}
    [Return]    ${conns}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable ALL Generated ID Ranges
	[Documentation]	Enables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Enable Generated VSN Range	${rangeUri}

Enable Generated VMAC Range
	[Documentation]	Enables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VWWN Range
	[Documentation]	Enables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VSN Range
	[Documentation]	Enables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword as user
	[Documentation]		Runs a Fusion_API keyword as a particular user.
	...					Ex:		Run Keyword As User		nat		Fusion Api Get Ethernet Networks	${empty}	param=?filter="'name'=='net_101'"
    [Arguments]     ${user}     ${keyword}      @{varargs}
    ${original_user} =   Fusion Api Get Active user
	${active_sessions} = 	Fusion Api Get Active Sessions
	Dictionary Should Contain Key	${active_sessions}	${user}
    Fusion Api Switch Active User   ${user}
    ${resp} =   Run Keyword and continue on failure     ${keyword}  @{varargs}
    Fusion Api Switch Active User   ${original_user}
    [Return]    ${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument. args and kwargs are supported.
	[Arguments]    ${list}   ${keyword}   @{varargs}    &{kwargs}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}   ${x}   @{varargs}    &{kwargs}

Run Keyword for Dict
	[Documentation]	Runs the specified keyword, passing each VALUE for each KEY in the dict. args and kwargs are supported.
	[Arguments]    ${dict}   ${keyword}   @{varargs}    &{kwargs}
	Set Log Level	TRACE
	${items} =    Get Dictionary Items    ${dict}
	:FOR	${key}   ${value}	IN 	@{items}
	\	Run Keyword		${keyword}   ${value}   @{varargs}    &{kwargs}

Add to headers
    [Documentation]  adds key\value pairs to the default headers and returns the resulting dict.
    ...   This is useful for supplying a customized header for an individual API call, like specify eTag.
    ...   example:  ${headers} =    Add to headers   If-Match=*    SomeKey=SomeValue
    [Arguments]     &{kwargs}
    ${headers} =    Fusion API get headers
    ${items} =      Get Dictionary Items    ${kwargs}
	:FOR	${key}   ${value}	IN   @{items}
	\	Set to Dictionary   ${headers}   ${key}   ${value}
    [Return]    ${headers}


Build LIG body
    [Documentation]    Build Logical Interconnect Group body
	[Arguments]		${xlig}
	${xlig} = 	Do Dictionary copy	${xlig}
	${uplinkSets} = 	Copy List	${xlig['uplinkSets']}
	${l} = 	Get Length	${uplinkSets}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	${name} =                       Get Variable Value  ${xlig['name']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
	${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
	${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
	${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	#${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         fcoeSettings=${fcoeSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
    [Return]    ${body}

Build US body
    [Documentation]    Build UplinkSet body
	[Arguments]		${us}	${li_uri}
	Set to dictionary	${us}	logicalInterconnectUri	${li_uri}
	${l} = 	Get Length	${us['portConfigInfos']}
	:FOR	${x}	IN RANGE	0	${l}
	\   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}	enclosure
	\   ${enc_uri} =        setup-bringup-keywords.Get Enclosure Uri   ${enc_uri}
	\	Set To Dictionary		${us['portConfigInfos'][${x}]}	enclosure	${enc_uri}

	# process eth
	${networks} = 		Get From Dictionary		${us}	networkUris
	${networkUris} = 	Get Ethernet Uris	${networks}
	Set to dictionary	${us}	networkUris	${networkUris}
	# process fc
	${networks} = 		Get From Dictionary		${us}	fcNetworkUris
	${networkUris} = 	Get FC Uris	${networks}
	Set to dictionary	${us}	fcNetworkUris	${networkUris}
	# process fcoe
	${networks} = 		Get From Dictionary		${us}	fcoeNetworkUris
	${networkUris} = 	Get FCoE Uris	${networks}
	Set to dictionary	${us}	fcoeNetworkUris	${networkUris}

	${body} = 		Fusion Api Create Uplink Set Payload	${us}
	[Return]	${body}

Build Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile
    [Arguments]     ${bay_num}    ${profile_body}  ${connection_type}=${NONE}  ${boot_Mode}=${NONE}  ${boot_order}=${NONE}  ${bandwidth}=${NONE}
    Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile} =    Do Dictionary copy    ${profile_body}
    ${uri}=    Get Server HW URI    ${bay_num}
    Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    ${eg} =     Get from Dictionary    ${profile}  enclosureGroupUri
    @{words} =  Split String    ${eg}    :
    ${type} =   Get From List   ${words}    0
    ${eg} =     Get From List   ${words}    1
    ${uri} =    Get Enclosure Group URI    ${eg}
    Set to Dictionary    ${profile}    enclosureGroupUri    ${uri}
    ${enc} =    Get from Dictionary    ${profile}    enclosureUri
    @{words} =  Split String    ${enc}    :
    ${type} =   Get From List   ${words}    0
    ${enc} =    Get From List   ${words}    1
    ${uri} =    setup-bringup-keywords.Get Enclosure URI   ${enc}
    Set to Dictionary   ${profile}  enclosureUri    ${uri}
    ${name}=    Catenate  SEPARATOR=_  ${enc}  Bay  ${bay_num}
    Set to Dictionary   ${profile}  name    ${name}
    Run Keyword If    ${connection_type} != ${NONE}    Set to Dictionary   ${profile}  connections    ${connection_type}
    ${connections} =    Get From Dictionary    ${profile}    connections
     ${connections} =    Run Keyword If  '${bandwidth}' == '${NONE}'    Lookup Connection Uris    ${connections}
    ...    ELSE    Lookup connection uris Change RequestedBW    ${connections}    ${bandwidth}
    Set to Dictionary   ${profile}  connections     ${connections}
    Run Keyword If    ${boot_Mode} != ${NONE}    Set to Dictionary    ${profile}    bootMode    ${boot_Mode}
    Run Keyword If    ${boot_order} != ${NONE}    Set to Dictionary    ${profile}    boot    ${boot_order}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Server Profile body SAN Storage
    [Documentation]   Build Server Profiles body with SAN storage
    [Arguments]     ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}
    ${enc} =    Get from Dictionary    ${profile_body}    enclosureUri
    @{words} =    Split String    ${enc}    :
    ${type} =    Get From List    ${words}    0
    ${enc} =    Get From List    ${words}    1
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}
    ${profile} =    Do Dictionary copy   ${profile_body}
    ${san_storage} =    Get From Dictionary    ${profile}    sanStorage
    ${volumeAttachments} =    Get From Dictionary    ${san_storage}    volumeAttachments
    ${volumeAttachments} =    Lookup volumeAttachments uris   ${volumeAttachments}    ${enc}    ${bay_num}
    Set to Dictionary   ${san_storage}    volumeAttachments     ${volumeAttachments}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Server Profile body UEFI Mode
    [Documentation]   Build Server Profiles body required to create the server profile in UEFI mode
    [Arguments]     ${bay_num}    ${profile_body}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}
    ${profile} =    Do Dictionary copy    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_uefi}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_uefi}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Server Profile body Legacy Mode
    [Documentation]   Build Server Profiles body required to create the server profile in Legacy mode
    [Arguments]     ${bay_num}    ${profile_body}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}
    ${profile} =    Do Dictionary copy    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_legacy}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_legacy}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile
    [Arguments]     ${bay_num}    ${profile_body}    ${connection_type}=${NONE}    ${boot_Mode}=${NONE}    ${boot_order}=${NONE}    ${bandwidth}=${NONE}
    Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    ${uri}=    Get Server Profile URI    ${bay_num}
    Set to Dictionary    ${profile}    uri    ${uri}
    ${uri}=    Get Server HW URI    ${bay_num}
    Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    ${eg} =     Get from Dictionary    ${profile}  enclosureGroupUri
    @{words} =  Split String    ${eg}    :
    ${type} =   Get From List   ${words}    0
    ${eg} =     Get From List   ${words}    1
    ${uri} =    Get Enclosure Group URI    ${eg}
    Set to Dictionary    ${profile}    enclosureGroupUri    ${uri}
    ${enc} =    Get from Dictionary    ${profile}    enclosureUri
    @{words} =  Split String    ${enc}    :
    ${type} =   Get From List   ${words}    0
    ${enc} =    Get From List   ${words}    1
    ${uri} =    setup-bringup-keywords.Get Enclosure URI   ${enc}
    Set to Dictionary   ${profile}  enclosureUri    ${uri}
    ${name}=    Catenate  SEPARATOR=_  ${enc}  Bay  ${bay_num}
    Set to Dictionary   ${profile}  name    ${name}
    Run Keyword If    ${connection_type} != ${NONE}    Set to Dictionary   ${profile}  connections    ${connection_type}
    ${connections} =    Get From Dictionary    ${profile}    connections
    ${connections} =    Run Keyword If  '${bandwidth}' == '${NONE}'    Lookup Connection Uris    ${connections}
    ...    ELSE    Lookup connection uris Change RequestedBW    ${connections}    ${bandwidth}
    Set to Dictionary   ${profile}  connections     ${connections}
    Run Keyword If    ${boot_Mode} != ${NONE}    Set to Dictionary    ${profile}    bootMode    ${boot_Mode}
    Run Keyword If    ${boot_order} != ${NONE}    Set to Dictionary    ${profile}    boot    ${boot_order}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body SAN Storage
    [Documentation]   Build Edit Server Profile body with SAN storage
    [Arguments]     ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}    ${bandwidth}    ${target_wwpn}
    ${enc} =    Get from Dictionary    ${profile_body}    enclosureUri
    @{words} =    Split String    ${enc}    :
    ${type} =    Get From List    ${words}    0
    ${enc} =    Get From List    ${words}    1
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}    ${bandwidth}
    ${profile} =    Do Dictionary copy    ${profile_body}
    ${san_storage} =    Get From Dictionary    ${profile}    sanStorage
    ${volumeAttachments} =    Get From Dictionary    ${san_storage}    volumeAttachments
    ${volumeAttachments} =    Lookup volume uris   ${volumeAttachments}    ${enc}    ${bay_num}    ${target_wwpn}
    Set to Dictionary   ${san_storage}    volumeAttachments     ${volumeAttachments}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body UEFI Mode
    [Documentation]   Build Server Profiles body required to create the server profile in UEFI mode
    [Arguments]     ${bay_num}    ${profile_body}    ${bandwidth}=${NONE}
    Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile_body}=    Run Keyword If  '${bandwidth}' == '${NONE}'    Build Edit Server Profile body    ${bay_num}    ${profile_body}
    ...    ELSE    Build Edit Server Profile body    ${bay_num}    ${profile_body}    ${bandwidth}
    ${profile} =    Do Dictionary copy    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_uefi}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_uefi}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body Legacy Mode
    [Documentation]   Build Server Profiles body required to create the server profile in Legacy mode
    [Arguments]     ${bay_num}    ${profile_body}    ${bandwidth}=${NONE}
    Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile_body}=    Run Keyword If  '${bandwidth}' == '${NONE}'    Build Edit Server Profile body    ${bay_num}    ${profile_body}
    ...    ELSE    Build Edit Server Profile body    ${bay_num}    ${profile_body}    ${bandwidth}
    ${profile} =    Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_legacy}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_legacy}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Ethernet Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile for Ethernet
    [Arguments]     ${bay_num}    ${profile_body}
    Log to console and logfile      Build PROFILE body with Ethernet connection for server bay:${bay_num}
    ${profile} =    Do Dictionary copy     ${profile_body}
    ${uri}=    Get Server HW URI    ${bay_num}
    Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    ${eg} =     Get from Dictionary    ${profile}  enclosureGroupUri
    @{words} =  Split String    ${eg}    :
    ${type} =   Get From List   ${words}    0
    ${eg} =     Get From List   ${words}    1
    ${uri} =    Get Enclosure Group URI    ${eg}
    Set to Dictionary    ${profile}    enclosureGroupUri    ${uri}
    ${enc} =    Get from Dictionary    ${profile}    enclosureUri
    @{words} =  Split String    ${enc}    :
    ${type} =   Get From List   ${words}    0
    ${enc} =    Get From List   ${words}    1
    ${uri} =    setup-bringup-keywords.Get Enclosure URI   ${enc}
    Set to Dictionary   ${profile}  enclosureUri    ${uri}
    ${name}=    Catenate  Bay  ${bay_num}
    Set to Dictionary   ${profile}  name    ${name}
    Set to Dictionary   ${profile}  connections    ${enet_connection}
    ${connections} =    Get From Dictionary    ${profile}    connections
    ${connections} =    Lookup Connection Uris  ${connections}
    Set to Dictionary   ${profile}  connections     ${connections}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build FCOE Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile for FCOE connection
    [Arguments]     ${bay_num}    ${profile_body}
    Log to console and logfile      Build PROFILE body with FCoE connection for server bay:${bay_num}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}
    ${profile} =    Do Dictionary copy    ${profile_body}
    Set to Dictionary   ${profile}  connections    ${fcoe_connection}
    ${connections} =    Get From Dictionary    ${profile}    connections
    ${connections} =    Lookup Connection Uris  ${connections}
    Set to Dictionary   ${profile}  connections     ${connections}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build FC Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile for FC connection
    [Arguments]     ${bay_num}    ${profile_body}
    Log to console and logfile      Build PROFILE body with FC connection for server bay:${bay_num}
    ${profile} =    Do Dictionary copy    ${profile_body}
    Set to Dictionary   ${profile}  connections    ${fc_connection}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile}
    ${body}=    Set Variable    ${profile_body}
    [Return]    ${body}

Create Network Set range
    [Documentation]    Create a range of Network Sets based on provided range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding NETWORK SET RANGES
	${body} = 	Do Dictionary copy 	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end
	${netlist} = 	Create List
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Append To List	${netlist}	${range['prefix']}${x}${range['suffix']}
	${networkUris} = 	Get Ethernet URIs	${netlist}
	Set To Dictionary 	${body}	networkUris	${networkUris}
	${nativeNetworkUri} = 	Run Keyword If 	'${range['nativeNetworkUri']}' != 'None'  Get Ethernet URI	${range['nativeNetworkUri']}
	Set To Dictionary 	${body}	nativeNetworkUri	${nativeNetworkUri}
	${resp} = 	Fusion Api Create Network Set		body=${body}
	[Return]	${resp}

Create Ethernet range
    [Documentation]    Create a range of Ethernet networks based on provided range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding ETHERNET NETWORK RANGES
	${body} = 	Do Dictionary copy 	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end

	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Set To Dictionary 	${body}	name	${range['prefix']}${x}${range['suffix']}
	\	Set To Dictionary 	${body}	vlanId	${x}
	\	${resp} = 	Fusion Api Create Ethernet Network	body=${body}

Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding FCOE NETWORK RANGES
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-networkV300
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\	fusion_api_appliance_setup.Wait For Task	${resp}

Get connectionTemplateUri
	[Documentation]	Retrieves the connectionTemplateUri from a given network {name} of a given {type} where:
	...             {name} is the name of the network
	...             {type} is the type of network: [ethernet, fc, fcoe], default=ethernet
	...             Returns: connectionTemplateUri string
	[Arguments]		${name}   ${type}=ethernet
    Set Log Level	DEBUG
    ${param} =      Set Variable    ?filter="'name'=='${name}'"
	${net} =		Run Keyword If          '${type}' == 'ethernet'      Fusion Api Get Ethernet Networks    param=${param}
	...             ELSE IF                 '${type}' == 'fc'            Fusion Api Get fc Networks          param=${param}
    ...             ELSE IF                 '${type}' == 'fcoe'          Fusion Api Get fcoe Networks        param=${param}
    ...             ELSE                    Log     Invalid network type specified for 'Get connectionTemplateUri'     WARN
	${ct_uri} =     Get From Dictionary      ${net['members'][0]}    connectionTemplateUri

    [Return]    ${ct_uri}

Get Enclosure URI
    [Documentation]    Get Enclosure URI for the named enclosure
	[Arguments]		${enc}
	${resp} = 	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Enclosure Group URI
    [Documentation]    Get Enclosure Group URI for the named enclosure group
	[Arguments]		${eg}
	${resp} = 	Fusion Api Get Enclosure Groups
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${eg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get Ethernet URI
    [Documentation]    Get Ethernet network URI for the named ethernet network
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Ethernet URIs
    [Documentation]    Get Ethernet network URIs for the named ethernet network list
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get FC URI
    [Documentation]    Get FC network URI for the named FC network
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FC URIs
    [Documentation]    Get FC network URIs for the named FC network list
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get FCoE URI
    [Documentation]    Get FCpE network URI for the named FCoE network
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FCoE Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FCoE URIs
    [Documentation]    Get FCoE network URIs for the named FCoE network list
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Fcoe Networks		param=?filter="'name'=='${net}'"    api=600
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get IC URI
    [Documentation]    Get Interconnect URI for the named interconnect
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Interconnect Type URI
    [Documentation]    Get Interconnect type URI for the named interconnect
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect Types 		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LE URI
    [Documentation]    Get Logical Enclosure URI for the named logical enclosure
	[Arguments]		${le}
	${resp} = 	fusion api get logical enclosure  		param=?filter="'name'=='${le}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LI member
    [Documentation]    Get Logical Interconnect member
	[Arguments]		${li}
	${resp} = 	    Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${member} = 	Get From List		${resp['members']}  ${x}
	[Return]	${member}

Get LI URI
    [Documentation]    Get Logical Interconnect URI for the named logical interconnect
	[Arguments]		${li}
	${resp} = 	Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LIG member
    [Documentation]    Get Logical Interconnect Group member
	[Arguments]		${lig}
	${resp} = 	    Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${member} = 	Get From List		${resp['members']}  0
	[Return]	${member}

Get LIG URI
    [Documentation]    Get Logical Interconnect Group URI for the named logical interconnect group
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LS URI
    [Documentation]    Get Logical Switch URI for the named logical switch
	[Arguments]		${ls}
	${resp} = 	Fusion Api Get LS 		param=?filter="'name'=='${ls}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LSG URI
    [Documentation]    Get Logical Switch Group URI for the named logical switch group
	[Arguments]		${lsg}
	${resp} = 	Fusion Api Get LSG 		param=?filter="'name'=='${lsg}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Network Set URI
    [Documentation]    Get Network Set URI for the named network set
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Network Set URIs
    [Documentation]    Get Network Set URIs for the named network set list
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Resource by URI
	[Documentation]    Returns any type of resource using its URI
	[Arguments]	${uri}   @{varargs}
    ${resp} =     Fusion Api Get Resource    ${uri}    @{varargs}
	[Return]    ${resp}

Get Server Hardware URI
    [Documentation]    Get ALL Appliance Server Hardware URI
    [Arguments]		${enc_server}
    ${resp} = 	Fusion Api Get Server Hardware
	${shlist} = 	Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} = 	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} = 	Get From dictionary 	${sh}	uri
	[Return]	${uri}

Get All Server Hardware Type URI
    [Documentation]    Get ALL Appliance Server Hardware Type URI
    [Arguments]		${sht}
    Set Log Level	TRACE
    ${resp} = 	Fusion Api Get Server Hardware Types
    ${l} = 	Get Length	${resp['members']}
    ${uri} =  Set Variable   ${null}
    :FOR    ${i}    IN RANGE    0    ${l}
    \  Log    ${resp['members'][${i}]['name']}
    \  Log    ${sht}
    \    ${uri} =    Run Keyword If    '${resp['members'][${i}]['name']}' == '${sht}'    Set Variable    ${resp['members'][${i}]['uri']}
    \    Exit For Loop If     '${uri}' != '${null}'
    [Return]    ${uri}

Get Server Hardware Type URI
    [Documentation]    Get Appliance Server Hardware Type URI
    [Arguments]    ${sht}
    Set Log Level    TRACE
    ${resp} =    Fusion Api Get Server Hardware Types    param=?filter="'name'=='${sht}'"
    ${uri} =    Get From dictionary    ${resp['members'][0]}    uri
    [Return]    ${uri}

Get Switch Type URI
    [Documentation]    Get Appliance Switch Type URI
    [Arguments]    ${ic}
    ${resp} =    Fusion Api Get Switch Types    param=?filter="'name'=='${ic}'"
    ${uri} =    Get From Dictionary    ${resp['members'][0]}    uri
    [Return]	${uri}

Get Uplinkset URI
    [Documentation]    Get Appliance Uplinkset URI
    [Arguments]    ${us}
    ${resp} =     Fusion Api Get Uplink Set    param=?filter="'name'=='${us}'"
    ${uri} =     Get From Dictionary    ${resp['members'][0]}    uri
    [Return]    ${uri}

Log to console and logfile
    [Documentation]    Log provided data to console and logfile with provided level
	[Arguments]	${data}     ${level}=INFO
	Log	${data}     ${level}
	Log to console	${data}

Wait For Task
    [Documentation]    Waits for a task to reach an end-state
    [Arguments]    ${resp}    ${timeout}=60s    ${interval}=2s    ${taskType}=Default   ${status_code}=${202}
    Log to console    \n
    ${valDict} =    Create Dictionary    status_code=${status_code}
    setup-bringup-keywords.validate Response    ${resp}    ${valDict}
    ${task} =    Run Keyword If    '${taskType}' == 'Default'   Wait Until Keyword Succeeds    ${timeout}    ${interval}    fusion_api_appliance_setup.Task Reached Endstate    ${resp}
    ...    ELSE IF    '${taskType}' == 'Restore'   Wait Until Keyword Succeeds    ${timeout}    ${interval}   fusion_api_appliance_setup.Restore Task Reached Endstate    ${resp}
    ...    ELSE    Fail    msg=The taskType specified is invalid. Please use 'Default' or 'Restore'...
    [Return]    ${task}

Task Reached Endstate
    [Documentation]    Waits for a task to reach an end-state
    [Arguments]    ${resp}
    Set Log Level    TRACE
    #Should Contain	${resp}	uri
    ${location} =    Get Variable Value    ${resp['headers']['location']}
    ${task_uri} =    Run Keyword If    '${location}' is 'None'    Get From Dictionary    ${resp}    uri
    ...     ELSE    Get Variable Value    ${location}
    Should Not Be Empty    ${task_uri}    msg=No task uri could be retreived from response
     # Hack for backup task uri that contains https://IP in error
    ${task_uri} =    Remove String    ${task_uri}    https://    ${APPLIANCE_IP}
    ${task} =    Fusion Api Get Task    uri=${task_uri}
    ${task_state} =    Get From Dictionary    ${task}    taskState
    ${task_category} =    Get From Dictionary    ${task}    	category
    ${task_name} =    Get From Dictionary    ${task}    name
    ${resource} =    Get From Dictionary    ${task['associatedResource']}    resourceName
    ${resource_uri} =    Get From Dictionary    ${task['associatedResource']}    resourceUri
    Log to console and logfile    \t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
    Should Match Regexp    ${task_state}    ((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
    ${failedsubtasks} =    Run Keyword If     '${task_state}' != 'Completed'    fusion api get task    param=?filter="parentTaskUri='${task_uri}'"&filter="taskState ne 'Completed'"
    [Return]    ${task}

Restore Task Reached Endstate
    [Documentation]    Waits for a restore task to reach an end-state
    [Arguments]	${resp}
    Set Log Level	TRACE
    Should Not Be Empty     ${resp['uri']}    msg=No task uri could be retreived from response
    ${task} = 		Fusion Api Get Task		uri=${resp['uri']}
    ${task_status} = 	Get From Dictionary		${task}		status
    ${task_category} = 	Get From Dictionary		${task}		category
    ${task_id} = 		Get From Dictionary		${task}		id
    ${task_percentComplete} =   Get From Dictionary		${task}		percentComplete
    ${task_progressStep} = 	    Get From Dictionary		${task}		progressStep
    Log to console and logfile  	\t Task: [${task_category}:${task_id}] is: ${task_status}(${task_percentComplete}%) [${task_progressStep}] : ${resp['uri']}
    Should Match Regexp	${task_status}	((?i)FAILED|SUCCEEDED|UNKNOWN)
    [Return]	${task}

Wait For Forked Tasks
    [Documentation]    Wait for forked tasks (off the response body list of dictionary) to reach end state
    [Arguments]    ${respList}    ${valDict}    ${timeout}    ${interval}=60m    ${validate}=${True}
    Wait Until Keyword Succeeds    ${timeout}    ${interval}    fusion_api_appliance_setup.Forked Tasks Reached Endstate     ${respList}   ${valDict}   ${validate}

Forked Tasks Reached Endstate
    [Documentation]    Look up through all the forked tasks to see if they reached end state
    [Arguments]    ${respList}    ${valDict}    ${validate}=${True}
    ${match} =    Set Variable    ${False}
    ${popped} =    Set Variable    ${null}
    ${l} = 	  Get Length    ${respList}
    ${taskStateList} =    Create List    Warning  Unknown  Terminated  Killed  Error  Completed
    :FOR    ${x}    IN RANGE   0    ${l}
    \    ${task} =    Fusion Api Get Task    uri=${respList[${x}]['uri']}
    \    ${match} =    Run Keyword If    ${validate} == ${True}    Match Value In List    ${task['taskState']}   ${taskStateList}
    \    ${popped} =    Run Keyword If    ${match} is ${True}    Remove From List     ${respList}    ${x}
    \    Run Keyword If    ${validate} == ${True}    Log to console and logfile     \t Task: [${task['category']}:${task['name']}] is: ${task['taskState']} for resource: ${task['associatedResource']['resourceName']} ${task['associatedResource']['resourceUri']}
    \    Run Keyword If    ${popped} is not ${null}    setup-bringup-keywords.validate Response    ${task}    ${valDict}
    Should Be Equal As Integers    ${l}    0

Wait For Task And Validate Response
    [Documentation]    Wait for task and setup-bringup-keywords.validate Response
    [Arguments]    ${resp}    ${valDict}    ${timeout}    ${interval}=15s    ${validate}=${True}
    ${task} =     Wait For Task    ${resp}    ${timeout}   ${interval}
    Run Keyword If   ${validate} == ${True}    setup-bringup-keywords.validate Response    ${task}   ${valDict}

Unix ping
	[Documentation]    check if provided Linux host is pingable
	[Arguments]		${host}
    ${Output}=    Run    ping -c 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
	[Return]	${Output}


Check For Whitespace From String
    [Documentation]   Check for whitespace from string. Returns true if whitespace exists else return false.
    [Arguments]    ${string}
    @{stringList} =    Split String    ${string}
    ${l} =    Get Length    ${stringList}
    ${result} =    Run Keyword If    ${l} > 1    Set Variable    ${True}
    ...                   ELSE    Set Variable   ${False}
    [Return]    ${result}

validate Response
    [Documentation]	Validates data in a response body against expected values
    ...   Example:
    ...   ${rc} = 		Convert to Integer	400
	...   ${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...   setup-bringup-keywords.validate Response   ${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE
	${response} = 	Do Dictionary copy 	${resp}
	@{vkeys} =	Get Dictionary Keys	${validation}
	${rkeys} =	Get Dictionary Keys	${response}
	@{keys} =	setup-bringup-keywords.Remove all the keys in response that are not in validation	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{keys}
	\	Remove From Dictionary	${response}	${x}
	Dictionaries Should Be Equal	${validation}	${response}	msg=Response does not match validation dictionary	values=True

validate Response Regex
    [Documentation]	Validates data in a response body against expected values using regex
    ...    Make sure to escape your pattern strings properly!
    ...    Example:
    ...    ${valDict} =    Create Dictionary    status_code=${200}
    ...                              taskState=Error
    ...                              taskStatus=Invalid uplink-set: Port: \\d+ for interconnect-type: .* is not an uplink port.
    ...    setup-bringup-keywords.validate Response Regex    ${respDict}    ${valDict}
    [Arguments]    ${resp}    ${validation}
    Set Log Level    TRACE
    ${response} =    Do Dictionary copy    ${resp}
    @{vkeys} =    Get Dictionary Keys    ${validation}
    :FOR    ${x}    IN    @{vkeys}
    \    ${r} =    Convert to string    ${resp['${x}']}
    \    ${v} =    Convert to string    ${validation['${x}']}
    \    Should Match Regexp    ${r}    ${v}

setup-bringup-keywords.Remove all the keys in response that are not in validation
	[Arguments]	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{vkeys}
	\	Remove Values From List	${rkeys}	${x}
	[Return]	${rkeys}

Match Value In List
    [Documentation]   Check if a value exists in list
    [Arguments]   ${val}   ${valList}
    :FOR   ${v}   IN   @{valList}
    \   Return From Keyword If   '${v}' == '${val}'   ${True}
    [Return]   ${False}


	
