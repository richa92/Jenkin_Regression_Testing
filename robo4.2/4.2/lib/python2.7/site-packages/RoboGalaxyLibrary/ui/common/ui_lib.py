# (C) Copyright 2013 Hewlett-Packard Development Company, L.P.
""" Common UI utility functions """

import re
from datetime import datetime
from os.path import join
from re import match
from threading import Thread
import logging
import os
import time
import sys
import traceback

from Selenium2Library.locators.elementfinder import ElementFinder
from robot.libraries.BuiltIn import BuiltIn
from selenium import webdriver
from selenium.common.exceptions import StaleElementReferenceException
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.remote.webelement import WebElement
import requests

from RoboGalaxyLibrary.common.decorators import deprecated
from RoboGalaxyLibrary.common.exceptions import FatalError
from RoboGalaxyLibrary.data import test_data
from RoboGalaxyLibrary.utilitylib import logging as logger

try:
    from robot.libraries.Screenshot import Screenshot
except RuntimeError as e:
    logger._log("Unable to import Screenshot. Cant open Display\n" + str(e), level='WARN')


# restrict logging messages from the requests modules to warning only
requests_log = logging.getLogger("requests")
requests_log.setLevel(logging.WARNING)

WAIT_SLEEP_TIME = 0.1
ROOT_XPATH = 'xpath=/html'

##############################################################################
# Generic functions
##############################################################################


def get_s2l():
    """ get_s2l
        Description : This function return the selenium2library object |
    """
    return BuiltIn().get_library_instance('RoboGalaxyLibrary')


def fail_test(failuremsg, captureScreenshot=True):
    """ fail_test
        Description : Function used for failing the test case explicitly, capture screenshot is enable by default
    """
    if captureScreenshot:
        get_s2l().capture_page_screenshot()
    BuiltIn().fail(failuremsg)


def get_property_value(propertyNameObj, propertyName):
    """ get_property_value
        Description : Gets an object property by name
    """
    propValue = ""
    newList = str(propertyNameObj).splitlines()
    for lis in newList:
        newList = lis.split(":")
        if newList[0].lower() == propertyName:
            propValue = newList[1]
    return propValue.strip()


def get_year_month_day_from_timestring(datetime_str):
    date = datetime.strptime(datetime_str.strip(), '%Y-%m-%d')
    return date.year, date.month, date.day


##############################################################################
# Element functions
##############################################################################
def verify_on_off_toggle(off_xpath, on_xpath):
    if is_visible(off_xpath):
        wait_for_element_and_click(off_xpath, fail_if_false=True)

        if is_visible(on_xpath):
            logger.info("Successfully toggled element from OFF to ON")
            logger.info("Returning element to original state of OFF")
            wait_for_element_and_click(on_xpath, fail_if_false=True)
        else:
            fail_test("Unable to toggle element with xpath: %s from OFF to ON" % off_xpath)

    elif is_visible(on_xpath):
        wait_for_element_and_click(on_xpath, fail_if_false=True)

        if is_visible(off_xpath):
            logger.info("Successfully toggled UID from ON to OFF")
            logger.info("Returning element to original state of ON")
            wait_for_element_and_click(off_xpath, fail_if_false=True)
        else:
            fail_test("Unable to toggle element with xpath: %s from ON to OFF" % on_xpath)
    else:
        raise NoSuchElementException("Unable to locate an element with xpath of %s or %s" % (off_xpath, on_xpath))


def get_html_element_index_in_row(row_locator, element_xpath):
    s2l = get_s2l()
    row = s2l.element_find(row_locator, True, False)
    target = row.find_element_by_xpath(element_xpath)
    children_of_row = row.find_elements_by_xpath("*")
    html_index = children_of_row.index(target) + 1

    return html_index


def is_element_enabled(locator, timeout=None):
    """ Determine if the element specified by the locator parameter is enabled
    """
    return get_s2l()._element_find(locator).is_enabled()


def find_element_and_verify_visible(locator, max_number_of_tries=1):
    s2l = get_s2l()

    for i in range(max_number_of_tries):
        try:
            element = s2l._element_find(locator, True, False)

            if element is None:
                raise NoSuchElementException("Unable to find element with locator: %s" % locator)

            if s2l.is_element_visible(element):
                logger.info("Element %s verified as visible" % locator)
            else:
                fail_test("Element %s NOT visible" % locator)
        except StaleElementReferenceException:
            continue
        else:
            break
    else:
        raise StaleElementReferenceException("Element %s not attached to DOM after %s try(s)" % (locator, max_number_of_tries))


def find_element_and_move(locator):
    s2l = get_s2l()
    action_chain = ActionChains(s2l._current_browser())
    action_chain.move_to_element(s2l._element_find(locator, True, False)).perform()


def move_to_element_verify_visible_move_away(locator1, *args):
    """ Move to the first element (hover over) and verify that the
        list of elements are visible after the hover over and then move away
        to ensure that pop ups aren't covering up other pop ups.
    """
    find_element_and_move(locator1)

    for locator2 in args:
        max_number_of_tries = 2
        find_element_and_verify_visible(locator2, max_number_of_tries)

    find_element_and_move(ROOT_XPATH)


def move_to_element_and_click(el1, el2):
    """ move_to_element_and_click
        Description: Utilize Selenium action chains to combine the actions of
            moving to an element (hovering) and clicking another (or the same)
            element.  This function will help in situations where chaining is needed.
    """
    s2l = get_s2l()
    element1 = s2l ._element_find(el1, True, False)
    element2 = s2l ._element_find(el2, True, False)
    if element1 is None:
        raise AssertionError("ERROR: Element %s not found." % (el1))
    if element2 is None:
        raise AssertionError("ERROR: Element %s not found." % (el2))
    ActionChains(s2l._current_browser()).move_to_element(element1).click(element2).perform()


def click_and_select_file_for_upload(locator, filename):
    """ Click a browser element which selects a file for upload, populate the dialog with the filename, and continue.
        Note that since opening a native dialog in WebDriver is a blocking action, we must use a
        thread to perform this operation.  Otherwise, the UI will block execution until the dialog is closed.
    """
    s2l = get_s2l()
    # Since clicking the file selection element blocks the UI, we need to do this in a separate thread
    Thread(target=s2l.click_element, args=(locator,)).start()
    browser_name = s2l._current_browser().capabilities['browserName']
    logger._info("*** Browser version '{0}' ***".format(browser_name))
    if browser_name == 'firefox':
        window_title = "File Upload"
    elif browser_name == 'chrome':
        window_title = "Open"
    elif browser_name == 'internet explorer':
        window_title = "Choose File to Upload"
    else:
        raise AssertionError("Unknown browser name '{0}'".format(browser_name))
    rg = BuiltIn().get_library_instance('RoboGalaxyLibrary')
    rg.send_keys_to_native_window(window_title, "%n{0}%o".format(filename))


def get_element_width(locator):
    """ Get an element width attribute
    """
    el = get_s2l()._element_find(locator, True, False)
    return el.get_attribute("width")


def get_element_height(locator):
    """ Get an element height attribute
    """
    el = get_s2l()._element_find(locator, True, False)
    return el.get_attribute("height")


def input_text_if_property_exist(objName, propertyName, propertyValueObj):
    """ input_text_if_property_exist
        Description :  selenium execute input_text keyword only if the property exist in the testdata xml
    """
    selenium2lib = get_s2l()
    if isProperty_exist_in_testdata(propertyValueObj, propertyName):
        propValue = get_property_value(propertyValueObj, propertyName)
        selenium2lib.input_text(objName, propValue)


def highlight(el, duration=300):
    """ Highlight an element in the DOM
    """
    get_s2l().highlight(el, duration)


def element_text_matches(locator, regex):
    """ See if the element text matches the supplied regular expression
    """
    s2l = get_s2l()
    s2l ._info("Verifying element '%s' matches regex '%s'."
               % (locator, regex))
    element = s2l ._element_find(locator, True, True)
    actual = element.text
    return match(regex, actual)


def element_text_should_match(locator, regex, message=''):
    """Verifies element identified by `locator` matches text `expected`.
    """
    s2l = get_s2l()
    s2l._info("Verifying element '%s' matches regex '%s'."
              % (locator, regex))
    element = s2l._element_find(locator, True, True)
    actual = element.text
    if match(regex, actual):
        if not message:
            message = "The text of element '%s' should have matched '%s' but "\
                      "in fact it was '%s'." % (locator, regex, actual)
        raise AssertionError(message)


def is_visible(obj, timeout=5, fail_if_false=False):
    """ StaleElementException safe function to determine if a locator or webelement is visible.
        Works with either a locator or webelement object
        Example:
             v = is_visible("id=my_locator")
             v = is_visible(my_webelement_object)

    :param obj: expression as string for locating element, An object of WebElement
    :param timeout: in second, the method will return None or throw exception if can't locate element or the element not become visible in specified time
    :param fail_if_false: set to True to fail the test case if can't locate element or element not become visible in :timeout seconds
    :return: webelement if it becomes visible in specified timeout, otherwise None
    """
    s2l = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            if isinstance(obj, str):
                return s2l._is_visible(obj)
            elif isinstance(obj, WebElement):
                return obj.is_displayed()
            else:
                raise TypeError("Cannot get text from unknown type {0}".format(type(obj)))
        except Exception:
            pass

    msg = "Failed to determine element's visibility within %s seconds due to NoSuchElementException, Timeout or StaleElementReferenceException " % timeout

    if fail_if_false is True:
        fail_test(msg)

    logger._warn(msg)
    return False


def ignore_staleElementRefException(function, *args):
    """ Function which adds a wrapper around selenium2library
        function to handle a StaleElementReferenceException.

        Example:
             name = ignore_staleElementRefException("get_text", xpath)
    """
    timeout = 5
    s2l = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            if (function == "get_text"):
                return s2l._get_text(*args)
            elif (function == "table_column_should_contain"):
                return s2l.table_column_should_contain(*args)
            elif (function == "_is_visible"):
                return s2l._is_visible(*args)
        except (StaleElementReferenceException):
            pass
    logger._warn("Failed to get element within timeout due to StaleElementReferenceException on %s function" % function)
    return None


##############################################################################
# Key related functions
##############################################################################


def send_keys(locator, string):
    """Send a string in the form of keystrokes to an element
    """
    s2l = get_s2l()
    for key in string:
        s2l.press_key(locator, key)


# Table functions
def table_column_should_contain(table_locator, col, expected, timeout=5):
    """ StaleElementException safe function to check for text in a table column
        Works with either a locator or webelement object.  Returns bool.
        Example:
             res = table_column_should_contain("id=my_locator")
             res = table_column_should_contain(my_webelement_object)
    """
    s2l = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            return s2l.table_column_should_contain(table_locator, col, expected)
        except (StaleElementReferenceException):
            pass
    logger._warn("Failed to get table column element within timeout due to StaleElementReferenceException")
    return None


def table_contains(locator, expected):
    """ table_contains
        Description: Returns whether a table contain the expected text in a cell
    """
    s2l = get_s2l()
    return s2l._table_element_finder.find_by_content(s2l._current_browser(), locator, expected)


##############################################################################
#  Wait functions
##############################################################################
def wait_for_table_to_contain(locator, expected, timeout=5, fail_if_false=False):
    """ wait_for_table_to_contain
        Description: Wait for a table identified by 'locator' to contain the text 'expected'
    """
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if table_contains(locator, expected):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for table '{0}' to contain '{1}'".format(locator, expected))
    return False


def wait_for_condition(condition, timeout=5, fail_if_false=False):
    """ Wait for a condition in the UI
        TODO: This function collides with the Selenium2Library wait_for_condition function
              which executes a block of javascript instead of a lambda.
        Description: Wait for the condition to be satisfied before the
            |    specified time - condition should be supplied as a
            |    lambda.
    """
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if condition():
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to satisfy condition within time period")
    return False


def wait_for_element_visible(locator, timeout=5, fail_if_false=False):
    """ wait_for_element_visible
        Description : Function wait for element to visible until the time mentioned.
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._is_visible(locator):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element visible '%s'" % locator)
    return False


def wait_for_element_notvisible(locator, timeout=5, fail_if_false=False):
    """ Wait for an element to be removed from the UI
        TODO: This function semi-collides with the S2L wait_funtil_element_is_not_visible
        function
        """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if not selenium2lib._is_visible(locator):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element invisible '%s'" % locator)
    return False


def wait_for_element_hidden(locator, timeout=5, fail_if_false=False):
    """ _wait_for_element_hidden
        Description : Wait for an element to be hidden in UI
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if not selenium2lib._is_visible(locator):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element hidden '%s'" % locator)
    return False


def wait_for_element(locator, timeout=5, fail_if_false=False):
    """ _wait_for_element
        Description : waits for an element to exist in UI
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._is_element_present(locator):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element '%s'" % locator)
    return False


def wait_for_element_and_click(locator, timeout=5, fail_if_false=False, js_click=False):
    """ waits for an element to exist then perform click action on it.

    :param locator: xpath/id/css expression to locate element
    :param timeout: in second, the method will return False or throw exception if can't locate element or click element in specified time
    :param fail_if_false: set to True to fail the test case if can't locate element or click element in :timeout seconds
    :param js_click: set to True to click by executing javascript "elt.click()" otherwise click by native selenium api
    :return: True if operation is successful otherwise return False
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._is_element_present(locator) and \
                    selenium2lib._is_visible(locator):

                if js_click is False:
                    selenium2lib.click_element(locator)
                else:
                    element = get_s2l()._element_find(locator, first_only=True, required=False)
                    script = """
                        el = arguments[0];
                        el.click();
                    """
                    get_s2l()._current_browser().execute_script(script, element)
                return True
        except:
            pass
        BuiltIn().sleep(0.1)

    if fail_if_false:
        fail_test("Failed to wait for element '%s'" % locator)
    return False


def wait_for_element_and_input_text(locator, text, timeout=5, fail_if_false=False):
    """ _wait_for_element
        Description : waits for an element to exist in UI
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._is_element_present(locator) and \
                    selenium2lib._is_visible(locator):

                selenium2lib.input_text(locator, text)
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element '%s'" % locator)
    return False


def wait_for_element_remove(locator, timeout=5, fail_if_false=False):
    """ wait_for_element remove
        Description : waits for an element to be removed from UI
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if not selenium2lib._is_element_present(locator):
                return True
        except:
            logger._warn('Exception caught while waiting for {0}'.format(locator))
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for remove element '%s'" % locator)
    return False


def wait_for_element_text(locator, text, timeout=5, fail_if_false=False):
    """ wait_for_element_text
        Description : waits for an element element text to change
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._get_text(locator).lower().strip().find(text.lower().strip()) != -1:
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element text'%s'" % locator)
    return False


def wait_for_element_text_to_change(locator, text, timeout=5, fail_if_false=False):
    """ wait_for_element_text
        Description : waits for an element element text to change
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._get_text(locator).lower().strip().find(text.lower().strip()) == -1:
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element text'%s'" % locator)
    return False


def wait_for_element_text_match(locator, regex, timeout=5, fail_if_false=False):
    """ wait_for_element_text
        Description : waits for an element element text to change
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if match(regex, selenium2lib._get_text(locator)):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element text'%s'" % locator)
    return False


def wait_for_element_value(locator, value, timeout=5, fail_if_false=False):
    """ wait_for_element_text
        Description : waits for an element element text to change
    """
    selenium2lib = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if selenium2lib._get_value(locator).lower().strip() == value.lower().strip():
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element text'%s'" % locator)
    return False


def wait_for_element_class(locator, value, timeout=5, fail_if_false=False):
    selenium2lib = get_s2l()
    start = datetime.now()
    el = selenium2lib._element_find(locator, True, True)
    if el is None:
        logger._warn("wait_for_element_class(): Failed to locate element '%s' on page" % locator)
        return False
    while (datetime.now() - start).total_seconds() < timeout:
        # Occasionally, a DOM refresh will cause an exception here
        # if the object is changing state.  Catch the exception
        # to prevent a failure.
        try:
            if value in el.get_attribute('class'):
                return True
        except:
            pass
        BuiltIn().sleep(WAIT_SLEEP_TIME)

    if fail_if_false:
        fail_test("Failed to wait for element text'%s'" % locator)
    return False


def wait_for_element_expand(locator):
    """ wait_for_element_expand
        Description : Wait for an expanding element to complete animation
            |    Useful to wait for pages to load when there's animation.
    """
    selenium2lib = get_s2l()
    # find the element on the page
    el = selenium2lib._element_find(locator, True, True)
    if el is None:
        logger._warn("wait_for_element_expand(): Failed to locate element '%s' on page" % locator)
        return False
    cur_width = el.size["width"]
    width_changing = True
    start = datetime.now()
    # wait for the width to stop changing
    while width_changing and (datetime.now() - start).total_seconds() < 5:
        # too frequent checking will result in a false positive
        BuiltIn().sleep(0.5)
        if el.size["width"] != cur_width:
            cur_width = el.size["width"]
        else:
            width_changing = False
    return True


def wait_for_element_location(locator, timeout=5):
    """ Description : Wait for an moving element to complete animation
            |    Useful to wait for pages to load when there's animation.
    """
    selenium2lib = get_s2l()
    el = selenium2lib._element_find(locator, True, True)
    if el is None:
        logger._warn("wait_for_element_move(): Failed to locate element '%s' on page" % locator)
        return False
    cur_location = el.location
    location_changing = True
    start = datetime.now()
    while location_changing and (datetime.now() - start).total_seconds() < timeout:
        BuiltIn().sleep(0.5)  # too frequent checking will result in a false positive
        try:
            if el.location != cur_location:
                cur_location = el.location
            else:
                location_changing = False
        except(StaleElementReferenceException):
            pass
    return True


def ui_get_html_source():
    """ UI Get HTML Source
        Description : Get HTML Source of the current page.  It's useful got scanning ui objects
    """
    selenium2lib = get_s2l()
    return selenium2lib.get_source()


def ui_log_html_source(loglevel='INFO'):
    """ UI Get HTML Source
        Description : Log HTML Source of the current page.  It's useful got scanning ui objects
    """
    selenium2lib = get_s2l()
    logger._info(selenium2lib.log_source(loglevel))


def isProperty_exist_in_testdata(testList, propertyName):
    if str(testList).find(propertyName) >= 0:
        return True
    else:
        return False


def get_ui_object(ui_object, *param):
    """Get a parameterized (or non-parameterized) object from the UI elements.
       This keyword can either use non-formatted string, or formatted strings using the %s
       specifier.  It utilizes the % Python string specifier.
       See Python string formatting for more information.
       Example:
    | Get UI Object | ${FusionUIBaseElements.ID_PAGE_LABEL} |
    | Get UI Object | ${FusionEnclosureGroupsPage.ID_COMBO_LIST_LOGICAL_SWITCH_TEMPLATE} | MyTemplateName |
    """
    count1 = len(ui_object.split("%s")) - 1
    count2 = len(param[0])
    if((len(ui_object.split("%s"))) - 1 == len(param[0])):
        return ui_object % (param[0])
    else:
        fail_test(
            "For given object '%s', 'get ui object' keyword is expecting '%s' parameters (object and %s of its strings to replace) and received '%s' parameters." %
            (ui_object,
             count1 +
             1,
             count1,
             count2 +
             1))


def download_file(link_locator, destination_folder=None):
    """Download a file from a link URL
        Arguments:
            link_locator - the locator of the link which should contain an href attribute
            destination_folder - the optional destination location of the downloaded file
    """
    # get selenium2library reference
    s2l = get_s2l()

    # get the download URL from the link
    url = s2l._element_find(link_locator, True, True).get_attribute("href")

    # if the folder is not specified, default to the current execution
    # directory
    if destination_folder is None:
        destination_folder = test_data.get_variable("EXECDIR")

    # create the destination path if it doesn't exist
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)

    # obtain the cookies and session ID from Selenium, copy the cookies into a
    # dict, and issue the request
    cookies = {}
    all_cookies = s2l._cache.current.get_cookies()
    for s_cookie in all_cookies:
        cookies[s_cookie["name"]] = s_cookie["value"]

    # perform the request
    r = requests.get(url, cookies=cookies, headers={'auth': cookies['token']}, verify=False)

    # validate the status
    if r.status_code != 200:
        raise FatalError("File download status code was '{0}'".format(r.status_code))

    # get file info
    file_length = long(r.headers['content-length'])
    filename = r.headers['content-disposition'].split("; ")[1].split("=")[1].strip('"')
    local_path = join(destination_folder, filename)

    # if the file exists, then append (1)
    while os.path.exists(local_path):
        tok = list(os.path.splitext(local_path))
        tok[0] += "(1)"
        local_path = join(destination_folder, "".join(tok))

    # download the file
    logger._debug("Downloading '{0}' to {1} - ({2} bytes)".format(filename, local_path, file_length))
    try:
        lf = open(local_path, 'wb')
        for chunk in r.iter_content(chunk_size=1024):
            if chunk:  # filter out keep-alive new chunks
                lf.write(chunk)
                lf.flush()
        lf.close()

        # validate the file size
        local_file_length = os.path.getsize(local_path)
        if local_file_length != file_length:
            raise FatalError("Download file size doesn't match.  Should be {0}.  Was {1}".format(file_length, local_file_length))
        else:
            logger._debug("Successfully downloaded {0} ({1} bytes)".format(local_path, local_file_length))
    except:
        raise FatalError("Failed to download '{0}' to '{1}'".format(filename, local_path))


def get_webelement_attribute(attribute, locator, timeout=5, fail_if_false=False):
    """ Function which adds a wrapper around retrieving
        webelement attributes to handle a
        StaleElementReferenceException.

        Example:
             name = get_webelement_attribute("text", user)

    :param attribute: name of the attribute/property to retrieve
    :param locator: xpath/id/css expression to locate element
    :param timeout: in second, the method will return None or throw exception if can't get desire attribute value in specified time
    :param fail_if_false: set to True to fail the test case if can't get elements' text in :timeout seconds
    :return: string value otherwise return None
    """
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            webelement = get_s2l()._element_find(locator, True, False)

            if webelement is None:
                time.sleep(0.1)
                continue

            if attribute == "text":
                return webelement.text
            elif attribute == "name":
                return webelement.name
            elif attribute == "innerHTML":
                return webelement.get_attribute('innerHTML')
            else:
                return webelement.get_attribute(attribute)
        except (StaleElementReferenceException):
            pass

    if fail_if_false:
        fail_test("Failed to get element attribute in %s seconds" % timeout)

    logger._warn(
        "Failed to get element within timeout due to StaleElementReferenceException on webelement")
    return None


def scroll_to_xpath(rowXPath, tableXPath, labelXPath, container):
    """ Scrolls to a particular element in a list based on its XPath, and accounts for any UI decoration overlap.
        Arguments: (note your XPaths are not to start with "xpath=", "id=", or anything; just get right into the XPath.)
            rowXPath: the XPath to the <tr> row you want to scroll to
            tableXPath: the XPath to the table that contains this <tr> (possibly inside a <tbody>)
            labelXPath: the XPath to the section label that we must compensate for in order to fully see & interact with the row
            container: The ID of the DOM element containing the scroll bar you need to manipulate to see the desired row
        Example: (This example pertains to the display of Tbird Enclosure Managers on the Enclosure Details page)
            ui_lib.scroll_to_xpath(
                '//table[@id="cic-enclosure-more-em-bays-table"]/tbody/tr/td[text()="%d"]/..' % bay,
                '//table[@id="cic-enclosure-more-em-bays-table"]',
                '//li[@id="cic-enclosure-more-em-bays"]/label',
                "cic-enclosure-more-panels"
    """

    # Fetch the browser instance since we'll need to run some JavaScript
    browser = get_s2l()._current_browser()
    # Do a courtesy check: wait for the row element to appear
    wait_for_element(rowXPath)
    # Find the distance from the top of the row element to the top of its container (the table)
    # Sometimes the JavaScript doesn't execute right the first time, so wait
    # for it to work
    counter = 0
    rowOffset = None
    while counter < 50 and rowOffset is None:
        try:
            rowOffset = browser.execute_script(
                "row = document.evaluate('%s', document, null, XPathResult.ANY_TYPE, null); item = row.iterateNext(); return item.offsetTop" %
                rowXPath)
            break
        except:
            counter += 1
    if rowOffset is None:
        logger._warn(
            "Javascript could not find the offsetTop of the table row specified (%s).  Make sure the element still exists." %
            rowXPath)
        return
    # Do another courtesy check: wait for the table element to appear
    wait_for_element(tableXPath)
    # Reset the counter & make room for the table offset
    counter = 0
    tableOffset = None
    # Find the distance from the top of the table to the top of its container (the div with the scroll bar)
    # Sometimes the JavaScript doesn't execute right the first time, so wait
    # for it to work
    while counter < 50 and tableOffset is None:
        try:
            tableOffset = browser.execute_script(
                "table = document.evaluate('%s', document, null, XPathResult.ANY_TYPE, null); item = table.iterateNext(); return item.offsetTop" %
                tableXPath)
            break
        except:
            counter += 1
    if tableOffset is None:
        logger._warn(
            "Javascript could not find the offsetTop of the table specified (%s).  Make sure the element still exists." %
            tableXPath)
        return
    # Now, scroll the scroll bar to (rowOffset + tableOffset = position of the row element within the scrolly div)
    # Then scroll up by the height of the UI decoration so it won't obscure
    # the table row from being clicked on
    rowHeight = browser.execute_script(
        "row = document.evaluate('%s', document, null, XPathResult.ANY_TYPE, null); item = row.iterateNext(); return item.offsetHeight" %
        labelXPath)
    totalOffset = int(rowOffset) + int(tableOffset) - rowHeight
    totalOffset = totalOffset if totalOffset > 0 else 0
    browser.execute_script(
        "document.getElementById('%s').scrollTop = %d" %
        (container, totalOffset))


def get_text(obj, timeout=5, fail_if_false=False, hidden_element=False):
    """ StaleElementException safe function to return element text
        Works with either a locator or webelement object
        Example:
             text = get_text("id=my_locator")
             text = get_text(my_webelement_object)

    :param obj: Web element or expression for locating web element
    :param timeout: in second, the method will return None or throw exception if can't get desire attribute value in specified time
    :param fail_if_false: set to True to fail the test case if can't get elements' text in :timeout seconds
    :param hidden_element: set to True to get text of hidden elements. (Selenium only give empty string for visible element)
    :return: text of web element otherwise return None
    """
    s2l = get_s2l()
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            if isinstance(obj, str) or isinstance(obj, unicode):
                if hidden_element is False:
                    return s2l._get_text(obj)
                else:
                    elt = s2l._element_find(obj, True, False)
                    if elt:
                        return elt.get_attribute('textContent')
            elif isinstance(obj, WebElement):
                if hidden_element is False:
                    return obj.text
                else:
                    return obj.get_attribute('textContent')
            else:
                raise TypeError("Cannot test for visibility with unknown type {0}".format(type(obj)))
        except Exception:
            pass

    if fail_if_false:
        fail_test("Fail to get element text in %s seconds" % timeout)

    logger._warn("Failed to get element visibility within timeout due to StaleElementReferenceException on webelement")
    return None


def get_multi_elements_text(locator, timeout=5, fail_if_false=False, hidden_element=False):
    """
    Get text for all elements that match locator. Return result as list

    :param locator: expression for locating elements
    :param timeout: in second, the method will return empty list or throw exception if can't retrieve elements text in specified time
    :param fail_if_false: set to True to fail the test case if can't get elements' text in :timeout seconds
    :param hidden_element: set to True to get text of hidden elements. (Selenium only give empty string for visible element)
    :return: all elements' text as list otherwise return empty list
    """
    s2l = get_s2l()
    start = datetime.now()
    ret = []
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            elt_list = ElementFinder().find(s2l._current_browser(), locator)
            for elt in elt_list:
                if hidden_element is False:
                    ret.append(elt.text)
                else:
                    ret.append(elt.get_attribute('textContent'))

            return ret
        except Exception:
            ret = []

    msg = "Failed to get multi elements visibility within %s seconds due to NoSuchElementException, Timeout or StaleElementReferenceException " % timeout

    if fail_if_false:
        fail_test(msg)

    logger._warn(msg)
    return ret

##############################################################################
# Checkbox related functions
##############################################################################


def is_checkbox_selected(locator):
    """ is_checkbox_selected
        Description: Determine if a checkbox is selected or not
    """
    return get_s2l()._get_checkbox(locator).is_selected()


def wait_for_checkbox_and_select(locator, timeout=5, fail_if_false=False):
    """Selects checkbox identified by `locator`.

    Does nothing if checkbox is already selected. Key attributes for
    checkboxes are `id` and `name`. See `introduction` for details about
    locating elements.

    :param locator: expression for locating checkbox element
    :param timeout: in second, the method will return None or throw exception if can't get checkbox selected in specified time
    :param fail_if_false: set to True to fail the test case if can't get checkbox selected in :timeout seconds
    :return:
    """
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            wait_for_element(locator)
            element = get_s2l()._get_checkbox(locator)
            while not element.is_selected():
                element.click()
                element = get_s2l()._get_checkbox(locator)
            return element
        except Exception:
            pass

        if fail_if_false:
            fail_test("Failed to select checkbox: [ %s ] in %s seconds" % (locator, timeout))

        logger._warn("Failed to select checkbox: " + locator)

    return None


def wait_for_checkbox_and_unselect(locator, timeout=5, fail_if_false=False):
    """Selects checkbox identified by `locator`.
    Does nothing if checkbox is already selected. Key attributes for
    checkboxes are `id` and `name`. See `introduction` for details about
    locating elements.

    :param locator: expression for locating checkbox element
    :param timeout: in second, the method will return None or throw exception if can't get checkbox unselected in specified time
    :param fail_if_false: set to True to fail the test case if can't get checkbox unselected in :timeout seconds
    :return:
    """
    start = datetime.now()
    while (datetime.now() - start).total_seconds() < timeout:
        try:
            wait_for_element(locator)
            element = get_s2l()._get_checkbox(locator)
            while element.is_selected():
                element.click()
                element = get_s2l()._get_checkbox(locator)
            return element
        except Exception:
            time.sleep(0.1)

        if fail_if_false:
            fail_test("Failed to unselect checkbox: [ %s ] in %s seconds" % (locator, timeout))

        logger._warn("Failed to unselect checkbox within timeout due to StaleElementReferenceException on webelement")
    return None


##############################################################################
# Browser functions
##############################################################################
def capture_page_screenshot(filename=None):
    """ Capture the page
    """
    get_s2l().capture_page_screenshot()


def scroll_into_view(locator, align_with_top=False):
    """ Scrolls an element into view

    :param locator: expression for locating checkbox element
    :param align_with_top: set to true to scroll to upper edge of the scrollable region else scroll to under edge of the region.
    """
    return get_s2l().scroll_into_view(locator, align_with_top)


def _set_browser_status(status):
    """ _set_browser_status
        Description : Function used for setting the global variable once the browser is opened.
    """
    test_data.set_variable(test_data.GlobalProperty.BrowserOpened, status)


def _get_browser_status():
    """ _get_browser_status
        Description : Function used for getting the browser status to verify browser already opened or not.
    """
    status = test_data.get_variable(test_data.GlobalProperty.BrowserOpened)
    if status is None:
        return False
    return status


def close_all_browsers():
    """ close_all_browsers
        Description :
            |    CLoses all browsers
    """
    selenium2lib = get_s2l()
    selenium2lib.close_all_browsers()
    _set_browser_status(False)


def refresh_browser(locator, time):
    """ Refresh the browser
    """
    selenium2lib = get_s2l()
    selenium2lib.reload_page()
    if wait_for_element_visible(locator, time):
        return True
    else:
        return False


def get_browser_capabilities():
    """ Return a dictionary containing the browser capability info
    """
    return get_s2l()._current_browser().capabilities


def get_firefox_version():
    """ Get Firefox version """
    try:
        driver = webdriver.Firefox()
        version = driver.capabilities['version']
        driver.quit()
        return version
    except:
        logger._warn("Couldn't get Firefox version")
        return False


##############################################################################
# Window functions
##############################################################################

def switch_window_by_title(title, timeout_sec=10):
    """ Activate a browser window based on its title
    """
    get_s2l().select_window("title=" + title)

##############################################################################
# Page functions
##############################################################################


def page_contains(text):
    """ page_contains
        Description : return true if page contains text
    """
    return get_s2l()._page_contains(text)

##############################################################################
# Dropdown functions
##############################################################################


def select_from_dropdown_by_text(dropdown_container_id, option_text, timeout=5, fail_if_false=False):
    '''
    Select an option from dropdown by option text displayed
    Works for all drop downs defined as <ol></ol> i.e ordered list
    '''

    search_res = re.search(r"^id=(.*)", dropdown_container_id.replace(' ', ''))
    if search_res is not None:
        dropdown_container_id = search_res.group(1)
    id_part = ' or '.join(["@id='%s'" % item for item in dropdown_container_id.split('|')])

    dropdown_select_xpath = "xpath=.//*[%s]//div[@class='hp-value']" % id_part
    dropdown_value_xpath = "xpath=.//*[%s]//li//span[text()='%s']" % (id_part, option_text)
    wait_for_element_and_click(dropdown_select_xpath, timeout, fail_if_false)
    return wait_for_element_and_click(dropdown_value_xpath, timeout, fail_if_false)


def select_from_dropdown_by_dataid(dropdown_container_id, data_id, timeout=5, fail_if_false=False):
    '''
    Select an option from dropdown by data-id of <li> tag
    Works for all drop downs defined as <ol></ol> i.e ordered list
    '''
    search_res = re.search(r"^id=(.*)", dropdown_container_id.replace(' ', ''))
    if search_res is not None:
        dropdown_container_id = search_res.group(1)
    id_part = ' or '.join(["@id='%s'" % item for item in dropdown_container_id.split('|')])

    dropdown_select_xpath = "xpath=.//*[%s]//div[@class='hp-value']" % id_part
    dropdown_value_xpath = "xpath=.//*[%s]//li[@data-id='%s']" % (id_part, data_id)
    wait_for_element_and_click(dropdown_select_xpath, timeout, fail_if_false)
    return wait_for_element_and_click(dropdown_value_xpath, timeout, fail_if_false)


def ScreenshotDeco(f):
    """
    Capture Screenshot for full screen when method throws exception
    """
    def action(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except Exception as e:
            exc_type, exc_instance, exc_traceback = sys.exc_info()
            formatted_traceback = ''.join(traceback.format_tb(exc_traceback))
            path, link = get_s2l()._get_screenshot_paths(filename=None)
            Screenshot().take_screenshot(path)
            BuiltIn().log("Took screenshot into %s" % BuiltIn().get_variable_value('${OUTPUT DIR}'), "DEBUG", console=True)
            message = 'Internal traceback:\n{0}\n{1}:\n{2}\n{3}'.format(
                formatted_traceback,
                exc_type.__name__,
                '',
                getattr(exc_instance, 'inner_exception_obj', '')
            )
            BuiltIn().log(message, "DEBUG", console=True)
            raise e
    return action
