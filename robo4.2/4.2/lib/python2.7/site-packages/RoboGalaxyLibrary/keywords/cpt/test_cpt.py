#!/usr/bin/env python27
# (C) Copyright 2018 Hewlett Packard Enterprise Development LP
"""
Unit tests for L2AddKeywords with python mock
"""
from cirrus_tool import L2AddKeywords
from mock import patch
from unittest import TestCase
import testdata


class TestL2AddKeywords(TestCase):
    """
    TestCase object for L2Add keywords
    """
    def test_set_credentials_assignments(self):
        """
        Validate CPT login configures the correct variables
        :return:
        """
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.124.10', user='root', passwd='hpvse1')
        self.assertEqual(cpt.ip, '192.168.124.10')
        self.assertEqual(cpt.username, 'root')
        self.assertEqual(cpt.password, 'hpvse1')

    def test_login_required_for_provision_server(self):
        """
        Verify 'CPT information' is required before calling Provision server
        :return:
        """
        with self.assertRaises(AssertionError) as e:
            cpt = L2AddKeywords()
            cpt.provision_server({})

        self.assertTrue('CPT information needs to be configured' in e.exception)

    def test_login_required_for_wait_on_task(self):
        """
        Verify 'CPT information' is required exception when Wait on Task is
        called without providing CPT server information
        :return:
        """
        with self.assertRaises(AssertionError) as e:
            cpt = L2AddKeywords()
            cpt.wait_on_task('')

        self.assertTrue('CPT information needs to be configured' in e.exception)

    @patch('cirrus_tool.L2AddKeywords._remote_cmd')
    def test_provision_server_error_handling(self, mock_fn):
        """
        Verify the error handling in provision server method
        :param mock_fn: Handle to _remote_cmd mock
        :return:
        """
        mock_fn.side_effect = AssertionError
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        self.assertRaises(AssertionError, cpt.provision_server, body=None)

    @patch('cirrus_tool.L2AddKeywords._remote_cmd')
    @patch('cirrus_tool.L2AddKeywords._generate_xml')
    def test_single_node_deployment(self, mock_gen, mock_cmd):
        """
        Verify the return value for a single node deployment
        :param mock_gen: Handle to _generate_xml mock
        :param mock_cmd: Handle to _remote_cmd mock
        :return:
        """
        # Prepare the return values
        out1 = {"output": "/tmp/tmpdir.XXXXXX"}
        out2 = {"output": "/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log"}
        mock_cmd.side_effect = [out1, out2]
        mock_gen.return_value = '/tmp/tmpdir.XXXXXX/input.xml'

        # Run the tests
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        r = cpt.provision_server(testdata.single_node)

        self.assertEqual('/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log', r)

    @patch('cirrus_tool.L2AddKeywords._remote_cmd')
    @patch('cirrus_tool.L2AddKeywords._remote_copy')
    def test_multi_node_deployment(self, mock_copy, mock_cmd):
        """
        Verify the return value for multiple node deployment
        :param mock_copy: Handle to _remote_copy mock method
        :param mock_cmd: Handle to _remote_cmd mock method
        :return:
        """
        # Prepare the mocked method return values
        cmd_out1 = {"output": "/tmp/tmpdir.XXXXXX"}
        cmd_out2 = {"output": "/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log"}

        mock_cmd.side_effect = [cmd_out1, cmd_out2]
        mock_copy.side_effect = [None, None]

        # Run test
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        r = cpt.provision_server(testdata.multi_node)

        self.assertEqual('/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log', r)

    @patch('cirrus_tool.L2AddKeywords._get_error_info', return_value=None)
    @patch('cirrus_tool.L2AddKeywords._remote_cmd')
    def test_wait_on_task_loop(self, mock_cmd, mock_err):
        """
        Verify wait on task
        :param mock_cmd: Handle to _remote_cmd mock method
        :return:
        """
        # Prepare the results for the mocked method
        # Loop 5 times before a success and then append final result
        # Last remote command is workspace cleanup
        out = [{"output": 2}, {'output': ''}] * 5
        out.append({"output": 0})
        o = 'bay03-01:;VMware ESXi 6.5.0-1.29.6765664:;Success:;10.1.46.140'
        out.append({"output": o})
        out.append(None)
        mock_cmd.side_effect = out

        # Run the test
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        cpt.nodes = 1
        r = cpt.wait_on_task('/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log',
                             timeout=3, interval=1)

        # asserts
        self.assertEqual('bay03-01', r['server'])
        self.assertEqual('VMware ESXi 6.5.0-1.29.6765664', r['os_name'])
        self.assertEqual('Success', r['status'])
        self.assertEqual('10.1.46.140', r['ipv4'])

    @patch('cirrus_tool.L2AddKeywords._remote_cmd',
           side_effect=[{"output": 2}] * 3)
    def test_task_timeout(self, mock_cmd):
        """
        Verify return status when task has timed out
        :param mock_cmd: Handle to _remote_cmd mock method
        :return:
        """
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        r = cpt.wait_on_task('/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log',
                             timeout=1, interval=60)

        self.assertEqual('Failed', r['status'])

    @patch('cirrus_tool.L2AddKeywords._get_error_info', return_value=None)
    @patch('cirrus_tool.L2AddKeywords._remote_cmd')
    def test_wait_on_task_loop_for_bulk(self, mock_cmd, mock_err):
        """
        Verify wait on task for bulk deployments
        :param mock_cmd: Handle to _remote_cmd mock method
        :return:
        """
        # Prepare the results for the mocked method
        # Loop 5 times before a success and then append final result
        # Last remote command is workspace cleanup
        out = [{"output": 2}, {'output': ''}] * 5
        out.append({"output": 0})
        o = 'bay03-01:;VMware ESXi 6.5.0-1.29.6765664:;Success:;10.1.46.140\r\n'
        o += 'bay04-01:;VMware ESXi 6.5.0-1.29.6765664:;Success:;10.1.46.141'
        out.append({"output": o})
        out.append(None)
        mock_cmd.side_effect = out

        # Run the test
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        r = cpt.wait_on_task('/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log',
                             timeout=3, interval=1)

        # asserts
        self.assertEqual(2, r['count'])
        self.assertEqual('Success', r['status'])
        self.assertEqual('Success', r['nodes'][1]['status'])

    @patch('cirrus_tool.L2AddKeywords._get_error_info', return_value=None)
    @patch('cirrus_tool.L2AddKeywords._remote_cmd')
    def test_wait_on_task_loop_for_bulk_failed(self, mock_cmd, mock_err):
        """
        Verify wait on task for bulk deployments
        :param mock_cmd: Handle to _remote_cmd mock method
        :return:
        """
        # Prepare the results for the mocked method
        # Loop 5 times before a success and then append final result
        # Last remote command is workspace cleanup
        out = [{"output": 2}, {'output': ''}] * 5
        out.append({"output": 0})
        o = 'bay03-01:;VMware ESXi 6.5.0-1.29.6765664:;Success:;10.1.46.140\r\n'
        o += 'bay04-01:;VMware ESXi 6.5.0-1.29.6765664:;FAILED:;10.1.46.141'
        out.append({"output": o})
        out.append(None)
        mock_cmd.side_effect = out

        # Run the test
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        r = cpt.wait_on_task('/tmp/tmpdir.XXXXXX/rg_cpt_deploy.log',
                             timeout=3, interval=1)

        # asserts
        self.assertEqual(2, r['count'])
        self.assertEqual('Success', r['nodes'][0]['status'])
        self.assertEqual('FAILED', r['nodes'][1]['status'])
        self.assertEqual('Warn', r['status'])

    @patch('cirrus_tool.L2AddKeywords.provision_server')
    @patch('cirrus_tool.L2AddKeywords.wait_on_task')
    def test_parallel_provision_servers(self, mock, mock_prov):
        """
        Verify the custom keyword CPT Parallel OS Deployment
        :param mock: Handle to wait_on_task
        :param mock_prov: Handle to provision_server
        :return:
        """
        # Mocked output
        mock.side_effect = [{'status': 'Success',
                             'os_name': 'VMware ESXi 6.5.0',
                             'ipv4': '10.1.146.200',
                             'server': 'bay01'},
                            {'status': 'Warn',
                             'nodes': [{'status': 'Success',
                                        'os_name': 'VMware ESXi 6.5.0',
                                        'ipv4': '10.1.146.201',
                                        'server': 'bay02'},
                                       {'status': 'Failed',
                                        'os_name': 'VMware ESXi 6.5.0',
                                        'ipv4': '10.1.146.202',
                                        'server': 'bay03'}]}]
        mock_prov.side_effect = ['/tmp/tmp.xx/cpt.log', '/tmp/tmp.yy/cpt.log']
        # Run the test
        cpt = L2AddKeywords()
        cpt.set_credentials(ipv4='192.168.10.12', user='root', passwd='hpvse1')
        r = cpt.parallel_provision_server([testdata.single_node,
                                           testdata.multi_node])

        # checks
        self.assertEquals(2, len(r))
        self.assertEquals('Success', r[0]['status'])
        self.assertEquals('Warn', r[1]['status'])
        self.assertEquals('Failed', r[1]['nodes'][1]['status'])
