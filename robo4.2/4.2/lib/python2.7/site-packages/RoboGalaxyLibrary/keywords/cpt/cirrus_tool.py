#!/usr/bin/env python27
# (C) Copyright 2018 Hewlett Packard Enterprise Development LP
"""
Keywords for Cirrus Provisioning Tool
"""
from datetime import datetime, timedelta
from functools import wraps
from jinja2 import Environment, FileSystemLoader
from RoboGalaxyLibrary.utilitylib.exec_process import remote_cmd, remote_copy
from RoboGalaxyLibrary.utilitylib.logging import LOG
from robot.api.deco import keyword
from time import sleep
from threading import Thread, Lock
import os
import random
import string


def username_required(func):
    """
    Decorate that checks if the object is initialized correctly
    :param func: Calling function
    :return: Function
    """
    @wraps(func)
    def wrap(self, *args, **kwargs):
        if not self.username:
            raise AssertionError('CPT information needs to be configured')
        return func(self, *args, **kwargs)
    return wrap


class L2AddKeywords(object):
    """
    Keywords for Cirrus Provisioning Tool
    L2Add -- was the christened name
    """
    def __init__(self):
        """
        Initialization method
        """
        self.ip = None
        self.username = None
        self.password = None
        self.nodes = 0
        self.lock = Lock()
        self.results = list()

    def _remote_copy(self, source, destn):
        """
        Calls remote_copy method and helps avoid providing credentials everytime
        :param source: Local/Remote file to be copied
        :param destn: Local/Remote folder to be copied to
        :return: Status of remote_copy
        """
        s = remote_copy(host_ip=self.ip, username=self.username,
                        password=self.password, source=source, destn=destn)

        if s.get('status') == "Failed":
            raise AssertionError(s.get('error', "Error encountered"))

        return s

    def _remote_cmd(self, cmd, block=True):
        """
        Calls remote_command method and helps avoid passing the credentials
        :param cmd: String, command to be executed
        :return: String
        """
        s = remote_cmd(host_ip=self.ip, username=self.username,
                       password=self.password, command=cmd, block=block)

        if s.get('status') == "Failed":
            raise AssertionError(s.get('error', "Error encountered"))

        return s

    def _copy_files_to_server(self, body, key, v, destn_dir):
        """
        Copies the local file to the CPT server and replaces the path for
        custom kickstart & scripts relative to the workspace in the CPT server
        :param body: payload passed by the user
        :param key: key in the body to be fixed
        :param v: Object that could be a variable or list containing local
                     path which needs to be copied to the workspace in the
                     l2add server
        :param destn_dir: Workspace directory for the task
        :return: True if success else error
        """
        if isinstance(v, list):
            if len(v) > 0:
                for c, f in enumerate(v):
                    # Continue on empty|None elements
                    if not f:
                        continue

                    # Forcing Linux os.sep as test head can be Windows or Linux
                    body['os'][c][key] = destn_dir + '/' + os.path.split(f)[1]
                    self._remote_copy(f, body['os'][c][key])
        else:
            if v:
                # Forcing Linux os.path.sep as test head can be Windows or Linux
                body[key] = destn_dir + '/' + os.path.split(v)[1]
                self._remote_copy(v, body[key])

    def _generate_xml(self, body, destn_dir, nodes=True):
        """
        Generates the XML file that is the input to CPT utility
        :param body: payload passed by the user... JSON object
        :param destn_dir: workspace for the task
        :param nodes: Boolean True for single node False for multiple
        :return: Absolute file path of the XML file in the remote workspace
        """
        fn = ''.join([random.choice(string.ascii_letters) for _ in range(12)])
        fn += '.xml'

        _dir = os.path.dirname(os.path.abspath(__file__))
        _tmpl = 'multi_node.template' if nodes else 'single_node.template'
        _env = Environment(autoescape=False,
                           loader=FileSystemLoader(_dir),
                           trim_blocks=False)

        with open(fn, 'w+') as f:
            o = _env.get_template(_tmpl).render(body)
            f.write(o)

        _d = destn_dir + '/' + fn
        self._remote_copy(fn, _d)
        # Remove the XML file created locally
        os.remove(fn)

        return _d

    def _pre_tasks(self, body, work_dir):
        """
        Steps to be executed before calling l2add for deployment. They are
        1. Create a workspace for the task
        2. Copy local files to workspace
        3. Create a temporary log file for monitoring purposes
        4. Generate the input XML that is provided to l2add
        :param body: payload passed by the user. It is a JSON object
        :param work_dir: workspace for the task
        :return: Absolute file path of the input XML file
        """
        # Check for custom information
        # Check if its bulk provisioning... os key is available in bulk mode
        if body.get('os'):
            _ks = map(lambda x: x.get('kickstart'), body['os'])
            self._copy_files_to_server(body, 'kickstart', _ks, work_dir)

            _cs = map(lambda x: x.get('custom_script'), body['os'])
            self._copy_files_to_server(body, 'custom_script', _cs, work_dir)
        else:
            # Check if user has custom kickstart and script
            if body.get('kickstart'):
                _ks = body.get('kickstart')
                self._copy_files_to_server(body, 'kickstart', _ks, work_dir)

            if body.get('custom_script'):
                _cs = body.get('custom_script')
                self._copy_files_to_server(body, 'custom_script', _cs, work_dir)

        flag = True if body.get('os', None) else False

        return self._generate_xml(body, work_dir, flag)

    def _remove_workspace(self, destn_dir):
        """
        Removes the workspace created for the task
        :param destn_dir: Folder to be removed
        :return: Response body
        """
        _cmd = "rm -rf {}".format(destn_dir)
        return self._remote_cmd(_cmd)

    @staticmethod
    def _result_to_dict(line):
        """
        Helper to convert the line to dictionary
        :param line: String - in the results format separated by :;
        :return: dictionary
        """
        f = line.split(':;')
        return {'server': f[0], 'os_name': f[1], 'status': f[2], 'ipv4': f[3]}

    def _convert_result_to_json(self, lines):
        """
        Converts the line which is of the below type into a JSON object
        'bay03-01:;VMware ESXi 6.5.0-1.29.6765664:;Success:;10.1.46.140'
        :param lines: String - as above
        :return: JSON object
        """
        if not lines:
            return {'status': 'Failed',
                    'msg': 'Final result is not available.'}

        lines = lines.split('\n')
        n = len(lines)

        if n == 1:
            return self._result_to_dict(lines[0])

        return {'count': n,
                'nodes': [self._result_to_dict(line) for line in lines]}

    def _get_error_info(self, result, log):
        """
        Retrieves the detailed error information for failed nodes
        :param dict result: Deployment results
        :param str log: Deployment task log file
        :return None:
        """
        _ = '/opt/l2deploy/logs/OverallStatusReport'
        f = self._remote_cmd("grep '{}' {}".format(_, log))
        f = f.get('output').split('[')[-1][:-1]

        for n in [result] if self.nodes == 1 else result['nodes']:
            if 'failed' == n.get('status').lower():
                # 10th line in the detail report contains the required info
                c = "grep -A 10 {} {}".format(n.get('server'), f)
                c += " | grep OS_Install_Status_Detail"
                e = self._remote_cmd(c).get('output').split(':', 1)[1]
                LOG.info("{} failed due to {}".format(n['server'], e))

    @keyword(name='CPT Login')
    def set_credentials(self, ipv4, user, passwd):
        """
        Configures the object credentials

        Example:
        CPT Login | 10.1.0.10 | root | hpvse123

        :param str ipv4: Host IPv4 address
        :param user: system username
        :param passwd: password for the provided user
        :return: None
        """
        self.ip = ipv4
        self.username = user
        self.password = passwd

    @username_required
    @keyword(name="CPT Deploy OS")
    def provision_server(self, body):
        """
        Bare-metal provisioning based on inputs provided. This method calls
        l2add utility available in the remote server

        Example:
        ${log}=    CPT Deploy Server | <json_dict>

        :param body: JSON body
        :return: Absolute path to logfile for monitoring
        """
        if not body:
            raise AssertionError("Payload cannot be empty")

        self.nodes = len(body.get('nodes')) if body.get('os') else 1

        _cmd = 'mktemp -d'
        workspace = self._remote_cmd(_cmd).get('output')
        xml = self._pre_tasks(body, workspace)
        log = workspace + '/' + 'rg_cpt_deploy.log'

        _bin = '/usr/bin/nohup /usr/bin/l2add'
        _cmd = '{} -f {} -c y -r > {} 2>&1 &'.format(_bin, xml, log)

        if self._remote_cmd(_cmd, block=False).get('output') is None:
            raise AssertionError("Error encountered during provisioning")

        return log

    @username_required
    @keyword(name="CPT Wait On Task")
    def wait_on_task(self, log, timeout=60, interval=60):
        """
        CPT has no monitor task feature. The process/task is monitored based on
        the number of processes watching/writing the log file

        Example:
        ${r}=    CPT Wait on Task | <log_file_path> | <timeout>M | <interval>S

        Returns:
            { 'server': 'Hostname',
              'os_name': 'Operating System',
              'status': 'SUCCESS' | 'FAILED' - based on the status
              'ipv4': 'IPv4 Address' }

        :param log: Log file name
        :param timeout: Maximum amount of time to wait in minutes
        :param interval: Periodic check/monitor in seconds
        :return: Response body
        """
        time_out = datetime.now() + timedelta(minutes=timeout)
        while time_out > datetime.now():
            sleep(interval)
            _cmd = 'lsof | fgrep {} | grep l2add | wc -l'.format(log)
            h_count = self._remote_cmd(_cmd).get('output')

            if int(h_count) == 0:
                # With the latest version of CPT the results are misaligned
                # The concerned lines are the only ones having :;
                # This fix would hold good for older versions
                _cmd = "grep ':;' {}".format(log)
                r = self._remote_cmd(_cmd).get('output', None)
                r = self._convert_result_to_json(r)

                if self.nodes == 1:
                    if r.get('status').lower() == 'Success'.lower():
                        self._remove_workspace('/tmp/' + log.split('/')[2])
                else:
                    if 'FAILED' not in map(lambda x: x['status'],
                                           r.get('nodes')):
                        self._remove_workspace('/tmp/' + log.split('/')[2])
                        r['status'] = 'Success'
                    else:
                        r['status'] = 'Warn'

                # Detailed error information is available in OverallStatusReport
                self._get_error_info(r, log)

                return r
            else:
                _cmd = "grep \'^| \' {} | tail -n {}".format(log, self.nodes)
                LOG.debug(self._remote_cmd(_cmd).get('output'))
                LOG.info("Task is in progress...")

        return {"status": "Failed",
                "msg": "Timeout. Task is still in progress."}

    def _parallel_deploy(self, body, timeout=60, interval=60):
        """
        Helper method for parallel provisioning. This in turn spawns a process
        on the CPT server and then waits for results
        :param dict body: Dictionary containing information of server and OS
        :param int timeout: Default 60 - timeout for the process
        :param int interval: default 60 - polling interval in seconds
        :return dict: Task status
        """
        try:
            r = self.wait_on_task(self.provision_server(body), timeout,
                                  interval)
        except AssertionError as ae:
            r = {"status": "Error", "msg": ae.message}

        with self.lock:
            self.results.append(r)

    @username_required
    @keyword(name="CPT Parallel OS Deployment")
    def parallel_provision_server(self, bodies, **kwargs):
        """
        Keyword to supporting bare-metal server OS deployment in parallel. It
        calls the _parallel_deploy method

        Usage
            @{r}=    CPT Parallel OS Deployment | <list> | <timeout> | <polling>

        :param list bodies: Iterable dictionary containing information of target
                            server and OS profile
        :param kwargs: Supported keys are
                        - count     # number of threads to spwan
                        - timeout   # timeout per thread in minutes
                        - interval  # polling interval in seconds
        :return list: Iterable dictionary containing information about
                      provisioning results of the target server
        """
        thrd_no = kwargs.get('count', 9)
        thrd_out = kwargs.get('timeout', 60)
        thrd_poll = kwargs.get('interval', 60)
        threads = list()

        # Identify time out for the keyword
        _t = 1 if len(bodies) < thrd_no else (len(bodies) / thrd_no) + 1
        time_out = datetime.now() + timedelta(minutes=thrd_out * _t)

        while time_out > datetime.now():
            LOG.publish_message(timeout=2)

            for index, item in enumerate(threads):
                if not item.is_alive():
                    threads.pop(index)

            if len(threads) < thrd_no and len(bodies):
                t = Thread(target=self._parallel_deploy,
                           args=(bodies.pop(), thrd_out, thrd_poll,))
                t.daemon = True
                t.start()
                threads.append(t)
            elif not len(bodies) and not len(threads):
                # No pending tasks or jobs
                break
            else:
                # There are some pending tasks or jobs
                sleep(5)

        LOG.publish_message(timeout=60)
        return self.results
