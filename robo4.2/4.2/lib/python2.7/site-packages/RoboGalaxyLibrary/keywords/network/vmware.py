#!/bin/env python27
# (C) Copyright 2018 Hewlett Packard Enterprise Development LP
"""
Module that performs network configurations on the ESXi target system or the
given vCenter
"""
from RoboGalaxyLibrary.utilitylib import logging as log
from RoboGalaxyLibrary.keywords.vsphere import VsphereKeywords


class VMwareNetConfig(object):
    """
    Object to configure VMware vSwitch and vDS
    """
    def __init__(self):
        """
        Initializer method
        """
        self.results = list()
        self.esx_ref = None
        self.vc_ref = None
        self.dc = None

    def __del__(self):
        """
        Destructor
        :return:
        """
        if self.vc_ref is not None:
            self.vc_ref.disconnect_from_vi_server()

        if self.esx_ref is not None:
            self.esx_ref.disconnect_from_vi_server()

    def _validate_and_set_host(self, host):
        """
        Verifies and sets the objective attribute host
        :param dict host: Key/value pairs having target information
        :return bool: True when criteria is meet else False
        """
        attrs = ['ipv4', 'user', 'password']

        if not set(attrs).issubset(host.keys()):
            log.info('Missing host information')
            log.info('Found attributes {}'.format(host.keys()))
            log.info('Required attributes {}'.format(attrs))
            return False

        self.esx_ref = VsphereKeywords()
        if self.esx_ref.connect_to_vi_server(ip=host['ipv4'],
                                             username=host['user'],
                                             password=host['password']) == 1:
            log.warn('Unable to establish connection')
            return False

        if not self.esx_ref.is_esxi():
            log.warn('System is not an ESXi instance.')
            return False

        if host.get('manager'):
            if set(attrs).issubset(host['manager'].keys()):
                self.vc_ref = VsphereKeywords()
                if self.vc_ref.connect_to_vi_server(host['manager']['ipv4'],
                                                    host['manager']['user'],
                                                    host['manager']['password'],
                                                    port=443) == 1:
                    log.warn('Unable to establish connection.')
                    return False

                if not self.vc_ref.is_vcenter():
                    log.warn('Host is not a vCenter Server instance')
                    return False

                self.dc = host['manager'].get('datacenter', None)

                if self.dc is None:
                    log.warn('Datacenter information is a mandatory key')
                    return False

                if not self.vc_ref.datacenter_exists(self.dc):
                    log.warn('Datacenter does not exists')
                    return False
            else:
                log.warn('Missing vCenter information')
                log.info('Found attributes {}'.format(host['manager'].keys()))
                log.info('Required attributes {}'.format(attrs))
                return False
        else:
            log.warn('No hypervisor manager information provided.')

        return True

    def _ports_exists(self, ports):
        """
        Verifies the ports exists on the host
        :param list ports: List containing network port names/mac
        :return bool: True when all ports are found else False
        """
        if not ports:
            log.debug('No ports to validate')
            return True

        macs = self.esx_ref.get_host_mac_addresses()
        devices = self.esx_ref.get_host_nic_names()
        port_exist = list()

        for port in ports:
            if port.count(':') == 5:
                port_exist.append(True if port.lower() in macs else False)
            else:
                port_exist.append(True if port.lower() in devices else False)

        return all(port_exist)

    def _configure_vswitch(self, net):
        """
        Create a standard vSwitch on the target system, it uses the ESXi
        endpoint for the performing the configuration. Irrespective of whether
        the target is part of the vCenter
        :param dict net: Dictionary containing Switch and PortGroup config
        :return: None -- results are appended to the Object attribute results
        """
        if not self._ports_exists(net['ports']):
            log.info('Network ports not found in the host system.')
            self.results.append({'ports': net['ports'], 'status': 'Fail'})
            return

        if not self.esx_ref.esx_vswitch_exists(net['name']):
            if not self.esx_ref.add_standard_vswitch(net['name']):
                self.results.append({'ports': net['ports'], 'status': 'Fail'})
                return

        if not self.esx_ref.vswitch_add_uplinks(net['name'], net['ports']):
            self.results.append({'ports': net['ports'], 'status': 'Fail'})
            return

        flag = True
        for n in net['networks']:
            pg_exist = self.esx_ref.get_portgroups_in_vswitch()
            pg_name = n.get('name', '{}-{}'.format(net['name'],
                                                   n.get('name', n.get('vlan',
                                                                       0))))
            if pg_name in pg_exist:
                log.warn('{} exists'.format(pg_name))
                continue

            # Build PortGroup Spec
            spec = dict()
            spec.update({'vlan': n.get('vlan', 0)})

            if 'team' in n:
                spec.update({'team': n.get('team')})
            elif 'policy' in n:
                spec.update({'team': {'policy': n.get('policy')}})

            if 'security' in n:
                spec.update({'security': n.get('security')})

            if 'shaping' in n:
                spec.update({'shaping': n.get('shaping')})

            log.debug('Adding portgroup with {}'.format(spec))
            if not self.esx_ref.add_portgroup_to_vswitch(net['name'],
                                                         pg_name, **spec):
                flag = False
                continue

            if n.get('vmk', False):
                nic_data = dict({'dhcp': n.get('dhcp'),
                                 'type': n.get('type'),
                                 'portgroup': pg_name})

                if nic_data.get('type').lower() == 'vmotion':
                    nic_data.update({'stack': 'vmotion'})

                if not n.get('dhcp'):
                    nic_data.update({'ipv4': n.get('ipv4'),
                                     'subnet': n.get('netmask')})

                if not self.esx_ref.add_nic_to_vswitch(**nic_data):
                    flag = False

        self.results.append({'ports': net['ports'],
                             'status': 'Pass' if flag else 'Fail'})

    def _configure_distributed_switch(self, net):
        """
        Creates a distributed vSwitch on the vCenter server using the server
        endpoint.
        :param dict net: Dictionary containing DVS and PortGroup configuration
        :return: None -- results are appended to the Object attribute results
        """
        pass

    def configure_network(self, body):
        """
        Creates the vSwitch or distributed vSwitch depending on the type
        provided and its port groups.
        :param dict body: JSON body
        :return list:  List of results for each network configuration
        """
        if not body.get('config', []):
            log.warn('No network configurations found')
            return self.results

        if not self._validate_and_set_host(body.get('host')):
            return self.results

        for net in body['config']:
            if not net.get('name'):
                log.warn('Missing required attribute: name')
                self.results.append({'ports': 'Unknown', 'status': 'Fail'})
                continue

            if net.get('type') == 'vss':
                self._configure_vswitch(net)
            elif net.get('type') == 'vds':
                self._configure_distributed_switch(net)
            else:
                log.info('Unknown network type provided {}'.format(net['type']))
                self.results.append({'ports': net['name'], 'status': 'Fail'})

        log.debug('Results\n{}'.format(self.results))

        return self.results
