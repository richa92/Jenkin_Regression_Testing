#!/bin/env python27
# (C) Copyright 2018 Hewlett Packard Enterprise Development LP
# Python module that configures the network connections of the target RedHat
# based system with the help of interface configuration template.
from copy import deepcopy
from RoboGalaxyLibrary.utilitylib.exec_process import remote_cmd
from RoboGalaxyLibrary.utilitylib.logging import logger as log


class RedHatNetConfig(object):
    """
    Module to configure the target server networks using NMCLI
    - Ethernet
    - Bond
    - Team
    """
    def __init__(self):
        """
        Object initialization method
        """
        self.result = list()
        self.host = None

    def _verify_host(self, host):
        """
        Verifies all the required attributes of the host is available or not
        :param dict host: Key-value pair of host section
        :return bool: True when all exists else False
        """
        attrs = ['ipv4', 'user', 'password']

        if not set(attrs).issubset(host.keys()):
            m = 'Required attributes: {}'.format(attrs)
            m += '\nFound attributes: {}'.format(host.keys())
            log.info(m)
            return False

        self.host = deepcopy(host)

        return True

    def _remote_cmd(self, cmd, block=True):
        """
        Executes the given command on the remote system and returns the outpu
        :param cmd: Command to be executed on the remote system
        :type: str
        :return str: Output
        """
        r = remote_cmd(host_ip=self.host['ipv4'], username=self.host['user'],
                       password=self.host['password'], command=cmd, block=block)

        if r.get('status').lower() == "failed":
            log.debug('Command: {}\nOutput: {}'.format(cmd, r['error']))
            return r.get('error') if r.get('error') else False

        if r.get('status').lower() == "success":
            log.debug('Command: {}\nOutput: {}'.format(cmd, r['output']))
            return r['output'] if r['output'] else True

    def _get_ifname(self, mac):
        """
        Retrieves the Interface Name for the provided MAC address
        :param str mac: MAC address
        :return str: interface name
        """
        cmd = 'ip link show | grep -i -B 1 {} | head -n 1 | '.format(mac)
        cmd += "cut -d ':' -f 2"
        r = self._remote_cmd(cmd)

        # Remove the leading whitespace if output is a string
        # The command is successful however there is no output hence check for
        # output to be a string
        r = r.strip() if isinstance(r, basestring) else None

        if not r:
            if not self._remote_cmd('ls /sys/class/net/bonding_masters'):
                return None

            if self._remote_cmd('which ethtool') is None:
                return None

            cmd = 'for i in $(ls /sys/class/net); do if [ $(ethtool -p $i '
            cmd += '2> /dev/null | grep {} | wc -l) -eq 1 ] ;'.format(mac)
            cmd += ' then echo $i && break ; fi ; done ;'
            r = self._remote_cmd(cmd)
            # The command execution is success as no error is thrown however
            # our check requires a string value.
            r = r if isinstance(r, basestring) else None

        return r

    def _get_mac(self, dev):
        """
        Retrieves the MAC address for the given interface name
        :param str dev: interface name or MAC
        :return str: MAC address
        """
        return self._remote_cmd('cat /sys/class/net/{}/address'.format(dev))

    def _get_device_info(self, port):
        """
        Retrieves the port information i.e. ifname & mac address from the system
        :param port: MAC or IFNAME
        :return:
        """
        if port.count(':') == 5:
            r = {'device_name': self._get_ifname(port), 'mac': port}
        else:
            r = {'device_name': port, 'mac': self._get_mac(port)}

        if r['device_name'] is None or r['mac'] is None:
            return None

        return r

    @staticmethod
    def _verify_network_info(net):
        """
        Verify the key-value pairs of the provided network address
        :param net:
        :return:
        """
        if not net.get('dhcp'):
            if net.get('ipv4', None) is None and net.get('ipv6', None) is None:
                log.info('Keys: ipv4 or ipv6 is required')
                return False

        if net.get('vlan'):
            if net.get('vlan') < 0 or net.get('vlan') > 4095:
                log.info('VLAN ID: {} is invalid.'.format(net['vlan']))
                return False

        return True

    def _configure_ethernet(self, cfg):
        """
        Method to configure network connections of type ETHERNET
        :param dict cfg: Dict containing information of network connections
        :return: None
        """
        if len(cfg['ports']) != 1:
            log.info('Invalid number of port provided for Ethernet network.')
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return

        p = self._get_device_info(cfg['ports'][0])
        if p is None:
            log.info('Invalid port information: {}'.format(cfg['ports']))
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return

        for net in cfg['networks']:
            flag = False
            cname = p['device_name']

            if self._verify_network_info(net):
                cmd = 'nmcli connection add'

                if net.get('vlan'):
                    cname += '.{}'.format(net['vlan'])
                    cmd += ' type vlan con-name {}'.format(cname)
                    cmd += ' dev {} id {}'.format(p['device_name'], net['vlan'])
                else:
                    cmd += ' type ethernet con-name {}'.format(cname)
                    cmd += ' ifname {}'.format(p['device_name'])

                if not net.get('dhcp'):
                    if net.get('ipv4'):
                        cmd += ' ip4 {}'.format(net['ipv4'])
                    else:
                        cmd += ' ip6 {}'.format(net['ipv6'])

                    if net.get('netmask'):
                        b = sum([bin(int(x)).count("1")
                                 for x in net['netmask'].split(".")])
                        cmd += '/{}'.format(b)

                if self._remote_cmd(cmd):
                    flag = True
                    log.info('Network {} configured.'.format(cname))
                else:
                    log.info('Network {} failed.'.format(cname))
            else:
                log.info('Incorrect network information {}'.format(net))

            if flag:
                self.result.append({"ports": cname, 'status': 'Pass'})
            else:
                self.result.append({"ports": cname, 'status': 'Fail'})

        _ = 'Network configuration completed for port: {}'.format(cfg['ports'])
        log.info(_)

    def _configure_bond(self, cfg):
        """
        Method to configure network connections of type BOND
        :param dict cfg: Dict containing information of network connections
        :return: None
        """
        if cfg.get('bond_opts') is None:
            log.info('Missing required attribute: bond_opts')
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return

        # Create Bond master
        cmd = 'nmcli connection add type bond ifname {}'.format(cfg['name'])
        cmd += ' con-name {}'.format(cfg['name'])
        cmd += " bond.options '{}'".format(cfg['bond_opts'])
        cmd += ' ipv4.method disabled ipv6.method ignore'

        if not self._remote_cmd(cmd):
            log.info('{} configuration failed.'.format(cfg['name']))
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return
        else:
            log.info('{} configuration succeed.'.format(cfg['name']))

        for net in cfg['networks']:
            flag = False
            cname = cfg['name']

            if self._verify_network_info(net):
                vlan_id = 0 if not net.get('vlan') else net['vlan']
                cname += '.{}'.format(vlan_id)
                cmd = 'nmcli connection add type vlan'
                cmd += ' ifname {} con-name {}'.format(cname, cname)
                cmd += ' id {} dev {}'.format(vlan_id, cfg['name'])

                if not net.get('dhcp'):
                    if net.get('ipv4'):
                        cmd += ' ip4 {}'.format(net['ipv4'])
                    else:
                        cmd += ' ip6 {}'.format(net['ipv6'])

                    if net.get('netmask'):
                        b = sum([bin(int(x)).count("1")
                                 for x in net['netmask'].split(".")])
                        cmd += '/{}'.format(b)

                if self._remote_cmd(cmd):
                    flag = True
                    log.info('{} configuration succeeded'.format(cname))
                else:
                    log.info('{} configuration failed'.format(cname))
            else:
                log.info('Incorrect network information {}'.format(net))

            if flag:
                self.result.append({"ports": cname, 'status': 'Pass'})
            else:
                self.result.append({"ports": cname, 'status': 'Fail'})

        # Bond master is not up till bond-slaves come online. This prevents
        # existing connectivity drops
        for port in cfg['ports']:
            p = self._get_device_info(port)
            if p is None:
                log.info('Invalid port: {}'.format(port))
                self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
                return

            cmd = 'nmcli connection add type bond-slave'
            cmd += ' ifname {} con-name {}-{}'.format(p['device_name'],
                                                      cfg['name'],
                                                      p['device_name'])
            cmd += ' master {}'.format(cfg['name'])

            if not self._remote_cmd(cmd):
                _ = '{} port configuration failed.'.format(p['device_name'])
                log.info(_)
                self.result.append({'ports': p['device_name'],
                                    'status': 'Fail'})
                return
            else:
                _ = '{} bond slave port configured.'.format(p['device_name'])
                log.info(_)

        _ = 'Network configuration completed for port: {}'.format(cfg['ports'])
        log.info(_)

    def _configure_team(self, cfg):
        """
        Method to configure network connections of type TEAM
        :param dict cfg: Dict containing information of network connections
        :return: None
        """
        if cfg.get('team_opts') is None:
            log.info('Missing required attribte: team_opts')
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return

        if cfg.get('team_port_cfg') is None or len(cfg['team_port_cfg']) != 2:
            log.info('Missing required attributes: team_port_cfg')
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return

        # Create Team Master
        cmd = 'nmcli connection add type team ifname {}'.format(cfg['name'])
        cmd += ' con-name {}'.format(cfg['name'])
        cmd += " team.options '{}'".format(cfg['team_opts'])
        cmd += ' ipv4.method disabled ipv6.method ignore'

        if self._remote_cmd(cmd):
            log.info('{} master configuration succeeded.'.format(cfg['name']))
        else:
            log.info('{} master configuration failed.'.format(cfg['name']))
            self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
            return

        for net in cfg['networks']:
            flag = False
            cname = cfg['name']

            if self._verify_network_info(net):
                vlan_id = 0 if not net.get('vlan') else net['vlan']
                cname += '.{}'.format(vlan_id)
                cmd = 'nmcli connection add type vlan'
                cmd += ' ifname {} con-name {}'.format(cname, cname)
                cmd += ' id {} dev {}'.format(vlan_id, cfg['name'])

                if not net.get('dhcp'):
                    if net.get('ipv4'):
                        cmd += ' ip4 {}'.format(net['ipv4'])
                    else:
                        cmd += ' ip6 {}'.format(net['ipv6'])

                    if net.get('netmask'):
                        b = sum([bin(int(x)).count("1")
                                 for x in net['netmask'].split(".")])
                        cmd += '/{}'.format(b)

                if self._remote_cmd(cmd):
                    flag = True
                    log.info('{} configuration succeeded'.format(cname))
                else:
                    log.info('{} configuration failed'.format(cname))
            else:
                log.info('Incorrect network information {}'.format(net))

            if flag:
                self.result.append({"ports": cname, 'status': 'Pass'})
            else:
                self.result.append({"ports": cname, 'status': 'Fail'})

        # Team master is not connect till all team-ports come on-line
        # This prevents existing connection drops.
        for i in range(len(cfg['ports'])):
            p = self._get_device_info(cfg['ports'][i])
            if p is None:
                log.info('Invalid port: {}'.format(cfg['ports'][i]))
                self.result.append({'ports': cfg['ports'], 'status': 'Fail'})
                return

            cmd = 'nmcli connection add team-slave'
            cmd += ' ifname {} con-name {}-{}'.format(p['device_name'],
                                                      cfg['name'],
                                                      p['device_name'])
            cmd += ' master {}'.format(cfg['name'])
            cmd += " team-port.options '{}'".format(cfg['team_port_cfg'][i])

            if self._remote_cmd(cmd):
                log.info('{}-{} configuration passed'.format(cfg['name'],
                                                             p['device_name']))
            else:
                log.info('{}-{} configuration failed'.format(cfg['name'],
                                                             p['device_name']))
                self.result.append({'ports': p['device_name'],
                                    'status': 'Fail'})
                return

        _ = 'Network configuration completed for port: {}'.format(cfg['ports'])
        log.info(_)

    def configure_network(self, body):
        """
        Entry point for configuring the network interfaces. Based on the network
        type, the appropriate configurator is executed. Below are the supported
        options

        Input
        ------
        [host]
        ipv4            -| Target system IPv4 address
        os              -| Operating system installed on the target
        user            -| Root privileged account
        password        -| Password of the provided user

        [config]
        ports           -| List of MAC addresses or device names - str
        type            -| Network configuration type - ETHERNET, BOND or TEAM
        name             | Name of the connection required for BOND & TEAM
        bond_opts        | Bond options for BOND network type
        team_opts        | Team options for TEAM network type
        team_port_cfg    | Required for TEAM type - configuration values

        [networks]        | List of items having the below configurations
        vlan             | VLAN ID for the network
        dhcp            -| True when address is received from DHCP server else
        ipv4             | IPv4 network address
        ipv6             | IPv6 network address
        netmask          | Network mask

        -| keys are mandatory

        Output
        -------
        List of { "port": '', "status": <Pass | Fail> }

        :param dict body: Dictionary containing key-values from the above
        :return dict: Status for each network configuration
        """
        if len(body.get('config', list())) == 0:
            log.info('No configurations to be applied')
            return self.result

        if body.get('host', None) is None or not \
                self._verify_host(body['host']):
            return self.result

        if not self._remote_cmd('modprobe bonding && modprobe 8021q'):
            log.info('VLAN and bonding modules missing.')
            return self.result

        if not self._remote_cmd('which nmcli'):
            log.info('Missing required utility: nmcli')
            return self.result

        for c in body['config']:
            if len(c.get('ports', [])) == 0 or len(c.get('networks', [])) == 0 \
                    or c.get('type', None) is None:
                log.info('Missing network information')
                self.result.append({'ports': c.get('ports', 'Unknown'),
                                    'status': 'Fail'})
                continue

            if c['type'].lower() == 'ethernet':
                self._configure_ethernet(c)
            elif c['type'].lower() == 'bond' or c['type'].lower() == "team":
                if len(c['ports']) != 2:
                    log.info('Incorrect number of interfaces provided.')
                    self.result.append({'ports': c['ports'], 'status': 'Fail'})
                    continue

                if c.get('name', None) is None:
                    log.info('Missing required attribute: name')
                    self.result.append({'ports': c['ports'], 'status': 'Fail'})
                    continue

                if c['type'].lower() == "bond":
                    self._configure_bond(c)
                else:
                    self._configure_team(c)
            else:
                log.info('Unknown network port type: {}'.format(c['ports']))
                self.result.append({'ports': c['ports'], 'status': 'Fail'})

        self._remote_cmd('systemctl restart network.service', False)
        return self.result
