#!/usr/bin/env python27
# (C) Copyright 2018 Hewlett Packard Enterprise Development LP
"""
Base Redfish API client that communicates with HPE iLO subsystem
"""
from redfish import AuthMethod, redfish_client
from redfish.ris import tpdefs
from RoboGalaxyLibrary.utilitylib.logging import logger


class RedfishClient(object):
    """
    Base class for communication using redfish interface
    """
    def __init__(self, host, user=None, password=None, session_key=None):
        """
        Object initialization method
        :param host: iLO sub-system IP or FQDN
        :param user: A user in iLO sub-system realm
        :param password: Password of the above user
        :param session_key: Session key
        """
        url = "https://{}".format(host)

        self.client = redfish_client(base_url=url, username=user,
                                     password=password, sessionkey=session_key)

        if not session_key:
            # With SSO, the user is already logged into a manager hence login
            # should not be called.
            self.client.login(auth=AuthMethod.SESSION)

        self.type_path = tpdefs.Typesandpathdefines()
        self.type_path.getgen(url=url)
        self.type_path.defs.redfishchange()

        self.SYS_RESOURCE = self._get_resource_directory()
        self.MSG_REGISTRY = self._get_base_registry()

    def get(self, uri=None):
        """
        Performs GET call
        :param uri: URI
        :return RestResponse: response of the request
        """
        return self.client.get(path=uri)

    def patch(self, uri=None, body=None):
        """
        Performs PATCH action
        :param uri: URI
        :param body: DICT - containing the payload
        :return RestResponse: response of the call
        """
        return self.client.patch(path=uri, body=body)

    def put(self, uri=None, body=None):
        """
        Performs PUT action
        :param uri: URI
        :param body: DICT - contains the request payload
        :return: Response of the call
        """
        return self.client.put(path=uri, body=body)

    def post(self, uri=None, body=None):
        """
        Performs POST action
        :param str uri: URI
        :param dict body: DICT - contains the request payload
        :return: dict - response of the request
        """
        return self.client.post(path=uri, body=body)

    def delete(self, uri=None, body=None):
        """
        Performs HTTP verb - Delete
        :param str uri: URI
        :param dict body: contains the request payload
        :return: dict - response of the request
        """
        return self.client.delete(path=uri, body=body)

    def _get_resource_directory(self):
        """
        Returns the list of system resources
        :return: Dictionary
        """
        resp = self.get(uri='/redfish/v1/resourcedirectory/')

        if resp.status == 200:
            return {'resources': resp.dict['Instances']}
        else:
            logger.debug("Unable to find resource directory.")
            raise AssertionError("Resource directory is missing.")

    def _get_base_registry(self):
        """
        Returns the list of message registries
        :return: dict
        """
        resp = self.get(uri='/redfish/v1/Registries/')
        msg = dict()

        for e in resp.dict['Members']:
            if not [x for x in ['/Base/', '/iLO/'] if x in e['@odata.id']]:
                continue
            else:
                reg = self.get(uri=e['@odata.id'])

            for l in reg.dict['Location']:
                loc = l['Uri']['extref'] if 'extref' in l['Uri'] else l['Uri']
                r = self.get(uri=loc)

                if r.status == 200:
                    msg[r.dict['RegistryPrefix']] = r.dict['Messages']
                else:
                    m = "{} not found at {}".format(r.dict['RegistryPrefix'],
                                                    loc)
                    logger.debug(m)

        return msg

    def get_message(self, resp):
        """
        Returns the error message code and description
        :param resp: RestResponse object
        :return dict: Error code & Description
        """
        if not self.MSG_REGISTRY:
            logger.debug("No message registry found.")
            return dict()

        try:
            r = resp.dict
            # The response would be of the below format
            # {"error":{"@Message.ExtendedInfo": \
            # [{"MessageId":"iLO.0.10.ResetInProgress"}]
            n = r['error']['@Message.ExtendedInfo'][0]['MessageId'].split('.')
        except:
            logger.debug("No extended error information.")
            return dict()

        for err in self.MSG_REGISTRY:
            if err != n[0]:
                continue

            for e in self.MSG_REGISTRY[err]:
                if e == n[3]:
                    code = n[3]
                    desc = self.MSG_REGISTRY[err][e]['Description']
                    m = "iLO Error Code:\t {}".format(code)
                    m += "\nDescription:\t{}".format(desc)

                    logger.debug(m)
                    return {'error_code': code, 'error_info': desc}

        # Unexpected code path
        logger.debug("There exists an error code with no description")
        return {'error_code': n[3], 'error_info': None}

    def get_resource_uris(self, types):
        """
        Returns the system resource links matching the request type
        :param str types: Type to be searched
        :return list: List of system resources
        """
        data = list()

        for i in self.SYS_RESOURCE['resources']:
            found = False

            if i.get('@odata.type', None) and types.lower() in \
                    i.get('@odata.type').lower():
                for e in self.SYS_RESOURCE['resources']:
                    if (i['@odata.type'] + '/settings/').lower() == \
                            (e['@odata.id']).lower():
                        found = True
                        break

                if not found:
                    data.append(i)

        if not data:
            logger.debug("{} resource or feature not supported".format(types))
            raise AssertionError("Not implemented feature")

        return data
