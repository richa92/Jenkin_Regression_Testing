'''
EMail Library keywords
    The keywords in this class use functions from poplib (https://docs.python.org/2/library/poplib.html)
    and smtplib (https://docs.python.org/2/library/smtplib.html)
'''
import poplib
import smtplib
import email
from re import match
import unittest
import socket       # used for unit tests
from datetime import datetime
from time import sleep


class TimeoutError(RuntimeError):

    """Raise this exception for an exiting timeout Robot error
    """
    ROBOT_EXIT_ON_FAILURE = True


class EmailKeywords(object):

    """Library for SMTP and POP Email keywords.

        This library provides the keywords for communicating with SMTP and POP servers and
        processing emails.
    """

    ROBOT_LIBRARY_SCOPE = 'Global'

    def __init__(self):
        self.pop_connected = False
        self.pop_server = None
        self.pop_user = None
        self.pop_password = None
        self.smtp_connected = False
        self.pop_obj = None
        self.smtp_obj = None

    def __del__(self):
        self.disconnect_from_pop_mail_server()
        self.disconnect_from_smtp_server()

    ##########################################################################
    # POP Mail Keywords
    ##########################################################################
    def _connect_pop(self, retry=5):
        """ Private method to connect to the POP server.
            Since POP sessions are locked, we must reconnect to get any message
            updates.  This method is used by the keywords that poll the POP server.
        """
        #  Occasionally, connections fail.  This might be due to high traffic, etc.
        # We retry [retry] times before raising an assertion.
        l_retry = retry
        while l_retry > 0:
            try:
                if self.pop_use_ssl:
                    self.pop_obj = poplib.POP3_SSL(self.pop_server, port=995)
                else:
                    self.pop_obj = poplib.POP3(self.pop_server, port=110)
                self.pop_obj.user(self.pop_user)
                self.pop_obj.pass_(self.pop_password)
                self.pop_connected = True
                return True
            except poplib.error_proto:  # indicates a login issue
                sleep(1)
                l_retry -= 1
            except socket.gaierror:     # this exception is tied to providing a bad server name
                raise AssertionError("Failed to connect to POP server: Bad server name '{0}'".format(self.pop_server))
        raise AssertionError("Failed to connect to POP server after {0} retries".format(retry))

    def connect_to_pop_mail_server(self, server, user, password, use_ssl=True):
        """
            Connect to the POP mail server
            Example:
            | Connect to POP Mail server | webmail.hp.com | americas/user/mailbox | password |
        """
        self.pop_server = server
        self.pop_user = user
        self.pop_password = password
        self.pop_use_ssl = use_ssl
        self._connect_pop()
        # The point of this keyword is to establish the initial connection and to save credentials for
        # future connections.  We can disconnect for now.
        self.disconnect_from_pop_mail_server()
        return True

    def reconnect_to_pop_mail_server(self):
        """ Since POP connections lock the mailbox, it is necessary to re-connect
            in order to determine updates.  This method serves that purpose.
            Examples:
        """
        # if we're already connected, disconnect
        if self.pop_connected and self.pop_obj is not None:
            self.disconnect_from_pop_mail_server()
        self._connect_pop()

    def disconnect_from_pop_mail_server(self):
        """
            Disconnect from the POP mail server
            Example:
            | Disconnect From POP Mail server |
        """
        if self.pop_obj is not None:
            self.pop_obj.quit()
            self.pop_connected = False
            self.pop_obj = None
        return True

    def wait_for_mail_message_count(self, count, timeout=60):
        """ Wait for a new message to appear on the POP server
            Example:
            | Wait for Mail Message | [timeout=20] |
        """
        start = datetime.now()
        while (datetime.now() - start).seconds < timeout:
            cur_count = self.get_mail_message_count()
            if cur_count == count:
                return cur_count
            sleep(5)    # sleep 5 seconds so as not to hammer the server with requests
        raise TimeoutError("Failed to wait for message count in {0}s".format(timeout))

    def get_mail_message_count(self):
        """ Return the count of messages in the currently connected POP mailbox.

            Example:
            | Get POP Mail Message Count |
        """
        self.reconnect_to_pop_mail_server()
        count = self.pop_obj.stat()[0]
        self.disconnect_from_pop_mail_server()
        return count

    def mail_message_count_should_be(self, count, timeout=60):
        """ Verify that the POP message count is as expected.
            Example:
            | Mail Message Count Should Be | 5 |
        """
        msg_count = self.wait_for_mail_message_count(count, timeout)
        if msg_count != count:
            raise AssertionError("POP message count should have been {0} when it was {1}".format(count, msg_count))

    def mail_message_count_should_not_be(self, count, timeout=20):
        """ Verify that the POP message count is not a certain value
            Example:
            | Mail Message Count Should Not Be | 5 |
        """
        start = datetime.now()
        # we need to wait for the message(s) to arrive, so a loop is necessary here
        while (datetime.now() - start).seconds < timeout:
            msg_count = self.get_mail_message_count()

        if msg_count == count:
            raise AssertionError("POP message count should have been {0}".count)

    def delete_mail_message(self, index):
        """ Delete a mail message from the POP server.
            NOTE: message index starts at 1
            Example:
            | Delete Mail Message | 1 |
        """
        self.reconnect_to_pop_mail_server()
        self.pop_obj.dele(index)
        # Disconnect will flush the connection and execute the delete operation
        self.disconnect_from_pop_mail_server()

    def get_mail_message_subject(self, message_number):
        """ Retrieve the subject for the supplied message number
            Example:
            | Get Mail Message Subject | 4 |
        """
        self.reconnect_to_pop_mail_server()
        mail = self.pop_obj.retr(message_number)[1]
        self.disconnect_from_pop_mail_server()
        msg = email.message_from_string("\n".join(mail))
        return msg['subject']

    def get_mail_message_body(self, message_number):
        """ Retrieve the body for the supplied message number
            Example:
            | Get Mail Message Body | 4 |
        """
        self.reconnect_to_pop_mail_server()
        mail = self.pop_obj.retr(message_number)[1]
        self.disconnect_from_pop_mail_server()
        msg = email.message_from_string("\n".join(mail))
        return msg.get_payload()

    def mail_message_subject_should_match(self, message_number, regular_expression):
        """
            Verifies that the email message subject contains the required regular expression match
        Example:
        | Mail Message Subject Should Match | 1 | .*Text I want.* |
        """
        self.reconnect_to_pop_mail_server()
        mail = self.pop_obj.retr(message_number)[1]
        self.disconnect_from_pop_mail_server()
        msg = email.message_from_string("\n".join(mail))
        if match(regular_expression, msg['subject']) is None:
            raise AssertionError("Message {0} subject did not match '{1}'.  Body:{2}".format(message_number, regular_expression, msg['subject']))

    def mail_message_subject_should_not_match(self, message_number, regular_expression):
        """
            Verifies that the email message subject does *not* contain the required regular expression match
        Example:
        | Mail Message Subject Should not Match | 1 | .*Text I want.* |
        """
        self.reconnect_to_pop_mail_server()
        mail = self.pop_obj.retr(message_number)[1]
        self.disconnect_from_pop_mail_server()
        msg = email.message_from_string("\n".join(mail))
        if match(regular_expression, msg['subject']) is not None:
            raise AssertionError("Message {0} subject matched '{1}' but should not have.  Subject:{2}".format(message_number, regular_expression, msg['Subject']))

    def mail_message_body_should_match(self, message_number, regular_expression):
        """
            Verifies that the email message body contains the required regular expression match
        Example:
        | Mail Message Body Should Match | 1 | .*Text I want.* |
        """
        self.reconnect_to_pop_mail_server()
        mail = self.pop_obj.retr(message_number)[1]
        self.disconnect_from_pop_mail_server()
        msg = email.message_from_string("\n".join(mail))
        body = msg.get_payload()
        if match(regular_expression, body) is None:
            raise AssertionError("Message {0} did not match '{1}'.  Body:{2}".format(message_number, regular_expression, body))

    def mail_message_body_should_not_match(self, message_number, regular_expression):
        """
            Verifies that the email message body does *not* contain the required regular expression match
        Example:
        | Mail Message Body Should Not Match | 1 | .*Text I want.* |
        """
        self.reconnect_to_pop_mail_server()
        mail = self.pop_obj.retr(message_number)[1]
        self.disconnect_from_pop_mail_server()
        msg = email.message_from_string("\n".join(mail))
        body = msg.get_payload()
        if match(regular_expression, body) is not None:
            raise AssertionError("Message {0} matched '{1}' but should not have.  Body:{2}".format(message_number, regular_expression, body))

    ##########################################################################
    # SMTP Mail Keywords
    ##########################################################################
    def smtp_server_should_be_connected(self):
        """ Verify that the SMTP server is connected
            Example:
            | SMTP server Should Be Connected |
        """
        if self.smtp_obj is None or self.smtp_connected is False:
            raise AssertionError("SMTP server should be connected but is not.")

    def smtp_server_should_not_be_connected(self):
        """ Verify that the SMTP server is not connected
            Example:
            | SMTP server Should Not Be Connected |
        """
        if self.smtp_obj is not None or self.smtp_connected is True:
            raise AssertionError("SMTP server should not be connected but is.")

    def connect_to_smtp_server(self, server, user='', password='', use_ssl=False):
        """ Connect to the SMTP server
            Example:
            | Connect to SMTP server | smtp-americas.hp.com |
        """
        port = 465 if use_ssl else 25
        self.smtp_obj = smtplib.SMTP(server, port)
        self.smtp_connected = True
        return True

    def disconnect_from_smtp_server(self):
        """ Disconnect from the SMTP server
            Example:
            | Disconnect from SMTP server |
        """
        if self.smtp_obj is not None:
            self.smtp_obj.quit()
            self.smtp_connected = False
            self.smtp_obj = None
        return True

    def send_email(self, from_addr, to_addrs, subject, message):
        """ Send an email to a recipient
            Example:
            | Send Email | me@hp.com | you@hp.com | This is a test | Hi you, here is you message. |
        """

        msg = email.mime.Text.MIMEText(message)
        msg['To'] = ", ".join(to_addrs).strip(", ") if isinstance(to_addrs, list) else to_addrs
        msg['From'] = from_addr
        msg['Subject'] = subject
        self.smtp_obj.sendmail(from_addr, to_addrs, msg.as_string())
        return True


class EmailKeywordsTest(unittest.TestCase):

    def __init__(self, *args, **kwargs):
        super(EmailKeywordsTest, self).__init__(*args, **kwargs)
        self.pop_server = 'webmail.hp.com'
        self.pop_user = 'americas/your account/your process mailbox'
        self.pop_password = 'your password'
        self.smtp_server = 'smtp-americas.hp.com'
        self.sender = 'test@hp.com'
        self.recipient = 'your mailbox@hp.com'

    def test_connect_to_smtp_server(self):
        kw = EmailKeywords()
        with self.assertRaises(socket.gaierror):
            kw.connect_to_smtp_server('badserver')
        self.assertIsNotNone(kw.connect_to_smtp_server(self.smtp_server))
        kw.disconnect_from_smtp_server()

    def test_connect_to_pop_mail_server(self):
        kw = EmailKeywords()
        with self.assertRaises(AssertionError):
            kw.connect_to_pop_mail_server('badserver', 'baduser', 'badpassword', use_ssl=True)
        with self.assertRaises(AssertionError):
            kw.connect_to_pop_mail_server('webmail.hp.com', 'baduser', 'badpassword', use_ssl=True)
        self.assertIsNotNone(kw.connect_to_pop_mail_server(self.pop_server, self.pop_user, self.pop_password, use_ssl=True))
        self.assertTrue(kw.disconnect_from_pop_mail_server())

    def test_send_mail(self):
        kw = EmailKeywords()
        num_messages = 10

        # get the count of messages
        print "Connecting to {0}".format(self.pop_server)
        self.assertIsNotNone(kw.connect_to_pop_mail_server(self.pop_server, self.pop_user, self.pop_password, use_ssl=True))
        count = kw.get_mail_message_count()
        print "Mailbox has {0} message(s)".format(count)

        # send the message
        print "Sending email to {0}".format(self.recipient)
        self.assertTrue(kw.connect_to_smtp_server(self.smtp_server))
        for i in range(count + 1, count + num_messages + 1):
            print "Sending message {0}".format(i)
            self.assertTrue(kw.send_email(self.sender, self.recipient, "Test {0}".format(i), "This is test message {0}".format(i)))
            sleep(1)    # messages can arrive in different order if we go as fast as possible
        self.assertTrue(kw.disconnect_from_smtp_server())

        print "Waiting for messages to arrive"
        kw.wait_for_mail_message_count(count + num_messages)

        for i in range(count + 1, count + num_messages + 1):
            print "Validating subject of message {0}".format(i)
            kw.mail_message_subject_should_match(i, "Test {0}".format(i))
            kw.mail_message_subject_should_not_match(i, "Test xxx")
            print "Validating body of message {0}".format(i)
            kw.mail_message_body_should_match(i, "This is test message {0}".format(i))
            kw.mail_message_body_should_not_match(i, "This is test message xxx")

        print "Removing message"
        for i in range(count + 1, count + num_messages + 1):
            print "Deleting message {0}".format(i)
            kw.delete_mail_message(1)
        print "Verifying count"
        kw.mail_message_count_should_be(count)
        count = kw.get_mail_message_count()
        print "Mailbox has {0} message(s)".format(count)
        self.assertTrue(kw.disconnect_from_pop_mail_server())


if __name__ == '__main__':
    unittest.main()
