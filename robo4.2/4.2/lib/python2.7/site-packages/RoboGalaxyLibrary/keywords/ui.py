'''
UI Library keywords
'''

from inspect import getargspec
from itertools import combinations_with_replacement, cycle
from re import match
from threading import Thread
from time import sleep
import datetime

from Selenium2Library import Selenium2Library
from decorator import decorator  # http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#using-decorators
from robot.libraries import Collections
from robot.libraries.BuiltIn import BuiltIn, RobotNotRunningError
from selenium.common.exceptions import StaleElementReferenceException
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.remote.webelement import WebElement

from RoboGalaxyLibrary.ui.common import ui_lib
from RoboGalaxyLibrary.ui.common.ui_lib import fail_test
from RoboGalaxyLibrary.utilitylib import logging as logger


@decorator
def autohighlight(func, *args, **kwargs):
    """ Decorator which can be used to highlight elements referenced in functions
        that utilize the "locator" parameter.
        NOTE: This decorator requires the RF variable HIGHLIGHT to be defined.
        Usage:

        @highlight
        def my_ui_function(self, locator):
          ...
    """
    argspec = getargspec(func).args
    if 'locator' in argspec and BuiltIn().convert_to_boolean(BuiltIn().get_variable_value("${HIGHLIGHT}", False)):
        index = getargspec(func).args.index('locator')
        args[0].highlight(locator=args[index])
    return func(*args, **kwargs)


@decorator
def autoscroll(func, *args, **kwargs):
    """ Decorator which can be used to automatically scroll to elements
        referenced in functions that utilize the "locator" parameter.
        NOTE: This decorator requires the RF variable AUTOSCROLL to be defined.
        Usage:

        @autoscroll
        def my_ui_function(self, locator):
          ...
    """
    argspec = getargspec(func).args
    if 'locator' in argspec and BuiltIn().convert_to_boolean(BuiltIn().get_variable_value("${AUTOSCROLL}", True)):
        index = getargspec(func).args.index('locator')
        args[0].scroll_into_view(locator=args[index])
    return func(*args, **kwargs)


@decorator
def conditional_timeout(func, *args, **kwargs):
    start = datetime.datetime.now()
    while (datetime.datetime.now() - start).total_seconds() < 5.0:
        if func(*args, **kwargs):
            return True
        sleep(0.1)
    raise AssertionError("Failed to wait for condition")


def get_s2l():
    """ get_s2l
        Description : This function return the ui_lib object |
    """
    return BuiltIn().get_library_instance('RoboGalaxyLibrary')


class UiLibKeywords(Selenium2Library):

    """Library for UI Library.

    This library makes selected ui_lib.py functions available as keywords.
    """
    ROBOT_LIBRARY_SCOPE = 'Global'

    built_in = BuiltIn()
    # Create a random string generator that's 4 lower-case characters in length
    # This is used by the highlight function to index the objects in the DOM
    _rnd_chr = cycle(combinations_with_replacement([chr(x) for x in range(97, 123)], 4))

    def __init__(self):
        # Call the base class __init__.  Note the default values for timeout *and* implicit wait.
        try:
            timeout = self.built_in.get_variable_value('${SELENIUM_TIMEOUT', 5.0)
            implicit_wait = self.built_in.get_variable_value('${SELENIUM_IMPLICIT_WAIT}', 0.0)
        except RobotNotRunningError:
            # If a utility such as libdoc is running, any attempt to access runtime variables
            # will result in a RobotNotRunningError exception.  Here, we catch that exception
            # to prevent it from disrupting external tool execution.
            timeout = 0
            implicit_wait = 0
        super(UiLibKeywords, self).__init__(timeout,
                                            implicit_wait,
                                            run_on_failure='Capture Page Screenshot')

    ###############################################################################
    # Element related functions
    ###############################################################################

    @conditional_timeout
    def wait_for_element_class_to_contain(self, locator, class_name):
        """ Wait for the element class to contain a name.  Useful for hidden type
            classes.
            Examples:
            | Wait for Element Class to Contain | id=my_div | hidden |
        """
        attr = self.get_element_attribute(locator + "@class")
        return class_name in attr if attr is not None else False

    @conditional_timeout
    def wait_for_element_class_to_not_contain(self, locator, class_name):
        """ Wait for the element class to *not* contain a name.  Useful for hidden type
            classes.
            Examples:
            | Wait for Element Class to Not Contain | id=my_div | hidden |
        """
        attr = self.get_element_attribute(locator + "@class")
        return class_name not in attr if attr is not None else False

    def _element_find(self, locator, first_only, required, tag=None):
        """ Override of _element_find to allow highlighting.
        """
        elements = super(UiLibKeywords, self)._element_find(locator, first_only, required, tag)
        if self.built_in.convert_to_boolean(self.built_in.get_variable_value('${HIGHLIGHT}', False)):
            self.highlight(elements)
        return elements

    element_find = _element_find

    def scroll_into_view(self, locator, align_with_top=False):
        """
            Scrolls an element into view
            Example:
            | Scroll Into View | xpath=//span[text()='Networks' |
        """
        script = """
            el = arguments[0];
            el.scrollIntoView(%s);
        """ % ("true" if align_with_top else "false")

        element = super(UiLibKeywords, self)._element_find(locator, first_only=True, required=False)
        if element is None:
            logger.warn("Failed to locate element: {0}".format(locator))
            return False
        else:
            return self._current_browser().execute_script(script, element)

    def highlight(self, el, duration=300):
        """ Highlights the given element(s) specified by the locator(s) for [duration] milliseconds
            Note that this keyword works for WebElements too.
            Example:
                | Highlight | link=Networks |
                | Highlight | xpath=//div |
        """
        # determine the element type
        elements = []
        if el is None:
            return
        elif isinstance(el, WebElement):
            elements = [el]
        elif all(isinstance(x, WebElement) for x in el):
            elements = el
        elif all(isinstance(x, str) for x in el) or isinstance(el, str):
            elements = super(UiLibKeywords, self)._element_find(el, first_only=False, required=False)
        else:
            element = elements
        for element in elements:
            # logger.info(element)
            # The scoping in the javascript will overwrite variables of the same name.
            # In order to prevent this, we assign the element and style to an randomly
            # generated variable.
            el = "".join(self._rnd_chr.next())
            el_style = "".join(self._rnd_chr.next())

            script = """
                try {{
                    {0} = arguments[0];
                    {1} = {0}.getAttribute('style');
                    {0}.setAttribute('style', 'background: yellow; border: 2px solid red');
                    setTimeout(function(){{
                        {0}.removeAttribute('style');
                    }}, 300);
                }} catch (e) {{}}
            """.format(el, el_style)

            self._current_browser().execute_script(script, element)

    def is_element_visible(self, locator):
        """ Determine the visibility of the element
            Examples:
            | ${status}=  Is Element Visible | id=my_el |
        """
        return self._is_visible(locator) is not None

    def is_element_present(self, locator, tag=None):
        """ Determine the presence of the element
            Examples:
            | ${status}=  Is Element Present | id=my_el |
        """
        return self._is_element_present(locator, tag)

    def hover_and_click(self, *locators):
        """ Hover and click on elements
            Parameters: locators - a variable list of locators.  They will be iterated, hovered,
                        and the last element clicked.
            Example:
                | Hover and Click | xpath=//mydiv1 | link=mylinknowactive |
        """
        chain = ActionChains(self._current_browser())
        last_element = self._element_find(locators[-1], first_only=True, required=True)
        if last_element is None:
            raise AssertionError("ERROR: Element %s not found." % (last_element))
        for locator in locators[:-1]:
            element = self._element_find(locator, first_only=True, required=True)
            if element is None:
                raise AssertionError("ERROR: Element %s not found." % (locator))
            chain.move_to_element(element)
        chain.click(last_element)
        chain.perform()

    @autoscroll
    def click_if_visible(self, locator):
        """ If an element is visible, click it.
            This keyword exists to provide the ability to optionally click
            elements if they exist in the UI.  i.e. non-critical clicking action.
            Example:
            | Click if visible | xpath=//span[text()='Networks'] |
        """
        if self._is_visible(locator):
            self.click(locator)

    @autoscroll
    def click(self, locator):
        """ Click an element in the browser.
            Example:
            | Click | xpath=//span[text()='Volumes'] |
        """
        self.wait_until_element_is_visible(locator)
        self.wait_for_element_class_to_not_contain(locator, 'hp-disabled')
        super(UiLibKeywords, self).click_element(locator=locator)

    @autoscroll
    def click_element(self, locator):
        """Override of click_element to take advantage of autoscroll
        """
        super(UiLibKeywords, self).click_element(locator=locator)

    @conditional_timeout
    def wait_for_element(self, locator, fail_if_false=True):
        """ Wait for an element to be present *and* visible
            Examples:
            | Wait for Element | id=my_div |
        """
        ret = self._is_element_present(locator) and self.is_element_visible(locator)
        if not ret:
            fail_test("Failed to locate element")
        return ret

    @conditional_timeout
    def wait_for_element_text_match(self, locator, regex):
        """ Waits for an element element text to match regular expression
            Examples:
            | Wait for Element Text Match | xpath=//span[id='my_id'] | New Text |
        """
        try:
            text = self._get_text(locator)
        except StaleElementReferenceException:
            return False
        return match(regex, text)

    def wait_until_element_is_not_visible(self, locator, timeout=None, error=None):
        """ Waits until element specified with `locator` is not visible.
            Fails if `timeout` expires before the element is not visible.
            `error` can be used to override the default error message.
            See also `Wait Until Element is Visible`
            Examples:
            | Wait Until Element Is Not Visible | id=my_el |
        """
        def check_visibility():
            visible = self._is_visible(locator)
            if not visible or visible is None:
                return
            else:
                return error or "Element '%s' was visible in %s" % (locator, self._format_timeout(timeout))
        self._wait_until_no_error(timeout, check_visibility)

    def element_class_contains(self, locator, class_text):
        """ element_class_contains
            Description: If the class contains specific text, return the result (true/false)
            Examples:
            | Element Class Contains | //table//td[id='my_td'] | My Value! |
        """
        return class_text in self.get_element_attribute(locator + "@class")

    def wait_for_element_resize(self, locator):
        """ wait_for_element_resize
            Description : Wait for an element resize to complete animation
                |    Useful to wait for pages to load when there's animation.
            Examples:
            | Wait for Element Resize | css=#mydiv |
        """
        # find the element on the page
        el = self._element_find(locator, True, True)
        if el is None:
            logger._warn("wait_for_element_resize(): Failed to locate element '%s' on page" % locator)
            return False
        cur_width = el.size["width"]
        width_changing = True
        start = datetime.datetime.now()
        # wait for the width to stop changing
        while width_changing and (datetime.datetime.now() - start).total_seconds() < self.get_selenium_timeout():
            # too frequent checking will result in a false positive
            self.built_in.sleep(0.5)
            if el.size["width"] != cur_width:
                cur_width = el.size["width"]
            else:
                width_changing = False
        return True

    def wait_for_element_location(self, locator):
        """ Wait for an element location to complete animation. Useful to wait for pages to load when there's animation.
            Examples:
            | Wait for Element Location | id=my_div |
        """
        # find the element on the page
        el = self._element_find(locator, True, True)
        if el is None:
            logger._warn("wait_for_element_location(): Failed to locate element '%s' on page" % locator)
            return False
        cur_location = el.location
        location_changing = True
        start = datetime.datetime.now()
        # wait for the width to stop changing
        while location_changing and (datetime.datetime.now() - start).total_seconds() < self.get_selenium_timeout():
            # too frequent checking will result in a false positive
            self.built_in.sleep(0.5)
            if el.location != cur_location:
                cur_location = el.location
            else:
                location_changing = False
        return True

    ###############################################################################
    # Droplist related functions
    ###############################################################################

    @autoscroll
    def droplist_select_item(self, locator, item_text):
        """ Select an item from a drop list identifed by [locator]
            Example:
                | Droplist Select Item | //div[id='mylist'] | Item1 |
        """
        logger.debug("Locating droplist element '{0}'".format(locator))
        self.wait_until_element_is_visible(locator)
        element = self._element_find(locator, first_only=True, required=True)
        logger.debug("Clicking droplist element '{0}'".format(locator))
        element.click()
        item_locator = "{0}//span[text()='{1}']".format(locator, item_text)
        logger.debug("Clicking droplist item '{0}'".format(item_locator))
        self._element_find(item_locator, first_only=True, required=True).click()
        logger.debug("Verifying selected item '{0}'".format(item_text))
        text = self._element_find(locator, first_only=True, required=True).text
        if text == item_text:
            logger.debug("Droplist selected item '{0}' == '{1}'".format(text, item_text))
        else:
            raise AssertionError("Droplist text ('{0}') does not match expected: '{1}'".format(text, item_text))

    def droplist_should_contain(self, locator, item_text, message=''):
        """ Verifies text item in list identified by locator exists
            Example:
                | Droplist Should Contain | //div[id='mylist'] | Item1 |
        """
        element = self._element_find(locator, first_only=True, required=True)
        element.click()
        if element.find_element_by_xpath("//span[text()='{0}']".format(item_text)) is None:
            if not message:
                message = "Failed to locate item '{0}' in list '{1}'".format(item_text, locator)
            raise AssertionError(message)

    def droplist_should_not_contain(self, locator, item_text, message=''):
        """ Verifies text item in list identified by locator exists
            This is the opposite of Droplist Should Contain
            Example:
                | Droplist Should Not Contain | //div[id='mylist'] | Item1 |
        """
        element = self._element_find(locator, first_only=True, required=True)
        element.click()
        if element.find_element_by_xpath("//span[text()='{0}']".format(item_text)) is not None:
            if not message:
                message = "Item '{0}' was in list '{1}' when it shouldn't have been".format(item_text, locator)
            raise AssertionError(message)

    def droplist_select_multiple(self, locator, *elements):
        raise NotImplementedError()

    def click_and_select_file_for_upload(self, locator, filename):
        """ Click the upload button and select a file in the native UI
            Example:
            | Click and Select File For Upload | id=upload_button | c:/test/myfile.bin |
        """
        # Since clicking the file selection element blocks the UI, we need to do this in a separate thread
        Thread(target=self.click, args=(locator,)).start()
        # Now, this code runs without blocking on the upload dialog
        browser_name = self._current_browser().capabilities['browserName']
        logger.info("*** Browser version '{0}' ***".format(browser_name))
        if browser_name == 'firefox':
            window_title = "File Upload"
        elif browser_name == 'chrome':
            window_title = "Open"
        elif browser_name == 'internet explorer':
            window_title = "Choose File to Upload"
        else:
            raise AssertionError("Unknown browser name '{0}'".format(browser_name))
        self.send_keys_to_native_window(window_title, "%n{0}%o".format(filename))

    # element keywords
    def element_is_visible(self, locator):
        """ Returns true if the element is visible on the page

        Example:
        | Element Is Visible | xpath="//a[@id='overridelink'] |
        """
        s2l = ui_lib.get_s2l()
        return s2l._is_visible(locator)

    def wait_for_element_and_click(self, locator, timeout=5, fail_if_false=False):
        """Waits for an element in the DOM and click when exists

        Example:
        | Wait For Element and Click | xpath="//input[@id='mybutton']" |
        | Wait For Element and Click | xpath="//input[@id='mybutton']" | 10 | 0.2 | True
        """
        ui_lib.wait_for_element_and_click(locator, timeout, fail_if_false)

    def _wait_for_element(self, locator, timeout=5, fail_if_false=False):
        """Waits for an element to exist in the DOM

        Example:
        | Wait For Element | xpath="//a[text()='The link I want']" |
        | Wait For Element | xpath="//a[text()='The link I want']" | 10 | 0.2 | True
        """
        ui_lib.wait_for_element(locator, timeout, fail_if_false)

    def wait_for_element_remove(self, locator, timeout=5, fail_if_false=False):
        """Waits for an element to be removed from the DOM
        Example:
        | Wait For Element Remove | xpath="//a[text()='The link I want']" |
        """
        return ui_lib.wait_for_element_remove(locator, timeout, fail_if_false)

    def wait_for_element_expand(self, locator):
        """Waits for an element to finish resizing

        Example:
        | Wait For Element Expand | xpath="//div[@class='container']" |
        | Wait For Element Expand | xpath="//div[@class='container']" | 10 | 0.2 | True
        """
        ui_lib.wait_for_element_expand(locator)

    def wait_for_element_text(self, locator, text, timeout=5, fail_if_false=False):
        """Waits for an element text to equal the provided value

        Example:
        | Wait For Element Text | xpath="//span[@class='span1']" | The text to wait for
        | Wait For Element Text | xpath="//span[@class='span1']" | The text to wait for | 10 | 0.2 | True
        """
        ui_lib.wait_for_element_text(locator, text, timeout, fail_if_false)

    def wait_for_element_text_to_change(self, locator, text, timeout=5, fail_if_false=False):
        """Waits for an element text to equal the provided value

        Example:
        | Wait For Element Text | xpath="//span[@class='span1']" | The text to wait for
        | Wait For Element Text | xpath="//span[@class='span1']" | The text to wait for | 10 | 0.2 | True
        """
        ui_lib.wait_for_element_text_to_change(locator, text, timeout, fail_if_false)

    def wait_for_element_and_input_text(self, locator, text, timeout=5, fail_if_false=False):
        """Wait for an element to exist and input text.
           Ideally used for a textbox control

        Example:
        | Wait For Element and Input Text | xpath="//input[@class='textbox']" | The text I wanted to type
        | Wait For Element and Input Text | xpath="//input[@class='textbox']" | The text I wanted to type | 10 | 0.2 | True
        """
        ui_lib.wait_for_element_and_input_text(locator, text, timeout, fail_if_false)

    def send_keys(self, locator, string):
        """Send a string in the form of keystrokes to an element

        Example:
        | Send Keys | xpath="//input[@class='textbox']" | The text I wanted to type
        | Send Keys | xpath="//input[@class='textbox']" | The text I wanted to type | 10 | 0.2 | True
        """
        ui_lib.send_keys(locator, string)

    def page_contains(self, text):
        """returns true if the page contains the text specified

        Example:
        | Page Contains | My Text |
        """
        return ui_lib.page_contains(text)

    def element_text_matches(self, locator, regex):
        """returns true if the element text contains the regex specified

        Example:
        | Page Contains | My Text |
        """
        return ui_lib.element_text_matches(locator, regex)

    def element_text_should_match(self, locator, regex, message=''):
        """returns true if the element text matches the regex specified

        Example:
        | Element Text Should Match | locator |
        """
        return ui_lib.element_text_should_match(locator, regex, message)

    def table_contains(self, locator, expected):
        """returns true if the table contains the expected text
        Example:
        | Table Contains | xpath=//talble[@id='mytable'] | The text I want to find
        """
        return ui_lib.table_contains(locator, expected)

    def wait_for_element_visible(self, locator, timeout=5, fail_if_false=False):
        """Wait for an element to become visible in the given time.
           Returns true if the element is visible else returns false.

        Examples:
        | Wait For Element Visible | hp-login-username |
        """
        return ui_lib.wait_for_element_visible(locator, timeout, fail_if_false=fail_if_false)

    def wait_for_element_not_visible(self, locator, timeout=5, fail_if_false=False):
        """Wait for an element to become non-visible in the given time.
           Returns true if the element is not visible else returns false.

        Examples:
        | Wait For Element Not Visible | hp-login-username |
        """
        return ui_lib.wait_for_element_notvisible(locator, timeout, fail_if_false=fail_if_false)

    def ui_close_all_browsers(self):
        """Closes all browsers
        Example:
        | close all browsers
        """
        ui_lib.close_all_browsers()

    def get_ui_object(self, ui_object, *param):
        """Get a parameterized (or non-parameterized) object from the UI elements.
           This keyword can either use non-formatted string, or formatted strings using the %s
           specifier.  It utilizes the % Python string specifier.
           See Python string formatting for more information.
        Example:
            | Get UI Object | ${FusionBasePage.ID_PAGE_LABEL} |
            | Get UI Object | ${FusionEnclosureGroupsPage.ID_COMBO_LIST_LOGICAL_SWITCH_TEMPLATE} | MyTemplateName |
        """
        return ui_lib.get_ui_object(ui_object, param)

    def download_file(self, link_locator, *folder):
        """ Download File from a link URL.
        The link will be extracted from the element provided.  i.e. <a id="test" href="some-url">my link</a>
        Will download from "some-url" when the "//a[@id=test]" locator is provided
        Note: The folder argument is optional and will default to ${EXECDIR} if not provided.
        Example:
        | Download File | hp-download-audit-logs-link | c:\temp  |
        """
        if len(folder) == 0:
            folder = None
        elif len(folder) > 1:
            raise ui_lib.FatalError("Too many arguments to Download File")
        else:
            folder = folder[0]
        ui_lib.download_file(link_locator, folder)

    def get_firefox_version(self):
        """ Get Firefox version
        Example:
            | ${Version}= | Get Firefox Version |
        """
        return ui_lib.get_firefox_version()

    def move_to_element_and_click(self, locator1, locator2):
        """Move the mouse cursor to a locator and perform a click
        operation on it (or another element that might be activated by the
        move operation).
        Examples:
        """
        ui_lib.move_to_element_and_click(locator1, locator2)

    def get_browser_capabilities(self):
        """Return the dictionary containing the browser capabilities info
        Examples:
        | Get Browser Capabilities |
        """
        return ui_lib.get_browser_capabilities()

    def get_browser_version(self):
        """Returns the opened browser version
        Examples:
        | Get Browser Version |
        """
        return self.get_browser_capabilities()['version']

    def get_browser_name(self):
        """Returns the current opened browser name
        Examples:
        | Get Browser Name |
        """
        return self.get_browser_capabilities()['browserName']

    def get_browser_platform(self):
        """ Returns the name of the browser platform
        Examples:
        | Get Browser Platform |
        """
        return self.get_browser_capabilities()['platform']

    def log_browser_capabilities(self):
        """Write browser capabilities dictionary to the log
        Examples:
        | Log Browser Info |
        """
        logger._log_to_console_and_log_file("Browser capabilities:")
        for k, v in ui_lib.get_browser_capabilities().iteritems():
            logger.info("{0}: {1}".format(k, v))
