'''

Utility Methods for processing JSON and XML
Code samples from http://pyparsing.wikispaces.com/

'''

import json
import pprint
from pyparsing import *
from lxml import objectify
try:
    import simplejson as json
except ImportError:
    import json


def print_entity(entity):
    if not entity:
        return
    if 'name' in entity:
        print "name: %s" % entity['name']
    if isinstance(entity, dict):
        for key, value in entity.iteritems():
            print "\t%s = %s" % (key, value)
    elif hasattr(entity, '__iter__'):
        for item in entity:
            print "\t%s" % item
    else:
        print "\t%s" % entity


def print_task_tuple(entities):
    print "Task/Entity Tuples:"
    for indx, (task, entity) in enumerate(entities):
        print "%s) Entry" % indx
        try:
            print ("\tTask: %s, %s, %s, %s" %
                   (task['name'], task['taskState'],
                    task['taskStatus'], task['uri']))
        except KeyError:
            print "\tTask: n/a"
        try:
            print "\tResource: %s, %s" % (entity['name'], entity['uri'])
        except KeyError:
            print "\tResource: n/a"


def printJson(data):
    print(json.dumps(data, sort_keys=True, indent=4, separators=(',', ': ')))


def conv_json_to_dict(json_str):
    try:
        dictt = json.loads(json_str)
    except Exception as e:
        info = ("Exception while converting json string to python dict",
                "Exception: '%s'" % e,
                "JSON string: %s" % json_str)
        raise Exception(*info)
    return dictt


def conv_dict_to_json(dictt):
    try:
        json_str = json.dumps(dictt)
    except Exception as e:
        info = ("Exception while converting python dict to json string",
                "Exception: '%s'" % e,
                "Dictionary: %s" % dictt)
        raise Exception(*info)
    return json_str


def _convertNumbers(s, l, toks):
    n = toks[0]
    try:
        return int(n)
    except ValueError as ve:
        return float(n)


def convert_json_to_dict_object(data):
    TRUE = Keyword("true").setParseAction(replaceWith(True))
    FALSE = Keyword("false").setParseAction(replaceWith(False))
    NULL = Keyword("null").setParseAction(replaceWith(None))

    jsonString = dblQuotedString.setParseAction(removeQuotes)
    jsonNumber = Combine(Optional('-') +
                         ('0' | Word('123456789', nums)) +
                         Optional('.' +
                                  Word(nums)) +
                         Optional(Word('eE', exact=1) +
                                  Word(nums +
                                       '+-', nums)))

    jsonObject = Forward()
    jsonValue = Forward()
    jsonElements = delimitedList(jsonValue)
    jsonArray = Group(Suppress('[') + Optional(jsonElements) + Suppress(']'))
    jsonValue << (jsonString | jsonNumber | Group(
        jsonObject) | jsonArray | TRUE | FALSE | NULL)
    memberDef = Group(jsonString + Suppress(':') + jsonValue)
    jsonMembers = delimitedList(memberDef)
    jsonObject << Dict(Suppress('{') + Optional(jsonMembers) + Suppress('}'))

    jsonComment = cppStyleComment
    jsonObject.ignore(jsonComment)
    jsonNumber.setParseAction(_convertNumbers)
    results = jsonObject.parseString(data)
    pprint.pprint(results.asList())
    return results


def _iter_nodes(node, parentDict):
    nodeDict = {}
    try:
        nodeDict.update(node.attrib)
    except AttributeError:
        pass
    if node.text is not None:
        nodeDict['$t'] = node.text

    for i in node.iterchildren():
        childDict = {}
        newDict = {}
        newDict = _iter_nodes(i, childDict)
        newList = []
        if i.tag in nodeDict:
            try:
                nodeDict[i.tag].append(newDict[i.tag])
            except:
                newList.append(nodeDict[i.tag])
                nodeDict[i.tag] = newList
                nodeDict[i.tag].append(newDict[i.tag])
        else:
            nodeDict.update(newDict)
    tagList = node.tag.split(':')
    namespace = '$'.join(tagList)
    parentDict[namespace] = nodeDict
    return parentDict


def xml_convert_to_dict(xml_file):
    with open(xml_file) as f:
        xml = f.read()

    root = objectify.fromstring(xml)
    empty_dict = {}
    dict_obj = _iter_nodes(root, empty_dict)
    return dict_obj
