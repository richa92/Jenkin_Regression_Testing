#!/usr/bin/python
##############################################################################
# HPCIManager.py
# - Example scripts for configuring the CI Manager appliance
##############################################################################
# The information contained herein is subject to change without notice.
# The only warranties for HP products and services are set forth in the
# express warranty statements accompanying such products and services.
# Nothing herein should be construed as constituting an additional warranty.
# HP shall not be liable for technical or editorial errors or omissions
# contained herein.
#
# (C) Copyright 2012 Hewlett-Packard Development Company, L.P.
##############################################################################

import json
import urllib
import requests
import time

from RoboGalaxyLibrary.api.common import HTTPClient
from RoboGalaxyLibrary.utilitylib import logging as logger

PROTOCOL_BASE = 'https://'
PROTOCOL_BASE_HTTPS = 'https://'
PROTOCOL_BASE_HTTP = 'http://'
OK_RESPONSES = (200, 201, 204)

TaskCompletedStates = ['Error', 'Warning', 'Completed', 'Terminated', 'Killed']
TaskPendingStates = [
    'Pending', 'New', 'Starting', 'Running', 'Suspended', 'Stopping']


class HPCIException(Exception):
    pass


class HPCITimeout(HPCIException):
    pass


class HPCIInvalidResource(HPCIException):
    pass


class HPCIManager(object):
    uri = {
        # ------------------------------------
        # Appliance Configuration
        # ------------------------------------
        'applEula': "/rest/appliance/eula",
        'applneti': '/rest/appliance/network-interfaces',
        'applDumps': '/rest/appliance/support-dumps',
        'applVersion': "/rest/appliance/version",
        'applNetConfig': "/fts/rest/networkconfig",
        'applNtpConfig': "/fts/rest/timeconfig/ntp",
        'applTimezoneList': "/fts/rest/timeconfig/timezones",
        'applGlobalSettings': "/settings/rest/resources",
        # ------------------------------------
        # Physical Resource Management
        # ------------------------------------
        'servers': "/rest/server-hardware",
        'serverList': "/rest/server-hardware?start=-1&count=-1",
        'serverHwTypes': "/rest/server-hardware-types",
        'enclosures': "/rest/enclosures",
        'enclosureGroups': "/rest/enclosure-groups",
        'enclosurePreview': "/rest/enclosure-preview",
        'upload': "/fwdrivers/rest/uploadspp",
        'fwDrivers': "/rest/firmware-drivers",
        'powerDevices': "/rest/power-devices",
        'racks': "/rest/racks",
        # ------------------------------------
        # Network Resource Management
        # ------------------------------------
        'healthStatus': "/rest/appliance/health-status",
        # ------------------------------------
        # Network Resource Management
        # ------------------------------------
        'networkSets': "/rest/network-sets",
        'ethNetworks': "/rest/ethernet-networks",
        'fcNetworks': "/rest/fc-networks",
        'connectionType': "/rest/connection-templates",
        'uplinkPortGroups': "/rest/UplinkPortGroup",
        'GetAllNetworks': "/index/rest/index/resources?sort=name:asc&category=fc-networks&category=networks&start=0&count=-1",
        'GetEthNetworks': "/index/rest/index/resources?sort=name:asc&category=networks&start=0&count=-1",
        'GetFcNetworks': "/index/rest/index/resources?sort=name:asc&category=fc-networks&start=0&count=-1",
        'logicalSwitchTemplates': "/rest/logical-switch-templates",
        'logicalSwitches': "/rest/logical-switches",
        'switches': "/rest/switches",
        'switchTypes': "/rest/switch-types",
        'switchList': "/rest/switches?start-1&count=-1",
        'logicalUplinks': "/rest/logical-uplinks",
        'logicalDownlinks': "/rest/logical-downlinks",
        'interconnectTypes': "/rest/interconnect-types",

        # ------------------------------------
        #  Profile Management
        # ------------------------------------
        'profiles': "/rest/server-profiles",
        'profileList': "/rest/server-profiles?start=-1&count=-1",
        # ------------------------------------
        #  Index Search
        # ------------------------------------
        'index': "/index/rest/index/resources?",
        'association': "/index/rest/index/associations?",
        # ------------------------------------
        #  Tasks
        # ------------------------------------
        'task': "/rest/resources",
        # ------------------------------------
        #  Alerts and Events
        # ------------------------------------
        'alerts': "/alerts/rest/resources?&start=0&count=-1",
        'events': "/events/rest/resources",
        # ------------------------------------
        #  CIMGMT Security (LDAP NOT AVAILABLE IN BETA)
        # ------------------------------------
        'loginSessions': "/rest/login-sessions",
        'users': "/rest/users",
        'userRole': "/rest/users/role",
        'userChangePassword': "/rest/users/changePassword",
        'loginDomains': "/rest/logindomains",
        # ------------------------------------
        # Logical Interconnect Groups
        # ------------------------------------
        'logicalInterconnectGroups': "/rest/logical-interconnect-groups",
        'logicalInterconnectGroupsdefaultsettings': "/rest/logical-interconnect-groups/defaultSettings",
        'logicalInterconnectGroupsSchema': "/rest/logical-interconnect-groups/schema",
        # ------------------------------------
        # Logical Interconnects
        # ------------------------------------
        'logicalInterconnects': "/rest/logical-interconnects",
        'logicalInterconnectsLocations': "/rest/logical-interconnects/locations/interconnects",
        # ------------------------------------
        # Interconnects
        # ------------------------------------
        'interconnects': "/rest/interconnects",
        # ------------------------------------
        # Interconnect Types
        # ------------------------------------
        'interconnectTypes': "/rest/interconnect-types",
        'interconnectTypesSchema': "/rest/interconnect-types/schema",
        # ------------------------------------
        # Uplink Sets
        # ------------------------------------
        'uplinkSets': "/rest/uplink-sets",
        # ------------------------------------
        # EM objects
        # ------------------------------------
        'emChassis': "/rest/v1/Chassis/1",
        'emEarFru': "/rest/v1/Chassis/1/FrontPanelFru",
        'fanFru': "/rest/v1/Chassis/1/Fans/%s/FanFru",
        'powerSupplyFru': "/rest/v1/Chassis/1/PowerSupplies/%s/PowerSupplyFru",
        'interconnectFru': "/rest/v1/Interconnects/%s/InterconnectFru",
        'bladeFru': "/rest/v1/Blades/%s/BladeFru",
        'cimanagerFru': "/rest/v1/CIManagers/%s/CIManagerFru",
        'emFru': "/rest/v1/EnclosureManagers/%s/Fru",
    }

    def __init__(self):

        self._host = ""
        self._session_id = ""
        self._cred = {}
        self._http = HTTPClient.HTTPClient()

    def set_active_session(self, session_id):
        self._session_id = session_id
        logger._info(session_id)
        self._http.set_headers({'auth': self._session_id,
                                'content-type': 'application/json',
                                'accept': 'application/json'})

    def api_logout(self):
        self.delete(self.uri['loginSessions'])

    def get_default_hdrs(self):
        hdrs = {'auth': self._session_id,
                'Content-Type': 'application/json',
                'Accept': 'application/json'}
        return hdrs

    def set_appliance_config(self, appliance, http=False):
        """ Hack for HC since HC does not do authentication at the moment
        """
        self._session_id = "datesdf45352234"
        if http is False:
            self._http._set_base_url(PROTOCOL_BASE_HTTPS + appliance)
        else:
            self._http._set_base_url(PROTOCOL_BASE_HTTP + appliance)
        self._http.set_headers(
            {'content-type': 'application/json', 'accept': 'application/json'})

    ##########################################################################
    # Logins
    ##########################################################################
    def login(self, appliance, user, passwd):

        self._http._set_base_url(PROTOCOL_BASE_HTTPS + appliance)
        self._http.set_headers(
            {'content-type': 'application/json', 'accept': 'application/json'})
        body = self.make_user_dto(user, passwd)
        try:
            resp = self._http.post(HPCIManager.uri['loginSessions'], body)
        except HTTPClient.RESTException as e:
            print "Exception occurred while logging in as '%s'" % user
            raise e
        except Exception as e:
            msg = "Exception occurred while logging in as '%s', %s" % (user, e)
            print msg
            raise HTTPClient.RESTException(msg)

        if resp.status != 200:
            msg = "Status (%d) rcvd from login request as '%s'" % (
                resp.status, user)
# raise HTTPClient.RESTException(msg, resp)

        if 'sessionID' not in resp.body:
            info = (
                "Resp body from login as '%s' doesn't contain sessionID" %
                user,
                "Response body: %s" %
                resp.body)
            logger._info(info)
# raise Exception(*info)

        login_session = None  # default session ID - in case of login failure
        if 'sessionID' in resp.body:
            login_session = self._session_id = resp.body['sessionID']
            self._http.set_headers({'auth': self._session_id,
                                    'content-type': 'application/json',
                                    'accept': 'application/json'})

        if resp.body:
            resp.update(resp.body)
        return resp, login_session

    def logout(self):
        try:
            self._http.delete(HPCIManager.uri['loginSessions'])
        except Exception as e:
            print "Caught exception while trying to logout ", e

    def get_session_id(self):
        return self._session_id

    ##########################################################################
    # Login utilities
    ##########################################################################
    def make_user_dto(self, name, password):
        return self.create_user_login_dict(name, password)

    def make_admin_dto(self, password=''):
        return self.make_user_dto("Administrator", password)

    def create_user_login_dict(self, name, password):
        return {"userName": name,
                "password": password
                }

    ##########################################################################
    # Utilities
    ###########################################################################

    def printJson(self, data):
        print(
            json.dumps(data, sort_keys=True, indent=4, separators=(',', ': ')))

    def get_appliance(self):
        return self._host

    def _get_member(self, mlist):
        if not mlist:
            return None
        if not mlist['members']:
            return None
        return mlist['members'][0]

    def _get_body(self, resp):
        body = None
        if resp.text:
            body = resp.json()
        return body

    def get_entities_byrange(self, uri, field, xmin, xmax):
        body = self.get("""%s?filter=%s>%s&filter=%s<%s&start=0&count=-1"""
                        % (uri, field, xmin, field, xmax))
        return self._get_members(body)

    def get_entities_byfield(self, uri, field, value):
        body = self.get("""%s?filter=%s regex '%s'&start=0&count=-1"""
                        % (uri, field, value))
        return self._get_members(body)

    def get_entity_byfield(self, uri, field, value):
        body = self.get("""%s?filter=%s='%s'&start=0&count=-1"""
                        % (uri, field, value))
        return self._get_member(body)

    def get_entities(self, uri):
        return self._get_members(self.get(uri))

    ##########################################################################
    # The 4 HTTP Verbs
    ##########################################################################

    def get(self, uri, hdrs=None):
        resp = self._http.get(uri, hdrs)
        response = resp.copy()
        if resp.body:
            response.update(resp.body)
        # if resp.status == 202:
        #    raise HTTPClient.RESTException("GET: Async response", resp)
        return response

    def put(self, uri, resource, hdrs=None):
        resp = self._http.put(uri, resource, hdrs)
        response = resp.copy()
        if resp.body:
            response.update(resp.body)
        return response

    def update(self, resource, hdrs=None):
        return self.put(resource['uri'], resource, hdrs)

    def post(self, uri, resource, hdrs=None):
        resp = self._http.post(uri, resource, hdrs)
        response = resp.copy()
        if resp.body:
            response.update(resp.body)
        return response

    def patch(self, uri, resource, hdrs=None):
        resp = self._http.patch(uri, resource, hdrs)
        response = resp.copy()
        if resp.body:
            response.update(resp.body)
        return response

    def conditional_post(self, uri, body):
        try:
            entity = self.post(uri, body)
        except requests.HTTPError as e:
            if e.response.status_code == 400 and 'name' in body:
                try:
                    entity = self.get_entity_byfield(uri, 'name', body['name'])
                except requests.HTTPError:
                    # Didn't find the entity, raise exception
                    raise e
                if not entity:
                    raise e
            else:
                raise e
        return entity

    def delete(self, uri, hdrs=None):
        resp = self._http.delete(uri, hdrs)
        response = resp.copy()
        if resp.body:
            response.update(resp.body)
        return response

    ########################################################################
    # Resource and Tasks
    ########################################################################
    def getResource(self, name):
        url = "?filter=\"name='" + urllib.quote(name) + "'\""
        resource = self._http.get(url)
        return resource

    ###########################################################################
    # Tasks
    ###########################################################################
    #
    def make_task_entity_tuple(self, obj):
        task = {}
        entity = {}
        if obj:
            if obj['category'] == "tasks":
                # it is an error if type is not in obj, so let the exceptions
                # flow
                uri = ''
                if obj['type'] == "TaskResource":
                    task = obj
                    uri = obj['associatedResourceUri']
                elif obj['type'] == "TaskResourceV2":
                    task = obj
                    uri = obj['associatedResource']['resourceUri']
                else:
                    raise HPCIInvalidResource(
                        "Task resource is not a recognized version")
                if uri:
                    try:
                        entity = self.get(uri)
                    except requests.HTTPError as e:
                        if e.response.status_code == 404:
                            entity = {}
                        else:
                            raise e
            else:
                entity = obj
        return task, entity

    def get_task_assocaited_resource(self, task):
        if not task:
            return {}
        if task['type'] == "TaskResource":
            obj = self.get(task['associatedResourceUri'])
            tmp = {'resourceName': obj['name'],
                   'associationType': None,
                   'resourceCategory': None,
                   'resourceUri': obj['uri']}
        elif task['type'] == "TaskResourceV2":
            tmp = task['associatedResource']
        else:
            raise HPCIInvalidResource(
                "Task resource is not a recognized version")
        return tmp

    def get_task_state(self, task_uri):
        if not task_uri:
            return False
        task = self.get(task_uri)
        return task['taskState']
        info = self.get_task_assocaited_resource(task)
        progress_string = ("Resource = %s: Progress=%s%%: State=%s"
                           % (info['resourceName'],
                              task['percentComplete'],
                              task['taskState']))
        return progress_string

    def is_task_running(self, task):
        global TaskPendingStates
        if not task:
            return False
        if isinstance(task, dict):
            task_uri = task['uri']
        else:
            task_uri = task
        return self.get_task_state(task_uri) in TaskPendingStates

    def wait4task(self, task, tout=60, verbose=False):
        count = 0
        while self.is_task_running(task):
            if verbose:
                print "Task still running after %s seconds" % count
            time.sleep(1)
            count = count + 1
            if count > tout:
                raise HPCITimeout(
                    "Waited %s seconds for task to complete, aborting" % tout)

    def wait4tasks(self, tasks, tout=60, verbose=True):
        running = filter(self.is_task_running, tasks[:])
        count = 0
        while running:
            if verbose:
                logger._log_to_console_and_log_file(
                    "Tasks still running after %s seconds" % count)
                logger._log_to_console_and_log_file("running")
            time.sleep(1)
            count = count + 1
            running = filter(self.is_task_running, running)
            if count > tout:
                raise HPCITimeout(
                    "Waited %s seconds for task to complete, aborting" % tout)
