'''
Fusion API Resource Dictionary

'''


def create_user_dict(name, password,
                     enabled=True,
                     fullName="",
                     emailAddress="",
                     officePhone="",
                     mobilePhone=""
                     ):
    return {"userName": name,
            "fullName": fullName,
            "password": password,
            "emailAddress": emailAddress,
            "officePhone": officePhone,
            "mobilePhone": mobilePhone,
            "enabled": enabled
            }


def create_user_role_dict(name,
                          roles=[]):
    return {"userName": name,
            "roles": roles
            }

UserRoles = {'Server administrator': 'Server administrator',
             'Network administrator': 'Network administrator',
             'Backup administrator': 'Backup administrator',
             'Infrastructure administrator': 'Infrastructure administrator',
             'Read only': 'Read only'
             }

############################################################################
# Create default Resource Instances
############################################################################


def make_bw_dict(maxbw=10000, minbw=1000):
    return {'maximumBandwidth': maxbw,
            'typicalBandwidth': minbw
            }


def make_netset_dict(name, networks=[]):
    return {'name': name,
            'type': 'network-set',
            'nativeNetworkUri': None,
            'networkUris': networks[:],
            'connectionTemplateUri': None
            }


def make_enet_dict(name, vlanid=0,
                   smartLink=True, privateNetwork=False):
    return {'name': name,
            'type': 'ethernet-network',
            'purpose': 'General',
            'connectionTemplateUri': None,
            'vlanId': vlanid,
            'smartLink': smartLink,
            'privateNetwork': privateNetwork
            }


def make_fc_dict(name, fabricType="FabricAttach"):
    return {'name': name,
            'type': 'fc-network',
            'connectionTemplateUri': None,
            'fabricType': fabricType,
            'uplinkBandwidth': "Auto",
            'autoLoginRedistribution': True,
            'linkStabilityTime': 30
            }


def make_interconnect_map_template():
    return {'interconnectMapEntryTemplates':
            [{'logicalLocation': {
                'locationEntries':
                [{'type': "Bay", 'relativeValue': N},
                 {'type': "Enclosure", 'relativeValue': 1}]},
              'permittedInterconnectTypeUri': None,
              'logicalDownlinkUri': None
              } for N in xrange(1, 9)],
            }


def make_enet_settings(name):
    return {'type': "EthernetInterconnectSettings",
            'name': name,
            'enableIgmpSnooping': False,
            'igmpIdleTimeoutInterval': 260,
            'enableFastMacCacheFailover': True,
            'macRefreshInterval': 5,
            'enableNetworkLoopProtection': True,
            'interconnectType': "Ethernet"
            }


def make_logical_interconnect_dict(
        name,
        ligURI,
        switchIP,
        switchUser,
        switchPass,
        interconnectUriList,
        enclosureUriList):
    "Makes a dictionary with the necessary structure for creating a Logical Interconnect. \
    REST call: POST /rest/logical-interconnects \
    Request Body Type: LogicalInterconnect \
    "
    return {'name': name,
            'type': "logical-interconnect",
            "logicalInterconnectGroupUri": ligURI,
            "interconnectMap": {
                "interconnectMapEntries": [{
                    "location": {
                        "locationEntries": [{
                            "value": switchIP,
                            "type": "Ip"
                        }, {
                            "value": switchUser,
                            "type": "UserId"
                        }, {
                            "value": switchPass,
                            "type": "Password"
                        }]
                    },
                    #                    "interconnectUri": None,
                    #                    "permittedInterconnectTypeUri": None,
                    #                    "logicalDownlinkUri": None
                }
                ]},
            'interconnects': interconnectUriList,
            'enclosureUris': enclosureUriList,
            # 'fusionDomainUri': domainURI
            # 'interconnectMapTemplate': make_interconnect_map_template(),
            # 'uplinkSets': [],  # call make_uplink_template
            # 'stackingMode': "Enclosure",
            # 'ethernetSettings': None,
            # 'state': "Active",
            # 'telemetryConfiguration': None,
            # 'snmpConfiguration' : None,
            # 'description': None
            #    "category": "logical-interconnect",
            }


def make_lig_dict(name):
    "Makes a dictionary with the necessary structure for creating a Logical Interconnect Group. \
    REST call: POST /rest/logical-interconnect-groups \
    Request Body Type: LogicalInterconnectGroup \
    "
    return {'name': name,
            'type': "logical-interconnect-group",
            'interconnectMapTemplate': make_interconnect_map_template(),
            'uplinkSets': [],  # call make_uplink_template
            'stackingMode': "Enclosure",
            # 'ethernetSettings': None,
            'state': "Active",
            # 'telemetryConfiguration': None,
            # 'snmpConfiguration' : None,
            # 'description': None
            }


def set_iobay_occupancy(switchMap, bays, stype):
    for location in switchMap['interconnectMapEntryTemplates']:
        entries = location['logicalLocation']['locationEntries']
        if filter(lambda x: x['type'] == "Bay" and x['relativeValue'] in bays,
                  entries):
            location['permittedInterconnectTypeUri'] = stype


def make_uplink_set_dict(
        logicalInterconnectUri,
        name,
        networks=[],
        ntype='Ethernet'):
    "Makes a dictionary with the necessary structure for creating an uplink set in a logical interconnect. \
    REST call: POST /rest/uplink-sets \
    Request Body Type: UplinkSet \
    "
    return {'name': name,
            'type': 'uplink-set',
            'connectionMode': "Auto",  # Auto or Failover
            'networkUris': networks[:],
            'networkType': ntype,
            'logicalInterconnectUri': logicalInterconnectUri,
            # Can be NotSupported, Distributing, Distributed, or
            # DistributionFailed
            'manualLoginRedistributionState': "NotSupported",
            # Ironically,
            # Supported
            # isn't
            # supported yet
            # :-P
            'fcNetworkUris': [],
            'portConfigInfos': [],  # Array of logicalLocations
            'nativeNetworkUri': None
            }


def make_port_config_info(enclosure, bay, port, speed="Auto"):
    "Makes a dictionary with the necessary structure for updating a port's configuration. \
    REST call: PUT /rest/interconnects/{id}/ports \
    Request Body Type: ?? <TBD> \
    "
    return {'logicalLocation': {
        'locationEntries':
        [{'type': "Enclosure", 'relativeValue': enclosure},
         {'type': "Bay", 'relativeValue': bay},
         {'type': "Port", 'relativeValue': port}]
    },
        'desiredSpeed': speed
    }


def make_egroup_dict(name, lig):
    "Makes a dictionary with the necessary structure for creating an enclosure group. \
    REST call: POST /rest/enclosure-groups \
    Request Body Type: EnclosureGroup \
    "
    return {
        'name': name,
        'type': 'EnclosureGroup',
        'stackingMode': "Enclosure",
        'interconnectBayMappings': [{
            'interconnectBay': N,
            'logicalInterconnectGroupUri': lig
        } for N in xrange(1, 9)],
    }


def make_add_enclosure_dict(host, user, passwd, egroup):
    "Makes a dictionary with the necessary structure for adding an enclosure to Fusion. \
    REST call: POST /rest/enclosures \
    Request Body Type: AddEnclosure \
    "
    return {
        'hostname': host,
        "username": user,
        "password": passwd,
        "force": False,
        "enclosureGroupUri": egroup,
        "firmwareBaselineUri": None,
        "licensingIntent": "OneView"
    }


def make_ls_firmware_dict(action, sppUri, force="true"):
    return {"command": action, "sppUri": sppUri, "force": force}


##########################################################################
#
# Functions To Manipulate Dictionaries
#
##########################################################################


def merge(a, b, path=None):
    "Merges two dictionaries in such a way that only the keys in dictionary B \
    that are not present in dictionary A will be added (with their values too) \
    to dictionary A.  This is useful for importing some of the unknown fields \
    like date created & modified into a dictionary object so we can simply \
    compare our dictionary of expected values (A) with what we actually get \
    from the REAT API call (B) without having to write a bunch of extra \
    considerations for each data object."
    if path is None:
        path = []
    for key in b:
        if key in a:
            # We are here if the dictionary key from B exists in A
            if isinstance(a[key], dict) and isinstance(b[key], dict):
                # Proceed recursively to ensure desired info from B gets merged
                # into A
                merge(a[key], b[key], path + [str(key)])
            else:
                # a[key] equals b[key] already, or else there's a mismatch &
                # the test will catch it later
                pass
        else:
            a[key] = b[key]   # this only happens if a[key] doesn't exist
    return a


def make_complete_dictionary(type, objectFromRest, customProps):
    expectedDict = None
    if type == "LIG":
        # Merge our template with the custom dictionary & save the results
        # Since we want customProps to override template settings, customProps must appear on the right
        # expectedDict contains the items we "expect" the object returned from
        # the REST call to contain
        expectedDict = dict(completeLIGTemplate.items() + customProps.items())

        # Now copy in the harder stuff like UUIDs, time created/modified, etc.
        # Don't worry; this merge function only adds keys we couldn't predict
        # ahead of time
        expectedDict = merge(expectedDict, objectFromRest)
    else:
        raise AssertionError(
            "Make Complete Dictionary: Unknown type " +
            type +
            ".  Supported types include LIG.")
    return expectedDict

##########################################################################
#
# Actual Dictionary Templates (Mostly Maximum Set for comparison)
# - Omits fields such as Created, Modified, & eTag since those are unpredictable
#
##########################################################################

completeEthernetNetworkTemplate = {
    "type": "ethernet-network",
    "smartLink": True,
    #    "internalVlanId":2,
    "vlanId": 998,
    "privateNetwork": False,
    "purpose": "General",
    #    "connectionTemplateUri":"/rest/connection-templates/990b901c-a5fe-47c7-9b97-a48e7c5dd2dd",
    "name": "ethNet1",
    "state": "Active",
    "description": None,
    "status": "OK",
    #    "uri":"/rest/ethernet-networks/195452a2-73f3-4b7c-9509-f22ba9f0aaf8",
    "category": "ethernet-networks",
    #    "created":"2013-11-06T21:40:11.555Z",
    #    "eTag":"174526b6-2dec-4696-9b2a-87f22ebd0b2a",
    #    "modified":"2013-11-06T21:40:11.558Z"
}

completeLIGTemplate = {
    "type": "logical-interconnect-group",
    "telemetryConfiguration": {
        "type": "telemetry-configuration",
        "enableTelemetry": True,
        "sampleCount": 12,
        "sampleInterval": 300,
        "name": None,
        "state": None,
        "description": None,
        "status": None,
        "uri": None,
        "category": "telemetry-configuration",
        #        "created":"2013-11-01T20:27:28.552Z",
        #        "eTag":None,
        #        "modified":"2013-11-01T20:27:28.552Z"
    },
    "snmpConfiguration": {
        "type": "snmp-configuration",
        "enabled": True,
        "readCommunity": "public",
        "systemContact": None,
        "trapDestinations": [],
        "snmpAccess": [],
        "name": None,
        "state": None,
        "description": None,
        "status": None,
        "uri": None,
        "category": "snmp-configuration",
        #        "created":"2013-11-01T20:27:28.235Z",
        #        "eTag":None,
        #        "modified":"2013-11-01T20:27:28.554Z"
    },
    "uplinkSets": [],
    'interconnectMapTemplate': make_interconnect_map_template(),
    "ethernetSettings": {
        "type": "EthernetInterconnectSettings",
        #        "name":"cdf25595-e98b-4fed-a031-cb2a7b519ee0",
        #        "id":"4797473a-4240-46e0-98a4-202652ca423e",
        "enableIgmpSnooping": False,
        "igmpIdleTimeoutInterval": 260,
        "enableFastMacCacheFailover": True,
        "macRefreshInterval": 5,
        "enableNetworkLoopProtection": True,
        "interconnectType": "Ethernet",
        #        "dependentResourceUri":"/rest/logical-interconnect-groups/01612f0a-c223-4b3e-bc9c-8d353317f9e9",
        "state": None,
        "description": None,
        "status": None,
        #        "uri":"/rest/logical-interconnect-groups/01612f0a-c223-4b3e-bc9c-8d353317f9e9/settings/4797473a-4240-46e0-98a4-202652ca423e",
        "category": None,
        #        "created":"2013-10-28T19:12:23.141Z",
        #        "eTag":None,
        #        "modified":"2013-11-01T20:27:28.554Z"
    },
    "stackingHealth": None,
    "stackingMode": "Enclosure",
    #    "name":"Stevo's Magical Mysterious LIG1383337673.81",
    "state": "Active",
    "description": None,
    "status": None,
    #    "uri":"/rest/logical-interconnect-groups/01612f0a-c223-4b3e-bc9c-8d353317f9e9",
    "category": "logical-interconnect-groups",
    #    "created":"2013-11-01T20:27:28.236Z",
    #    "eTag":"f7a9eb4f-8792-4306-977e-e4793a7da0cd",
    #    "modified":"2013-11-01T20:27:28.555Z"
}
