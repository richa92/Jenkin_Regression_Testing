'''
Module StateChartMBT
Created on Aug 13, 2013
@Author: Joseph Rodrigo (joseph.a.rodrigo@hp.com)
@Author: Michael Boucher (michael.r.boucher@hp.com)
'''

import xml.etree.ElementTree as ET
from operator import itemgetter
import pprint
import random
import time
import re
import copy
import string
import types
from robot.libraries.BuiltIn import BuiltIn
from RoboGalaxyLibrary.utilitylib import logging


class StateChartMBT:

    '''
    StateChartMBT - Model-based testing with Harel state charts using SCXML

    == Params ==
      xml                      :  Required. XML Model document.
      debug                    :  Enable debug message logging. Defaults to 0.
      skip_keyword_validation  :  Disables keyword validation. To be used when utilizing variables in Keyword names. Defaults to 0.

    '''

    def __init__(self, xml=None, debug=0, skip_keyword_validation=0):
        '''
        Constructor
        '''
        # initialize some attributes we might use later
        self.states = {}
        self.debug = debug
        self.skip_keyword_validation = skip_keyword_validation
        self.flat_model = None
        self.root = None
        self.built_in = BuiltIn()

        if xml is not None:
            self.set_xml(xml)

        if self.debug:
            logging._info("Module Debug Mode Enabled")

    def set_xml(self, xml):
        if xml is None:
            raise AttributeError("SCXML model not specified")
        else:
            self.scxml = xml
            tree = ET.parse(self.scxml)
            self.root = tree.getroot()
            self.xml = self._parse_xml(self.root)
            self._validate_scxml()
        pass

    def run_defined_path(self, path=None, minutes=None):
        '''
        Runs a defined path
        '''
        rc = None

        # Verify args
        if path is None:
            raise AttributeError("Run Defined Path requires 'path' arg")

        # Get Path
        steps = []
        if isinstance(path, list) or isinstance(path, dict):
            logging._debug("Reading from specified path")
            steps = path
        else:
            logging._debug("Reading from file")
            fh = open(path, "r")
            if fh is None:
                raise RuntimeError("unable to open file %s" % path)
            steps = fh.read()
            steps = steps.splitlines()
            fh.close()

        start = time.time()

        for step in steps:
            logging._debug("Current Step: %s" % step)

            if ":" not in step:
                continue

            # Check for exit conditions
            if minutes is not None:
                if (time.time() - start >= minutes * 60):
                    logging._debug("exiting path early due to time limit")
                    break

            # Decipher step to take
            match = re.search(r"(\S+):\s+(.+)", step)
            if not match:
                raise RuntimeError("Invalid step '%s'" % step)
            step_type = match.group(1)
            step_name = match.group(2)
            if step_type != 'state' and step_type != 'event':
                raise RuntimeError("Invalid step_type '%s'" % step_type)

            # Execute and verify event or state
            if step_type == 'event':
                rc = self._verify_event(step_name)
            else:
                rc = self._verify_state(step_name)

            if not rc:
                return rc

        if rc is None:
            raise Exception("No steps taken in runDefinedPath")
        return rc

    def run_random_path(self, type="online", file=None, transitions=None,
                        minutes=None):
        '''
        Run a random path with set transitions and/or minutes
        usage: run_random_path(transitions, minutes, type, file)
         transitions -- maximum number of transitions to run
         minutes -- maximum number of minutes to run
         type -- online or offline (defaults to onliine)
         file -- file to log transitions
        '''
        rc = True

        # Validate arguments
        if minutes is None and transitions is None:
            raise AttributeError("run_random_path requires 'minutes' or \
                            'transitions' argument")

        if string.lower(type) != "offline" and string.lower(type) != "online":
            raise AttributeError("run_random_path requires 'type' argument set to \
                            offline or online. (%s)" % type)

        if string.lower(type) == "offline" and file is None:
            raise AttributeError("run_random_path requires 'file' arg for \
                            offline run")

        if string.lower(type) == "offline" and minutes is not None:
            raise AttributeError("can't use 'minutes' constraint in offline \
                                test eneration")
        if not self.scxml:
            raise AttributeError("can't run_random_path without SCXML to \
                                constructor")

        # Open file handle if needed
        fh = None
        if file is not None:
            fh = open(file, "w")

        transitions_taken = 0
        start = time.time()

        # Verify initial state(s)
        curr_states = self._get_full_state(self.root.attrib['initial'])

        if file is not None:
            for state in curr_states:
                fh.write("state: " + state['id'] + "\n")

        if string.lower(type) == "online":
            for state in curr_states:
                rc = self._verify_state(state['id'])
                if not rc:
                    return rc

        while True:
            # Check for exit conditions
            if minutes is not None:
                if (time.time() - start) > (int(minutes) * 60):
                    break
            if transitions is not None:
                transitions_taken += 1
                if transitions_taken > int(transitions):
                    break

            # get list of possible transitions
            available_transitions = []
            for state in curr_states:
                for transition in state['transition']:
                    if self._cond_met(transition, curr_states):
                        available_transitions.append(transition)

            # Pick random transition
            transition = available_transitions[
                random.randint(
                    0,
                    len(available_transitions) -
                    1)]
            curr_states = self._get_next_state(curr_states, transition)

            # Log choice to file if needed
            if string.lower(type) == "offline":
                logging._debug("Writing event '%s' to file." %
                               transition['event'])
                fh.write("event: " + transition['event'] + "\n")
                for state in curr_states:
                    logging._debug("Writing state '%s' to file." % state['id'])
                    fh.write("state: " + state['id'] + "\n")
            if string.lower(type) == "online":
                # Execute event for the transition
                rc = self._verify_event(transition['event'])
                if not rc:
                    return rc
                # Verify resulting states from transition
                for state in curr_states:
                    rc = self._verify_state(state['id'])
                    if not rc:
                        return rc
        return rc

    def run_all_transitions(self, type="online", file=None, minutes=None,):
        '''
        Runs all transitions
        usage: runAllTransitions(minutes, type, file)
         minutes -- maximum number of minutes to run
         type -- online or offline (defaults to onliine)
         file -- file to log transitions
        '''
        path = None
        fh = None
        start = time.time()

        # Validate args
        if (type is None) or (string.lower(type) != "online"
                              and string.lower(type) != "offline"):
            raise AttributeError("run_all_transitions requires 'type' arg set to \
                            offline or online")

        if (string.lower(type) == "offline" and (file is None)):
            raise AttributeError("run_all_transitions requires 'file' arg for \
                            offline run")

        if (string.lower(type) == "offline" and minutes is not None):
            raise AttributeError("can't use 'minutes' constraint in offline test \
                            generation")

        if self.root is None:
            raise AttributeError("can't run_all_transitions without SCXML to \
                            constructor")

        # State with initial state
        curr_states = self._get_full_state(self.root.attrib['initial'])
        self._flatten_state(curr_states)

        if file is None:
            path = []
            for state in curr_states:
                path.append("state: %s" % state['id'])
        else:
            path = file
            fh = open(file, "w")
            for state in curr_states:
                fh.write("state: %s\n" % state['id'])

        # for trans in self._untaken_transitions():
        while self._untaken_transitions():
            if self.debug:
                logging._log_to_console(
                    "=======================================================")
                logging._log_to_console(
                    "Now in state: %s\n" %
                    pprint.pformat(
                        curr_states[0]['id']))

            # Check for exit conditions
            if minutes is not None:
                if (time.time() - start) > (int(minutes) * 60):
                    logging._info(
                        "Time Constraint of %s minutes has been exceeded. Execution complete." %
                        minutes)
                    break

            # Get to closest state with untaken transitions
            transitions = self._transitions_to_needed_state(curr_states)
            if transitions is None:
                state_ids = [state['id'] for state in curr_states]
                raise RuntimeError("Unable to get to needed states from %s" %
                                   ' '.join(state_ids))

            # Log transitions to get to that state
            for trans in transitions:
                curr_states = self._get_next_state(curr_states, trans)
                if file is not None:
                    fh.write("event: %s\n" % trans['event'])
                    # FIXME: Better way to do this
                    for state in curr_states:
                        fh.write("state: %s\n" % state['id'])
                else:
                    path.append("event: %s" % trans['event'])
                    # FIXME: Better way to do this
                    for state in curr_states:
                        path.append("state: %s" % state['id'])

            logging._debug("curr_states: %s" % pprint.pformat(curr_states))

            # Choose an untaken transition
            if self.debug:
                logging._log_to_console("Getting untaken transitions...")
            transitions = self._untaken_transitions_in_state(curr_states)
            if self.debug:
                logging._log_to_console(
                    "Selecting from transitions: %s" %
                    pprint.pformat(transitions))
            trans = transitions[random.randint(0, len(transitions) - 1)]
            trans['-taken'] = 1
            curr_states = self._get_next_state(curr_states, trans)
            self._flatten_state(curr_states)

            if self.debug:
                logging._log_to_console(
                    "\nTook transition: %s" % pprint.pformat(trans))

            # Log it
            if file is not None:
                logging._debug("Writing event '%s' to file." % trans['event'])
                fh.write("event: %s\n" % trans['event'])
                for state in curr_states:
                    logging._debug("Writing state '%s' to file." % state['id'])
                    fh.write("state: %s\n" % state['id'])
            else:
                path.append("event: %s" % trans['event'])
                for state in curr_states:
                    path.append("state: %s" % state['id'])

        if file is not None:
            fh.close()

        # Run this path if online, otherwise done
        if string.lower(type) == "online":
            return self.run_defined_path(path)

        return True

    def _untaken_transitions(self):
        '''
        Are there untaken transitions?
        '''
        if self.debug:
            logging._log_to_console("\nAre there untaken transitions?")
        for state in self.flat_model.keys():
            if self._untaken_transitions_in_state(state):
                if self.debug:
                    logging._log_to_console("There are untaken transitions\n")
                return 1
        if self.debug:
            logging._log_to_console("No untaken transitions\n")
        return 0

    def _untaken_transitions_in_state(self, state):
        '''
        List of untaken transitions in given state(uses flattened states)
        '''
        logging._debug("Calling _untaken_transitions_in_state")
        logging._debug("Got State: '%s'" % state)

        if (not isinstance(state, str)):
            state = self._flatten_state(state)

        if self.debug:
            logging._log_to_console(
                "Looking for untaken transitions in state: %s" %
                pprint.pformat(state))

        transitions = self.flat_model[state]
        untaken = []

        for transition in transitions:
            if '-taken' not in transition:
                if self.debug:
                    logging._log_to_console(
                        "Found untaken transition: %s" %
                        pprint.pformat(transition))
                untaken.append(transition)

        if self.debug:
            logging._info(
                "_untaken_transitions_in_state returning: %s" %
                pprint.pformat(untaken))
        return untaken

    def _transitions_to_needed_state(self, states, ttl=None):
        '''
        Transition to a state with untaken transitions
        '''
        logging._debug("Calling _transitions_to_needed_state")

        # None needed if there are untaken transitions from current state(s)
        if self._untaken_transitions_in_state(states):
            if self.debug:
                logging._log_to_console(
                    "There are untaken transitions in this state.\n")
            return []

        # Longest possible number of needed transitions
        if ttl is None:
            ttl = self._number_of_flat_states()

        # Increase number of transitions to take to find path to needed
        # state(s)
        for depth in range(1, ttl + 1):
            for trans in self._available_transitions(states):
                if 'target' not in trans:
                    continue

                # Check each transition from this state
                nextStates = self._get_next_state(states, trans)
                transitions = self._transitions_to_needed_state(
                    nextStates, depth - 1)
                # FIXME: This can be done better
                if transitions is not None:
                    ret = [trans]
                    ret.extend(transitions)
                    return ret

        # Unable to get to needed state from in $ttl transitions
        return None

    def _number_of_flat_states(self):
        '''
        Number of states in model
        '''
        logging._debug("%s flat states found" % len(self.flat_model.keys()))
        return len(self.flat_model.keys())

    def _flatten_state(self, states):
        '''
        Creates a flattened version of complex state and adds to flattened
        model
        '''
        logging._debug("Calling _flatten_state")
        if self.flat_model is None:
            self.flat_model = {}

        logging._debug("Flattening states: %s" % pprint.pformat(states))

        # just return if flattened state has already been generated
        flat_state = []
        for state in states:
            flat_state.append(state['id'])
        flat_state = ' '.join(str(n) for n in flat_state)
        if (flat_state in self.flat_model):
            return flat_state

        # add flattened state & transition
        self.flat_model[flat_state] = copy.deepcopy(
            self._available_transitions(states))

        # conds not useful in flattened model
        for item in self.flat_model[flat_state]:
            if 'cond' in item:
                del item['cond']

        logging._debug("_flatten_state returning: %s" %
                       pprint.pformat(flat_state))
        return flat_state

    def _available_transitions(self, states):
        '''
        Transitions you can take from the given states
        '''
        addedAncestors = []
        transitions = []

        for state in states:
            # add transitions from each state
            for transition in state['transition']:
                if self._cond_met(transition, states):
                    transitions.append(transition)

            # also add transitions from ancestor/super states
            for i in range(1, len(state['-hierarchy']), 2):
                ancestor = state['-hierarchy'][i]
                ancestor = self._find_state(ancestor)

                # skip if it has no transitions
                if 'transition' not in ancestor:
                    continue
                # skip if it's already a part of the given states
                found = False
                for st in states:
                    if ancestor['id'] == st['id']:
                        found = True
                if found:
                    continue
                # skip if we have already added its transitions
                if ancestor['id'] in addedAncestors:
                    continue

                # if we've made it this far,
                # add this ancestor state's transitions
                addedAncestors.append(ancestor['id'])
                for transition in ancestor['transition']:
                    if self._cond_met(transition, states):
                        transitions.append(transition)

        return transitions

    def _cond_met(self, trans, states):
        '''
        Returns true if transition conditions are met
        '''
        # If no cond, then conditions are met
        if 'cond' not in trans:
            return True

        ins = []
        cond = copy.deepcopy(trans['cond'])

        # Evaluate each in predicate
        regex = re.compile("In\([\"\'](\S+)[\"\']\)", re.IGNORECASE)
        matches = regex.findall(cond)
        if self.debug:
            logging._log_to_console(
                "Found Matches: %s" % pprint.pformat(matches))

        # for match in regex.finditer(cond):
        for match in matches:
            zin = 0
            for state in states:
                if (state['id'] == match) or (match in state['-hierarchy']):
                    zin = 1
                    break
            ins.append(zin)

        if len(ins) == 0:
            if self.debug:
                logging._log_to_console("ins: %s" % pprint.pformat(ins))
            raise AttributeError(
                "Failed to find 'In' predicate in cond '%s'" % cond)

        # Replace each In predicate with True or False
        for val in ins:
            cond = regex.sub(str(val), cond, 1)

        # TODO: Replace any '!'s with 'not'
        regex = re.compile("\!")
        cond = regex.sub('not ', cond)

        # Evaluate Condition
        if self.debug:
            logging._log_to_console("_cond_met eval string: %s" % cond)
        cond_val = eval(cond)

        if self.debug:
            logging._log_to_console("_cond_met returning %s" % bool(cond_val))
        return bool(cond_val)

    def _get_next_state(self, states, trans):
        '''
        Get next state given transition from current state
        '''
        old_states = copy.deepcopy(states)
        new_states = []
        implied = []

        logging._debug("Calling _get_next_state")
        if self.debug:
            logging._debug("with states: %s" % pprint.pformat(states))
            logging._debug("and with transition: %s" % pprint.pformat(trans))

        # no change if target not defined
        if 'target' not in trans:
            return old_states

        for target in trans['target'].split(' '):
            # check effect of each new target
            target_xml = self._find_state(target)
            if target_xml is None:
                raise RuntimeError("failed to find state %s" % target)

            # if target is at top of SCXML, everything will change
            if (len(target_xml['-hierarchy']) == 1):
                old_states = []

            # check each existing state to see if it is replaced
            for i in range(len(old_states) - 1, - 1, - 1):
                state = old_states[i]

                logging._debug("Considering State: %s" % pprint.pformat(state))

                # if state is at top of SCXML, it will be replaced
                if (len(state['-hierarchy']) == 1):
                    old_states.pop(i)
                    continue

                # if state is in target hierarchy, it will not change
                if (state['id'] in target_xml['-hierarchy']):
                    continue

                # FIXME: is this the best way to accomplish this?
                parent_type = state['-hierarchy'][-3]
                parent = state['-hierarchy'][-2]
                changing_parent = parent if parent_type == 'state' else state[
                    'id']
                if (changing_parent in target_xml['-hierarchy']):
                    old_states.pop(i)
                    continue

                parent_type = target_xml['-hierarchy'][-3]
                parent = target_xml['-hierarchy'][-2]
                changing_parent = parent if parent_type == 'state' else target_xml[
                    'id']
                if (changing_parent in state['-hierarchy']):
                    old_states.pop(i)
                    continue

            # if target is part of parallel state,
            # include other implied new states
            for i in range(0, len(target_xml['-hierarchy']) - 1, 2):
                # check all parallel states in hierarchy
                if target_xml['-hierarchy'][i] != 'parallel':
                    continue
                parallel = target_xml['-hierarchy'][i + 1]

                # skip if parallel ancestor is part of
                # hierarchy of current states
                # FIXME: Grep: This can be done better.
                for h in old_states:
                    if parallel in h['-hierarchy']:
                        continue
                parallel = self._find_state(parallel)

                # keep track of implied parallel states
                # (ignore dups)
                # FIXME: Grep: This can be done better
                for state_xml in self._get_full_state_from_here(parallel):
                    dup = 0
                    for imply in implied:
                        if imply['id'] == state_xml['id']:
                            dup += 1
                            break

                    if dup > 0:
                        implied.append(state_xml)

            full_state = self._get_full_state_from_here(target_xml)
            if (isinstance(full_state, types.ListType)):
                new_states.extend(full_state)
            else:
                new_states.append(full_state)

        logging._debug("new_states without old_states: %s" %
                       pprint.pformat(new_states))

        # combine new and the unchanged old states
        new_states.extend(old_states)

        logging._debug("new_states with old_states: %s" %
                       pprint.pformat(new_states))

        # remove non-transitionable ancestors of new_states from implied new
        # states
        for i in range(len(implied) - 1, -1, -1):
            id = implied[i]['id']
            for new_state in new_states:
                # of course, remove implied state if it's the same as new state
                if id == new_state['id']:
                    implied.pop(i)
                    break

                lca = self._get_lca(implied[i], new_state)
                # remove state from @implied if LCS with
                # new state is not 'parallel'
                if (lca is not None) and (lca['-hierarchy'][-1] == 'state'):
                    implied.pop(i)
                    break

                # remove state from @implied if it is ancestor of new state
                if (id in new_state['-hierarchy']) or new_state['id'] == id:
                    implied.pop(i)
                    break

        # combine new resulting states with implied states
        new_states.extend(implied)

        if self.debug:
            logging._debug("new_states with implied: %s" %
                           pprint.pformat(new_states))

        # add transitionable ancestors of new_states
        for state in new_states:
            for i in range(1, len(state['-hierarchy']), 2):
                ancestor = state['-hierarchy'][i]
                ancestor = self._find_state(ancestor)
                if 'transitions' not in ancestor:
                    continue
                dup = 0
                # FIXME: Grep: This can be done better
                for new_state in new_states:
                    if new_state['id'] == ancestor['id']:
                        dup += 1
                        break

                if dup > 0:
                    new_states.append(ancestor)

        if self.debug:
            logging._debug("new_states with ancestors: %s" %
                           pprint.pformat(new_states))

        return sorted(new_states, key=itemgetter('id'))

    def _get_lca(self, s1, s2):
        '''
        Gets least common ancestor of two states
        '''
        h1 = s1['-hierarchy']
        h2 = s2['-hierarchy']

        lca_index = None
        i = 1
        while (i < len(h1) - 1) and (i < len(h2) - 1):
            i += 2
            if (h1[i] is not h2[i]):
                break
            lca_index = i

        if lca_index is None:
            # LCS is 'scxml'
            return None
        else:
            return self._find_state(h1[lca_index])
        pass

    def _get_full_state(self, target):
        '''
        Gets the full resulting state from a transition
        '''
        state_xml = self._find_state(target)
        return self._get_full_state_from_here(state_xml)

    def _find_state(self, zid, xml=None):
        '''
        Finds XML section matching state id somewhere in the SCXML
        '''
        logging._debug("Calling findState")
        logging._debug("Looking for ID: %s" % zid)

        if xml is None:
            xml = self.xml

        if ('id' in xml):
            if self.debug:
                logging._debug("Considering State: %s" % xml['id'])
        if ('id' in xml and xml['id'] == zid):
            # Found it
            if self.debug:
                logging._debug("FOUND IT!!!")
            return xml

        # Search states
        if 'state' in xml:
            for state in xml['state']:
                ret = self._find_state(zid, xml['state'][state])
                if ret is not None:
                    return ret

        return None

    def _get_full_state_from_here(self, xml=None):
        '''
        Get full state (dig through sub-states and parallel states) from
        current position in xml
        '''
        logging._debug("Calling getFullStateFromHere")

        type = xml['-hierarchy'][len(xml['-hierarchy']) - 1]
        if self.debug:
            logging._debug("TYPE: %s" % type)
        states = []

        # If no substates, I am part (or all) of the full state
        if 'state' not in xml:
            return xml

        # If I have a transition, I am part (or all) of the full state
        if 'transition' in xml:
            states.append(xml)

        # If i'm a parallel state, expand to lower states
        if type is 'parallel':
            for key in xml['state'].keys():
                states.append(
                    self._get_full_state_from_here(xml['state'][key])[0])
            # If there's an initial substate, jump to it
        elif 'initial' in xml:
            states.append(
                self._get_full_state_from_here(xml['state'][xml['initial']]))

        return sorted(states, key=itemgetter('id'))

    def _get_verifiable_states(self, xml=None, hierarchy=None):
        '''
        Get verifiable states and verify stuff along the way. A verifiable
        state refers to states with transition(s) and/or no sub-states.
        '''
        logging._debug("Calling _get_verifiable_states")
        if xml is None:
            xml = copy.deepcopy(self.xml)

        states = []

        if hierarchy is None:
            hierarchy = []

        # Store hierarchy if at state of parallel tag
        if 'id' in xml:
            xml['-hierarchy'] = hierarchy
            hierarchy.append(xml['id'])

        # Return if no more substates
        if 'state' not in xml and 'parallel' not in xml:
            if hierarchy[-1] == 'parallel':
                raise AttributeError(
                    "found parallel tag %s with no substates" % xml['id'])
            else:
                return xml

        # Might as well verify any initial tags
        if 'initial' in xml:
            initial = copy.deepcopy(xml['initial'])
            if not isinstance(initial, str):
                if 'transition' not in initial:
                    raise AttributeError(
                        "initial tag of %s has no transition" %
                        xml['id'])

                if len(initial['transition']) != 1:
                    raise AttributeError("initial tag for %s must have only one \
                                        transition" % xml['id'])

                trans = copy.deepcopy(initial['transition'][0])
                if 'target' in trans:
                    raise AttributeError("transition in initial tag for %s must \
                                        have target" % xml['id'])

                if 'event' in trans:
                    raise AttributeError("transition in initial tag for %s \
                                        shouldn't have event" % xml['id'])

                initial = copy.deepcopy(trans['target'])
            if not (
                'state' in xml and (
                    key == initial for key in xml['state'].keys())) and not (
                'parallel' in xml and (
                    key == initial for key in xml['parallel'].keys())):
                raise AttributeError(
                    "failed to find state for initial target %s" % initial)

        # Check in all parallel tags
        if 'parallel' in xml:
            for key in xml['parallel'].keys():
                parallel_hierarchy = copy.deepcopy(hierarchy)
                parallel_hierarchy.append("parallel")
                rc = self._get_verifiable_states(
                    copy.deepcopy(xml['parallel'][key]), parallel_hierarchy)
                states.extend(rc) if isinstance(
                    rc,
                    list) else states.append(rc)

        # Check in all state tags
        if 'state' in xml:
            for key in xml['state'].keys():
                state_hierarchy = copy.deepcopy(hierarchy)
                state_hierarchy.append("state")
                rc = self._get_verifiable_states(
                    copy.deepcopy(xml['state'][key]), state_hierarchy)
                states.extend(rc) if isinstance(
                    rc,
                    list) else states.append(rc)

        if 'transition' in xml:
            states.append(xml)

        logging._debug("_get_verifiable_states Returning States: %s" %
                       pprint.pformat(states))

        return states

    def _verify_event(self, event):
        '''
        executes and verifies an event
        '''
        event = string.replace(event, "_", " ")
        # Initiate instead of Verify
        logging._info("Executing event: " + event)

        rtnCode = BuiltIn.run_keyword_and_return_status(self.built_in, event)
        if not rtnCode:
            raise RuntimeError("Failed to verify event " + event)
        else:
            logging._info("Executed event " + event)
        return rtnCode

    def _verify_state(self, state):
        '''
        executes and verifies a state
        '''
        state = string.replace(state, "_", " ")
        logging._info("Verifying state: " + state)
        rtnCode = BuiltIn.run_keyword_and_return_status(self.built_in, state)

        if not rtnCode:
            raise Exception("Failed to verify state " + state)
        else:
            logging._info("Verified state " + state)
        return rtnCode

    def _validate_scxml(self):
        '''
        basic validation of the SCXML
        '''
        xml = self.xml

        # Check basic first tags/attributes
        if 'state' not in xml:
            raise AttributeError("No states?")

        if 'initial' not in self.root.attrib:
            raise AttributeError("No initial attribute for scxml")

        # Check and gather states
        states = self._get_verifiable_states()
        if len(states) == 0:
            raise AttributeError("No verifiable states in SCXML")

        # Gather and check transitions for each state
        events = []
        for state in states:
            if 'transition' not in state:
                print "No transitions in state %s. Skipping." % state
                continue

            for trans in state['transition']:
                if 'event' not in trans:
                    raise AttributeError(
                        "missing event in transition for state %s" %
                        state['id'])

                if 'cond' in trans:
                    match = re.search(
                        "In\([\"\']\S+[\"\']\)", trans['cond'], re.IGNORECASE)
                    if match is None:
                        raise AttributeError(
                            "only supporting conditions with In predicates")

                events.append(trans['event'])

        if len(events) == 0:
            raise AttributeError("no transitions with events?")

        # Validate initial
        if not ('state' in xml) and (
                [1 for x in xml['state'] if x['id'] == self.root.attrib['initial']]):
            raise AttributeError(
                "failed to find corresponding state tag for initial state")

        # No state id can be 'state' or 'parallel', that's just confusing
        if ([1 for state in states if (
                re.search(r"(state|parallel)", state['id'], re.IGNORECASE))]):
            raise NameError("don't make a state id 'state' or 'parallel'")

        # Also can't contain a space
        if ([1 for state in states if (
                re.search(r"\s", state['id'], re.IGNORECASE))]):
            raise NameError("state or parallel id can't contain a space")

        # If running in debug mode, skip verification of expected keywords
        if self.debug:
            logging._log_to_console("Skipping expected keyword verification")
            return

        # Skip Keyword validation if specified
        if self.skip_keyword_validation:
            logging._debug("Skipping Keyword Validation.")
            return

        # Validating keywords
        for state in states:
            self.built_in.keyword_should_exist(
                state['id'], "Keyword for state '%s' not found" % state['id'])
        for event in events:
            self.built_in.keyword_should_exist(
                event, "Keyword for event '%s' not found" % event)

        pass

    def _parse_xml(self, parent_element, path=None):
        '''
        Basic validation of the SCXML
        '''
        logging._debug("Calling _parse_xml")

        if path is None:
            path = ""

        data = {}
        # Store parent_element information
        if ('parallel' in parent_element.tag or 'state' in parent_element.tag):
            xtype = 'parallel' if 'parallel' in parent_element.tag else 'state'

            data['id'] = parent_element.attrib['id']

            if 'initial' in parent_element.attrib:
                data['initial'] = parent_element.attrib['initial']

            path += " " if path is not "" else ""    # Avoids leading spaces
            path += xtype                            # Add type to hierarchy
            data['-hierarchy'] = path.split(' ')     # Store hierarchy
            path += " " + parent_element.attrib['id']  # Add id to hierarchy

        if parent_element.items():
            dict(parent_element.items())

        states = {}
        transitions = []
        for element in parent_element:
            # print element.tag

            # Ignore Top-most level
            if ('}scxml' in parent_element.tag):
                return self._parse_xml(element, path)

            # Parallel or Serial States
            elif ('parallel' in element.tag or 'state' in element.tag):
                if 'state' not in data:
                    data['state'] = []
                states[element.attrib['id']] = self._parse_xml(element, path)
                data['state'] = states

            # Transitions
            elif 'transition' in element.tag:
                transition = {}

                # Store transition information
                transition['event'] = element.attrib['event']
                transition['target'] = element.attrib['target']

                if 'cond' in element.attrib:
                    transition['cond'] = element.attrib['cond']
                    # Replace multiple spaces with single
                    r = re.compile('\s+')
                    transition['cond'] = r.sub(' ', transition['cond'])

                # TODO: Currently does not store conditions
                # Add transition into transitions array
                transitions.append(transition)
                # Store transitions in data dictionary
                data['transition'] = transitions

        return data

if __name__ == '__main__':

    '''
    Test program for StateChartMBT module
    '''
    import pprint
    import sys
    import os.path

    print "Running Debug Program"

    if len(sys.argv) < 2:
        print "Usage: python %s file.xml" % str(sys.argv[0])
        sys.exit(2)

    xml = str(sys.argv[1])
    if not os.path.exists(xml):
        print "== ERROR :: Input SCXML file %s not found." % xml
        exit(1)

    SC = StateChartMBT(xml, 1)
    SC.run_all_transitions(type="offline", file="all.txt")

    print "== INFO :: All Transitions offline execution completed successfully."

    exit(0)
