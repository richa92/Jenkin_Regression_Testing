"""
Main entry point for Config Manager
"""
# from RoboGalaxyLibrary.configmgr import ilo, oa, storage_3par, storage, switch_5900
import oa
import switch
import san_switch
import storage
import fw_flasher
import iLO
import sut
# from RoboGalaxyLibrary.configmgr import log, config_parser, hw_objects
import config_parser
import hw_objects  # , fw_flasher
# import log
import argparse
# import state_machine, xworkflows #inherit from xworkflows.WorkflowEnabled
from snapshot_writer import RetrieveData, CreateSnapshotXml
import custom_logging as log
import logging

import datetime
import os
if os.name == 'nt':
    from pywintypes import error as Exception
    from winpexpect import winspawn as spawn
else:
    from pexpect import spawn


class ConfigManager(object):

    """
    Main class for Config Manager
    """

    def __init__(self, config_xml):
        """
        config_xml should be full path to XML'
        """
        # state = MyWorkflow()  #google Pylint False Positive E1101
        self.xml = config_xml
        try:
            self.my_parser = config_parser.ConfigParser(self.xml)
        except:
            log._error(
                "Unable to use given path to input XML, please check the path for errors")
            exit(0)

    def setup(self):
        """
        Sets up environment based on config file. First validates, and if
        validate() returns True, continues with configuring.
        """

        if self.my_parser.parse_xml():
            try:
                if self.my_parser.store_xml_data():
                    return True
                else:
                    log._warn("Failed to store XML data")
                    return False
            except:
                log._warn(
                    "config_manager:setup: Encountered error parsing XML, please file bug under Quix")
                return False
        else:
            log._warn(
                "config_manager:setup: Invalid or malformed XML '%s', please check format for errors or use XML validator online" %
                (self.xml))
            return False

    def teardown(self):
        """
        Will attempt to restore environment back to initial state, saving a
        snapshot (before or after?)
        """
        pass

    def flash_firmware(self):
        """
        uses fw_flasher to update firmwares based on test environment
        """

        for fw_obj in self.my_parser.firmware_list:
            # below section of code involves firmware update on OA, Enclosure
            # Blades and Virtual Connect modules
            cur_fw_obj = fw_flasher.EnclFwFlasher(
                fw_obj.oa_ip, fw_obj.oa_user, fw_obj.oa_passwd)
            cur_fw_obj.set_firmware_environment(fw_obj.spp_http_url)
            cur_fw_obj.check_if_oa_requires_update(fw_obj.oa_firmware_version)
            if fw_obj.bay_numbers == "None":
                log._info(
                    " There are no Blade servers for firmware update \n\n\n")
            else:
                bay_no = fw_obj.bay_numbers.split(',')
                for i in bay_no:
                    cur_fw_obj.initiate_firmware_update(i)
            vc_firmware_list = cur_fw_obj.check_for_vc_firmware_version(
                "show firmware summary")
            cur_fw_obj.update_vc_firmware(
                fw_obj.vc_user,
                fw_obj.vc_passwd,
                fw_obj.vc_firmware_location,
                vc_firmware_list)

            # Below section of code involves Switch firmware update
            if fw_obj.is_net_switch_update_enabled == 'True':
                switch_obj = fw_flasher.SwitchFwFlasher(
                    fw_obj.network_switch_ip,
                    fw_obj.network_switch_user,
                    fw_obj.network_switch_passwd,
                    fw_obj.nework_switch_firmware_download_command,
                    fw_obj.network_swtich_firmware_update_command)
                switch_obj.download_firmware_image_to_switch()
                # switch_obj.initialize_firmware_update_on_switch()

        # Below code involves firmware update on DL servers
        dl_fw_obj = fw_flasher.DLFwFlasher()
        dl_fw_obj.initiate_firmware_update_on_gen8_dl_servers()

    def configure_storage(self):
        """
        One of the main threads of Config Manager, configures storage
        objects based on what is present in input XML
        """
        for storage_obj in self.my_parser.storages_list:
            if "3par" in storage_obj.model.lower():
                cur_3par_obj = storage.Storage3par(
                    storage_obj.ip_address,
                    storage_obj.username,
                    storage_obj.password)
                if storage_obj.domains:
                    for domain in storage_obj.domains:
                        # add check to see if domain exists
                        cur_3par_obj.create_domain(
                            domain["Name"], domain["DomainUsers"])
                if storage_obj.cpgs:
                    for cpg in storage_obj.cpgs:
                        cur_3par_obj.create_cpg(
                            cpg["Name"],
                            cpg["Size"],
                            cpg["Domain"],
                            cpg["RaidType"])
                if storage_obj.virtual_volumes:
                    for virtvol in storage_obj.virtual_volumes:
                        # add check to see if virtual volume exists
                        cur_3par_obj.create_virtual_volume(
                            virtvol["Name"],
                            virtvol["Size"],
                            virtvol["UserCPG"],
                            virtvol["Thin"])
                if storage_obj.hosts:
                    for host in storage_obj.hosts:
                        # add check to see if host exists
                        if host["wwn_or_iqn"] == '':
                            cur_3par_obj.create_host(
                                host["Name"], host["HostOS"], host["Domain"])
                        else:
                            cur_3par_obj.create_host(
                                host["Name"],
                                host["HostOS"],
                                host["Domain"],
                                host["wwn_or_iqn"])
                if storage_obj.vluns:
                    for vlun in storage_obj.vluns:
                        cur_3par_obj.create_vlun(
                            vlun["LUN"], vlun["HostName"], vlun["VV_Name"])
            elif "eva" in storage_obj.model.lower():
                cur_eva_obj = storage.StorageEva(
                    storage_obj.ip_address,
                    storage_obj.username,
                    storage_obj.password,
                    storage_obj.name)
                cur_eva_obj.validate_system()
                if cur_eva_obj.validated:
                    if storage_obj.virtual_volumes:
                        for virtvol in storage_obj.virtual_volumes:
                            # add check to see if virtual volume exists
                            cur_eva_obj.create_virtual_volume(
                                virtvol["Name"],
                                virtvol["Size"],
                                virtvol["UserCPG"],
                                virtvol["Thin"])
                            # add check to see if virtual volume was created..?
                    if storage_obj.hosts:
                        for host in storage_obj.hosts:
                            # add check to see if host exists
                            cur_eva_obj.create_host(
                                host["Name"],
                                host["wwn_or_iqn"],
                                host["ConnectionType"],
                                host["HostOS"])
                    if storage_obj.vluns:
                        for vlun in storage_obj.vluns:
                            # add check to see if vlun exists
                            cur_eva_obj.create_vlun(
                                vlun["HostName"], vlun["LUN"], vlun["VV_Name"])

                    """if storage_obj.cpgs:
                        for cpg in storage_obj.cps:
                            # add check to see if cpg (disk group) exists
                            cur_eva_obj.create_cpg(cpg["Name"])"""
                else:
                    log._warn(
                        "System name '%s' in XML not defined in EVA" %
                        storage_obj.name)
            # elif model == 'LeftHand':
                # currently not yet implemented

    def teardown_storage(self):
        for storage_obj in self.my_parser.storages_list:
            if "3par" in storage_obj.model.lower():
                cur_3par_obj = storage.Storage3par(
                    storage_obj.ip_address,
                    storage_obj.username,
                    storage_obj.password)
                if storage_obj.vluns:
                    for vlun in storage_obj.vluns:
                        cur_3par_obj.delete_vlun(
                            vlun["LUN"], vlun["VV_Name"], vlun["HostName"])
                if storage_obj.hosts:
                    for host in storage_obj.hosts:
                        # add check to see if host exists
                        cur_3par_obj.delete_host(host["Name"])
                if storage_obj.virtual_volumes:
                    for virtvol in storage_obj.virtual_volumes:
                        # add check to see if virtual volume exists
                        cur_3par_obj.delete_virtualvolume(virtvol["Name"])
                if storage_obj.cpgs:
                    for cpg in storage_obj.cpgs:
                        cur_3par_obj.delete_cpg(cpg["Name"])
                if storage_obj.domains:
                    for domain in storage_obj.domains:
                        # add check to see if domain exists
                        cur_3par_obj.delete_domain(
                            domain["Name"], domain["DomainUsers"])

            elif "eva" in storage_obj.model.lower():
                cur_eva_obj = storage.StorageEva(
                    storage_obj.ip_address,
                    storage_obj.username,
                    storage_obj.password,
                    storage_obj.name)
                cur_eva_obj.validate_system()
                if cur_eva_obj.validated:
                    # deleting the resources. We may include in tear down
                    if storage_obj.vluns:
                        for vlun in storage_obj.vluns:
                            # add check to see if vlun exists
                            cur_eva_obj.delete_vlun(
                                vlun["LUN"], vlun["HostName"])
                    if storage_obj.virtual_volumes:
                        for virtvol in storage_obj.virtual_volumes:
                            # add check to see if virtual volume exists
                            cur_eva_obj.delete_virtual_volume(virtvol["Name"])
                    if storage_obj.hosts:
                        for host in storage_obj.hosts:
                            # add check to see if host exists
                            cur_eva_obj.delete_host(host["Name"])
            # add teardown verification

    def configure_network(self):
        """
        One of the main threads of Config Manager, configures network
        and SAN switches based on what is present in input XML
        """
        for network_switch_obj in self.my_parser.network_switches_list:
            sw_obj = switch.SwitchCfg(
                network_switch_obj.ip_address,
                network_switch_obj.username,
                network_switch_obj.password,
                network_switch_obj.tftp_server_ip,
                network_switch_obj.config_file_name)
            '''
            sw_obj.upload_switch_config_file_to_tftp_server()
            sw_obj.download_switch_config_file_to_switch()
            '''
            lista = []
            for vlan in network_switch_obj.vlans:
                vlan_dict = vlan.attrib
                vlan_dict['name'] = vlan.tag
                # print vlan_dict
                lista.append(vlan_dict)
                for i in lista:
                    untag = i["UntaggedPorts"]
                    vlan_id = i["ID"]
                    tagged = i["TaggedPorts"]
                    # sw_obj.create_vlan(vlan_id)
                if vlan_id == 'None':
                    log._info(
                        "There are no VLAN's defined to be created, Hence Tagging and Untagging of ports will be skipped")
                    log._info(
                        "Please define a VLAN to be created with tag %s so, ports could be tagged or untagged" %
                        vlan.tag)
                else:
                    log._info("Creating VLAN %s" % vlan_id)
                    sw_obj.create_vlan(vlan_id)
                    untagged_ports = untag.split(',')
                    tagged_ports = tagged.split(',')

                    if untagged_ports == 'None':
                        log._info("There are no ports to be untagged")
                    else:
                        for port in untagged_ports:
                            log._info("untagging port %s to vlan %s" %
                                      (port, vlan_id))
                            sw_obj.untag_ports_to_vlan(vlan_id, port)

                    if tagged_ports == 'None':
                        log._info("There are no ports to be tagged")
                    else:
                        for port in tagged_ports:
                            log._info("tagging port %s to vlan %s" %
                                      (port, vlan_id))
                            sw_obj.tag_ports_to_vlan(vlan_id, port)
            user_list = []
            for user in network_switch_obj.users:
                user_dict = user.attrib
                user_dict['name'] = user.tag
                # print user_dict
                user_list.append(user_dict)
                for i in user_list:
                    user_name = i["Username"]
                    user_pw = i["Password"]
                    sw_obj.configure_users(user_name, user_pw)

            port_list = []
            for port in network_switch_obj.ports:
                port_dict = port.attrib
                port_dict['name'] = port.tag
                port_list.append(port_dict)
            for i in port_list:
                port_nu = i['PortList']
                port_state = i['PortState']
                port_duplex = i['PortDuplex']
                port_speed = i['PortSpeed']
                # print port_number, port_state, port_duplex, port_speed
                if port_nu == 'None':
                    log._warn(
                        "There are no ports mentioned for port attribute configuration under xml tag %s" %
                        port.tag)
                else:
                    log._info(
                        "There ports mentioned to be configured with port attributes")
                    port_number = port_nu.split(',')
                    for po in port_number:
                        if port_state == 'None':
                            log._info(
                                "port attribute state will not be configured as the value of it xml is set to None")
                        else:
                            log._info(
                                "Port attribute state will be configured for port %s " %
                                po)
                            sw_obj.configure_port_state(po, port_state)
                        if port_duplex == 'None':
                            log._info(
                                "port attribute duplex will not be configured as the value of it xml is set to None")
                        else:
                            log._info(
                                "Port attribute duplex will be configured for port %s " %
                                po)
                            sw_obj.configure_port_duplex_mode(po, port_duplex)
                        if port_speed == 'None':
                            log._info(
                                "port attribute speed will not be configured as the value of it xml is set to None")
                        else:
                            log._info(
                                "Port attribute speed will be configured for port %s " %
                                po)
                            sw_obj.configure_port_speed(po, port_speed)

        for san_switch_obj in self.my_parser.san_switches_list:
            # NOTE: expect should return 0 if 'successful' exists within the
            # output

            # here, check model and create object of corresponding class
            if 'SN6000B' in san_switch_obj.model:

                creds = san_switch_obj.ip_address + ';' + \
                    san_switch_obj.username + ';' + \
                    san_switch_obj.password + ';'
                sn_log = os.path.join(
                    os.getcwd(), r"logs", r"sn6000config.txt")
                try:
                    child = spawn(
                        'python san_switch.py model %s creds = %s' %
                        (san_switch_obj.model, creds), logfile=file(
                            sn_log, 'w'))
                    # port zoning to go here later
                    if os.name == 'nt':
                        SENDLINE = child.direct_sendline
                    else:
                        SENDLINE = child.sendline
                    # if there are zone configs present
                    if san_switch_obj.zone_configs:
                        for config in san_switch_obj.zone_configs:
                            # create zones with added wwns
                            # zone elements!
                            zone_list = [zone for zone in config.find("Zones")]
                            for zone in zone_list:
                                # compile the list of hosts to be added to zone
                                host_list = [
                                    host for host in zone.find("Hosts")]
                                for host in host_list:
                                    # compile the list of wwns to add to host
                                    wwn_list = [wwn.attrib["wwn"]
                                                for wwn in host.find('WWNs')]
                                    SENDLINE(
                                        'my_san.create_alias(%s, %s)' %
                                        (host.attrib['alias'], wwn_list))
                                    # no need to send a y for creating alias
                                    # expect should return 0 if 'successful'
                                    # exists within the output
                                    if child.expect("successful"):
                                        log._warn(
                                            "Failed to create host %s with given WWNs or domain/port index list" %
                                            (host.attrib['alias']))
                                    del wwn_list[:]
                                SENDLINE('my_san.create_zone(%s,%s)' %
                                         (zone.attrib["alias"], host_list))
                                # no need to send a y for creating a zone
                                if child.expect("successful"):
                                    log._warn(
                                        "Failed to create zone %s with given host list" %
                                        (zone.attrib['alias']))
                                del host_list[:]
                            # compile the list of zones to be added to config
                            SENDLINE('my_san.create_config(%s,%s)' %
                                     (config.attrib["name"], zone_list))
                            # no need to send a y for creating a zone
                            if child.expect("successful"):
                                log._warn(
                                    "Failed to create conig %s with given zone list" %
                                    (config.attrib["name"]))
                            del zone_list[:]
                        # here, use winpexpect to answer the decision prompts
                        # from SN6000 switch
                    if san_switch_obj.ports:
                        for port in san_switch_obj.ports:
                            port_num = port.tag.strip("PORTport")
                            SENDLINE('my_san.set_port_speed(%s,%s)' %
                                     (port_num, port.attrib["Speed"]))
                            # no need to send a y for creating a zone
                            if child.expect("successful"):
                                log._warn(
                                    "Failed to set port speed for port %s" %
                                    (port_num))
                            SENDLINE('my_san.set_port_fillword(%s, %s)' %
                                     (port_num, port.attrib["Fillword"]))
                            if child.expect("successful"):
                                log._warn(
                                    "Failed to set port fillword for port %s" %
                                    (port_num))
                    SENDLINE('my_san.save_config()')
                    child.expect("(yes, y, no, n):")
                    SENDLINE('yes')
                    SENDLINE('my_san.enable_config(%s)' %
                             (config.attrib["name"]))
                    child.expect("(yes, y, no, n):")
                    SENDLINE('yes')
                    SENDLINE('my_san.terminate_connection()')
                    child.terminate()
                    if child.isalive():
                        log._warn(
                            "CHILD PROCESS FAILED TO TERMINATE, PLEASE FILE BUG")
                except Exception:
                    log._warn(
                        "Failed to start child process for SAN switch configuration")
            # elif 'some other model' in san_switch_obj.model:
                # configure that model

            else:
                log._warn("Model not supported by Config manager at this time")

    def teardown_network(self):
        """
        """
        for network_switch_obj in self.my_parser.network_switches_list:
            pass

        for san_switch_obj in self.my_parser.san_switches_list:
            if 'SN6000B' in san_switch_obj.model:
                sn_log = os.path.join(
                    os.getcwd(), r"logs", r"sn6000config.txt")
                try:
                    creds = san_switch_obj.ip_address + ';' + \
                        san_switch_obj.username + ';' + \
                        san_switch_obj.password + ';'
                    child = spawn(
                        'python san_switch.py model %s creds = %s' %
                        (san_switch_obj.model, creds), logfile=file(
                            sn_log, 'w'))
                    if os.name == 'nt':
                        SENDLINE = child.direct_sendline
                    else:
                        SENDLINE = child.sendline
                    for config in san_switch_obj.zone_configs:
                        SENDLINE('my_san.disable_config(%s)' %
                                 (config.attrib["name"]))
                        child.expect("(yes, y, no, n):")
                        SENDLINE('yes')
                    SENDLINE('my_san.terminate_connection()')
                    child.terminate()
                    if child.isalive():
                        log._warn(
                            "CHILD PROCESS FAILED TO TERMINATE, PLEASE FILE BUG")
                except Exception:
                    log._warn(
                        "Failed to start child process for SAN switch configuration")
                    # elif 'some other model' in san_switch_obj.model:
                # configure that model
            else:
                log._warn("Model not supported by Config manager at this time")

    def san_switch_download_firmware(self):
        for san_switch_obj in self.my_parser.san_switches_list:
            # NOTE: expect should return 0 if 'successful' exists within the
            # output

            # here, check model and create object of corresponding class
            if 'SN6000B' in san_switch_obj.model:

                creds = san_switch_obj.ip_address + ';' + \
                    san_switch_obj.username + ';' + \
                    san_switch_obj.password + ';'
                child = spawn(
                    'python san_switch.py model %s creds = %s' %
                    (san_switch_obj.model, creds), logfile=file(
                        'logs/sn6000firmwarelog.txt', 'w'))
                if san_switch_obj.update == 'True':
                    SENDLINE('my_san.download_firmware(%s, %s, %s, %s)')

    def configure_rack(self):
        """
        """
        for rack in self.my_parser.rack_list:
            for server in rack.servers:
                self.configure_ilo(server)

    def teardown_rack(self):
        """
        """
        for rack in self.my_parser.rack_list:
            for server in rack.servers:
                self.teardown_ilo(server)

    def configure_ilo(self, server_object):
        """
        One of the main threads of Config Manager, configures iLO
        objects based on what is present in input XML
        """
        ilo = server_object
        if ilo.users:  # if there are any users defined,
            cur_ilo_obj = iLO.Ilo(ilo.ilo_ip, ilo.ilo_un, ilo.ilo_pw)
            for user in ilo.users:
                if user.attrib["License"] == '':
                    cur_ilo_obj.add_user(
                        user.attrib["Username"], user.attrib["Password"])
                else:
                    cur_ilo_obj.add_user(
                        user.attrib["Username"],
                        user.attrib["Password"],
                        user.attrib["License"])
            if ilo.bootorder:
                cur_ilo_obj.set_boot_order(ilo.bootorder)

    def teardown_ilo(self, server_object):
        """
        Reverts iLO back to preexisting settings before configure_ilo took place.  Uses
        a teardown reference XML to restore settings
        """
        ilo = server_object
        if ilo.users:  # if there are any users defined,
            cur_ilo_obj = iLO.Ilo(ilo.ilo_ip, ilo.ilo_un, ilo.ilo_pw)
            for user in ilo.users:
                cur_ilo_obj.delete_user(user.attrib["Username"])
        # if ilo.bootorder:
            # TODO: reset boot order based on teardown reference xml...

    def configure_sut(self):
        """
        One of the main threads of Config Manager, configures SUT
        objects based on what is present in input XML
        """
        for vsphere_obj in self.my_parser.vsphere_list:
            cur_vsphere_obj = sut.VSphere(
                vsphere_obj.ip_address,
                vsphere_obj.username,
                vsphere_obj.password)
            if cur_vsphere_obj:
                for vm in vsphere_obj.vms:
                    if vm.attrib["Reset"] == 'True':
                        cur_vsphere_obj.reset_vm(vm.attrib["Name"])
                    if vm.attrib["PowerOn"] == 'True':
                        cur_vsphere_obj.power_on_vm(vm.attrib["Name"])
                    if vm.attrib["Clone"] == 'True':
                        cur_vsphere_obj.clone_vm(
                            vm.attrib["Name"],
                            vm.attrib["CloneName"],
                            power_on=True,
                            is_template=False)
                cur_vsphere_obj.end_session()
            else:
                log._info(
                    "Skipping this vSphere object as connection failed..")

    def teardown_sut(self):
        """
        Undo anything created in configure_sut
        """
        for vsphere_obj in self.my_parser.vsphere_list:
            cur_vsphere_obj = sut.VSphere(
                vsphere_obj.ip_address,
                vsphere_obj.username,
                vsphere_obj.password)
            if cur_vsphere_obj:
                for vm in vsphere_obj.vms:
                    if vm.attrib["ShutdownAfter"] == 'True':
                        cur_vsphere_obj.power_off_vm(vm.attrib["Name"])
                    if vm.attrib["Clone"] == 'True':
                        # add a check to see if clone even got created..
                        try:
                            cur_vsphere_obj.power_off_vm(
                                vm.attrib["CloneName"])
                            cur_vsphere_obj.destroy_vm(vm.attrib["CloneName"])
                        except:
                            log._info(
                                "Clone does not exist, nothing to destroy")
            else:
                log._info(
                    "Skipping this vSphere object as connection failed..")

    def configure_oa(self):
        """
        One of the main threads of Config Manager, configures OA
        objects based on what is present in input XML
        """
        for oa_obj in self.my_parser.oa_list:

            cur_oa_obj = oa.OA(
                oa_obj.ip_address, oa_obj.username, oa_obj.password)
            cur_oa_obj.set_ebipa_for_interconnect(
                oa_obj.inter_start_addr, oa_obj.subnet)
            cur_oa_obj.set_ebipa_servers(
                oa_obj.server_start_addr, oa_obj.subnet)
            cur_oa_obj.set_ebipa_server_and_inter_gateway(oa_obj.gateway)
            cur_oa_obj.enable_ebipa_for_interconnect()
            cur_oa_obj.enable_ebipa_for_server()

            cur_oa_obj.clear_vc_mode()
            cur_oa_obj.poweroff_servers()
            cur_oa_obj.restart_interconnect()
            cur_oa_obj.ping_vc_ip(oa_obj.inter_start_addr)

    def create_snapshotxml(self, input_xml, xmltype, snapshot_name=None):
        """
        Will attempt to restore environment back to initial state, saving a
        snapshot (before or after?)
        """
        status = True
        DataGenerate = RetrieveData(input_xml, xmltype)
        if(DataGenerate.get_read_status()):
            snapshot_obj = CreateSnapshotXml()
            if(snapshot_obj.writeXML(DataGenerate, snapshot_name, xmltype, snapshot_name)):
                log._info("Snapshot XML is created successfully")
            else:
                status = False
                log._warn(
                    "failed to create snapshot xml. Please verify the log for more information.")
        else:
            status = False
            log._warn(
                "failed to retrieve the data from the configMgr.xml file or from the devices. Please verify the log for more information.")
        return status

if __name__ == "__main__":
    my_parser = argparse.ArgumentParser(
        description="see README.txt",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=True)
    my_parser.add_argument(
        '-d',
        '--debug',
        nargs='?',
        const=True,
        help="turns on DEBUG flag for addtl output for debugging purposes.  Optionally specifies a file to write debug data to. (Use 'stdout' for standard out or 'stderr' for standard error)")
    my_parser.add_argument(
        '-f',
        '--file',
        required=True,
        nargs=1,
        help="Full path to input XML file with environment paramaters.")
    my_parser.add_argument(
        '-s',
        '--snapshot',
        help="Name of snapshot XML (snapshot of the environment post-configuration")
    # my_parser.add_argument('-l', '--log', required =True, nargs=1, help="specify full path to logfile for information and error reports")
    # my_parser.add_argument('-v', '--verbose', nargs='?', default=

    args = my_parser.parse_args()
    input_file = str(args.file)
    cm = ConfigManager(input_file)

    # logfile_name = args.log
    # fh = logging.FileHandler("logs\configmgr.log", "w")
    # fh.setLevel(logging.INFO)
    # fh.setFormatter(formatter)
    # logger.addHandler(fh)

    cm.setup()
    # cm.flash_firmware()
    cm.create_snapshotxml(input_file, "teardown")
    # add parallel processing maybe?  some methods may depend on others..
    # cm.configure_storage()
    cm.configure_network()
    # cm.configure_rack()
    # cm.configure_oa()
    # cm.configure_sut()

    # pause... run test...
    raw_input("Press ENTER to teardown")

    # cm.teardown_storage()
    # cm.teardown_network()
    # cm.teardown_rack()
    # cm.teardown_oa()
    # cm.teardown_sut()

    if args.snapshot:
        cm.create_snapshotxml(
            input_file, "snapshot", snapshot_name=args.snapshot)
    else:
        cm.create_snapshotxml(input_file, "snapshot")
