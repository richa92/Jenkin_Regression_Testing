"""
Contains the base of the runner framework which launches a list of Operations in the background.

"""
import time

from vulcanlib.operations.operation import Operation


class OperationRunner(Operation):

    """Runs a list of Operations in the background.

    The runner maintains two separate lists: one for active operations and one for
    available operations.

    When the runner is launched (through the launch() or launch_in_background() methods)
    it will iterate through the list of available operations and kick each one off in
    the background. These operations are no longer available, they are now active.

    The runner then waits for the first operation to complete by checking the has_completed()
    method. If this completed operation had any errors (seen in the is_error variable),
    any registered callback method for failed operations is invoked with the failed operation.
    If the completed operation was successful, any registered callback method for completed
    operations is invoked with the completed operation.

    After successfully pulling an operation out of the active list, an optional timeout is
    checked and any available operations are kicked off.

    This loop continues until we have run out of available operations or have timed out
    with no more active operations.
    """

    def __init__(
            self,
            callback_operation_completed,
            callback_operation_failed):
        """Create a new runner that will invoke the provided callbacks when operations complete.

        Call the launch() or launch_in_background() method to kick off the main loop.

        This class keeps track of the number of completed operations through the completed_count
        variable and also stores a list called failed_operations. The entire run is timed
        and the total time can be checked after completion in the elapsed_time variable.
        """
        Operation.__init__(self)
        self.callback_operation_completed = callback_operation_completed
        self.callback_operation_failed = callback_operation_failed
        self.available_operations = []
        self.active_operations = []
        self.failed_operations = []
        self.completed_count = 0
        self.elapsed_time = 0
        self.timed_out = False

    def launch(self, timeout_seconds=None):
        """Launch the main processing loop for this runner.

        The main loop checks to see if we have more work to process before launching
        any available operations and waiting for the first active operation to complete.

        Callback methods are invoked for the completed active operation before we go
        back through the loop where we check for more work again.

        When there is no more work, we mark ourselves complete and return.

        Sub classes of OperationRunner may want to override this behavior to add their
        own operations before calling OperationRunner.launch() to enter the main loop.
        """
        start_time = time.time()

        while self._we_still_have_work_to_do():
            self._launch_any_available_operations()
            operation = self._wait_for_any_operation()
            if operation.is_error:
                self.failed_operations.append(operation)
                self.callback_operation_failed(operation)
            else:
                self.completed_count += 1
                self.callback_operation_completed(operation)

            if self._has_timed_out(start_time, timeout_seconds):
                self.timed_out = True
                time.sleep(2)

        self.elapsed_time = time.time() - start_time
        self.is_done = True

    def add_operation(self, operation):
        """Add another operation to the list of available operations to later be launched."""
        self.available_operations.append(operation)

    def _launch_any_available_operations(self):
        """Launch any operations in the available list in the background."""
        for operation in self.available_operations[:]:
            operation.launch_in_background()  # no timeout
            self.available_operations.remove(operation)
            self.active_operations.append(operation)

    def _wait_for_any_operation(self):
        """Find and return the first completed active operation or wait until one has completed."""
        while True:
            for operation in self.active_operations[:]:
                if operation.has_completed():
                    self.active_operations.remove(operation)
                    return operation

            # give us a little break if we didn't find a finished operation
            time.sleep(1)

    def _we_still_have_work_to_do(self):
        """Determine if we have more work to do or if we should mark ourselves as complete.

        If we have active operations, we always have more work to do. If we have timed out
        then we have no more work to do unless there are still active operations.

        Returns True if we should continue in our processing loop, False if we should exit.
        """
        # obviously, if operations are still running, we still have work to do
        if len(self.active_operations) > 0:
            return True

        # nothing is active and we have timed out, so we have nothing left to
        # do
        if self.timed_out:
            return False

        # no time outs, nothing active, check to see if more work is available
        if len(self.available_operations) > 0:
            return True

        # since nothing is available, we must be done
        return False

    def _has_timed_out(self, start_time, timeout_seconds):
        """Determine if we have timed out based on the start_time in seconds and the timeout.

        Returns True if we have gone over the time limit, False otherwise.
        """
        if timeout_seconds is None:
            return False

        time_diff_seconds = time.time() - start_time

        if time_diff_seconds > timeout_seconds:
            return True

        return False
