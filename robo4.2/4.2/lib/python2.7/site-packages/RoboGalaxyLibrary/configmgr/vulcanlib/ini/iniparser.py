"""
Contains base parser class and constants for all Vulcan configuration files.

"""
import logging
import re
import sys
import ConfigParser


_LOG = logging.getLogger()


class IniParser:

    """Base parser class for all DM configuration files.
    Extend from this class if you have custom configuration requirements for a script.

    Parsers commonly call the has_option() method before reading data out of a ConfigParser
    object. Utility methods are provided to parse common values types supplied by the user
    lists, required options, etc.).
    """

    def parse_time_suffix(self, value):
        """Take a string and use its time suffix (s, m, h) to return an int value in seconds."""
        if re.search("[$a-zA-Z]", str(value)):
            suffix = value[-1]
            suffix = suffix.lower()
            value = re.sub("[^0-9]", "", value)

            if(re.search("s", suffix)):
                value = int(value)
            elif(re.search("m", suffix)):
                value = int(value) * 60
            elif(re.search("h", suffix)):
                value = int(value) * 3600
            elif(re.search("d", suffix)):
                value = int(value) * 3600 * 24
            else:
                _LOG.error(
                    "Unknown suffix sent to time suffix parser:" + suffix)
                sys.exit(1)

        return int(value)

    def parse_int_range_list(self, val):
        """Take a string value for a list of integers and return a list with each entry.

        Input strings should take one of the following forms:
         - 1-5 (dash-separated)
         - 1 2 3 5 6 7 (space separated)
         - 1, 2, 3, 4, 5 (comma separated with a space)
         - 1,2,3,4,5 (comma separated with no space)
         - 1 (just one entry)
        These forms cannot be mixed (don't try: "1-5, 7, 10")

        The returned list will contain only integers, one per item in the specified range.
        """
        items = []
        if "-" in val:
            items = val.split("-")
            items = range(int(items[0]), int(int(items[1]) + 1))
        elif " " in val:
            for item in val.split(" "):
                if len(item.strip()) > 0:
                    items.append(int(item.strip()))
        elif "," in val:
            for item in val.split(","):
                if len(item.strip()) > 0:
                    items.append(int(item.strip()))
        else:
            items.append(int(val))

        return items

    def parse_simple_list(self, val):
        """Take a string value with space or comma separated items and return a list with each entry.

        The returned list will contain strings, one per item.
        """
        items = []
        if "," in val:
            for item in val.split(","):
                if len(item.strip()) > 0:
                    items.append(item.strip())
        elif " " in val:
            for item in val.split(" "):
                if len(item.strip()) > 0:
                    items.append(item.strip())
        else:
            items.append(val)

        return items

    def get_required_option(self, config, section, option):
        """Return the specified option in the specified section or throw an OptionMissingError.

        The OptionMissingError will be thrown whether the value was never specified in the
        .ini file or if the value is blank.
        """
        try:
            val = config.get(section, option)
        except ConfigParser.NoOptionError as err:
            raise OptionMissingError(err.section, err.option)

        if val is None or len(val) == 0:
            raise OptionMissingError(section, option)
        return val

    def get_required_int_range_list(self, config, section, option):
        """Return the specified option as a list or throw an OptionMissingError.

        The OptionMissingError will be thrown whether the value was never specified in the
        .ini file or if the value is blank. This method calls get_required_option() to
        retrieve the value.
        """
        return self.parse_int_range_list(
            self.get_required_option(
                config,
                section,
                option))

    def has_option(self, config, section, option):
        """Determine if the specified option exists in the .ini file or not.

        The option is considered missing if the option is blank.
        """
        if config.has_option(
                section,
                option) and len(
                config.get(
                section,
                option)) > 0:
            return True
        return False


class OptionMissingError(object):

    """Indicates that an option in the .ini file was either not specified or blank."""

    def __init__(self, section, option):
        """Create a new error for the specified option in the specified section of the .ini file."""
        self.section = section
        self.option = option
