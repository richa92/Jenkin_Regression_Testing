import time
import string
import re

# convert_lldp_to_fusion:  Convert LLDP data from the switch to format specified by Fusion API
# Inputs:
# -- comware_dict:  Dictionary of LLDP data to convert
# Outputs:
# -- rtn:  Converted dictionary that can now be used for comparison with LLDP data from Fusion


def convert_lldp_to_fusion(comware_dict):
    if ('0/0/0' in comware_dict):
        # Management port is not reported by Fusion.  Not a server-facing port
        del comware_dict['0/0/0']
    rtn = comware_dict
    # Convert all port names to the last numeric characters in the string for
    # Fusion comparison purposes
    for port in rtn:
        # Special case where we are joining remoteSystemCapabilities(Supported/Enabled) into
        # the same key/variable pair as Fusion expects
        if ('remoteSystemCapabilitiesEnabled' in rtn[port]):
            rtn[port]['remoteSystemCapabilities'] = "enabled=" + \
                rtn[port]['remoteSystemCapabilitiesEnabled']
            del rtn[port]['remoteSystemCapabilitiesEnabled']
        if ('remoteSystemCapabilitiesSupported' in rtn[port]):
            rtn[port]['remoteSystemCapabilities'] += "; supported=" + \
                rtn[port]['remoteSystemCapabilitiesSupported']
            del rtn[port]['remoteSystemCapabilitiesSupported']
        # According to Ted Beckett, all ports will have LLDP "remoteType" =
        # "external"
        rtn[port]['remoteType'] = 'external'
        for k in rtn[port]:
            if (k == 'remoteChassisId' or k == 'remoteMgmtAddress'):
                # \w\w\w\w-\w\w\w\w-\w\w\w\w  converts to \w\w:\w\w:\w\w:\w\w:\w\w:\w\w
                m = re.search(
                    '(\w{2})(\w{2})-(\w{2})(\w{2})-(\w{2})(\w{2})',
                    rtn[port][k])
                if (m):
                    hexList = []
                    for i in range(1, 7):
                        hexList.append(m.group(i))
                    rtn[port][k] = ':'.join(hexList)
            if (rtn[port][k] == 'MAC address'):
                rtn[port][k] = 'macAddress'
            if (rtn[port][k] == 'Locally assigned'):
                rtn[port][k] = 'local'
            if (rtn[port][k] == 'Interface name'):
                rtn[port][k] = 'interfaceName'
    return rtn

# filter_lldp:  Filter LLDP dictionary to return only 1 field per LLDP port.
# Input:
# -- lldp:  dictionary of LLDP port data
# -- filter:  dictionary key to filter on
# Returns:  dictionary with filter key as only field per LLDP port.


def filter_lldp(lldp, filter):
    rtn = dict()
    for port in lldp:
        rtn[port] = dict()
        rtn[port][filter] = lldp[port][filter]
    return rtn

# get_lldp_neighbor_data:  Get the LLDP neighbor data using the Comware CLI
# call : "display lldp neighbor-information verbose"
# LLDP data will be used to populate a dictionary of neighbor port data returned
# to caller.
# Inputs:
# -- lldp_output:  Output from call to Comware switch containing LLDP data
# Returns:
# -- dictionary of LLDP neighbor data from switch


def lldp_output_to_dict(lldp_output):
    '''
    Example LLDP output from command.  Rely on this format to parse the data.
LLDP neighbor-information of port 18[Ten-GigabitEthernet1/0/18]:
LLDP agent nearest-bridge:
 LLDP neighbor index : 1
 Update time         : 19 days, 0 hours, 7 minutes, 3 seconds
 Chassis type        : MAC address
 Chassis ID          : d07e-28ee-cbd7
 Port ID type        : Interface name
 Port ID             : Ten-GigabitEthernet1/0/31
 Time to live        : 120
 Port description    : Ten-GigabitEthernet1/0/31 Interface
 System name         : HP
 System description  : HP Comware Platform Software, Software Version 7.1.045, E
                       SS 2305
                       HP 5900AF-48XG-4QSFP+ Switch
                       Copyright (c) 2010-2013 Hewlett-Packard Development Compa
                       ny, L.P.
 System capabilities supported : Bridge, Router, Customer Bridge, Service Bridge
 System capabilities enabled   : Bridge, Router, Customer Bridge
 Management address type           : All802
 Management address                : d07e-28ee-cc1e
 Management address interface type : IfIndex
 Management address interface ID   : Unknown
 Management address OID            : 0
 Port VLAN ID(PVID)  : 1
 Link aggregation supported : Yes
 Link aggregation enabled   : No
 Aggregation port ID        : 0
 Auto-negotiation supported : Yes
 Auto-negotiation enabled   : Yes
 OperMau                    : Speed(10000)/Duplex(Full)
 Power port class           : PSE
 PSE power supported        : No
 PSE power enabled          : No
 PSE pairs control ability  : No
 Power pairs                : Signal
 Port power classification  : Class 0
 Maximum frame size         : 10000
     '''

    rtn = dict()
    key = ""

    for line in lldp_output.split('\n'):
        m = re.search('LLDP neighbor-information of port \d+\[(\S+)\]', line)
        if (m):
            portName = m.group(1)
            m = re.search('GigabitEthernet([\d\/]+)$', portName)
            if (m):
                rtn[m.group(1)] = dict()
                key = m.group(1)
            else:
                rtn[portName] = dict()
                key = portName
        m = re.search('Chassis ID\s+:\s+([^\r]+)', line)
        if (m):
            chassis = m.group(1)
            rtn[key]['remoteChassisId'] = chassis
        m = re.search('Port description\s+:\s+([^\r]+)', line)
        if (m):
            descPort = m.group(1)
            rtn[key]['remotePortDescription'] = descPort
        m = re.search('Management address\s+:\s+([^\r]+)', line)
        if (m):
            remoteMgmtAddress = m.group(1)
            rtn[key]['remoteMgmtAddress'] = remoteMgmtAddress
        m = re.search('Port ID type\s+:\s+([^\r]+)', line)
        if (m):
            remotePortIdType = m.group(1)
            rtn[key]['remotePortIdType'] = remotePortIdType
        m = re.search('Port ID type\s+:\s+([^\r]+)', line)
        if (m):
            remotePortId = m.group(1)
            rtn[key]['remotePortId'] = remotePortId
        m = re.search('Management address type\s+:\s+([^\r]+)', line)
        if (m):
            remoteMgmtAddressType = m.group(1)
            rtn[key]['remoteMgmtAddressType'] = remoteMgmtAddressType
        m = re.search('System capabilities supported\s+:\s+([^\r]+)', line)
        if (m):
            remoteSystemCapabilitiesSupported = m.group(1)
            rtn[key][
                'remoteSystemCapabilitiesSupported'] = remoteSystemCapabilitiesSupported
        m = re.search('System capabilities enabled\s+:\s+([^\r]+)', line)
        if (m):
            remoteSystemCapabilitiesEnabled = m.group(1)
            rtn[key][
                'remoteSystemCapabilitiesEnabled'] = remoteSystemCapabilitiesEnabled
        m = re.search('Chassis type\s+:\s+([^\r]+)', line)
        if (m):
            remoteChassisIdType = m.group(1)
            rtn[key]['remoteChassisIdType'] = remoteChassisIdType
        m = re.search('System name\s+:\s+([^\r]+)', line)
        if (m):
            remoteSystemName = m.group(1)
            rtn[key]['remoteSystemName'] = remoteSystemName
        m = re.search('System description\s+:\s+([^\r]+)', line)
        if (m):
            remoteSystemDescription = m.group(1)
            rtn[key]['remoteSystemDescription'] = remoteSystemDescription
        m = re.search('Management address\s+:\s+([^\r]+)', line)
        if (m):
            remoteMgmtAddress = m.group(1)
            rtn[key]['remoteMgmtAddress'] = remoteMgmtAddress
    return rtn

if __name__ == '__main__':
    p = config_parser.ConfigParser('testcase\ConfigMgr.xml')
    p.parse_xml()
    p.store_xml_data()
    lista = []
    for net in p.network_switches_list:
        for vlan in net.vlans:
            vlan_dict = vlan.attrib
            vlan_dict['name'] = vlan.tag
            # print vlan_dict
            lista.append(vlan_dict)
    for i in lista:
        untagged_ports = i["UntaggedPorts"]
        vlan_id = i["ID"]
        tagged_ports = i["TaggedPorts"]
        s = SwitchCfg("172.24.92.243", "root", "password", "test", "test")
        s.create_vlan(vlan_id)
