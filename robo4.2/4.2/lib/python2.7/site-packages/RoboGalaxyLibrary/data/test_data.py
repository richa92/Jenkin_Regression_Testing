""" envdata.py - This file contains the classes and methods for importing
    a data source into RobotGalaxy for use with tests.

    As this file creates the data source with a factory method,
    no object instantiation is necessary.

    Usage:
      # xml source example
      import envdata
      data = envdata.get('me1_data.xml')

      This returns an EnvDataObject (see below) which allows the
          representation of the data as a python object.
           i.e.  >>> data.lsts.lst[0].switch[0].bay
                 '1'
"""

from robot.libraries.BuiltIn import BuiltIn
from RoboGalaxyLibrary.utilitylib import logging as logger
from lxml import etree as etree
import os as os
import types


class GlobalProperty(object):

    """
        Global properties allow standardized naming for common variables
        used in RoboGalaxy
    """
    Browser = 'Browser'
    TestData = 'TestData'
    FusionIP = 'FusionIP'
    AltairIP = 'AltairIP'
    BrowserOpened = 'BrowserOpened'
    UiLoggedIn = 'UiLoggedIn'
    SeleniumSpeed = 'SeleniumSpeed'


class DataObj(object):

    def __init__(self):
        self.properties = []  # the list of added properties

    def add_property(self, name, value):
        """ add a property to the object """
        self.properties.append(name)
        setattr(self, name, value)

    def set_property(self, name, value):
        """ Set value for a property """
        setattr(self, name, value)

    def get_property(self, name):
        """ return the value of a set property """
        return getattr(self, name)

    def has_property(self, name):
        return hasattr(self, name)

    def get_properties(self):
        """ return a list of all properties that have been added """
        return self.properties

    def __str__(self):
        """ overload of str for pretty-printing the object """
        ret = ""
        for key in self.properties:
            prop = self.get_property(key)
            if isinstance(prop, list):
                ret += key + ': ' + str(prop)
            else:
                ret += '{0}: {1}\r\n'.format(key, prop)
        return ret

    def __repr__(self):
        """ repr overload for pretty-printing the object """
        return str(self)


class TestData(DataObj):

    """ This class encapsulates the data structure which holds all information
        relevant to testing.  You can use the add_property method to add
        any supported object you want.
    """

    users = None
    var = None
    versions = None
    networkconfigs = None
    users = None
    networks = None
    fcnetworks = None
    networksets = None
    encgroups = None
    enclosures = None
    lsts = None
    spps = None
    servers = None
    profiles = None
    testconfigs = None


def _is_xml_file_exist(file_name):
    file_name = os.path.normpath(file_name)
    if not os.path.exists(file_name):
        exe_dir = get_variable('EXECDIR')
        exe_dir_path = os.path.normpath(
            os.path.join(exe_dir, file_name))
        logger.info(
            "ExeDir is {0}".format(exe_dir))
        logger.info(
            "exe_dir_path is {0}".format(exe_dir_path))
        if os.path.exists(exe_dir_path):
            logger.info(
                "Found {0} in {1}".format(file_name, get_variable('EXECDIR')))
            file_name = exe_dir_path
    if not os.path.exists(file_name):
        raise IOError('Failed to find file "{0}"'.format(file_name))
    file_name = os.path.abspath(file_name)
    extension = os.path.splitext(file_name)[1]
    # if it isn't an xml file
    if extension != '.xml':
        raise NotImplementedError(
            'No handler for file type {0}'.format(extension))
    return file_name


def str2bool(value):
    if isinstance(value, types.BooleanType):
        return value
    else:
        return value.lower() in ('true', "yes", "1")


def load(file_name, eliminate_same_node=True):
    logger.info('')
    eliminate_same_node = str2bool(eliminate_same_node)
    file_name = _is_xml_file_exist(file_name)
    var = get_variable(GlobalProperty.TestData)
    if var is None:
        var = TestData()
    parser = etree.XMLParser(remove_comments=True)
    root_obj = etree.parse(file_name, parser=parser).getroot()
    set_variable("test_data_xml_root_node", root_obj)
    data_obj = __SawXmlDataFactory(
        file_name).xml_to_obj(data_node=var,
                              eliminate_same_node=eliminate_same_node)
    data_obj.add_property("eliminate_same_node", eliminate_same_node)
    set_variable(GlobalProperty.TestData, data_obj)
    logger.info("Loaded {0}".format(file_name))
    return get()


def load_multi_data_files_from_config(config_file_name, eliminate_same_node=True):
    logger.info('')
    eliminate_same_node = str2bool(eliminate_same_node)
    config_file_name = _is_xml_file_exist(config_file_name)
    config_file_dirname = os.path.dirname(config_file_name)
    logger.info("Loading data files from {0}".format(config_file_name))
    parser = etree.XMLParser(remove_comments=True)
    root_obj = etree.parse(config_file_name, parser=parser).getroot()
    if root_obj.tag != 'config':
        raise ValueError('Root node was not <config>')
    if len(root_obj) == 0:
        raise ValueError('No children node found in root node')
    var = get_variable(GlobalProperty.TestData)
    if var is None:
        var = DataObj()
    parent_node_obj = etree.Element('data')
    for child in root_obj.getchildren():
        if child.tag != "file":
            raise ValueError('{0}: Node name was not <file>'.format(child.attrib))
        if "id" not in child.keys():
            raise ValueError("{0}:Couldn't find property:'id'".format(child.attrib))
        if "path" not in child.keys():
            raise ValueError("{0}: Couldn't find property:'path'".format(child.attrib))
        sub_obj_id = child.get("id")
        sub_file = child.get("path")
        if not os.path.isabs(sub_file):
            sub_file = os.path.join(config_file_dirname, sub_file)
        sub_file = _is_xml_file_exist(sub_file)
        sub_file_root_obj = etree.parse(sub_file, parser=parser).getroot()
        for sub_file_child_obj in sub_file_root_obj.getchildren():
            sub_file_child_obj_copy = etree.fromstring(etree.tostring(sub_file_child_obj))
            parent_node_obj.append(sub_file_child_obj_copy)
        set_variable("test_data_xml_%s_node" % sub_obj_id, sub_file_root_obj)
        sub_file_data_obj = __SawXmlDataFactory(
            sub_file).xml_to_obj(eliminate_same_node=eliminate_same_node)
        if sub_obj_id.lower() != "none":
            var.add_property(sub_obj_id, sub_file_data_obj)
        else:
            for one_property in sub_file_data_obj.get_properties():
                var.add_property(one_property, sub_file_data_obj.get_property(one_property))
    var.add_property("eliminate_same_node", eliminate_same_node)
    set_variable(GlobalProperty.TestData, var)
    set_variable("test_data_xml_root_node", parent_node_obj)
    logger.info("Loaded {0}".format(config_file_name))
    return get()


def get():
    return get_variable(GlobalProperty.TestData)


def get_browser_name():
    return get().browser[0].name


def get_data_by_xpath(xpath, obj_id=None, filename=None, eliminate_same_node=True):
    logger.info('')
    if filename is None:
        if obj_id is None:
            xml_root_node = get_variable('test_data_xml_root_node')
        else:
            xml_root_node = get_variable('test_data_xml_%s_node' % obj_id)
    else:
        parser = etree.XMLParser(remove_comments=True)
        xml_root_node = etree.parse(filename, parser=parser).getroot()
    xpath_data = __SawXmlDataFactory(
        xml_root_node=xml_root_node).get_data_by_xpath(xpath=xpath, eliminate_same_node=eliminate_same_node)
    return xpath_data


def get_data_by_property(data_item, *props):
    """ Get data by supplied properties.
        Multiple properties are supported
        Note that props is passed from Robot as a nested tuple.

        Example:  get_data_by_property(data.users, ('name', 'Administrator', 'role', 'Infrastructure administrator')
    """
    # Create a dictionary from the tuple
    prop_dict = dict(zip(props[0][::2], props[0][1::2]))

    # Iterate over the data item looking for the object that contains matching
    # properties.
    ret = [val for val in data_item
           for key, value in prop_dict.items()
           if val.get_property(key) == value]
    return ret


def set_value_for_property(data_obj, prop, value):
    """ update property value.

        Example:  update_data_for_property(data_obj, 'name', 'test')
    """
    data_obj.set_property(prop, value)
    return data_obj


def get_users(prop):
    if get().eliminate_same_node is True:
        return [user for user in get().users if prop]
    else:
        return [user for user in get().users.user if prop]


def get_user_by_name(user_name):
    if get().eliminate_same_node is True:
        ret = [user for user in get().users if user.name == user_name]
    else:
        ret = [user for user in get().users.user if user.name == user_name]
    return ret[0]


def get_test_config(config_name):
    ret = [config for config in
           get().testconfigs if config.name == config_name]
    return ret[0]


def get_enclosures():
    if get().eliminate_same_node is True:
        return get().enclosures
    else:
        return get().enclosures.enclosure


def get_variable(name):
    # logger.info("Getting variable '{0}'".format(name))
    value = BuiltIn().get_variable_value("${%s}" % name)
    if isinstance(value, unicode):
        return value.encode('ascii')
    else:
        return value


def set_variable(name, value):
    if isinstance(value, unicode):
        value = value.encode('ascii')
# logger.info("Setting variable '{0}'".format(name))

    BuiltIn().set_global_variable("${%s}" % name, value)


class __SawXmlDataFactory:

    """ This factory class returns a list of dictionaries that
        correspond to the SAW data file structure
    """

    def __init__(self, file_name=None, xml_root_node=None):
        """ parse the XML file or xml object"""
        if file_name is not None:
            logger.info(
                "Loading {0}".format(file_name))
            parser = etree.XMLParser(remove_comments=True)
            self.root = etree.parse(file_name, parser=parser).getroot()
        elif xml_root_node is not None:
            self.root = xml_root_node
        else:
            raise ValueError('None type for all variables is not acceptable')

        if self.root.tag != 'data':
            raise ValueError('Root node was not <data>')

    def xml_to_obj(self, xml_node=None, data_node=None, eliminate_same_node=True):
        """ Convert SAW XML data to a python object """
        if data_node is None:
            data_node = DataObj()  # create this node object

        # if no xml node was specified, we assume the root as the start
        if xml_node is None:
            xml_node = self.root
        else:  # add the node attributes as properties if they exist
            for key in xml_node.attrib:
                if key not in data_node.properties:
                    data_node.add_property(key, xml_node.attrib[key])

        # get the children of the xml node
        children = xml_node.getchildren()

        if len(children) == 0:  # no children - return the new DataObject
            # data_node.add_property(xml_node.tag, xml_node.value)
            return data_node
        else:  # create the child lists recursively
            # iterate over the list of node tags
            for tag in set([c.tag for c in children]):
                # create a list of the nodes that share the same tag name
                same_tag = [c for c in children if c.tag == tag]

                # If there's only one node with this tag, don't create a list,
                # just add it to this parent recursively
                if len(same_tag) == 1:
                    if len(same_tag[0].getchildren()) == 0:
                        data_node.add_property(
                            tag, [
                                self.xml_to_obj(
                                    xml_node=same_tag[0], eliminate_same_node=eliminate_same_node)])
                    else:
                        # If the child object is a list of the same element,
                        # fold it up as the current object.
                        # This eliminates the need to
                        # index like: users.user[0].name
                        # instead, you can use users[0].name
                        tag = same_tag[0].tag
                        obj = self.xml_to_obj(xml_node=same_tag[0], eliminate_same_node=eliminate_same_node)
                        if (len(obj.get_properties()) == 1) and (eliminate_same_node is True):
                            obj_list = obj.get_property(
                                obj.get_properties()[0])
                            if not isinstance(obj_list, list):
                                obj_list = [obj_list]
                            data_node.add_property(tag, obj_list)
                        else:
                            data_node.add_property(tag, obj)
                # If there are multiple nodes that share the same tag,
                # instantiate them as a list
                else:
                    node_list = []
                    data_node.add_property(tag, node_list)
                    for child in same_tag:  # add the child nodes recursively
                        node_list.append(self.xml_to_obj(child, eliminate_same_node=eliminate_same_node))
        return data_node

    def get_data_by_xpath(self, xml_node=None, xpath=None, eliminate_same_node=True):
        """ Get XML data By Xpath  """
        xpath_result = etree.Element('data')
        # if no xml node was specified, we assume the root as the start
        if xml_node is None:
            xml_node = self.root
        xpath = str(xpath.strip())
        child_nodes = xml_node.xpath(xpath)

        tags = []
        if (child_nodes is None) or (len(child_nodes) == 0):
            logger.warn("Couldn't find data which matched xpath expression '%s'" % xpath)
            return None

        if isinstance(child_nodes, list):
            for child_node in child_nodes:
                child_node_copy = etree.fromstring(etree.tostring(child_node))
                xpath_result.append(child_node_copy)
                if child_node_copy.tag not in tags:
                    tags.append(child_node_copy.tag)
        else:
            child_nodes_copy = etree.fromstring(etree.tostring(child_nodes))
            xpath_result.append(child_nodes_copy)
            tags.append(child_nodes_copy.tag)

        xpath_data = self.xml_to_obj(xml_node=xpath_result, eliminate_same_node=eliminate_same_node)
        for tag in tags:
            if xpath_data.has_property(tag):
                sub_data = xpath_data.get_property(tag)
                if not isinstance(sub_data, list):
                    xpath_data.set_property(tag, [sub_data])

        return xpath_data
