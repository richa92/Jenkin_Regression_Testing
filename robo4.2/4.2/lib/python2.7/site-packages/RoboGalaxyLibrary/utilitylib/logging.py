'''
General Purpose Logging module

'''
from __future__ import absolute_import  # fix name conflict with logging module

from datetime import datetime, timedelta
import types

from robot.api import logger
from robot.libraries.BuiltIn import BuiltIn
from robot.libraries.BuiltIn import RobotNotRunningError

from threading import current_thread, RLock
from multiprocessing import Queue

import logging as _logging
# Since the RF TRACE and WARN levels have no string value in the logging module,
# we need to add at runtime here.
_logging.addLevelName(5, "TRACE")
_logging.addLevelName(_logging.WARN, "WARN")


def _process_msg(message):
    """ Convert the message to a printable string
    """
    return repr(message) if not isinstance(message, types.UnicodeType) and not isinstance(message, types.StringType) else message


def _debug(message):
    """ Log a debug message
    """
    logger.debug(message)


def debug(message, also_console=True, newline=True, time_prefix=True):
    """ Log an informational message
    """
    msg = _process_msg(message)
    logger.debug(msg)
    try:
        level = _logging._checkLevel(BuiltIn().get_variable_value("${LOG LEVEL}", _logging.DEBUG))
    except RobotNotRunningError:
        # if we're not in a Robot context (i.e. unit test), set the level to debug
        level = _logging.DEBUG

    if time_prefix is True:
        msg = "{0} {1}".format(datetime.now().strftime("%H:%M:%S.%f")[:-3], msg)

    if level <= _logging.DEBUG and also_console is True:
        logger.console("[DEBUG] {0}".format(msg), newline)


def _html(message):
    """ Log a HTML message
    """
    logger.info(message, True, False)


def _info(message):
    """ Log an informational message
    """
    info(message)


def _log(message, level='INFO'):
    """ Log a message with level
    """
    level = level.upper()
    if level == 'INFO':
        _info(message)
    elif level == 'DEBUG':
        _debug(message)
    elif level == 'WARN':
        warn(message)
    elif level == 'HTML':
        _html(message)


def _log_list(items, what='item'):
    """ Log a list
    """
    msg = ['Altogether %d %s%s.' %
           (len(items), what, ['s', ''][len(items) == 1])]
    for index, item in enumerate(items):
        msg.append('%d: %s' % (index + 1, item))
        _info('\n'.join(msg))
    return items


def warn(message):
    """ Log a warning to the log and console
    """
    logger.warn(message)


def _warn(message):
    """ Log a warning to the log and console
    """
    warn(message)


def info(message, also_console=True, newline=True, time_prefix=True):
    """ Log an informational message
    """
    msg = _process_msg(message)
    logger.info(msg)
    try:
        level = _logging._checkLevel(BuiltIn().get_variable_value("${LOG LEVEL}", _logging.INFO))
        if time_prefix is True:
            msg = "{0} {1}".format(datetime.now().strftime("%H:%M:%S.%f")[:-3], msg)

        if level <= _logging.INFO and also_console is True:
            logger.console("[INFO] {0}".format(msg), newline)
    except RobotNotRunningError:
        # if we're not in a Robot context (i.e. unit test), set the level to debug
        level = _logging.INFO


def _log_to_console(message):
    """genericlib.function for log message to console"""
    logger.console(message)


def _log_to_console_and_log_file(arg):
    """genericlib.function for log message to file and console"""
    logger.info(arg, also_console=True)


class LogQueue(object):
    """
    RobotFramework logging is supported from 'MainThread' and
    'RobotFrameworkTimeoutThread'. Any log messages from other threads are
    silently ignored. This object stores the messages from other threads in a
    queue and periodically flushes them when 'publish_messages' method is
    called/executed.

    This is a derivative from RobotBackgroundLogger as suggested at
    http://robotframework.org/robotframework/latest/
    RobotFrameworkUserGuide.html#communication-when-using-threads

    Note: publish_message() method should be called where custom keywords use
          threads. It should be done from the main thread
    """
    LOGGING_THREADS = logger.librarylogger.LOGGING_THREADS

    def __init__(self):
        self.q = Queue(-1)
        self.lock = RLock()

    def _write(self, msg, level, also_console=True, html=False):
        """
        Performs logging using Robot API Logger when the calling thread is
        'MainThread' or 'RobotFrameworkTimeoutThread'
        :param str msg: String to be logged
        :param str level: Type of logging
        :param bool also_console: True message is also send to stdout
        :param bool html: True for HTML based logging else False
        :return: None
        """
        html = html and level == 'INFO'
        level = level if not html else 'HTML'

        if current_thread().getName() in self.LOGGING_THREADS:
            logger.write(msg, level, html)
            if also_console:
                _ = datetime.now().strftime("%H:%M:%S.%f")[:-3]
                logger.console('{} [{}] {}'.format(_, level, msg))
        else:
            with self.lock:
                self.q.put({'level': level,
                            'message': msg,
                            'also_console': also_console,
                            'html': html})

    def info(self, msg, also_console=True, html=False):
        """
        Add info message to the queue
        :param str msg: Message to be logged
        :param bool also_console: Default True, message is printed on console
        :param bool html: True if HTML based logging is required
        :return None: None
        """
        if current_thread().getName() not in self.LOGGING_THREADS:
            msg = '[{}] {}'.format(current_thread().getName(), msg)

        self._write(msg, 'INFO', also_console, html)

    def debug(self, msg, also_console=True, html=False):
        """
        Add debug message to the queue
        :param str msg: Message to be logged
        :param bool also_console: Default True, message is printed on console
        :param bool html: True if HTML based logging is required
        :return None: None
        """
        if current_thread().getName() not in self.LOGGING_THREADS:
            msg = '[{}] {}'.format(current_thread().getName(), msg)

        self._write(msg, 'DEBUG', also_console, html)

    def warn(self, msg, also_console=False, html=False):
        """
        Adds a message to the queue with log level as WARN
        :param str msg: Message to be logged
        :param bool also_console: True message is printed on console
        :param bool html: True when logging to HTML file
        :return None: None
        """
        if current_thread().getName() not in self.LOGGING_THREADS:
            msg = '[{}] {}'.format(current_thread().getName(), msg)

        self._write(msg, 'WARN', also_console, html)

    def publish_message(self, timeout=5):
        """
        Publish messages held in the queue to Robot API Logger. This is done for
        said timeout
        :param timeout: Blocking time to publish the message
        :return:
        """
        time_out = datetime.now() + timedelta(seconds=timeout)

        while time_out > datetime.now():
            if self.q.empty():
                break

            with self.lock:
                m = self.q.get()
                self._write(m['message'], m['level'], m['also_console'],
                            m['html'])


# Throttling log generation
LOG = LogQueue()
