"""

Misc genericlib.functions

"""
import re
import subprocess as sp
import paramiko
from datetime import datetime, timedelta
from functools import wraps
from time import sleep
from RoboGalaxyLibrary.utilitylib.logging import LOG as logging
from os.path import expandvars


def run_cmd(command):
    """Run the specified command on the local machine.

    Until the command completes, this method will not return.

    Returns a tuple with the standard output and standard error streams of the command.
    """
    cmd = command
    process = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE, shell=1)

    (stdout, stderr) = process.communicate()
    returncode = process.returncode

    if stderr is not None and re.search("\w", stderr):
        print("cmd:%s returned:%s" % (cmd, stderr))
    else:
        print("Command completed!")
    return stdout, stderr


def run_cmdNonBlk(command):
    """Run the specified command on the remote machine through plink in a background process.

    Once the command has been launched, this method returns immediately with the
    subprocess.Popen() object used to launch it. Call the results_cmdNonBlk() method
    to bring the command into the foreground and get its results.
    """
    cmd = command
    process = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE, shell=1)
    return process


def run_command(command, powershell=False):
    """
    Executes the command either in the Shell or command prompt when PowerShell
    is set to False. When True, the execution of commands or script is carried
    out in the PowerShell environment.

    Execution in PowerShell environment works best when robot is run with
    elevated privileges.
    :param list command: Script/command/s to be executed
    :param bool powershell: True if PowerShell environment is required
    :return dict: {'return_code': , 'output': , 'error': }
    """
    logging.debug('Command:\t{}'.format(' '.join(command)))

    if powershell:
        ps = '%windir%\system32\WindowsPowerShell\\v1.0\powershell.exe'
        cmd = list([expandvars(ps), '-ExecutionPolicy', 'Unrestricted'])
        command = cmd + command
        logging.debug('PowerShell Command:\t{}'.format(' '.join(command)))

    p = sp.Popen(command, stdout=sp.PIPE, stderr=sp.PIPE)
    o, e = p.communicate()
    o = o.strip('\r\n')

    m = 'Return Code: {} \tOutput: {}\tError: {}'.format(p.returncode, o, e)
    logging.debug(m)

    return {'return_code': p.returncode, 'output': o, 'error': e}


def return_command_exit_code(command, timeout=60):
    """
    Executes a blocking CLI command with high amount of stdout content in a
    timely fashion. This enhance's the user to control the timeout
    :param list command: Command/s or script to be executed
    :param int timeout: Default 60 minutes, time in minutes
    :return int: Command/script's exit code
    """
    logging.debug('Command:\t{}'.format(' '.join(command)))

    p = sp.Popen(command, stdout=sp.PIPE, stderr=sp.PIPE)
    time_out = datetime.now() + timedelta(minutes=timeout)

    while time_out > datetime.now():
        if p.poll() is not None:
            logging.info('Process exited with code: {}'.format(p.returncode))
            return p.returncode

        o = p.stdout.readline().strip('\r\n')
        if o:
            logging.debug(o)

    logging.info('Command execution is progress after specified timeout.')
    return -2


def ssh_login(func):
    """SSH Login wrapper for performing remote command execution"""
    @wraps(func)
    def wrap(*args, **kwargs):
        host = kwargs.get('host_ip')
        user = kwargs.get('username')
        passwd = kwargs.get('password')
        port = kwargs.get('port', 22)
        result = dict()

        try:
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(host, port=port, username=user, password=passwd)
            result = func(ssh_client=client, *args, **kwargs)

            client.close()
            return result
        except paramiko.SSHException as e:
            result['error'] = "ERR: Unable to establish connection to host"
            logging.debug(e)
        except IOError as e:
            result['error'] = "ERR: Input/output access violation."
            logging.debug(e)
        except Exception as e:
            result['error'] = e
            logging.debug(e)

        result['status'] = "Failed"
        return result
    return wrap


@ssh_login
def _wait_remote_cmd(**kwargs):
    """
    This method waits for the remote command to complete execution and returns
    a dictionary
    :param kwargs: Refer remote_cmd for supported keywords
    :return: DICT object
    """
    client = kwargs.get('ssh_client')
    _, o, e = client.exec_command(kwargs.get('command'), get_pty=True)

    result = dict()
    result['output'] = '\n'.join([l.strip('\r\n') for l in o.readlines()])
    result['error'] = '\n'.join([l.strip('\r\n') for l in e.readlines()])

    if not result['output'] and not result['error']:
        result['status'] = "Success"
    elif not result['output'] and result['error']:
        result['status'] = "Failed"
    elif result['output'] and not result['error']:
        result['status'] = "Success"
    else:
        result['status'] = "Failed"

    return result


@ssh_login
def _no_wait_remote_cmd(**kwargs):
    """
    This method does not wait for the remote command to complete execution. It
    is best suited for running background processes or long running commands.
    :param kwargs: Refer remote_cmd for supported keywords
    :return: DICT object
    """
    client = kwargs.get('ssh_client')
    s = client.get_transport().open_session()
    logging.debug("Executing {} remotely".format(kwargs.get('command')))
    s.exec_command(kwargs.get('command'))

    # Prevents from early closing
    sleep(5)
    f = s.fileno()
    m = "DEBUG: Command execution initialized. Handle: {}".format(f)
    logging.debug(m)
    s.close()

    return {'status': "Success", 'output': f}


@ssh_login
def _interactive_remote_cmd(**kwargs):
    """
    Enables remote commands to be executed that require inputs to be provided at
    various stages during command execution. The method is a blocking method
    that is waits till the command has completed execution.
    :param kwargs: Refer remote_cmd for supported keywords
    :return: DICT object
    """
    client = kwargs.get('ssh_client')
    s = client.get_transport().open_session()
    s.get_pty()

    timeout = datetime.now() + timedelta(minutes=kwargs.get('timeout', 3))
    interval = kwargs.get('interval', 10)
    input_data = kwargs.get('input_data', '')

    input_len = len(input_data)
    input_ctr = 0
    stdin_data = str()
    stderr_data = str()

    m = "DEBUG: Executing {} remotely.".format(kwargs.get('command'))
    logging.debug(m)
    m = "DEBUG: Inputs passed to the command are: {}".format(input_data)
    logging.debug(m)
    s.exec_command(kwargs.get('command'))

    # Prevents from early reading/writing
    sleep(2)

    while timeout > datetime.now():
        # Read stdout & stdin channels
        if s.recv_ready():
            stdin_data += s.recv(65536)

        if s.recv_stderr_ready():
            stderr_data += s.recv_stderr(65536)

        # The command has executed without inputs
        if s.exit_status_ready():
            # Leaving the caller to determine the status based on exit code
            exit_code = s.recv_exit_status()
            s.close()
            return {'output': stdin_data, 'error': stderr_data,
                    'status': "Unknown", 'exit_code': exit_code}

        # Check and send inputs in sequence
        if s.send_ready():
            if input_len == 0 or input_len < input_ctr:
                m = "ERR: Input required for command execution."
                logging.debug(m)
                s.close()
                return {'output': stdin_data, 'error': m, 'status': "Failed",
                        'exit_code': -1}

            s.send(input_data[input_ctr] + '\n')
            input_ctr += 1

        sleep(interval)

    logging.debug("WARN: Command execution is still in progress")
    s.close()

    return {'output': stdin_data, 'error': stderr_data, 'status': "Failed",
            'exit_code': -1}


def remote_cmd(**kwargs):
    """
    Executes the command on the remote system. The method returns when the
    command has completed execution.
    :param kwargs: Support keys are
                   host_ip -> String, FQDN or IPv4 of the remote host
                   username -> String, username to connect
                   password -> String, password for the above user
                   port -> Int (Optional), by default 22... port to connect
                   block -> bool (Optional), By default waits for completion
                   interactive -> bool (Optional), By default false
                   input_data -> list (Optional), inputs to be passed in
                                  sequence to the command. Required if
                                  interactive is set to True
                   timeout -> int (optional), effective for interactive mode
                   interval -> int (optional), effective for interactive mode
    :return: stdout on success else stderr
    """
    if kwargs.get('interactive', False):
        return _interactive_remote_cmd(**kwargs)
    elif kwargs.get('block', True):
        return _wait_remote_cmd(**kwargs)
    else:
        return _no_wait_remote_cmd(**kwargs)


@ssh_login
def remote_copy(**kwargs):
    """
    Copies a local file to the remote system. Note: destn should be a filename
    :param kwargs: Supported keys are
                   host_ip -> String, FQDN or IPv4 of the remote host
                   username -> String, username to connect
                   password -> String, password for the above user
                   src -> String, absolute path to the source file
                   destn -> String, absolute path to the destination file
                   port -> Int (Optional), by default 22... port to connect
    :return: DICT Object
    """
    client = kwargs.get('ssh_client')
    s = client.open_sftp()

    m = "DEBUG:\nSource: {}\nTarget: {}\n".format(kwargs.get('source'),
                                                  kwargs.get('destn'))
    logging.debug(m)
    r = s.put(kwargs.get('source'), kwargs.get('destn'))

    return {'output': r, 'status': "Success"}


@ssh_login
def remote_get(**kwargs):
    """
    Copies a file from a remote system to the local
    :param kwargs: Supported keys are
                   host_ip -> String, FQDN or IPv4 of the remote host
                   username -> String, username to connect
                   password -> String, password for the above user
                   src -> String, absolute path to the source file
                   destn -> String, absolute path to the destination file
                   port -> Int (Optional), by default 22... port to connect
    :return: DICT object
    """
    client = kwargs.get('ssh_client')
    s = client.open_sftp()

    m = "DEBUG:\nSource: {}\nTarget: {}\n".format(kwargs.get('source'),
                                                  kwargs.get('destn'))
    logging.debug(m)
    s.get(kwargs.get('source'), kwargs.get('destn'))

    return {'output': '', 'status': "Success"}
