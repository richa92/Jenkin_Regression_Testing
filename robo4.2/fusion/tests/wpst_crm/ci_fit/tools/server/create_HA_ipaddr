#!/bin/bash

NETWORK1=192.168
NETWORK2=192.169
NETWORK3=192.170
NETWORK4=192.171
NETWORK5=192.172
NETWORK6=192.173
NETWORK7=192.174
NETWORK8=192.175
NETWORK9=192.176
NETWORK10=192.177
NETWORK11=192.178
NETWORK12=192.179
NETWORK13=192.180
NETWORK14=192.181
NETWORK15=192.182
NETWORK16=192.183
NETWORK17=192.184
NAME="create_HA_ipaddr"
CONF="../conf/HA_ipaddr.conf"
LOG_DIR="/tmp/$NAME"
MGMT_NET="enet-server-mgmt"
set -o pipefail
#set -x

#=============================================================================
# usage 
#=============================================================================
usage()
{
        echo "usage: $0 -vcu <VCM User> -vcip <VCM IP>" 
	echo ""
}

#=============================================================================
# init_host_ipaddr 
# TODO: Had to use a tmp file as the host ip data structure to store the 
#       values of the host ip address for each vlan because of a interesting
#       issue with global arrays.  Writing and reading from a global array
#       between functions worked fine until there was a nested function that
#       updated the array.  
#=============================================================================
init_host_ipaddr()
{
	HOSTIPADDR_FILE=$(mktemp /tmp/$DOMAIN_NAME/HOSTIPADDR.XXXXXXXXXX)
	for((i=0; $i<=4096; i++)); do
		HOSTIPADDR[$i]=254
		echo "${HOSTIPADDR[$i]}" >> $HOSTIPADDR_FILE
	done
}

#=============================================================================
# check_for_conf
#=============================================================================
check_for_conf()
{
	if [ -f $CONF ]; then
		TMP_FILE=$(mktemp HA_ipaddr.XXXXXXXXXX)
		mv $CONF $TMP_FILE
	fi
}
	
#============================================================================= 
# calculate_ipaddr 
# TODO:  See init_host_ipaddr. Would like to remove the tmp file usage for storing
#        the contents of the host ip data 
#=============================================================================
calculate_ipaddr()
{
	local vlan=$1
	local network_ip
	local vlan_offset
	local host_addr
	local ipaddr
	local hostipaddr=(`cat $HOSTIPADDR_FILE`)	


	if [ $vlan -eq 0 ]; then
		network_ip=$NETWORK1
		vlan_offset=$vlan
	fi
	if [ $vlan -ge 1 -a $vlan -le 250 ]; then
		network_ip=$NETWORK1
		vlan_offset=$vlan
	fi
	if [ $vlan -ge 251 -a $vlan -le 500 ]; then
		network_ip=$NETWORK2
		let vlan_offset=$vlan-250
	fi
	if [ $vlan -ge 501 -a $vlan -le 750 ]; then
		network_ip=$NETWORK3
		let vlan_offset=$vlan-500
	fi
	if [ $vlan -ge 751 -a $vlan -le 1000 ]; then
 		network_ip=$NETWORK4
		let vlan_offset=$vlan-750
	fi
	if [ $vlan -ge 1001 -a $vlan -le 1250 ]; then
		network_ip=$NETWORK5
		let vlan_offset=$vlan-1000
	fi
	if [ $vlan -ge 1251 -a $vlan -le 1500 ]; then
		network_ip=$NETWORK6
		let vlan_offset=$vlan-1250
	fi
	if [ $vlan -ge 1501 -a $vlan -le 1750 ]; then
		network_ip=$NETWORK7
		let vlan_offset=$vlan-1500
	fi
	if [ $vlan -ge 1751 -a $vlan -le 2000 ]; then
		network_ip=$NETWORK8
		let vlan_offset=$vlan-1750
	fi
	if [ $vlan -ge 2001 -a $vlan -le 2250 ]; then
		network_ip=$NETWORK9
		let vlan_offset=$vlan-2000
	fi
	if [ $vlan -ge 2251 -a $vlan -le 2500 ]; then
		network_ip=$NETWORK10
		let vlan_offset=$vlan-2250
	fi
	if [ $vlan -ge 2501 -a $vlan -le 2750 ]; then
		network_ip=$NETWORK11
		let vlan_offset=$vlan-2500
	fi
	if [ $vlan -ge 2751 -a $vlan -le 3000 ]; then
		network_ip=$NETWORK12
		let vlan_offset=$vlan-2750
	fi
	if [ $vlan -ge 3001 -a $vlan -le 3250 ]; then
		network_ip=$NETWORK13
		let vlan_offset=$vlan-3000
	fi
	if [ $vlan -ge 3251 -a $vlan -le 3500 ]; then
		network_ip=$NETWORK14
		let vlan_offset=$vlan-3250
	fi
	if [ $vlan -ge 3501 -a $vlan -le 3750 ]; then
		network_ip=$NETWORK15
		let vlan_offset=$vlan-3500
	fi
	if [ $vlan -ge 3751 -a $vlan -le 4000 ]; then
		network_ip=$NETWORK16
		let vlan_offset=$vlan-3750
	fi
	if [ $vlan -ge 4001 -a $vlan -le 4096 ]; then
		network_ip=$NETWORK17
		let vlan_offset=$vlan-4000
	fi
	host_addr=${hostipaddr[$vlan]}
	ipaddr=$network_ip.$vlan_offset.$host_addr
	let host_addr=host_addr-1
	hostipaddr[$vlan]=$host_addr

	rm -f $HOSTIPADDR_FILE
	for((i=0; $i<=4096; i++)); do
		echo "${hostipaddr[$i]}" >> $HOSTIPADDR_FILE
	done

	echo "$ipaddr"
return
}

#=============================================================================
# get_vc_domain_name
#=============================================================================
get_vc_domain_name()
{

	DOMAIN_NAME=$(get_domain_name $VCM_IP)

	if [ -z "$DOMAIN_NAME" ]; then
		echo "`date`: Failed to get the domain name so exiting..." 2>&1 | tee -a $LOG 
		exit 1
	fi

	if [ -d /tmp/$DOMAIN_NAME ]; then
		rm -rf /tmp/$DOMAIN_NAME; mkdir -p /tmp/$DOMAIN_NAME
	else
		mkdir -p /tmp/$DOMAIN_NAME	
	fi
}

#=============================================================================
# create_log 
#=============================================================================
create_log()
{
	local run_time
	local vc_build

	run_time=$(get_date)
	vc_build=$(get_vc_version $VCM_IP)
	vc_build=`echo "$vc_build" | awk '{print $2}'`
	if [ -z "$run_time" -o -z "$vc_build" ]; then
		echo "run time is $run_time"
		echo "vc build is $vc_build"
        	echo "`date`: WARNING - Failed to get the date or VC build version so exiting..."
        	exit -1
	else
        	mkdir -p $LOG_DIR/$vc_build/$NAME-$run_time/
        	LOG="$LOG_DIR/$vc_build/$NAME-$run_time/$NAME.log"
	fi
}

#=============================================================================
# get_profiles
#=============================================================================
get_profiles()
{
	local profile

	PROFILE_FILE=$(mktemp /tmp/$DOMAIN_NAME/profile.XXXXXXXXXX)
	show_profile $VCM_IP | tee $PROFILE_FILE
	PROFILES=(`grep Name $PROFILE_FILE | awk 'BEGIN{FS="="} {print $NF}'`)

	for profile in "${PROFILES[@]}"
	do
		mkdir -p /tmp/$DOMAIN_NAME/$profile
	done
}
#=============================================================================
# get_profile_connections
#=============================================================================
get_profile_connections()
{
	local profile
	local profile_conn_file
	local enet_conn_file
	local num_enet_conn

	for profile in "${PROFILES[@]}"
	do
		profile_conn_file=$(mktemp /tmp/$DOMAIN_NAME/$profile/profile_conn.XXXXXXXXXX)
		show_profile $VCM_IP $profile | tee $profile_conn_file
		num_enet_conn=`cat $profile_conn_file | grep "Connection Type=Ethernet" | wc -l`
		for conn in $(eval echo {1..$num_enet_conn})
		do
			enet_conn_file=$(mktemp /tmp/$DOMAIN_NAME/$profile/enet.XXXXXXXXXX)
			show_enet-connection $VCM_IP $profile:$conn | tee $enet_conn_file
		done
		
	done
}
#=============================================================================
# get_server_port_map
# Call show server-port-map to determine the server profile:port to network mappings.
# ID=Server_01:1
# Network=net_001,net_002,net_003, 
#=============================================================================
get_server_port_map()
{
	local profile

	SERVER_PORT_MAP_FILE=$(mktemp /tmp/$DOMAIN_NAME/server_port_map.XXXXXXXXXX)
	show_server_port_map $VCM_IP | tee $SERVER_PORT_MAP_FILE
}

#=============================================================================
# get_networks
# Call show network to get the network to VLAN ID mappings.
# Name=net_001
# Status=OK
# Shared Uplink Set=BigPipe_01
# VLAN ID=1
#=============================================================================
get_networks()
{
	NETWORK_FILE=$(mktemp /tmp/$DOMAIN_NAME/network.XXXXXXXXXX)
	show_network $VCM_IP | tee $NETWORK_FILE
}

#=============================================================================
# getVLANforTunnel
#=============================================================================
getVLANforTunnel()
{
	local profile=$1
	local bay 
	local vlan

	bay=`cat $PROFILE_FILE | grep -A 1 "$profile" | grep "Device Bay" | cut -d ":" -f 2`

	if [ "$bay" == "1" -o "$bay" == "2" -o "$bay" == "9" -o "$bay" == "10" ]; then
		vlan="1001"
	elif [ "$bay" == "3" -o "$bay" == "4" -o "$bay" == "11" -o "$bay" == "12" ]; then
		vlan="1000"
	elif [ "$bay" == "5" -o "$bay" == "6" -o "$bay" == "13" -o "$bay" == "14" ]; then
		vlan="999"
	elif [ "$bay" == "7" -o "$bay" == "8" -o "$bay" == "15" -o "$bay" == "16" ]; then
		vlan="998"
	else
		vlan="UNKNOWN"
	fi

	echo "$vlan"

}

#=============================================================================
# getVLAN 
#=============================================================================
getVLAN()
{
	local network=$1
	local vlan

	vlan=`cat /tmp/$DOMAIN_NAME/network* | grep -A 6 -m 1 $network | grep "VLAN ID" | awk 'BEGIN{FS="="} {print $NF}'`
	if [ "$vlan" == "-- --" ]; then
		vlan="None"
	fi
	echo "$vlan"
}

#=============================================================================
# iSvlanTunnel 
#=============================================================================
iSvlanTunnel()
{
	local network=$1
	local isTunnel 
	
	isTunnel=`cat $NETWORK_FILE | grep -A 10 "$network" | grep "VLAN Tunnel" | awk 'BEGIN{FS="="} {print $NF}'`
	
	if [ "$isTunnel" = "Enabled" ]; then
		isTunnel="Yes"
	else
		isTunnel="No"
	fi
	
	echo "$isTunnel"	
}

#=============================================================================
# write_HA_ipaddr
#=============================================================================
write_HA_ipaddr()
{
	local profile

	for profile in "${PROFILES[@]}"
        do
		get_portmapping $profile
		bind_devices $profile
        done

}

#=============================================================================
# print_param 
#=============================================================================
print_param()
{
	local profile_port=$1
	local port_map=$2
	local bind_port_map=$3
	local network=$4
	local mac=$5
	local serial_number=$6
	local bind_mac
	local profile
	local ipaddr
	local vlan
	local bind_mac
	local bind_network
	local bind_vlan
	local bind_profile_port
	local port_mapping_file
	local is_net_tunnel
	local is_bind_net_tunnel
	local -a network_params

	profile=`echo $profile_port | awk 'BEGIN{FS=":"} {print $NR}'`
	port_mapping_file=`ls /tmp/$DOMAIN_NAME/$profile/ | grep -m 1 "port_mapping"`

	bind_mac=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "$bind_port_map" | awk '{print $3}'`
	bind_network=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "$bind_port_map" | awk '{print $4}'`
	bind_profile_port=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "$bind_port_map" | awk '{print $1}'`

	#-------------------------------------------------------------------------
        # Unassigned Networks 
        #-------------------------------------------------------------------------
	if [ "$network" == "<Unassigned>" -o "$bind_network" == "<Unassigned>" ]; then
		return
	fi

	#-------------------------------------------------------------------------
        # MGMT_NET
        #-------------------------------------------------------------------------
	if [ "$network" == "$MGMT_NET" -o "$bind_network" == "$MGMT_NET" ]; then
		return
	fi

	#-------------------------------------------------------------------------
        # Multiple Networks 
        #-------------------------------------------------------------------------
	if [ "$network" == "Multiple" -a "$bind_network" == "Multiple" ]; then
        	network_params=(`get_multiple_network_ips "$network_params" $profile_port $bind_profile_port`)
		for param in ${network_params[@]}
		do
			ipaddr=`echo $param | awk 'BEGIN{FS=","} {print $NR}'`
			vlan=`echo $param | awk 'BEGIN{FS=","} {print $NF}'` 
			echo "$profile $port_map $mac $bind_port_map $bind_mac $vlan $ipaddr $serial_number"  2>&1 | tee -a $CONF
		done
		return
	fi

	is_net_tunnel=$(iSvlanTunnel $network)
	is_bind_net_tunnel=$(iSvlanTunnel $bind_network)
	echo "network $network, is_net_tunnel $is_net_tunnel"
	echo "bind_network $bind_network, is_bind_net_tunnel $is_bind_net_tunnel"

	#-------------------------------------------------------------------------
        # Same Networks 
        #-------------------------------------------------------------------------
	if [ "$network" == "$bind_network" -a "$network" != "Multiple" -a "$is_net_tunnel" = "No" ]; then
		vlan=$(getVLAN $network)
		if [ "$vlan" == "None" ]; then
                	vlan=0
                fi
         	ipaddr=$(calculate_ipaddr $vlan)
		if [ "$vlan" = "0" ]; then
			echo "$profile $port_map $mac $bind_port_map $bind_mac $ipaddr $serial_number"  2>&1 | tee -a $CONF
		else
			echo "$profile $port_map $mac $bind_port_map $bind_mac $vlan $ipaddr $serial_number"  2>&1 | tee -a $CONF
		fi
		return
	fi

	#-------------------------------------------------------------------------
        # Different Networks but same VLANs
        #-------------------------------------------------------------------------
	if [ "$network" != "$bind_network" -a "$is_net_tunnel" = "No" ]; then
		vlan=$(getVLAN $network)
		bind_vlan=$(getVLAN $bind_network)
		if [ "$vlan" = "$bind_vlan" -a "$vlan" != "None" -a "$bind_vlan" != "None" ]; then
         		ipaddr=$(calculate_ipaddr $vlan)
			echo "$profile $port_map $mac $bind_port_map $bind_mac $ipaddr $serial_number"  2>&1 | tee -a $CONF
		fi
		return
	fi

	#-------------------------------------------------------------------------
        # Tunnel Networks 
        #-------------------------------------------------------------------------
	if [ "$is_net_tunnel" = "Yes" -a "$is_bind_net_tunnel" = "Yes" ]; then
		vlan=$(getVLANforTunnel $profile)
		ipaddr=$(calculate_ipaddr $vlan)
		echo "$profile $port_map $mac $bind_port_map $bind_mac $vlan $ipaddr $serial_number"  2>&1 | tee -a $CONF
	fi
}

#=============================================================================
# tokenize_port_map
# Seperate the port map string into the following tokens
#
# Type = 1GBE_LOM  Type = FLEX_LOM  Type = 1GBE_MEZZ  Type = FLEX_MEZZ
# LOM:<Port>       LOM:<Port-PF>    MEZZ<Slot>:<Port> MEZZ<Slot>:<Port>-<PF>
# 0 - Type         0 - Type         0 - Type          0 - Type
# 1 - Port         1 - Port         1 - Slot	      1 - Slot
#                  2 - PF           2 - Port          2 - Port
#                                                     3 - PF
#=============================================================================
tokenize_port_map()
{
	local port_map=$1
	local tokens=(`echo "$2"`)

	echo "$port_map" | grep "LOM" >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		echo "$port_map | grep -e \"-a\" -e \"-b\" -e \"-c\" -e \"-d\"" >/dev/null 2>&1
		if [ $? -eq 0 ]; then
			tokens[0]="FLEX_LOM"
			tokens[1]=`echo "$port_map" | awk 'BEGIN{FS=":"} {print $NF}' | awk 'BEGIN{FS="-"} {print $NR}'`
			tokens[2]=`echo "$port_map" | awk 'BEGIN{FS=":"} {print $NF}' | awk 'BEGIN{FS="-"} {print $NF}'`
		else
			tokens[0]="1GBE_LOM"
			tokens[1]=`echo "$port_map" | awk 'BEGIN{FS=":"} {print $NF}'` 
			
		fi
	else
		echo "$port_map" | grep "MZ" >/dev/null 2>&1
		if [ $? -eq 0 ]; then
			echo "$port_map | grep -e \"-a\" -e \"-b\" -e \"-c\" -e \"-d\"" >/dev/null 2>&1
			if [ $? -eq 0 ]; then
				tokens[0]="FLEX_MEZZ"
				tokens[1]=`echo "$port_map" | sed "s/MZ//" | awk 'BEGIN{FS=":"} {print $NR}'` 
				tokens[2]=`echo "$port_map" | sed "s/MZ//" | awk 'BEGIN{FS="-"} {print $NR}' | awk 'BEGIN{FS=":"} {print $NF}'` 
				tokens[3]=`echo "$port_map" | sed "s/MZ//" | awk 'BEGIN{FS="-"} {print $NF}'`
			else
				tokens[0]="1GBE_MEZZ"
				tokens[1]=`echo "$port_map" | sed "s/MZ//" | awk 'BEGIN{FS=":"} {print $NR}'` 
				tokens[2]=`echo "$port_map" | sed "s/MZ//" | awk 'BEGIN{FS=":"} {print $NF}'`
			fi
		fi
	fi
	
	echo "${tokens[@]}"
}

#=============================================================================
# bind_devices 
#=============================================================================
bind_devices()
{
	local profile=$1
	local port_mapping_file
	local profile_conn_file
	local port_map
	local profile_port
	local mac
	local network
	local vlan
	local ipaddr
	local bind_port
	local bind_pf
	local bind_port_map
	local bind_mac
	local bind_network
	local bind_profile_port
	local odd_port
	local -a tokens=( EMPTY )

	port_mapping_file=`ls /tmp/$DOMAIN_NAME/$profile/ | grep -m 1 "port_mapping"`
	profile_conn_file=`ls /tmp/$DOMAIN_NAME/$profile/ | grep -m 1 "profile_conn"`
	
	while read line
	do
		profile_port=`echo "$line" | awk '{print $1}'`
		port_map=`echo "$line" | awk '{print $2}'`
		mac=`echo "$line" | awk '{print $3}'`
		network=`echo "$line" | awk '{print $4}'`
		tokens=(`tokenize_port_map $port_map "$tokens"`)
		serial_number=`cat /tmp/$DOMAIN_NAME/$profile/$profile_conn_file | grep "Serial Number (Logical)" | awk 'BEGIN{FS="="} {print $NF}'` 
		
		#-------------------------------------------------------------------------
                # LOMs 
                #-------------------------------------------------------------------------

		if [ "${tokens[0]}" = "1GBE_LOM" -o "${tokens[0]}" = "FLEX_LOM" ]; then
			odd_port=`expr ${tokens[1]} % 2` 
			if [ $odd_port -eq 0 ]; then
				#--------------------------------------------------------------------
				# Only bind odd ports to even ports - LOM1->LOM2 or LOM3:1-a->LOM4:1a
				# Don't bind LOM2->LOM3
				#--------------------------------------------------------------------
				continue;
			fi

		        #-------------------------------------------------------------------------
                        # 1GbE LOM  
                        #-------------------------------------------------------------------------

			if [ "${tokens[0]}" = "1GBE_LOM" ]; then
				bind_port=${tokens[1]}
				let bind_port=bind_port+1
				bind_port_map=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "LOM:$bind_port" | awk '{print $2}'`
				if [ "$bind_port_map" == "" ]; then
					echo "`date`: Profile $profile does not have a port to bind for $port_map so continuing..." 2>&1 | tee -a $LOG 
					continue;
				else
					print_param $profile_port $port_map $bind_port_map $network $mac $serial_number
				fi
			fi
				
		        #-------------------------------------------------------------------------
                        # Flex LOM  
                        #-------------------------------------------------------------------------

			if [ "${tokens[0]}" = "FLEX_LOM" ]; then
				bind_port=${tokens[1]}
				let bind_port=bind_port+1
				bind_pf=${tokens[2]}
				bind_port_map=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "LOM:$bind_port-$bind_pf" | awk '{print $2}'`
				if [ "$bind_port_map" == "" ]; then
					echo "`date`: Profile $profile does not have a port to bind for $port_map so continuing..." 2>&1 | tee -a $LOG 
					echo "cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file, LOM:$bind_port-$bind_pf"
					continue;
				else
					print_param $profile_port $port_map $bind_port_map $network $mac $serial_number
				fi
		
			fi

		#-------------------------------------------------------------------------
                # Mezz  
                #-------------------------------------------------------------------------

		elif [ "${tokens[0]}" = "1GBE_MEZZ" -o "${tokens[0]}" = "FLEX_MEZZ" ]; then 
			odd_port=`expr ${tokens[1]} % 2` 
			if [ $odd_port -eq 0 ]; then
				#----------------------------------------------------------------------------
				# Only bind odd ports to even ports - MEZZ1:1->MEZZ2:1 or MEZZ3:1-a->MEZZ4:1a
				# Don't bind MEZZ2:2->MEZZ3:2
				#----------------------------------------------------------------------------
				continue;
			fi

		        #-------------------------------------------------------------------------
                        # 1GbE Mezz  
                        #-------------------------------------------------------------------------

			if [ "${tokens[0]}" = "1GBE_MEZZ" ]; then
				bind_port=${tokens[2]}
				let bind_port=bind_port+1
				bind_port_map=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "MZ${tokens[1]}:$bind_port" | awk '{print $2}'`
				if [ "$bind_port_map" == "" ]; then
					echo "`date`: Profile $profile does not have a port to bind for $port_map so continuing..." 2>&1 | tee -a $LOG 
					continue;
				else
					print_param $profile_port $port_map $bind_port_map $network $mac $serial_number
				fi
			fi

		        #-------------------------------------------------------------------------
                        # Flex Mezz  
                        #-------------------------------------------------------------------------

			if [ "${tokens[0]}" = "FLEX_MEZZ" ]; then
                                bind_port=${tokens[2]}
				let bind_port=bind_port+1
                                bind_pf=${tokens[3]}
                                bind_port_map=`cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file | grep "MZ${tokens[1]}:$bind_port-$bind_pf" | awk '{print $2}'`
                                if [ "$bind_port_map" == "" ]; then
                                        echo "`date`: Profile $profile does not have a port to bind for $port_map so continuing..." 2>&1 | tee -a $LOG
					echo "cat /tmp/$DOMAIN_NAME/$profile/$port_mapping_file, MZ${tokens[1]}:$bind_port-$bind_pf"
                                        continue;
                                else
					print_param $profile_port $port_map $bind_port_map $network $mac $serial_number
                                fi
                        fi
		fi

	done </tmp/$DOMAIN_NAME/$profile/$port_mapping_file

}

#=============================================================================
# get_multiple_network_ips 
#=============================================================================
get_multiple_network_ips()
{
	local network_params=(`echo "$1"`) 
	local params_idx=0
	local profile_port=$2
	local bind_profile_port=$3
	local vlan
	local bind_vlan
	local ipaddr
	local -a profile_port_nets
	local -a bind_profile_port_nets

	profile_port_nets=(`grep -A 1 -w $profile_port $SERVER_PORT_MAP_FILE | grep Network | awk 'BEGIN{FS="="} {print $NF}' |  sed 's/,/ /g'`)
	bind_profile_port_nets=(`grep -A 1 -w $bind_profile_port $SERVER_PORT_MAP_FILE | grep Network | awk 'BEGIN{FS="="} {print $NF}' |  sed 's/,/ /g'`)

	for net in "${profile_port_nets[@]}"
	do
		vlan=$(getVLAN $net)
		for bind_net in "${bind_profile_port_nets[@]}"
		do
			bind_vlan=$(getVLAN $bind_net)
			if [ "$vlan" == "$bind_vlan" ]; then
				ipaddr=$(calculate_ipaddr $vlan)
				network_params[$params_idx]="$ipaddr,$vlan"
				let params_idx=params_idx+1
			fi
		done

	done
	
	echo "${network_params[@]}"
}

#=============================================================================
# filter_portmap 
#
# Filter the portmap for each connection so that the mapping is consistent.
# The mapping could be displayed in two different forms - 
#
# LOM:1-a
# LOM1:1-a 
#=============================================================================
filter_portmap()
{
	port_map=$1

	for lom_port in {1..8}	
	do
		port_map=`echo $port_map | sed s"/LOM$lom_port/LOM/"`
	done

	echo "$port_map"

}
#=============================================================================
# get_portmapping
#=============================================================================
get_portmapping()
{
	local profile_1=$1
	local -a enet_connections
	local port_mapping_file
	local port_mapping_file_tmp
	local port
	local port_map
	local mac
	local network

	enet_connections=(`ls /tmp/$DOMAIN_NAME/$profile_1/ | grep "enet"`)
	if [ ${#enet_connections[@]} -gt 0 ]; then
		port_mapping_file=$(mktemp /tmp/$DOMAIN_NAME/$profile_1/port_mapping.XXXXXX)
		for connection in "${enet_connections[@]}"
		do
			port=`cat /tmp/$DOMAIN_NAME/$profile_1/$connection | grep -m 1 "Port" | awk 'BEGIN{FS="="} {print $NF}'`
			port_map=`cat /tmp/$DOMAIN_NAME/$profile_1/$connection | grep -m 1 "Port Mapping" | awk 'BEGIN{FS="="} {print $NF}'`
			port_map=$(filter_portmap $port_map)
			mac=`cat /tmp/$DOMAIN_NAME/$profile_1/$connection | grep "MAC Address" | awk 'BEGIN{FS="="} {print $NF}'`
			mac=`echo $mac | sed 's/-/:/g'`
			network=`cat /tmp/$DOMAIN_NAME/$profile_1/$connection | grep "Network Name" | awk 'BEGIN{FS="="} {print $NF}'`
			if [ "$port" = "" -o "$port_map" = "" -o "$mac" = "" -o "$network" = "" ]; then
        			echo "`date`: WARNING - Failed to get port mapping data so exiting..."
				exit -1
			else
				echo "$profile_1:$port $port_map $mac $network" 2>&1 | tee -a $port_mapping_file 	
			fi
		done
		port_mapping_file_tmp=$(mktemp /tmp/$DOMAIN_NAME/$profile_1/port_mapping.XXXXXX)
		cat $port_mapping_file | sort +1 -2 > $port_mapping_file_tmp
		rm -f $port_mapping_file
	fi
}

####################################################################################
# Get the VCM username and IP address from the command line.  There is not any error
# checking so the user should ensure that the VCM username name and IP are correct.  
####################################################################################

while [ -n "$(echo $1 | grep '-')" ]; do
	case $1 in
	-vcu ) VCM_USER=$2
	       shift ;;
	-vcip ) VCM_IP=$2
	       shift ;;
        * ) usage 
	    exit 1
	esac
	shift
done

if [ -z "$VCM_USER" -o -z "$VCM_IP" ]; then 
	usage
	exit 1
fi

# Load the OA and VC and IP functions
if [ -f ../lib/OA_functions ] && [ -f ../lib/VC_functions ]; then
	. ../lib/OA_functions
	. ../lib/VC_functions
else
	echo "`date`: Library functions not found so exiting..." 2>&1 | tee -a $LOG 
	exit 1
fi

check_for_conf
create_log
get_vc_domain_name 
init_host_ipaddr
get_profiles
get_profile_connections
get_server_port_map
get_networks
write_HA_ipaddr


