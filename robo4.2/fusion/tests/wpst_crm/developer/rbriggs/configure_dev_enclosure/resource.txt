*** Settings ***
Library				RoboGalaxyLibrary
Library				FusionLibrary
Library				OperatingSystem
Library				BuiltIn
Library				Collections
Library				XML
Library				String
Library             json

#Variables 		    C:\\rg-fusion\\fusion\\tests\\wpst_crm\\ci_fit\\config\\I13\\data_variables.py
#Variables 		    data_variables.py

#Variables 		    response_validation.py
						

*** Variables ***
#${X-API-VERSION}							199
#${X-API-VERSION}							${null}

#${APPLIANCE_IP}                 15.199.229.190
${APPLIANCE_IP}                 15.199.201.72
${VM}							HPOneView-DCS_2.00.00_21242
#${DATAFILE}                    C:\\rg-fusion\\fusion\\tests\\wpst_crm\\developer\\rbriggs\\configure_dev_enclosure\\data.xml
${DATAFILE}                    C:\\rg-fusion\\fusion\\tests\\wpst_crm\\feature_tests\\fcoe\\data-fcoe.xml
${JSON}                    C:\\rg-fusion\\fusion\\tests\\wpst_crm\\developer\\rbriggs\\configure_dev_enclosure\\eth.json


*** Keywords ***
#######################################
# SETUP WORFLOWS - Variables
#######################################
Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	Log to console and logfile  	Adding LICENSES	
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	Log to console and logfile  	Adding USERS	
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding ETHERNET NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FC NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FCoE NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding NETWORK SETS	
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}			
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}
	Log to console and logfile  	Adding RANGES	
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
	\ 	${resp} =	Run Keyword If 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range		body=${range}		
	[Return]	${resp}

Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILES	
	:FOR	${profile}	IN	@{profiles}
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri 
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1	
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri 
	\	@{words} = 	Split String	${enc}	:
	\	${type} = 	Get From List	${words}	0
	\	${enc} = 	Get From List	${words}	1	
	\	${uri} = 	Get Enclosure Group URI	${enc}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}	
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	Wait For Task	${resp}		timeout=5 mins		interval=10s

Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	:FOR	${connection}	IN	@{connections}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1	
	\	${net} = 	Create List	${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\ 	#${uri} = 	Run Keyword If 	'${functionType}' == 'FibreChannel'	Get FC URIs			${net}
	\ 	#...			ELSE IF			'${functionType}' == 'Ethernet'		Get Ethernet URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Set to Dictionary	${connection}	networkUri	${uri}
	[Return]	${connections}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'GENERATED'	Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'GENERATED'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'GENERATED'	Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'GENERATED'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'GENERATED'	Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'GENERATED'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument
	[Arguments]	${list}	${keyword}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}	${x}
		
#######################################
# COMMON KEYWORDS
#######################################
Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	#Set Log Level	TRACE
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-network
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\	Wait For Task	${resp}

Delete fcoe range
	[Documentation]	Deletes a range of FCoE networks based on range data provided
	[Arguments]	${range}
	#Set Log Level	TRACE
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${resp} = 	Fusion Api Delete Fcoe Network	name=${range['prefix']}${x}${range['suffix']}

Get Enclosure URI
	[Arguments]		${enc}
	${resp} = 	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Enclosure Group URI
	[Arguments]		${eg}
	${resp} = 	Fusion Api Get Enclosure Groups	
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}		
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${eg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri	
	[Return]	${uri}

Get Ethernet URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}
	
Get Ethernet URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}	

Get FC URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}
	
Get FCoE URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Fcoe Networks		param=?filter="'name'=='${net}'"
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Network Set URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Server Hardware URI
	[Arguments]		${enc_server}
	${resp} = 	Fusion Api Get Server Hardware
	${shlist} = 	Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} = 	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} = 	Get From dictionary 	${sh}	uri
	[Return]	${uri}

Log to console and logfile
	[Arguments]	${data}
	Log	${data}
	Log to console	${data}
	
Wait For Task
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate	${resp}
	[Return]	${task}
	
Task Reached Endstate
	[Arguments]	${resp}
	Set Log Level	TRACE
	Should Contain	${resp}	uri
	${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)	
	[Return]	${task}

Wait For Appliance To Be Ready
	[Documentation]	Waits for an appliance reach a the ready state
	[Arguments]		${appliance}	${timeout}=20 min	${interval}=30 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance Reached Ready State	${appliance}	

Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	Log to console and logfile 		Pinging: ${appliance} ...
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance is pingable 	${appliance}	

Appliance is pingable
	[Arguments]		${appliance}
	Set Log Level	TRACE
	${rc} = 	Run and return rc 	ping ${appliance}		
	Log to console and logfile 		return code: ${rc} ...
	Should be equal as integers 	${rc}	1
	
Appliance Reached Ready State
	[Arguments]		${appliance}
	${state} = 	Fusion Api Get Resource		${appliance}/controller-state.json
	Log to console and logfile	-Appliance state: ${state['state']}
	Should Match Regexp	${state['state']}	((?i)OK)
	
First Time Setup
	[Documentation]	Changes intial administrator password, answers EULA, enables service access, adds licenses, configures appliance interfaces.
	...	If args are null, uses XML ${DATAFILE}
	[Arguments]	${DATAFILE}=${null}	${password}=${null}	${interfaces}=${null}
	#${password} =	Set Variable	${password}
	Log to console and logfile	[FIRST TIME SETUP]
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}		
	Wait For Appliance To Be Ready			${APPLIANCE_IP}
	Log to console and logfile	-Agree to EULA	
	Fusion Api Save EULA	${APPLIANCE_IP}
	Log to console and logfile	-Enable service access
	Fusion Api Set service access	${APPLIANCE_IP}

	#Run Keyword If	${password} is ${null}	Change Initial Administrator Password From Xml	${APPLIANCE_IP}	${DATAFILE}
	${req} = 		Create Dictionary		newPassword=${password}
	...										oldPassword=admin
	...										userName=Administrator
	#Run Keyword If	${password} is not ${null}	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	
	#Run Keyword If	${licenses} is ${null}	Add Licenses From Xml							${DATAFILE}
	#Run Keyword If	${licenses} is not ${null}	Fusion Api Add license						${licenses}
	#Run Keyword If	${appliance} is ${null}	Configure Interfaces From Xml				${DATAFILE}
	#Run Keyword If	${appliance} is not ${null}	Fusion Api Configure Interfaces			${appliance}
	Add licenses from variable		${licenses}
	Configure Appliance Interfaces	
	
Configure Appliance Interfaces
	Log to console and logfile	-Configuring Appliance Interfaces, Time, Locale
	${resp} =	Fusion Api Get Appliance Interface Mac	eth0
	Set to dictionary	${appliance['applianceNetworks'][0]}	macAddress	${resp}	
	${ipv4Type} = 		Get From Dictionary 	${appliance['applianceNetworks'][0]}	ipv4Type
	${app1Ipv4Addr} = 	Get From Dictionary	${appliance['applianceNetworks'][0]}	app1Ipv4Addr
	Sleep 	10s			
	${resp} = 	Fusion Api Configure Appliance Interfaces			${appliance}
	# if STATIC, get new IP and login 
	Run Keyword If	'${ipv4Type}' == 'STATIC'	Set New IP and Login	${app1Ipv4Addr}
	Wait For Task	${resp}		timeout=200s		interval=5s
	${resp} = 	Fusion Api Configure Appliance Time and Locale			${timeandlocale}
	Wait For Task	${resp}		timeout=200s		interval=5s
	
Set New IP and Login
	[Arguments]	${IP}
	Set Suite Variable		${APPLIANCE_IP}	${IP}
	Sleep 	60s	
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	
Login all users
	[Arguments] ${users}
	Set Log Level	TRACE
	:FOR	${user}	IN	@{users}
	\	${user_and_pass} = 	Create Dictionary	userName=${user['userName']}	password=${user['password']}
	\	Login User	${user}

#######################################
# TEARDOWN WORFLOWS
#######################################
Suite Teardown
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[TEARDOWN]
	#
	#Power off ALL Servers
	#Remove All Server Profiles
	#Remove ALL Enclosures
	#Remove ALL Enclosure Groups
	#Remove ALL LIGs
	#Remove ALL Ethernet Networks
	#Remove ALL FC Networks
	#Remove ALL FCoE Networks	
	#Remove ALL Network Sets
	#Remove Users

Remove All Enclosures
	[Documentation]	Querys the appliance for all Enclosures and then removes them
	Log to console and logfile  	Removing ENCLOSURES	
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} = 	Fusion Api Remove Enclosure		uri=${enc['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	10s

Remove All Enclosure Groups
	[Documentation]	Querys the appliance for all Enclosure Groups and then removes them
	Log to console and logfile  	Removing ENCLOSURE GROUPS	
	${encs} = 	Fusion Api Get Enclosure Groups
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} = 	Fusion Api Delete Enclosure Group		uri=${enc['uri']}

Remove All Ethernet Networks
	[Documentation]	Querys the appliance for all Ethernet networks and then removes them
	Log to console and logfile  	Removing ETHERNET NETWORKS	
	${networks} = 	Fusion Api Get Ethernet Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Ethernet Network		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All FC Networks
	[Documentation]	Querys the appliance for all FC networks and then removes them
	Log to console and logfile  	Removing FC NETWORKS	
	${networks} = 	Fusion Api Get FC Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FC Network		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All FCoE Networks
	[Documentation]	Querys the appliance for all FCoE networks and then removes them
	Log to console and logfile  	Removing FCoE NETWORKS	
	${networks} = 	Fusion Api Get FCoE Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FCoE Network		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All LIGs
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console and logfile  	Removing LIGS	
	${ligs} = 	Fusion Api Get LIG
	:FOR	${lig}	IN	@{ligs['members']}
	\		${resp} = 	Fusion Api Delete LIG		uri=${lig['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All Network Sets
	[Documentation]	Querys the appliance for all Network Sets and then removes them
	Log to console and logfile  	Removing NETWORK SETS	
	${networks} = 	Fusion Api Get Network Sets
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Network Set		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Power off ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them off
	Log to console and logfile  	Powering off SERVERS	
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	5s
	
Remove All Server Profiles
	[Documentation]	Querys the appliance for all Server Profiles and then removes them
	Log to console and logfile  	Removing SERVER PROFILES	
	${profiles} = 	Fusion Api Get Server Profiles
	:FOR	${profile}	IN	@{profiles['members']}
	\		${resp} = 	Fusion Api Delete Server Profile		uri=${profile['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	10s
	
Remove All Users
	[Documentation]	Querys the appliance for all Users and then removes them
	Log to console and logfile  	Removing USERS	
	${users} = 	Fusion Api Get Users
	:FOR	${user}	IN	@{users['members']}
	\		Continue For Loop If	'${user['userName']}'=='Administrator' 	
	\		Continue For Loop If	'${user['userName']}'=='administrator' 	
	\		${resp} = 	Fusion Api Delete User		uri=${user['uri']}
		
#######################################
# VALIDATION
#######################################
New Validate Response
    [Documentation]	Validates data in a response body against expected values using REGEX
    ...	looks up ${validation_code} in codes dicitonary
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation_code}
	Set Log Level	TRACE
	${validation} = 	Get From Dictionary	${codes}	${validation_code}
	${validation_results} = 	Fusion Api Validate Response	${resp}	${validation}
	# Log results	
	# Fail if results['passed'] is False
	[Return]	${validation_results}
	
Validate Response
    [Documentation]	Validates data in a response body against expected values
    ...	Example:
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE	
	${response} = 	Copy Dictionary	${resp}	
	@{vkeys} =	Get Dictionary Keys	${validation}
	${rkeys} =	Get Dictionary Keys	${response}
	@{keys} =	Remove all the keys in response that are not in validation	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{keys}
	\	Remove From Dictionary	${response}	${x}
	Dictionaries Should Be Equal	${validation}	${response}	msg=Response does not match validation dictionary	values=True
    
Remove all the keys in response that are not in validation
	[Arguments]	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{vkeys}
	\	Remove Values From List	${rkeys}	${x}
	[Return]	${rkeys}
	