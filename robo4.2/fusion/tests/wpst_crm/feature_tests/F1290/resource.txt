*** Settings ***
Library			RoboGalaxyLibrary
Library			FusionLibrary
Library			OperatingSystem
Library			BuiltIn
Library			Collections
Library		        SSHLibrary
Library			String

Variables		${DATA}								
#Variables		errors.py
#Variables		licenses.py
Variables		data_variables.py

*** Variables ***
${APPLIANCE_IP}     ${None}
${DATA}			data_variables.py
${VM}			${None}
${VMSETUP}		no
${FTS}			no
${CONFIGURE}		no
${None}		None

*** Keywords ***
#######################################
# SETUP WORFLOWS - Variables
#######################################
Get Logical Downlink from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${downlinkuri}
	
	
	${resp} = 	Fusion Api Get Logical Downlink		uri=${downlinkuri['enclosureTypeUri']}
	
	${li_downlink} =	Copy Dictionary		${li_downlink}
    Log to console and logfile		${li_downlink['module1']}
	${l} = 	Get Length	${resp['members']}
	
	
	:FOR	${x}	IN RANGE	0	${l}		
	\	@{words} = 	Split String	${resp['members'][${x}]['name']}	(
	\	${type} = 	Get From List	${words}	1
	\	Log to console and logfile	FFFF ${type}
	\	${Data}      Set Variable    ${resp['members'][${x}]}
	\	Log to console and logfile	FFFF1 ${li_downlink['module1']}
	\	Run keyword if	'${type}' == '${li_downlink['module1']}'	Exit For Loop
	Log to console and logfile		pppppppppppppppppppppppppp
	Log to console and logfile		${Data['downlinkPortCapability']['downlinkSubPorts']}
	Log to console and logfile		pppppppppppppppppppppppppp
	Log to console and logfile		${li_downlink['Ports']}
	Dictionaries Should Be Equal	${Data['downlinkPortCapability']['downlinkSubPorts']}	${li_downlink['Ports']}	msg=Response does not match validation dictionary	values=True
	
	Log to console and logfile  	AAAAAA
	Log to console and logfile		completed
	[Return]	${resp}
	
Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	Log to console and logfile  	Adding LICENSES	
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}
	\		Run keyword if 		${resp['status_code']} != ${201}	    Log     Error adding License Key:${license['key']}   WARN

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	Log to console and logfile  	Adding USERS	
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding ETHERNET NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FC NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FCOE NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding NETWORK SETS	
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}		
	\		${nativeNetworkUri} = 	Run Keyword If 	'${net['nativeNetworkUri']}' != 'None'		Get Ethernet URI	${net['nativeNetworkUri']}
	\		Set To Dictionary 	${net}	nativeNetworkUri	${nativeNetworkUri}		
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}
	Log to console and logfile  	Adding RANGES	
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
	\ 	${resp} =	Run Keyword If 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range		body=${range}		
	[Return]	${resp}

Process InterconnectMapTemplate
	[Arguments]		${icmap}
	${l} = 	Get Length	${icmap['interconnectMapEntryTemplates']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	${permittedInterconnectTypeUri} = 	Get Interconnect Type URI	${permittedInterconnectTypeUri}
	\	Set to dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri		${permittedInterconnectTypeUri}
	[Return]	${icmap}

Add LIG from variable
	[Documentation]	Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ligx}
	#Log to console and logfile  	Adding LIG ${ligx['name']}
	
	${ligx} = 	Copy Dictionary	${ligx}
	#Log to console and logfile	${ligx}
    ${name} =                       Get Variable Value  ${ligx['name']}
    #Log to console and logfile	${name}
	${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
	${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
	${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
	${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
	${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
	${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
	#${uplinkSets} = 	Copy List	${ligx['uplinkSets']}
	#Log to console and logfile	${uplinkSets}
	${l} = 	Get Length	${uplinkSets}
	#Log to console and logfile	${l}
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}
	
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	    ${networkUris}
	\   ${nativeNetworkUri} = 	Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri	${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}	nativeNetworkUri     ${nativeNetworkUri}
	#Log to console and logfile	${ethernetUris}
    # Process Internal URIs
	${internalNetworkUris} = 	Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris	${internalNetworkUris}
	#Log to console and logfile	${internalNetworkUris}
	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}

	${resp} = 	Fusion Api Create LIG	${body}
	#log to console  resp in func is:${resp}
	${task} =	Wait For Task1	${resp} 	60s	20s
	#Log to console and logfile	${task}
	${liguri} = 	Get From Dictionary	${task['associatedResource']}	resourceUri		
	[Return]	${resp}

Add Enclosure Group from variable
	[Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${enc_group}
	#Log to console and logfile		${enc_group['name']}
	#Log to console and logfile		${enc_group}
	#Log to console and logfile  	Adding ENCLOSURE GROUP ${enc_group['name']}
	${l} = 	Get Length	${enc_group['interconnectBayMappings']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${liguri} = 	Get From Dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
	\   Continue For Loop If    '${liguri}' == 'None'
	\	${liguri} = 	Common URI Lookup by name    ${liguri}
	\	Set to dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}	
	${resp} =	Fusion Api Create Enclosure Group	${enc_group}
	[Return]	${resp}

Common URI lookup by name
	[Documentation]	Takes a string containing URI type + : + resource name, performs a lookup and returns URI
	...				Ex:    ${uri} = 	Common Lookup by name	LIG:LIG1
	[Arguments]		${uri}
	@{words} = 	Split String	${uri}	:
	${type} = 	Get From List	${words}	0
	${name} = 	Get From List	${words}	1
	${uri} = 	Run Keyword If 	'${type}' == 'EG'		Get Enclosure Group URI		${name}
	...         ELSE IF         '${type}' == 'ENC'		Get Enclosure URI		    ${name}
	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URI			${name}
	...			ELSE IF			'${type}' == 'FC'		Get FC URI					${name}
	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URI				${name}
	...			ELSE IF			'${type}' == 'LI'		Get LI URI					${name}
	...			ELSE IF			'${type}' == 'LIG'		Get LIG URI					${name}
	...			ELSE IF			'${type}' == 'NS'		Get Network Set URI			${name}
	...			ELSE IF			'${type}' == 'SH'		Get Server Hardware URI		${name}
	...			ELSE IF			'${type}' == 'US'		Get Uplink Set URI			${name}
	...			ELSE IF			'${type}' == 'LSG'		Get LSG URI					${name}
	...		    ELSE IF			'${type}' == 'switchype'    Get lsgs Member					${name}
	...			ELSE			Set variable			ResourceTypeNotFound:${type}

	[Return]	${uri}

Add Enclosures from variable
	[Documentation]	Adds Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${encs}
	#Log to console and logfile  	Adding ENCLOSURES
	:FOR	${enc}	IN	@{encs}
	\	${encuri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	\	${encuri} = 	Common URI Lookup by name    ${encuri}
	\	Set to dictionary	${enc}	enclosureGroupUri		${encuri}
	\	${resp} =	Fusion Api Add Enclosure 	${enc}
	\	${task} =	Wait For Task1	${resp} 	15min	20s
	[Return]    ${resp}

Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}
	Log to console and logfile  	Adding LOGICAL ENCLOSURE

	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri

	${eguri} = 	Common URI Lookup by name    ${eguri}

    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris

	Set to dictionary	${enc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
    \   Log to Console  \ninside for is ${encuri}
	\   ${encuri} = 	Common URI Lookup by name    ${encuri}
	\   Append to List	${encuri_list}	${encuri}
    Log to Console  \nencuri_list is ${encuri_list} 
	Set to dictionary   ${enc}  enclosureUris   ${encuri_list}
    Log to Console  \nenc ${enc}
	${resp}     Fusion Api Create Logical Enclosure 	${enc}
	#${task} = ${resp} 	120min	1min
    ${task} =	Wait For Task1	${resp} 	120min	1min
    #${task}     ${resp}		120min		1min
    Log to Console  \ntask ${task} 
    [Return]    ${resp}
	

Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILES	
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	Log to console and logfile	${profile}
	\	Log to console and logfile	aaaa111
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	Log to console and logfile	${shuri}
	\	Log to console and logfile	aaaa
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	Log to console and logfile	${uri}
	\	Log to console and logfile	bbbb111
	\	Log to console and logfile	${profile}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	Log to console and logfile	${eg}
	\	Log to console and logfile	bbbb
	\	${uri} = 	Common URI Lookup by name    ${eg}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	Log to console and logfile	cccc
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri
	\	Log to console and logfile	${enc} 
	\	${uri} = 	Common URI Lookup by name    ${enc}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}
	\	Log to console and logfile	dddd
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	Log to console and logfile	${connections}
	\	Log to console and logfile	eeeeeee
	\	${connections} = 	Lookup Connection Uris	${connections}
	\	Log to console and logfile	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	Log to console and logfile	ggggg
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	Log to console and logfile	${resp}
	\	Log to console and logfile	ooooo
	\	${task} =   Wait For Task	${resp}		timeout=13 mins		interval=10s
	\	Log to console and logfile	iiiiiii
	\	Log to console and logfile	${task}
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\	Log to console and logfile	${task}
	\	Log to console and logfile	ffff
	\	Log to console and logfile	${task}
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)

Add Server Profile Templates from variable
	[Documentation]	Adds Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILE TEMPLATES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	${sht} = 	Get from Dictionary	${profile}	serverHardwareTypeUri
	\	${uri} = 	Common URI lookup by name		${sht}
	\	Set to Dictionary	${profile}	serverHardwareTypeUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	${uri} = 	Common URI Lookup by name	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile template		body=${profile}
	\   # TODO: Change timeout!
	\	${task} =   	${resp}		timeout=1 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)


Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	${conns} =  Create List
	:FOR	${connection}	IN	@{connections}
	\   ${connection} =     Copy dictionary     ${connection}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1	
	\	${net} = 	Create List	${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Set to Dictionary	${connection}	networkUri	${uri}
	\   append to list  ${conns}    ${connection}
	[Return]	${conns}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable ALL Generated ID Ranges
	[Documentation]	Enables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Enable Generated VSN Range	${rangeUri}

Enable Generated VMAC Range
	[Documentation]	Enables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VWWN Range
	[Documentation]	Enables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VSN Range
	[Documentation]	Enables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword as user
	[Documentation]		Runs a Fusion_API keyword as a particular user.
	...					Ex:		Run Keyword As User		nat		Fusion Api Get Ethernet Networks	${empty}	param=?filter="'name'=='net_101'"
    [Arguments]     ${user}     ${keyword}      @{varargs}
    ${original_user} =   Fusion Api Get Active user
	${active_sessions} = 	Fusion Api Get Active Sessions
	Dictionary Should Contain Key	${active_sessions}	${user}
    Fusion Api Switch Active User   ${user}
    ${resp} =   Run Keyword and continue on failure     ${keyword}  @{varargs}
    Fusion Api Switch Active User   ${original_user}
    [Return]    ${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument
	[Arguments]	${list}	${keyword}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}	${x}
		
#######################################
# COMMON KEYWORDS
#######################################
Build LIG body
	[Arguments]		${xlig}
	${xlig} = 	Copy Dictionary	${xlig}
	${uplinkSets} = 	Copy List	${xlig['uplinkSets']}
	${l} = 	Get Length	${uplinkSets}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	${name} =                       Get Variable Value  ${xlig['name']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
	${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
	${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
	${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	#${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
    [Return]    ${body}

Build US body
	[Arguments]		${us}	${li_uri}
	Set to dictionary	${us}	logicalInterconnectUri	${li_uri}
	${l} = 	Get Length	${us['portConfigInfos']}
	:FOR	${x}	IN RANGE	0	${l}
	\   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}	enclosure
	\   ${enc_uri} =        Get Enclosure Uri   ${enc_uri}
	\	Set To Dictionary		${us['portConfigInfos'][${x}]}	enclosure	${enc_uri}

	# process eth
	${networks} = 		Get From Dictionary		${us}	networkUris
	${networkUris} = 	Get Ethernet Uris	${networks}
	Set to dictionary	${us}	networkUris	${networkUris}
	# process fc
	${networks} = 		Get From Dictionary		${us}	fcNetworkUris
	${networkUris} = 	Get FC Uris	${networks}
	Set to dictionary	${us}	fcNetworkUris	${networkUris}
	# process fcoe
	${networks} = 		Get From Dictionary		${us}	fcoeNetworkUris
	${networkUris} = 	Get FCoE Uris	${networks}
	Set to dictionary	${us}	fcoeNetworkUris	${networkUris}

	${body} = 		Fusion Api Create Uplink Set Payload	${us}
	[Return]	${body}



Create Network Set range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding NETWORK SET RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end
	${netlist} = 	Create List
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Append To List	${netlist}	${range['prefix']}${x}${range['suffix']}
	${networkUris} = 	Get Ethernet URIs	${netlist}
	Set To Dictionary 	${body}	networkUris	${networkUris}
	${nativeNetworkUri} = 	Run Keyword If 	'${range['nativeNetworkUri']}' != 'None'  Get Ethernet URI	${range['nativeNetworkUri']}
	Set To Dictionary 	${body}	nativeNetworkUri	${nativeNetworkUri}
	${resp} = 	Fusion Api Create Network Set		body=${body}
	[Return]	${resp}

Create Ethernet range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding ETHERNET NETWORK RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end

	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Set To Dictionary 	${body}	name	${range['prefix']}${x}${range['suffix']}
	\	Set To Dictionary 	${body}	vlanId	${x}
	\	${resp} = 	Fusion Api Create Ethernet Network	body=${body}

Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding FCOE NETWORK RANGES
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-network
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\		${resp}

Get connectionTemplateUri
	[Documentation]	Retrieves the connectionTemplateUri from a given network {name} of a given {type} where:
	...             {name} is the name of the network
	...             {type} is the type of network: [ethernet, fc, fcoe], default=ethernet
	...             Returns: connectionTemplateUri string
	[Arguments]		${name}   ${type}=ethernet
    Set Log Level	DEBUG
    ${param} =      Set Variable    ?filter="'name'=='${name}'"
	${net} =		Run Keyword If          '${type}' == 'ethernet'      Fusion Api Get Ethernet Networks    param=${param}
	...             ELSE IF                 '${type}' == 'fc'            Fusion Api Get fc Networks          param=${param}
    ...             ELSE IF                 '${type}' == 'fcoe'          Fusion Api Get fcoe Networks        param=${param}
    ...             ELSE                    Log     Invalid network type specified for 'Get connectionTemplateUri'     WARN
	${ct_uri} =     Get From Dictionary      ${net['members'][0]}    connectionTemplateUri

    [Return]    ${ct_uri}

Get Enclosure URI
	[Arguments]		${enc}
	${resp} = 	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Enclosure Group URI
	[Arguments]		${eg}
	#Log to console and logfile	Get Enclosure Group Uri
	${resp} = 	Fusion Api Get Enclosure Groups
	#Log to console and logfile	${resp}
	#Log to console and logfile	encl members
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}		
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${eg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get Ethernet URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Network Set URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}
	
Get Ethernet URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}	

Get FC URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FC URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get FCoE URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FCoE Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FCoE URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Fcoe Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get IC URI
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Get Interconnect Type URI
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect Types 		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LI member
	[Arguments]		${li}
	${resp} = 	    Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${member} = 	Get From List		${resp['members']}  ${x}
	[Return]	${member}

Get LI URI
	[Arguments]		${li}
	${resp} = 	Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LS URI
	[Arguments]		${ls}
	${resp} = 	Fusion Api Get Ls
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${ls}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LSG URI
	[Arguments]		${lsg}
	${resp} = 	Fusion Api Get Lsg
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${lsg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get Switch URI
    [Arguments]		${sw}
	${resp} = 	Fusion Api Get Switch
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${sw}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LIG member
	[Arguments]		${lig}
	${resp} = 	    Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${member} = 	Get From List		${resp['members']}  0
	[Return]	${member}

Get LIG URI
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Get Network Set URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Resource by URI
	[Documentation]    Returns any type of resource using its URI
	[Arguments]	${uri}   @{varargs}
    ${resp} =     Fusion Api Get Resource    ${uri}    @{varargs}
	[Return]    ${resp}

Get Scope URI

    [Arguments]		${scope}
	${resp}     Fusion Api Get Scope		param=?filter="'name'=='${scope}'"
	${l} =     Get Length    ${resp['members']}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${scopename} =  Get Variable value        ${resp['members'][${x}]}
	\   Run Keyword If     '${scopename['name']}' != '${scope}'        Continue For Loop
    \   ${uri} =     Get From Dictionary        ${resp['members'][${x}]}    uri
	[Return]	${uri}

Get Server Hardware URI
	[Arguments]		${enc_server}
	${resp} = 	Fusion Api Get Server Hardware
	${shlist} = 	Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} = 	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} = 	Get From dictionary 	${sh}	uri
	[Return]	${uri}

Get Server Hardware Type URI
	[Arguments]		${sht}
	Set Log Level	TRACE
	${resp} = 	Fusion Api Get Server Hardware Types    param=?filter="'name'=='${sht}'"
	${uri} = 	Get From dictionary 	${resp['members'][0]}	uri
	[Return]	${uri}


Get Uplinkset URI
	[Arguments]		${us}
	${resp} = 	Fusion Api Get Uplink Set 		param=?filter="'name'=='${us}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Log to console and logfile
	[Arguments]	${data}     ${level}=INFO
	Log	${data}     ${level}
	Log to console	${data}


Wait For Task
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate	${resp}
	[Return]	${task}

Task Reached Endstate
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}

Wait For Appliance To Be Ready
	[Documentation]	Waits for an appliance reach a the ready state
	[Arguments]		${appliance}	${timeout}=20 min	${interval}=30 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance Reached Ready State	${appliance}	

Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	Log to console and logfile 		Pinging: ${appliance} ...
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance is pingable 	${appliance}	

Appliance is pingable 
	[Arguments]		${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	Windows ping	${appliance}
	...	ELSE	Unix ping	${appliance}

Unix ping
	[Arguments]		${host}
    ${Output}=    Run    ping -c 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
	[Return]	${Output}
	
Windows ping
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    TTL=
	[Return]	${Output}
		
Appliance Reached Ready State
	[Arguments]		${appliance}
	${state} = 	Fusion Api Get Resource		${appliance}/controller-state.json
	Log to console and logfile	-Appliance state: ${state['state']}
	Should Match Regexp	${state['state']}	((?i)OK)
	
First Time Setup
	[Documentation]	Changes intial administrator password, answers EULA, enables service access, adds licenses, configures appliance interfaces.
	...	If args are null, uses XML ${DATAFILE}
	[Arguments]	${DATAFILE}=${null}	${password}=${null}	${interfaces}=${null}
	#${password} =	Set Variable	${password}
	Log to console and logfile	[FIRST TIME SETUP]
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}		
	Wait For Appliance To Be Ready			${APPLIANCE_IP}
	Log to console and logfile	-Agree to EULA	
	Fusion Api Save EULA	${APPLIANCE_IP}
	Log to console and logfile	-Enable service access
	Fusion Api Set service access	${APPLIANCE_IP}

	${req} = 		Create Dictionary		newPassword=${password}
	...										oldPassword=admin
	...										userName=Administrator
	#Run Keyword If	${password} is not ${null}	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	#Add licenses from variable		${licenses}
	Configure Appliance Interfaces	
	
Configure Appliance Interfaces
	Log to console and logfile	-Configuring Appliance Interfaces, Time, Locale
	${resp} =	Fusion Api Get Appliance Interface Mac	eth0
	Set to dictionary	${appliance['applianceNetworks'][0]}	macAddress	${resp}	
	${ipv4Type} = 		Get Variable Value 	${appliance['applianceNetworks'][0]['ipv4Type']}
	${app1Ipv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['app1Ipv4Addr']}
    ${virtIpv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['virtIpv4Addr']}
	Sleep 	10s			
	${resp} = 	Fusion Api Configure Appliance Interfaces			${appliance}
	# if STATIC, get new IP and login. for 2.00, use virtIpv4Addr (Tbird), otherwise use app1Ipv4Addr
    Run Keyword If	'${virtIpv4Addr}' is not 'None'     			Set New IP and Login	${virtIpv4Addr}
	...             ELSE IF     '${app1Ipv4Addr}' is not 'None'     Set New IP and Login	${app1Ipv4Addr}
	...             ELSE    Log     Either app1Ipv4Addr or virtIpv4Addr must be provided in the 'appliance' variable in your data file     WARN

		${resp}		timeout=200s		interval=5s
	${resp} = 	Fusion Api Configure Appliance Time and Locale			${timeandlocale}
		${resp}		timeout=200s		interval=5s
	
Set New IP and Login
	[Arguments]	${IP}
	Set Suite Variable		${APPLIANCE_IP}	${IP}
	Sleep 	60s	
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	
Login all users
	[Arguments]     ${users}
	Set Log Level	TRACE
	${original_user} =    Fusion Api Get Active User
	:FOR	${user}	IN	@{users}
	\	${user_and_pass} = 	Create Dictionary	userName=${user['userName']}	password=${user['password']}
	\	Fusion Api Login Appliance 		${APPLIANCE_IP}		${user_and_pass}
	Fusion api switch active user    user=${original_user}


# -----------------------------------------------------------------------------
#   EM KEYWORDS
# -----------------------------------------------------------------------------
Get EM IP
	Set Log Level	TRACE
    # Get EM IP
    # TODO:  going to need to see how this works with multiple EM's
    ${EM_IP} =  Execute SSH Command     lldpcli show neighbors
    ${m}    ${EM_IP} =  Should Match Regexp     ${EM_IP}    (?im)MgmtIP:\\s*(\\S*:\\S*:\\S*:\\S*:\\S*:\\S*)
    Set Suite Variable    ${EM_IP}
    log to console     EM IP: ${EM_IP}
    [Return]    ${EM_IP}

Get EM Enclosures
    # Get EM enclosures
    ${EM_ENCS} =   Execute SSH Command     /ci/bin/tbird/appliance-hal.sh list-enclosures
    @{ignore last} =     Split to lines  ${EM_ENCS}  ${null}   -1
    ${EM_ENCS} =        Create List     @{ignore last}
    Set Suite Variable    ${EM_ENCS}
    log to console     Enclosures: ${EM_ENCS}
    [Return]    ${EM_ENCS}

Get EM Token
    [Arguments]     ${enc_serial}
    # Get EM token
    ${EM_TOKEN} =  Execute SSH Command     /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${enc_serial} -o token
    ${EM_TOKEN}    Should Match Regexp    ${EM_TOKEN}    (?i)\\S*
    Set Suite Variable    ${EM_TOKEN}   ${EM_TOKEN}
    log to console     EM TOKEN: ${EM_TOKEN}
    [Return]    ${EM_TOKEN}

Get EM Sessions
    # Get Sessions using session Id to test that everything is working
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Output}    Execute SSH Command
    ...    curl -ikX GET https://${EM_IP}%${FUSION_NIC}/rest/v1/Sessions -H ${Header}
    Should Contain    ${Output}    "Name": "Sessions Collection"
    ...    msg=Get Sessions action failed \n${Output}

EFuse ICM
    [Documentation]    Perform an efuse action on a ICM bay. Action = EFuseOff | EFuseOn
    [Arguments]    ${Action}    ${BayNumber}
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Data}      Set Variable    {"Action":"${Action}"}
	Log to console and logfile  	\t Issuing ${Action} for ICM:${BayNumber}
    ${Output}    Execute SSH Command
    ...    curl -ikX POST -H ${Header} --data-ascii '${data}' https://${EM_IP}%${FUSION_NIC}/rest/v1/InterconnectBays/${BayNumber}
    Should Contain    ${Output}    { "Action": "${Action}" }
    ...    msg=EFuse action failed \n${Output}

IC reached state
	[Arguments]	    ${uri}  ${state}
	Set Log Level	TRACE
    ${resp} =   fusion api get resource     ${uri}
	Log to console and logfile  	\t ${uri}: ${resp['state']}
	Should Match Regexp 	${resp['state']}    ${state}
	[Return]	${resp}

Get IC
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	${l} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${ICM_MODEL}'		Continue For Loop
	\   Append to list      ${ic_list}  ${ic}
	[Return]    ${ic_list}

Get from IC
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}

# -----------------------------------------------------------------------------
#   FUSION BASH SHELL INTERFACE KEYWORDS
# -----------------------------------------------------------------------------
Login to Fusion via SSH
    [Documentation]             Connect to Fusion VM Bash via SSH
    ...                         Example:\n| Login to Fusion Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}=${FUSION_IP}      ${USERNAME}=${FUSION_SSH_USERNAME}
    ...                         ${PASSWORD}=${FUSION_SSH_PASSWORD}    ${PROMPT}=${FUSION_PROMPT}
    ...                         ${TIMEOUT}=${FUSION_TIMEOUT}    ${ALIAS}=Fusion_SSH
    Log Many                    ${IP}                   ${USERNAME}     ${PASSWORD}     ${PROMPT}   ${TIMEOUT}
    Set Default Configuration   prompt=${PROMPT}        timeout=${TIMEOUT}
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    [Return]                    ${Id}

Logout of Fusion Via SSH
    [Documentation]     Exits the current Bash SSH session
    ...                 Example:\n| Logout Of Fusion Via SSH |
    Close Connection

Execute SSH Command
    [Documentation]     Executes given command on the Fusion SSH shell
    ...                 Example:\n| Execute CLI Command | show enclosure list |
    [Arguments]         ${Command}      ${PROMPT}=${FUSION PROMPT}
    Login to Fusion via SSH
    SSHLibrary.Write    ${Command}
    ${Output}=          Read until      ${PROMPT}
    Logout of Fusion Via SSH
    [Return]            ${Output}


#######################################
# TEARDOWN WORKFLOWS
#######################################
Suite Teardown
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[TEARDOWN]
	
	Run Keyword If All Tests Passed    Power off ALL Servers
	Run Keyword If All Tests Passed    Remove All Server Profiles
	Run Keyword If All Tests Passed    Remove ALL Enclosures
	Run Keyword If All Tests Passed    Remove ALL Enclosure Groups
	Run Keyword If All Tests Passed    Remove ALL LIGs
	Run Keyword If All Tests Passed    Remove ALL LS
	Run Keyword If All Tests Passed    Remove ALL LSGs
	Run Keyword If All Tests Passed    Remove ALL Ethernet Networks
	Run Keyword If All Tests Passed    Remove ALL FC Networks
	Run Keyword If All Tests Passed    Remove ALL FCoE Networks
	Run Keyword If All Tests Passed    Remove ALL Network Sets
	Run Keyword If All Tests Passed    Remove ALL Users
	Run Keyword If All Tests Passed    Remove ALL Scopes

Remove All Enclosures
	[Documentation]	Querys the appliance for all Enclosures and then removes them
	Log to console	Removing ENCLOSURES	
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} =   Fusion Api Remove Enclosure		uri=${enc['uri']}
	\		${task} =   Wait For Task1  ${resp}     2 minutes 40 seconds
	\       ${val} =       Create Dictionary   taskState=Completed
	\       ${result} =    Validate Response    ${task}	${val}

Remove All Enclosure Groups
	[Documentation]	Querys the appliance for all Enclosure Groups and then removes them
	Log to console      Removing ENCLOSURE GROUPS
	${encs} = 	Fusion Api Get Enclosure Groups
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} =   Fusion Api Delete Enclosure Group		uri=${enc['uri']}
	#\       Log to console  ${resp}
	#\       ${task} =  Wait For Task  ${resp}     240s    30s

Remove All Ethernet Networks
	[Documentation]	Querys the appliance for all Ethernet networks and then removes them
	Log to console	Removing ETHERNET NETWORKS	
	${networks} = 	Fusion Api Get Ethernet Networks
	:FOR	${net}	IN	@{networks['members']}
	\		Log to console	\n-Removing: ${net['name']}
	\		${resp} = 	Fusion Api Delete Ethernet Network		uri=${net['uri']}
	\		${task} =   Wait For Task   ${resp} 	240s	2s

Remove All FC Networks
	[Documentation]	Querys the appliance for all FC networks and then removes them
	Log to console	Removing FC NETWORKS	
	${networks} = 	Fusion Api Get FC Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FC Network		uri=${net['uri']}
	\		${task} =   Wait For Task   ${resp} 	240s	2s

Remove All FCoE Networks
	[Documentation]	Querys the appliance for all FCoE networks and then removes them
	Log to console	Removing FCoE NETWORKS	
	${networks} = 	Fusion Api Get FCoE Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} =   Fusion Api Delete FCoE Network		uri=${net['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	2s

Remove All LIGs
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console	Removing LIGs
	${ligs} = 	Fusion Api Get LIG
	:FOR	${lig}	IN	@{ligs['members']}
	\		${resp} =   Fusion Api Delete LIG		uri=${lig['uri']}
	\		${task} =   Wait For Task       ${resp} 	240s	2s

Remove All LS
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console	Removing LS
	${lsw} = 	Fusion Api Get Ls
	:FOR	${ls}	IN	@{lsw['members']}
	\		${resp} =   Fusion Api Delete LS		uri=${ls['uri']}
	\		${task} =   Wait For Task       ${resp} 	240s	2s

Remove All LSGs
	[Documentation]	Querys the appliance for all LSGs and then removes them
	Log to console	Removing LSGs
	${lsgs} = 	Fusion Api Get Lsg
	:FOR	${lsg}	IN	@{lsgs['members']}
	\		${resp} =   Fusion Api Delete Lsg		uri=${lsg['uri']}
	#\		${task} =   Wait For Task       ${resp} 	240s	2s

Remove All Network Sets
	[Documentation]	Querys the appliance for all Network Sets and then removes them
	Log to console	Removing NETWORK SETS	
	${networks} = 	Fusion Api Get Network Set
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Network Set		uri=${net['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	2s

Power off ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them off
	Log to console	Powering off SERVERS	
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	5s

Power on server
	[Arguments]     ${server}
	[Documentation]	Querys the appliance for a server by name and then Powers it on
	Log to console  Powering on ${server}
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${s}	IN	@{servers['members']}
	\       Continue For Loop If	  '${s['name']}' != '${server}'
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${s['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	10s

Power on ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them on
	Log to console  Powering On SERVERS
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='Off' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	5s

powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	5s
	
Remove All Server Profiles
	[Documentation]	Querys the appliance for all Server Profiles and then removes them
	Log to console  Removing SERVER PROFILES
	${profiles} = 	Fusion Api Get Server Profiles  param=?sort=name:ascending
	:FOR	${profile}	IN	@{profiles['members']}
	\		${resp} = 	Fusion Api Delete Server Profile		uri=${profile['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	10s

Remove Custom Range
	[Documentation]	Querys the appliance for all CUSTOM vmac, vwwn, vsn ranges and then removes them
	[Arguments]		${uri}
	Log to console  Removing CUSTOM RANGES
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'     Remove VWWN Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	    Remove VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	    Remove VMAC Range	${rangeUri}

Remove VMAC Range
	[Documentation]	Removes a CUSTOM VMAC range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VMAC Range	uri=${uri}

Remove VWWN Range
	[Documentation]	Removes a CUSTOM VWWN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VWWN Range	uri=${uri}

Remove VSN Range
	[Documentation]	Removes a CUSTOM VSN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VSN Range	uri=${uri}

Remove All Users
	[Documentation]	Querys the appliance for all Users and then removes them
	Log to console  Removing USERS
	${users} =  Fusion Api Get User
	:FOR	${user}	IN	@{users['members']}
	\		Continue For Loop If	'${user['userName']}'=='Administrator'
	\		Continue For Loop If	'${user['userName']}'=='administrator'
	\		${resp} =   Fusion Api Remove User		uri=${user['uri']}

Remove All Scopes
    [Documentation]   Querys the appliance for all the scopes and Removes them
    Log to console  Removing Scopes
    ${scopes} =     Fusion Api Get Scope
    ${headers}  Get From Dictionary     ${scopes}  headers
    ${Headers_temp}     Copy Dictionary     ${headers}
    :FOR	${scope}	IN	@{scopes['members']}
	\		Log to console	\nRemoving ${scope['name']}
    \       ${eTag}    Get From Dictionary     ${scope}  eTag
	\       ${headers_new}    Set To Dictionary	${Headers_temp}	If-Match=${eTag}
    \		${resp} =   Fusion Api Delete Scope     uri=${scope['uri']}     headers=${headers_new}
	
#######################################
# VALIDATION
#######################################
New Validate Response
    [Documentation]	Validates data in a response body against expected values using REGEX
    ...	looks up ${validation_code} in codes dicitonary
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation_code}
	Set Log Level	TRACE
	${validation} = 	Get From Dictionary	${codes}	${validation_code}
	${validation_results} = 	Fusion Api Validate Response	${resp}	${validation}
	# Log results	
	# Fail if results['passed'] is False
	[Return]	${validation_results}
	
Validate Response
    [Documentation]	Validates data in a response body against expected values
    ...	Example:
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE	
	${response} = 	Copy Dictionary	${resp}	
	@{vkeys} =	Get Dictionary Keys	${validation}
	${rkeys} =	Get Dictionary Keys	${response}
	@{keys} =	Remove all the keys in response that are not in validation	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{keys}
	\	Remove From Dictionary	${response}	${x}
	Dictionaries Should Be Equal	${validation}	${response}	msg=Response does not match validation dictionary	values=True

Validate Response Regex
    [Documentation]	Validates data in a response body against expected values using regex
    ...    Make sure to escape your pattern strings properly!
    ...    Example:
	...    ${valDict} = 	Create Dictionary	status_code=${200}
	...                                     taskState=Error
	...									    taskStatus=Invalid uplink-set: Port: \\d+ for interconnect-type: .* is not an uplink port.
	...    Validate Response Regex		${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE
	${response} =   Copy Dictionary    ${resp}
	@{vkeys} =      Get Dictionary Keys    ${validation}
	:FOR	${x}	IN	@{vkeys}
	\   ${r} =    Convert to string    ${resp['${x}']}
	\   ${v} =    Convert to string    ${valDict['${x}']}
	\   Should Match Regexp		       ${r}   ${v}

Remove all the keys in response that are not in validation
	[Arguments]	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{vkeys}
	\	Remove Values From List	${rkeys}	${x}
	[Return]	${rkeys}

#######################################
# VM
#######################################

VM setup and FTS
	[Arguments]		${VM}
	Log to console and logfile	[VM SETUP]
	Run Keyword If 	'${VMSETUP}' == 'yes'	VM setup		${VM}
	Get VM IP	${VM}
	Run Keyword If 	'${FTS}' == 'yes'		First Time Setup	password=hpvse123

Get VM IP
	[Arguments]		${VM}
    # Skip looking up IP from vCenter if IP provided via command line\suite variable
	Return from Keyword If	'${APPLIANCE_IP}' is not 'None'

	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Retrieving IPv4 Address for ${VM}
	${IPS} = 	Get VM IPv4 Addresses	${VM}
	${APPLIANCE_IP} = 	Get From List	${IPS}	0
	Log to console and logfile	- Found ${APPLIANCE_IP}
    Set Suite Variable		${APPLIANCE_IP}	${APPLIANCE_IP}

VM setup
	[Arguments]		${VM}
	Set Log Level	TRACE
	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Creating snapshot for ${VM}
	Create VM Snapshot	${VM}	oob-snapshot	True	True
	Log to console and logfile	- Powering on ${VM}
	Power On VM 	${VM}
	Log to console and logfile	- Sleeping 2 min while ${VM} boots ...
	Sleep	2 min

#######################################
# LOGGING
#######################################
Open Connection And Log In
    [Arguments]         ${SSH_HOST}=localhost   ${SSH_USER}=root
    Open Connection     ${SSH_HOST}     timeout=180s
    Run Keyword If	    '${SSH_PASS}' is ${null}      Set Suite variable  ${SSH_PASS}     hpvse1
    Login               ${SSH_USER}     ${SSH_PASS}

Get Latest Log
   [Arguments]      ${LOG}=/ci/logs/ciDebug.*
   ${LATEST_LOG_FILE}=  Execute Command  ls \-r ${LOG} | head \-1
   [return]  ${LATEST_LOG_FILE}

Write To ciDebug Log
    [Documentation]    This example uses ssh to write out to the latest
    ...                ciDebug on on the OV appliance.
    [Arguments]	       ${TEXT_TO_LOG}=[${SUITE_NAME}:${TEST_NAME}]      ${SSH_HOST}=${APPLIANCE_IP}
    Open Connection And Log In      ${SSH_HOST}
    ${LOG}=  Get Latest Log
    ${rc}=    Execute Command    echo "\n#### ${TEXT_TO_LOG}\n" >> ${LOG}     return_stdout=False    return_rc=True
    Should Be Equal    ${rc}    ${0}
    Close All Connections

#######################################
# OA CLI Commands
#######################################
OA CLI EFUSE
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}    ${ACTION}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    ++diag--
    Read Until    diag>
    Write    efuse ${DEVICE} ${BAY} ${ACTION}
    Write    q
    Close All Connections

OA CLI POWERON
    [Documentation]    issues an POWERON command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWERON ${DEVICE} ${BAY}
    Close All Connections

OA CLI POWEROFF
    [Documentation]    issues an POWEROFF command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWEROFF ${DEVICE} ${BAY}
    Close All Connections


Wait For Task1
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=160 s	${interval}=40 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate1	${resp}
	[Return]	${task}

Task Reached Endstate1
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['headers']['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}


Filter By

    [Arguments]     ${category}     ${scope}
	${nameList} =	Create List
    ${resp}     Fusion Api Index Resource   ?category=${category}&query="scope:'${scope}'"
    Log to console	\nresp is ${resp}
	${length} =		Get Length		${resp['members']}
	${nameList} =	Set Variable If	'${length}'=='0'	None
	
	:FOR	${x}	IN RANGE	0	${length}
	\   ${name} =   Get From Dictionary		${resp['members'][${x}]}	name
	\	Log to console	\n${name} is assigned to ${scope}
	[Return]	${nameList}

Filter By Any Scopes

    [Arguments]     ${category}     ${scope1}   ${scope2}
	${Namelist} =	Create List
    ${resp}     Fusion Api Index Resource   ?category=${category}&query="(scope:'${scope1}' OR scope:'${scope2}')"
	${length} =		Get Length		${resp['members']}
	${NameList} =	Set Variable If	'${length}'=='0'	None
	
	${len} =	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${len}
	\	${name} =	Get From Dictionary     ${resp['members'][${x}]}    name
	\	Log to console	\n${name} is assigned either in Scope1 or Scope2
    [Return]	${Namelist}

Filter By All Scopes

    [Arguments]     ${category}     ${scope1}   ${scope2}
	${NameList} =	Create List
    ${resp}     Fusion Api Index Resource   ?category=${category}&query="(scope:'${scope1}' AND scope:'${scope2}')"
	${length} =		Get Length		${resp['members']}

	${NameList} =	Set Variable If	'${length}'=='0'	None
	
	${len} =	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${len}
	\	${name} =	Get From Dictionary     ${resp['members'][${x}]}    name
	\	Log to console	\n${name} is assigned in both Scope1 and Scope2
    [Return]    ${NameList}

Add LS from variable
	[Documentation]	Adds an LS Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ls}


	${lgsuri} = 	Get From Dictionary	${ls['logicalSwitch']}	logicalSwitchGroupUri
	${lgsuri} = 	Common URI Lookup by name    ${lgsuri}
	Set to dictionary	${ls['logicalSwitch']}	logicalSwitchGroupUri		${lgsuri}
	${resp} =   Fusion Api Create LS    ${ls}
	${task} =	Wait For Task	${resp} 	60s	20s
	[Return]	${resp}
	
Wait For Task2
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate2	${resp}
	[Return]	${task}

Task Reached Endstate2
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	x-task-uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}

Get Scope Member
    [Documentation]     Negative Scenario
    [Arguments]     ${scopename}
    ${resp1}    Fusion Api Get Scope
    ${l} =     Get Length    ${resp1['members']}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${scope} =  copy Dictionary        ${resp1['members'][${x}]}
    \   Run Keyword If     '${scope['name']}' == '${scopename}'     Exit For Loop
    [Return]	${scope}

Get lsgs Member
    [Arguments]     ${type}
    ${resp} =   Fusion Api Get Switch Types
    ${l} =     Get Length    ${resp['members']}

    :FOR	${x}	IN RANGE	0	${l}
    \	@{words} = 	Split String	${resp['members'][${x}]['partNumber']}	-
	\	${type1} = 	Get From List	${words}	1
	\ 	Run Keyword If 	'${type}' != '${type1}'		Continue For Loop
	\   Set to dictionary	${lsg_1[0]['switchMapTemplate']['switchMapEntryTemplates'][0]}     permittedSwitchTypeUri		${resp['members'][${x}]['uri']}
    \   Set to dictionary	${lsg_1[1]['switchMapTemplate']['switchMapEntryTemplates'][0]}     permittedSwitchTypeUri		${resp['members'][${x}]['uri']}
    [Return]    ${lsg_1}

Add Enclosure Group TB from variable
        [Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
        [Arguments]		${enc_group}
        #log to console	encg is :${enc_group}
        #log to console	encgp is :${enc_group['enc_group1']}	
        #Log to console		name of eg is:${enc_group['enc_group1']['name']}
        
        #Log to console and logfile  	Adding ENCLOSURE GROUP ${enc_group['enc_group1']['name']}
        ${l} = 	Get Length	${enc_group['enc_group1']['interconnectBayMappings']}
        :FOR 	${x}	IN RANGE	0	${l}
        \	${liguri} = 	Get From Dictionary	${enc_group['enc_group1']['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
        \   Continue For Loop If    '${liguri}' == 'None'
        \	${liguri} = 	Common URI Lookup by name    ${liguri}
        \	Set to dictionary	${enc_group['enc_group1']['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}
        ${resp} =	Fusion Api Create Enclosure Group	${enc_group['enc_group1']}
        #${task} =	Wait For Task1	${resp} 	60s	20s
        #log to console	task is :${task}
        [Return]	${resp}	
