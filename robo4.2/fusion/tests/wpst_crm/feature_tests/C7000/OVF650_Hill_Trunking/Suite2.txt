| *** Settings *** |
| Documentation | OVF650 - Hill trunking. |
| Library | json |
| Library | FusionLibrary |
| Library | RoboGalaxyLibrary |
| Library | Collections |
| Library | String |
| Library | BuiltIn |
| Library | SSHLibrary |
| Variables | data_variables.py |
| Resource | ../../../resources/resource.txt |

| *** Test cases *** |
| Step1 Create SessionID through API |
| | [Documentation] | Creating the session ID through rest calls |
| | Set Log Level | TRACE |
| | ${Login_response} | Fusion Api Login Appliance | ${APPLIANCE_IP} | ${admin_credentials} |
| | Run keyword unless | ${Login_response[0]['status_code']}== 200 | Fail | ${Login_response[0]['message']} |
| | Log | Test Step-1 completed successfully | console=True |

| | Get LIG names,uris and FC uris |
| | ${uri} | Get Enclosure URI | ${Enclosure_Name[0]} |
| | Set Global Variable | ${ENC_uri} | ${uri} |

| step2 clearing the trunk group in switch
| | [Documentation] | clearing the trunk group in switch |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | No trunk groups available |
| | ${TG_count} | ${TG_data} | Get the number of Trunk Group in switch | ${show_command_output} |
| | :FOR | ${x} | IN RANGE | 0 | ${TG_count} |
| | \ | @{lines} | Split String | ${TG_data[${x}]} | \n |
| | \ | ${TG_number} | Evaluate | ${x}+1 |
| | \ | ${Ports_count} | ${Master_port} | ${Ports_in_TG} | Check For Ports in Trunk Group | ${lines} | ${TG_number} |
| | \ | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |

| step3(TC#11) OVF650_API_TC_Create US1 in bay 5 with ports 1-4 with trunking disabled, and trunking disabled on TOR |
| | [Documentation] | OVF650_API_TC_Create US1 in bay 5 with ports 1-4 with trunking disabled, and trunking disabled on TOR.Objective of the test case is to validate when trunking is disabled on both OV and TOR, the ports should be linked and no TG should be formed. |
| | Clear ULS in LIG | ${LIG_uri} |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[1]} | ${FC_uris[0]} | ${US_details[0]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][0:4]} |
| | Sleep | 30s |
| | LI update from Group | ${lig_body1['name']} |
| | Sleep | 30s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| step4(TC#12) OVF650_API_TC_Create US1 in bay 5 with ports 1-4, with trunking enabled and trunking disabled on TOR. |
| | [Documentation] | OVF650_API_TC_Create US1 in bay 5 with ports 1-4, with trunking enabled and trunking disabled on TOR.Objective of the test case is to validate when trunking is enabled on OV and disabled on TOR, the ports should be linked and no TG should be formed. |
| | Clear ULS in LIG | ${LIG_uri} |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[0]} | ${FC_uris[0]} | ${US_details[0]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][0:4]} |
| | Sleep | 30s |
| | LI update from Group | ${lig_body1['name']} |
| | Sleep | 30s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |


| step5(TC#13) OVF650_API_TC_Create US1 in bay 5 with ports 1-4, with trunking enabled and enable the trunk ports on TOR (0-3 ports ) in HW trunk group 1 but with no trunk groups. |
| | [Documentation] | OVF650_API_TC_Create US1 in bay 5 with ports 1-4, with trunking enabled and enable the trunk ports on TOR (0-3 ports ) in HW trunk group 1 but with no trunk groups.Objective of the test case is to validate when trunking is enabled on both OV and TOR,the ports should be linked with trunkgroup.|

| | Enable trunk ports but with no trunk group | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:4]} |
| | Sleep | 300s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| | Disable trunk ports in trunk group | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:4]} |

| step6(TC#14) OVF650_API_TC_Create US1 in bay 5 with ports 1-4, with trunking enabled and trunking enabled on TOR with 1-2ports in HW Trunk group 1.|
| | [Documentation] | OVF650_API_TC_Create US1 in bay 5 with ports 1-4, with trunking enabled and trunking enabled on TOR with 1-2ports in HW Trunk group 1.Objective of the test case is to validate when trunking is enabled on both OV and TOR,ports should be linked and master port should be assigned to the port. |
| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:2]} |
| | Sleep | 300s |
| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:2]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][2:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| step7 Checking TrunkGroup and delete existing |
| | [Documentation] | Checks the trunk group and deletes in the FC switch |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | No trunk groups available |
| | ${TG_count} | ${TG_data} | Get the number of Trunk Group in switch | ${show_command_output} |
| | :FOR | ${x} | IN RANGE | 0 | ${TG_count} |
| | \ | @{lines} | Split String | ${TG_data[${x}]} | \n |
| | \ | ${TG_number} | Evaluate | ${x}+1 |
| | \ | ${Ports_count} | ${Master_port} | ${Ports_in_TG} | Check For Ports in Trunk Group | ${lines} | ${TG_number} |
| | \ | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | Sleep | 60s |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |


| step8(TC#15) OVF650_API_TC_Create US1 in bay 5 with ports 1-4 with  trunking enabled and configure TOR with  8-10  ports in HW Trunk group 2.
| | [Documentation] | OVF650_API_TC_Create US1 in bay 5 with ports 1-4 with  trunking enabled and configure TOR with  8-10  ports in HW Trunk group 2.Objective of the test case is to validate when trunking is enabled in bay 5 in OV and trunking is enabled on TOR in bay 6,both bay 5 and 6 ports should be linked and master port should be assigned to bay 6 pors|

| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment2']} |
| | Sleep | 300s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[1]['Act_ports']} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[1]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| step9: | [Documentation] | clearing the trunk group in switch |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | No trunk groups available |
| | ${TG_count} | ${TG_data} | Get the number of Trunk Group in switch | ${show_command_output} |
| | :FOR | ${x} | IN RANGE | 0 | ${TG_count} |
| | \ | @{lines} | Split String | ${TG_data[${x}]} | \n |
| | \ | ${TG_number} | Evaluate | ${x}+1 |
| | \ | ${Ports_count} | ${Master_port} | ${Ports_in_TG} | Check For Ports in Trunk Group | ${lines} | ${TG_number} |
| | \ | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | Sleep | 60s |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |

| step10(TC#16) Create US1 in bay 5 with ports 1-4 with trunking enabled, and configure TOR with 0 port in HW trunk group 1 as TG1 and configure TOR with 1 port in same HW trunk group 1  as TG2.
| | [Documentation] | Create US1 in bay 5 with ports 1-4 with trunking enabled, and configure TOR with  port 0 in HW trunk group 1 as TG1 and configure TOR with  port 0 in same HW trunk group 1  as TG2. Since only one trunk group can be formed on one HW trunkgroup,this test case is to validate TG1 should be formed and TG2 should be formed.|

| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:1]} |
| | Sleep | 30s |
| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][1:2]} |
| | Sleep | 300s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:1]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][1:2]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Unlinked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][2:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| step11: | [Documentation] | clearing the trunk group in switch |
| | Clear ULS in LIG | ${LIG_uri} |
| | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:1]} |
| | Sleep | 60s |
| | Delete trunk group and release ports persistently | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][1:2]} |
| | Sleep | 60s |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |


| step12(TC#17) OVF650_API_TC_Create US1 with ports 1-2 in bay 5 and US2 with ports 3-4 in bay 5,with trunking enabled and  TOR configured with port 0-3 in HW trunk group 1.
| | [Documentation] | OVF650_API_TC_Create US1 with ports 1-2 in bay 5 and US2 with ports 3-4 in bay 5,with trunking enabled and  TOR configured with port 0-3 in HW trunk group 1.As the master port will be assigned to US1,the ports in US1 will be linked and master port will be assigned to the port and the ports in us2 will be unlinked. |

| | Clear ULS in LIG | ${LIG_uri} |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[0]} | ${FC_uris[0]} | ${US_details[0]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][0:2]} |
| | Sleep | 30s |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[0]} | ${FC_uris[1]} | ${US_details[1]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][2:4]} |
| | Sleep | 30s |
| | LI update from Group | ${lig_body1['name']} |
| | Sleep | 30s |
| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:4]} |
| | Sleep | 300s |
| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:2]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][2:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Unlinked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| step13: Checking TrunkGroup and delete existing |
| | [Documentation] | Checks the trunk group and deletes in the FC switch |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | No trunk groups available |
| | ${TG_count} | ${TG_data} | Get the number of Trunk Group in switch | ${show_command_output} |
| | :FOR | ${x} | IN RANGE | 0 | ${TG_count} |
| | \ | @{lines} | Split String | ${TG_data[${x}]} | \n |
| | \ | ${TG_number} | Evaluate | ${x}+1 |
| | \ | ${Ports_count} | ${Master_port} | ${Ports_in_TG} | Check For Ports in Trunk Group | ${lines} | ${TG_number} |
| | \ | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | Sleep | 60s |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |

| step14(TC#18) OVF650_API_TC_Create US1 with ports 1-2 in bay 5  and US2 with ports 3-4 in bay 5 with trunking enabled in ULS and trunking enabled on TOR for 0-1 ports in HW trunk group 1 |
| | [Documentation] | OVF650_API_TC_Create US1 with ports 1-2 in bay 5  and US2 with ports 3-4 in bay 5 with trunking enabled in ULS and trunking enabled on TOR for 0-1 ports in HW trunk group 1.Since TG is enabled for only US1, the ports in US1 will be linked and master port will be assigned to the port. |
| | Clear ULS in LIG | ${LIG_uri} |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[0]} | ${FC_uris[0]} | ${US_details[0]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][0:2]} |
| | Sleep | 30s |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[0]} | ${FC_uris[1]} | ${US_details[1]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][2:4]} |
| | Sleep | 30s |
| | LI update from Group | ${lig_body1['name']} |
| | Sleep | 30s |

| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:2]} |
| | Sleep | 300s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:2]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][2:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| step15: Checking TrunkGroup and delete existing |
| | [Documentation] | Checks the trunk group and deletes in the FC switch |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | No trunk groups available |
| | ${TG_count} | ${TG_data} | Get the number of Trunk Group in switch | ${show_command_output} |
| | :FOR | ${x} | IN RANGE | 0 | ${TG_count} |
| | \ | @{lines} | Split String | ${TG_data[${x}]} | \n |
| | \ | ${TG_number} | Evaluate | ${x}+1 |
| | \ | ${Ports_count} | ${Master_port} | ${Ports_in_TG} | Check For Ports in Trunk Group | ${lines} | ${TG_number} |
| | \ | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | Sleep | 60s |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |

| step16(TC#19) OVF650_API_TC_Create US1 with ports 1-2 in bay 5 with trunk enabled and US2 with ports 3-4 in bay 5 with trunk disabled, and configure TOR in 0-1 ports in HW trunk group 1 as TG1  and 8-9 ports in HW trunk group 2.
| | [Documentation] | OVF650_API_TC_Create US1 with ports 1-2 in bay 5 with trunk enabled and US2 with ports 3-4 in bay 5 with trunk disabled, and configure TOR in 0-1 ports in HW trunk group 1 as TG1  and 8-9 ports in HW trunk group 2. |
| | Clear ULS in LIG | ${LIG_uri} |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[0]} | ${FC_uris[0]} | ${US_details[0]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][0:2]} |
| | Sleep | 30s |
| | Create uls in LIG | ${LIG_uri} | ${fcmodes[1]} | ${FC_uris[1]} | ${US_details[1]['name']} | ${desiredSpeeds[0]} | ${US_details[0]['bay']} | ${US_details[0]['rel_ports'][2:4]} |
| | Sleep | 30s |
| | LI update from Group | ${lig_body1['name']} |
| | Sleep | 30s |

| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment1'][0:2]} |
| | Sleep | 30s |
| | Create Trunk Group with ports | ${FC_switch_details} | ${Trunk_Commands} | ${FC_switch_ports['segment2'][0:2]} |
| | Sleep | 300s |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][0:2]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[0]['Act_ports'][2:4]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'=='None' | FAIL |

| | :FOR | ${port} | IN | @{US_details[1]['Act_ports'][0:2]} |
| | \ | ${portStatus} | ${trunkMaster} | ${enabled} | Get port details | ${Enclosure_Name[0]} | ${US_details[0]['bay']} | ${port} |
| | \ | Run Keyword Unless | '${portStatus}'=='Linked' | FAIL |
| | \ | Run Keyword Unless | '${trunkMaster}'!='None' | FAIL |

| step17: | [Documentation] | Checking TrunkGroup and delete existing | [Documentation] | Checks the trunk group and deletes in the FC switch |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | No trunk groups available |
| | ${TG_count} | ${TG_data} | Get the number of Trunk Group in switch | ${show_command_output} |
| | :FOR | ${x} | IN RANGE | 0 | ${TG_count} |
| | \ | @{lines} | Split String | ${TG_data[${x}]} | \n |
| | \ | ${TG_number} | Evaluate | ${x}+1 |
| | \ | ${Ports_count} | ${Master_port} | ${Ports_in_TG} | Check For Ports in Trunk Group | ${lines} | ${TG_number} |
| | \ | Delete trunk group and release ports | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | Sleep | 60s |
| | ${show_command_output} | Check For Trunk Group in Brocade | ${FC_switch_details} | ${Trunk_Commands} |
| | ${lines} | Get Lines Containing String | ${show_command_output} | ${no_trunk_message} |
| | ${line_count} | Get Line Count | ${lines} |
| | Pass Execution If | ${line_count} == 1 | Trunk Groups deleted succeesfully | ELSE | FAIL |

****keywords****
| Get LIG names,uris and FC uris |
| | [Documentation] | This keyword will fetvh exixting LIG and FC uris |
| | ${FC_uris} | Create List |
| | ${resp} | Fusion Api Get Lig |
| | :FOR | ${member} | IN | @{resp['members']} |
| | \ | Set Global Variable | ${LIG_name} | ${member['name']} |
| | \ | Set Global Variable | ${LIG_uri} | ${member['uri']} |
| | ${resp} | Fusion Api Get Fc Networks |
| | :FOR | ${member} | IN | @{resp['members']} |
| | \ | Append To List | ${FC_uris} | ${member['uri']} |
| | Set Global Variable | ${FC_uris} | ${FC_uris} |

| Clear ULS in LIG | [Arguments] | ${LIG_uri} |
| | [Documentation] | This keyword will clear uplink sets in both LI and LIG |
| | ${resp} | fusion_api_get_lig | uri=${LIG_uri} |
| | Remove From Dictionary | ${resp} | headers |
| | Remove From Dictionary | ${resp} | status_code |
| | Set To Dictionary | ${resp} | uplinkSets | ${empty_list} |
| | ${resp1} | Fusion Api Edit Lig | ${resp} | ${LIG_uri} |
| | ${task} | Wait For Task | ${resp1} | 20s | 2s |


| LI Update from group | [Arguments] | ${LIG_name} |
| | [Documentation] | Performing LI Update from group |
| | ${URI} | Get LI URI | ${ENCLOSURE_NAME[0]}-${LIG_name} |
| | Set Global Variable | ${LI_URI} | ${URI} |
| | ${li_resp} | Fusion Api Get Li | ${LI_URI} |
| | ${resp_update} | Fusion Api Update From Group | ${LI_uri} |
| | Run keyword If | '${resp_update['status_code']}' != '202' | Fail | ${resp_update['message']} |
| | ${task} | Wait For Task | ${resp_update} | 600s | 30s |
| | Log | \nLI updated from group successfully. | console=True |
| | [Return] | ${task} |


| Create Trunk Group with ports | [Arguments] | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_to_trunk} |
| | [Documentation] | Creating Trunk Group with ports on switch
| | ${First_port} | Set Variable | ${Ports_to_trunk[0]} |
| | ${Last_port} | Set Variable | ${Ports_to_trunk[-1]} |
| | Open Connection | ${FC_switch_details['ip']} |
| | Login | ${FC_switch_details['userName']} | ${FC_switch_details['password']} |
| | Execute Command | ${Trunk_Commands[1]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | :FOR | ${y} | IN  | @{Ports_to_trunk} |
| | \ | Execute Command | ${Trunk_Commands[3]} ${y} 1 |
| | \ | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[5]} ${First_port}-${Last_port} -index ${First_port} |
| | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[4]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Close Connection |

| Check For Trunk Group in Brocade | [Arguments] | ${FC_switch_details} | ${Trunk_Commands} |
| | [Documentation] | Checking for the trunk group existence in switch |
| | Log | Checking for trunk group details in the Brocade switch | console=True |
| | Open Connection | ${FC_switch_details['ip']} |
| | Login | ${FC_switch_details['userName']} | ${FC_switch_details['password']} |
| | ${stdout} | Execute Command | ${Trunk_Commands[0]} |
| | Log | Show command output is \n ${stdout} | console=True |
| | Close Connection |
| | [Return] | ${stdout} |

| Get the number of Trunk Group in switch | [Arguments] | ${show_command_output} |
| | [Documentation] | Getting the number of trunk groups in switch |
| | @{words} | Split String | ${show_command_output} | ------------------------------------- |
| | Log | The output splitted with dots is \n ${words} | console=True |
| | Remove From List | ${words} | -1 |
| | Remove From List | ${words} | 0 |
| | ${group_count} | Get Length | ${words} |
| | Log | The number of trunk groups present is ${group_count} | console=True |
| | [Return] | ${group_count} | ${words} |

| Check For Ports in Trunk Group | [Arguments] | ${Ports_data} | ${TG_number} |
| | [Documentation] | Checking for the master port and port count in the trunk group |
| | Log | Checking the ports present in each trunk group | console=True |
| | Remove From List | ${Ports_data} | -1 |
| | Remove From List | ${Ports_data} | 0 |
| | ${Ports_count} | Get Length | ${Ports_data} |
| | Log | The number of ports present in TG${TG_number} is ${Ports_count} | console=True |
| | ${Ports_list} | Create List |
| | :FOR | ${y} | IN RANGE | 0 | ${Ports_count} |
| | \ | ${data1} | Split String | ${Ports_data[${y}]} |
| | \ | ${data2} | Get Length | ${data1} |
| | \ | Append To List | ${Ports_list} | ${data1[-1]} |
| | ${Master_port} | Set Variable | ${data1[-2]} |
| | [Return] | ${Ports_count} | ${Master_port} | ${Ports_list} |

| Delete trunk group and release ports | [Arguments] | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | [Documentation] | Deleting the trunk group |
| | ${First_port} | Set Variable | ${Ports_in_TG[0]} |
| | ${Last_port} | Set Variable | ${Ports_in_TG[-1]} |
| | Open Connection | ${FC_switch_details['ip']} |
| | Login | ${FC_switch_details['userName']} | ${FC_switch_details['password']} |
| | Execute Command | ${Trunk_Commands[1]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[2]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | :FOR | ${y} | IN  | @{Ports_in_TG} |
| | \ | Execute Command | ${Trunk_Commands[3]} ${y} 0 |
| | \ | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[4]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Close Connection |

| Delete trunk group and release ports persistently | [Arguments] | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_in_TG} |
| | [Documentation] | Deleting the trunk group |
| | ${First_port} | Set Variable | ${Ports_in_TG[0]} |
| | ${Last_port} | Set Variable | ${Ports_in_TG[-1]} |
| | Open Connection | ${FC_switch_details['ip']} |
| | Login | ${FC_switch_details['userName']} | ${FC_switch_details['password']} |
| | Execute Command | ${Trunk_Commands[1]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[2]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | :FOR | ${y} | IN  | @{Ports_in_TG} |
| | \ | Execute Command | ${Trunk_Commands[3]} ${y} 0 |
| | \ | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[6]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Close Connection |



| Create uls in LI | [Arguments] | ${fcmode} | ${uls_name} | ${FC_uri} | ${desiredSpeed} | ${IC_bay_set} | ${ENC_uri} | ${ports} |
| | [Documentation] | Creating uplinkset with network in LI through rest calls |
| | ${li_resp} | Fusion Api Get Li |
| | Set Global Variable | ${LI_uri} | ${li_resp['members'][0]['uri']} |
| | Set To Dictionary | ${li_upsbody[0]} | fcMode | ${fcMode} |
| | Set To Dictionary | ${li_upsbody[0]} | name | ${uls_name} |
| | Append To List | ${li_upsbody[0]['fcNetworkUris']} | ${FC_uri} |
| | ${port_list} | Create List |
| | ${ports_length} | Get Length | ${ports} |
| | :FOR | ${x} | IN RANGE | 0 | ${ports_length} |
| | \ | Set To Dictionary | ${portConfigInfos[${x}]} | desiredSpeed | ${desiredSpeed} |
| | \ | Set To Dictionary | ${portConfigInfos[${x}]['location']['locationEntries'][1]} | value | ${IC_bay_set} |
| | \ | Set To Dictionary | ${portConfigInfos[${x}]['location']['locationEntries'][2]} | value | ${ENC_uri} |
| | \ | ${tmp_list} | Create List |
| | \ | ${tmp_var} | Copy Dictionary | ${portConfigInfos[${x}]} |
| | \ | Set To Dictionary | ${tmp_var['location']['locationEntries'][0]} | value | ${ports[${x}]} |
| | \ | Append To List | ${port_list} | ${tmp_var} |
| | Set To Dictionary | ${li_upsbody[0]} | portConfigInfos | ${port_list} |
| | Set To Dictionary | ${li_upsbody[0]} | logicalInterconnectUri | ${LI_uri} |
| | ${resp_li} | Fusion Api Create Uplink Set | body=${li_upsbody[0]} |
| | ${task} | Wait For Task | ${resp_li} | 240s | 10s |
| | Remove From List | ${li_upsbody[0]['fcNetworkUris']} | 0 |

| Create uls in LIG | [Arguments] | ${LIG_uri} | ${fcmode} | ${FC_uri} | ${uls_name} | ${desiredSpeed} | ${IC_bay_set} | ${ports} |
| | [Documentation] | Creating Uplinkset with network in LIG through rest calls
| | ${port_list} | Create List |
| | ${resp} | fusion_api_get_lig | uri=${LIG_uri}
| | Set To Dictionary | ${lig_uls_body1} | fcMode | ${fcMode} |
| | Set To Dictionary | ${lig_uls_body1} | name | ${uls_name} |
| | Append To List | ${lig_uls_body1['networkUris']} | ${FC_uri} |
| | ${ports_length} | Get Length | ${ports} |
| | :FOR | ${x} | IN RANGE | 0 | ${ports_length} |
| | \ | Set To Dictionary | ${logicalPortConfigInfos[${x}]} | desiredSpeed | ${desiredSpeed}
| | \ | Set To Dictionary | ${logicalPortConfigInfos[${x}]['logicalLocation']['locationEntries'][0]} | relativeValue | ${IC_bay_set} |
| | \ | ${tmp_list} | Create List |
| | \ | ${tmp_var} | Copy Dictionary | ${logicalPortConfigInfos[${x}]} |
| | \ | Set To Dictionary | ${tmp_var['logicalLocation']['locationEntries'][1]} | relativeValue | ${ports[${x}]} |
| | \ | Append To List | ${port_list} | ${tmp_var} |
| | Set To Dictionary | ${lig_uls_body1} | logicalPortConfigInfos | ${port_list} |
| | Remove From Dictionary | ${resp} | headers |
| | Remove From Dictionary | ${resp} | status_code |
| | Append to List | ${resp['uplinkSets']} | ${lig_uls_body1} |
| | ${resp1} | Fusion Api Edit Lig | ${resp} | ${LIG_uri} |
| | ${task} | Wait For Task | ${resp1} | 20s | 2s |
| | Remove From List | ${lig_uls_body1['networkUris']} | 0 |

| Get port details | [Arguments] | ${Enc_name} | ${bay_num} | ${Port_num} |
| | [Documentation] | Getting the port details of respective port number. |
| | ${resp} | Fusion Api Get Interconnect | param=?filter="'name'=='${Enc_name}, interconnect ${bay_num}'" |
| | ${ports} | Get Variable Value | ${resp['members'][0]['ports']} |
| | :FOR | ${port} | IN | @{ports} |
| | \ | Run Keyword If | '${port['portName']}' != '${Port_num}' | Continue For Loop |
| | \ | ${portStatus} | Set Variable | ${port['portStatus']} |
| | \ | ${trunkMaster} | Set Variable | ${port['fcPortProperties']['trunkMaster']} |
| | \ | ${enabled} | Set Variable | ${port['enabled']} |
| | \ | Exit For Loop |
| | [Return] | ${portStatus} | ${trunkMaster} | ${enabled} |

| Enable trunk ports but with no trunk group | [Arguments] | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_to_trunk} |
| | [Documentation] | Creating Trunk ports but without creating trunk group |
| | ${First_port} | Set Variable | ${Ports_to_trunk[0]} |
| | ${Last_port} | Set Variable | ${Ports_to_trunk[-1]} |
| | Open Connection | ${FC_switch_details['ip']} |
| | Login | ${FC_switch_details['userName']} | ${FC_switch_details['password']} |
| | Execute Command | ${Trunk_Commands[1]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | :FOR | ${y} | IN  | @{Ports_to_trunk} |
| | \ | Execute Command | ${Trunk_Commands[3]} ${y} 1 |
| | \ | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[4]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Close Connection |

| Disable trunk ports in trunk group | [Arguments] | ${FC_switch_details} | ${Trunk_Commands} | ${Ports_to_trunk} |
| | [Documentation] | Disabling the trunkports in trunk group |
| | ${First_port} | Set Variable | ${Ports_to_trunk[0]} |
| | ${Last_port} | Set Variable | ${Ports_to_trunk[-1]} |
| | Open Connection | ${FC_switch_details['ip']} |
| | Login | ${FC_switch_details['userName']} | ${FC_switch_details['password']} |
| | Execute Command | ${Trunk_Commands[1]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | :FOR | ${y} | IN  | @{Ports_to_trunk} |
| | \ | Execute Command | ${Trunk_Commands[3]} ${y} 0 |
| | \ | Sleep | 3s |
| | Execute Command | ${Trunk_Commands[4]} ${First_port}-${Last_port} |
| | Sleep | 3s |
| | Close Connection |
