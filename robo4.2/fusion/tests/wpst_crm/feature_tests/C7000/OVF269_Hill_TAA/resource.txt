*** Settings ***
Library			RoboGalaxyLibrary
Library			FusionLibrary
Library			OperatingSystem
Library			BuiltIn
Library			Collections
Library		    SSHLibrary
Library			String
Library 		c7000_login_redistribution
Resource		../../../resources/resource.txt

Variables		${DATA}								
Variables		data_variables.py

*** Variables ***
${APPLIANCE_IP}     ${None}
${DATA}			data_variables.py
${VM}			${None}
${VMSETUP}		no
${FTS}			no
${CONFIGURE}		no
${None}		None

*** Keywords ***
Wait For Task LE Update
	[Documentation]    sleep until LE updates
	Sleep    ${LE_Update_Sleep_Time}
	
Wait For Task LI Update
	[Documentation]    sleep until LI updates
	Sleep    ${LI_Update_Sleep_Time}
	
Wait For Restarting Interconnect
	[Documentation]    sleep until interconnect restarts
	Sleep    600
	
Wait For Disabling Ports
	[Documentation]    sleep until ports disabled
	Sleep    30
	
Wait For Enabling Ports
	[Documentation]    sleep until ports enabled
	Sleep    30
	
Wait Until Support Dump Creation
	[Documentation]    sleep until support dump created
	Sleep    ${LE_Support_Dump_Time}
	
Wait For Restarting OV Appliance
	[Documentation]    sleep until OV restarts
	Sleep	1200
	
Open Connection And Log In OA
	[Documentation]    opens oa connection and login
    [Arguments]         ${SSH_HOST}=15.186.28.6   ${SSH_USER}=Administrator
    Open Connection     ${SSH_HOST}     timeout=180s
    Set Suite variable  ${SSH_PASS}     ${OA_PASS}
    Login               ${SSH_USER}     ${SSH_PASS}
	
SSH to host and ping x
    [Documentation]    SSH's to a given host, then pings an IP from that host
    [Arguments]         ${HOST}    ${HOST2}
    Open Connection And Log In OA     ${HOST}
    #${Output}=    Execute Command        connect interconnect 5 return_stdout=True    return_rc=False
                ${Output}=         Write     connect interconnect 5
                ${o}=     Read
    Log to console and logfile    ${Output}
                #${r}=   Write Until Expected output       ${\n}      expected=Press [Enter] to display the switch console:                timeout=10s      retry_interval=0.5s
                ${r}=      Write Until Expected output       ${\n}      expected=(reverse-i-search)`':  timeout=10s                retry_interval=0.5s
                ${o}=     Read
    Log to console and logfile    ${Output}
                Log to console and logfile    ${o}
                #${Output}=      Write     root
                #${r}=   Write Until Expected output       ${\n}      expected=Password:     timeout=10s      retry_interval=0.5s
                #${Output}=      Write     6KWDJF7J
                #${s}=   Read
                ${r}=      Write Until Expected output       ${\n}      expected=VCFC3CN85030042:root>        timeout=10s                retry_interval=0.5s         
                ${r}=      Write Until Expected output       snmpconfig --show snmpv1        expected=VCFC3CN85030042:root>                timeout=10s      retry_interval=0.5s
                ${s}=      Read
                Log to console and logfile    ${s}
                ${r}=      Write Until Expected output       snmpconfig --show snmpv1        expected=VCFC3CN85030042:root>                timeout=10s      retry_interval=0.5s
                ${s}=      Read
                Log to console and logfile    ${s}
                Log to console and logfile    ${s}
                
                
    Close All Connections

Download Backup
	[Documentation]    downloads the backup file
  [Arguments]	${filename}=None
  ${Backup}	Fusion Api Get Backup
  Log To Console	${Backup}
  @{members}	Get From Dictionary	${Backup}	members
  ${file}	Run Keyword If		'${filename}'=='None'
  ...		Set Variable		${members[0]['id']}
  ...		ELSE	Set Variable	${filename}
  ${ret}	Fusion Api Download Backup	${members[0]['downloadUri']}	${file}
  log to console		${ret}
  
Upload Backup
	[Documentation]    uploads the backup file
  [Arguments]	${filename}
  ${Response}	Fusion Api Upload Backup	${filename}
  Log		${Response}
  
Login to OneView via REST	
	[Documentation]		Login to the appliance with the cred
	[Tags]  add   POSITIVE
	Set Log Level    TRACE
	${resp}     Fusion Api Login Appliance    ${appliance_IP}        ${admin_credentials}

Logout OneView via REST
	[Documentation]	log out from the appliance
	Fusion Api Logout Appliance
	
Restore From Backup
	[Documentation]    restores the appliance from backup
	${status}=	Set Variable    ${EMPTY}
    Sleep    60
	${Response}		Fusion Api Get Backup
	Run keyword unless	${Response['status_code']}== 200	Fail	"Unable to Get the latest backup"
	${restore_body}		Create Dictionary	type=RESTORE 	
	...										uriOfBackupToRestore=${Response['members'][0]['uri']}
	Log to console and logfile		"restore Body si"
	Log to console and logfile		${restore_body}
	${output}		Fusion Api Restore Backup		${restore_body}
	Log to console and logfile		${output}
	Run keyword unless	${output['status_code']}== 202	Fail	"Unable to perform the restore from backup operation"
    Sleep   1800sec
	${restore_resp}		Fusion API Get Restore Status
	#Log to console and logfile		"Restore_resp values is "	${\n}
	Log to console and logfile		${restore_resp}
	Run keyword unless	${restore_resp['status_code']}== 200	Fail	"Unable to get the restore details"
	:FOR	${index}	IN RANGE	${restore_resp['count']}
	\	Run Keyword If	'${restore_resp['members'][${index}]['backupIdToRestore']}' != '${Response['members'][0]['id']}'		Continue For Loop
	\	${restore_id} =    Set Variable    ${restore_resp['members'][${index}]['id']}
	:FOR	${index}	IN RANGE	50
	\	sleep	30sec
	\	Log to console and logfile		"Restoring is in Progress..."
	\	${resp}		Fusion API Get Restore Status	${restore_id}
	\	Run keyword unless	${resp['status_code']}== 200	Fail	"Unable to get the restore id details"
	\	Run Keyword If	'${resp['progressStep']}' != 'COMPLETED'	Continue For Loop
	\	${status} =    Set Variable    ${resp['status']}
	\	Run Keyword If	'${resp['progressStep']}' == 'COMPLETED'	Exit For Loop
	Should Be Equal    ${status}	SUCCEEDED
	Log to console and logfile		"Exited from the for loop"
	Sleep    60
	Login to OneView via REST
	Validate IC State    ${IC_Configured}
	
SET EBIPA
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {BAY} = desired bay for given device
    ...   {IP1} = <IP gping to changed in interconnect>
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}    ${IP1}  ${bay}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s
    Login               ${OA_USER}     ${OA_PASS}
    
    Log to console and logfile	set ebipa
    ${OA_USER} =	Write    set ebipa interconnect ${IP1} 255.255.255.0 ${bay}
	Log to console and logfile		${OA_USER}
    Sleep 		${cmd_sleep_time}secs
    Write    yes
    Sleep 		${cmd_sleep_time}secs
	Log to console and logfile		ebipa enabling
	Write    enable ebipa interconnect ${bay}
    Sleep 		${cmd_sleep_time}secs
    Write    yes
    Sleep 		${cmd_sleep_time}secs
    
    Log to console and logfile		poweroff interconnect
    Write    poweroff interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    Log to console and logfile		poweron interconnect
    Write    poweron interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    
    
DISABLE EBIPA
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}	${bay}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s    
    Login               ${OA_USER}     ${OA_PASS}
    Log to console and logfile		disable ebipa
    Write   disable ebipa interconnect ${bay}
    Sleep 		${cmd_sleep_time}secs
    Write    yes
    Sleep 		${cmd_sleep_time}secs
    Log to console and logfile		poweroff interconnect
    Write    poweroff interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    Log to console and logfile		poweron interconnect
    Write    poweron interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    
    
SHOW INTERCONNECT
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}    ${bay}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s
    Login               ${OA_USER}     ${OA_PASS}
    Log to console and logfile		show interconnect IP ${bay}
    
    Write    show interconnect list
    Sleep 		${cmd_sleep_time}secs
    ${Id}=  Read Until    Totals:
    @{lines}=   Split to lines  ${Id}
    :FOR	${line}	IN	@{lines}
	
	\   ${Lines_2}=    Get Lines Containing String     ${line}      Fibre Channe
	\   ${Count2}=    Get Line Count    ${Lines_2}
    \	Run Keyword If	'${Count_2}' != '1'	Continue For Loop
	\	Log to console and logfile	line2 is ${line}	
	\   @{words} = 	Split String	${line}   Fibre Channe
	
    \	Run Keyword If	${words[0]} == ${bay}	Exit For Loop
	
	${one_group} = 	Get Regexp Matches 	${words[1]} 	(\\d.*\\d)
    Log to console and logfile      ${one_group}	
	
	Log to console and logfile		close show interconnect IP
    Close All Connections
	[Return]    ${one_group[0]}	
	
Get interconnect ip
	[Documentation]    gets the ips of the interconnects
	[Arguments]		${ic}    ${type}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${interconnectIP} = 	Get From Dictionary		${resp['members'][0]}	ipAddressList
	${value1} =    Run Keyword If	  '${type}' == 'IPV4'   Get From List    ${interconnectIP}    0     ELSE    Get From List    ${interconnectIP}    1
	${value} =    Get From Dictionary    ${value1}    ipAddress
	[Return]	${value}
	
SHOW INTERCONNECT EBIPAV6
    [Documentation]    Gets the IPV6 address from OA
    ...   {bay} = desired bay for given device
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}    ${bay}
	
    Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Process_Sleep_Time}
    write    show interconnect info ${bay}
	sleep    ${Command_Execute_Sleep_Time}
    ${Id} =  Read Until    Platform>
	write    show interconnect info ${bay}
	sleep    ${Command_Execute_Sleep_Time}
    ${Id} =  Read Until    Platform>
    Log to console and logfile      ${Id}
    @{lines}=   Split to lines  ${Id}
    :FOR  ${line}   IN           @{lines}
                
    \   ${Lines_2}=    Get Lines Containing String     ${line}      EBIPA Address
    \   ${Lines_1}=    Get Lines Containing String     ${line}     DHCPv6 Address
    \   ${Count2}=    Get Line Count    ${Lines_2}
    \   ${Count1}=    Get Line Count    ${Lines_1}
    \          Run Keyword If    '${Count2}' == '1'           Exit For Loop
    \          Run Keyword If    '${Count1}' == '1'              Exit For Loop
    Log to console and logfile      ${line}            
    @{words} =    Split String           ${line}   Address:${SPACE}
    Close All Connections
    [Return]    ${words[1]}    
 

DISABLE EBIPAV6
	[Documentation]    Used to disable ebipav6 for a particular interconnect
	...    {OA_HOST} = OA IP of the enclosure
	...    {bay} = desired bay for given device
	[Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
    Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Command_Execute_Sleep_Time}
    Write    disable ebipav6 interconnect ${bay}
	sleep    ${Command_Execute_Sleep_Time}
	Write    yes
	sleep    ${Process_Sleep_Time}
	${command_output} =	Read Until    >
	Log to console	${command_output}
	Write    poweroff interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Write    poweron interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Close All Connections
	Log to console    Successfully disabled ebipa
	
SET EBIPAV6

	[Documentation]    Used to set ebipav6 for a particular interconnect
	...    {OA_HOST} = OA IP of the enclosure
	...    {bay} = desired bay for given device
	...    {ip} = Ip that needs to be set to the interconnect
	[Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}    ${ip}
	
    Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Command_Execute_Sleep_Time}
	Write    set ebipav6 interconnect ${ip} ${bay}
	sleep    ${Command_Execute_Sleep_Time}
	Write    yes
	sleep    ${Process_Sleep_Time}
	${command_output} =	Read Until    >
	Log to console	${command_output}
	Close All Connections
	Log to console    Successfully set ebipav6 for the interconnect
	
ENABLE EBIPAV6

	[Documentation]    Used to enable ebipav6 for a particular interconnect
	...    {OA_HOST} = OA IP of the enclosure
	...    {bay} = desired bay for given device
	[Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
	Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Command_Execute_Sleep_Time}
    Write    enable ebipav6 interconnect ${bay}
	sleep    ${Command_Execute_Sleep_Time}
	Write    yes
	sleep    ${Process_Sleep_Time}
	${command_output} =	Read Until    >
	Log to console	${command_output}
	Write    poweroff interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Write    poweron interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Close All Connections
	Log to console    Successfully Enabled ebipa
	
####Precheck for the presence of Module#######
	
Precheck for IC in OA
	[Documentation]    prechecks the presence of hill module in enclosure
	${ICtype_Uris} =	Create List
    Log to console and logfile    ${APPLIANCE_IP}
	${resp} =    Enclosure Preview    ${APPLIANCE_IP}    ${enclosure_preview}
    Log to console and logfile    ${resp}
	${interconnectMapTemplate}      Set Variable    ${resp['logicalInterconnectGroup']['interconnectMapTemplate']}
	Set Global Variable    ${interconnectMapTemplate_Global}    ${interconnectMapTemplate} 
	:FOR	${x}	IN RANGE	0	${8}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary 	${interconnectMapTemplate['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	Run Keyword If    '${permittedInterconnectTypeUri}' != 'None'    Append To List    ${ICtype_Uris}    ${permittedInterconnectTypeUri}	
	Log to console and logfile    ${ICtype_Uris}
	
	${ICtype_Names} =	Create List
	:FOR	${y}	IN    @{ICtype_Uris}
	\	${string} =    Fetch From Right    ${y}    /
	\	${param} =	Catenate	SEPARATOR=	/	${string}
	\	${IC_Details} =    Fusion Api Get Interconnect Types    param=${param}
	\	Append To List    ${ICtype_Names}    ${IC_Details['name']}
	Log to console and logfile    ${ICtype_Names}
	Should Contain    ${ICtype_Names}    ${Module_name}    --exitonfailure
	Log to console and logfile    Hill module is present in the enclosure. Hence proceeding with the test case.
	
########LI and LIG Consistency State#####

Get LI LIG Consistency
	[Documentation]    gets the consistency status
	[Arguments]    ${LI_Consistent}
	${resp} = 	Fusion Api Get Li
	#Log to console and logfile		${resp}
	${li_state} =	Get From Dictionary		${resp['members'][0]}	consistencyStatus  
	Log to console and logfile		${li_state}
	Run Keyword If    '${li_state}' == '${LI_Consistent}'    Log to console    \n\nThe LI is ${li_state} with LIG    Fail    "The LI is ${li_state} with LIG"

	
#######IC State####

Validate IC State
	[Documentation]    validates the ic state
	[Arguments]    ${IC_State}
	${resp} =	Get IC State
	#Log to console and logfile    \n\n${resp}
	${len} = 	Get Length	${resp}
	:FOR	${x}	IN RANGE	0	${len}
	\	Run Keyword If    '${resp[${x}]}' == '${IC_State}'    Log to console    \nThe state of IC(HILL Module) is ${resp[${x}]}    Fail    "The state of IC(HILL Module) is not ${resp[${x}]}"
	
Get IC Model
	[Documentation]    gets the IC model
	${resp} =   fusion api get interconnect
    ${ic_model} =    Create List
	${ic_uri} =    Create List
	${ic_name} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	${len} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${len}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${Module_name}'		Continue For Loop
	\   Append to list      ${ic_model}  ${ic['model']}
	\   ${uri} =     Get From Dictionary   ${ic}    uri
	\   Append to list      ${ic_uri}  ${uri}
	\	${name} =     Get From Dictionary   ${ic}    name
	\   Append to list      ${ic_name}  ${name}
	\	Log to console and logfile		\n\nPresence of Module with their respective name and uri ${ic['model']} : ${uri} : ${name}
	[Return]    ${ic_model} : ${ic_uri} : ${ic_name}

Get IC State
	[Documentation]    gets the current state of the IC
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	#Log to console and logfile	${ics}
	${l} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${Module_name}'		Continue For Loop
	\   ${uri} =     Get From Dictionary   ${ic}    uri
	\	${name} =     Get From Dictionary   ${ic}    name
	\	${state} =    Get From Dictionary   ${ic}    state
	\	Log to console and logfile		\n\n${ic['model']} : ${uri} : ${name} : ${state}
	\   Append to list      ${ic_list}  ${state}
	\	Log To Console		\nGet IC:${ic_list} 
	[Return]    ${ic_list}
	
###SNMP Keywords###
Open SNMP Client and Login
	[Documentation]    opens the client and login
	[Arguments]         ${SSH_SNMP_IP}=localhost   ${SSH_USER}=root	
    Open Connection     ${SSH_SNMP_IP}     timeout=180s
    Set Suite variable  ${SSH_PASS}     ${SNMP_Password}
    Login               ${SSH_USER}     ${SSH_PASS}
	log to console    Logged into the Snmp client : ${SSH_SNMP_IP}

Clear Trap
	[Documentation]    clears existing traps
	Write	 cd SNMP
	Write    > vcmtrap2.log
	Close All Connections
		
Get Remote files
	[Documentation]    gets the file from remote machine
     [Arguments]    ${host}     ${user}     ${pwd}    ${query}
     Open Connection  ${host}
     Login    ${user}    ${pwd}
     Log To Console     Logged in to SNMP Client
     SSHLibrary.Get File    ${query}
     Log To Console     Files copied to
     close all connections
	 	
Perform an LI Update From Group
	[Documentation]    performs LI UFG
	[Arguments]       ${li}=${LE}-${LIG1}     ${timeout}=10 min    ${interval}=30s
    ${resp} =       Fusion Api Update from group    ${li}
    ${task} =       Wait For Task       ${resp}     ${timeout}        ${interval}
    ${valDict} = 	Create Dictionary	status_code=${200}
	...									taskState=Completed
	Validate Response    ${task}    ${valDict}
	
GET SERIAL AND PART NUMBER FROM OA
    [Documentation]    Gets the hostname for the given bay
    ...   {bay} = desired bay for given device
    [Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
	Open Connection And Log In OA    ${OA_HOST}
	Write    show interconnect info ${bay}
	sleep    ${Command_Execute_Sleep_Time}
    ${Id} =  Read Until    >
    Log to console and logfile      ${Id}
    @{lines}=   Split to lines  ${Id}
    :FOR  ${line}   IN           @{lines}
                
    \   ${Lines_2}=    Get Lines Containing String     ${line}      Part Number
    \   ${Count2}=    Get Line Count    ${Lines_2}
    \          Run Keyword If    '${Count2}' == '1'              Exit For Loop

	Log to console and logfile     Part ${line}
	:FOR  ${line}   IN           @{lines}
	
    \   ${Lines_1}=    Get Lines Containing String     ${line}     Serial Number
	\   ${Count1}=    Get Line Count    ${Lines_1}
    \          Run Keyword If    '${Count1}' == '1'              Exit For Loop
	Log to console and logfile     Serial ${line}
	
    @{Serial} =    Split String           ${Lines_1}   Number:${SPACE}
	@{Part} =    Split String           ${Lines_2}   Number:${SPACE}
	
	Close All Connections
    [Return]    ${Serial[1]}    ${Part[1]}
	
GET HOSTNAME FROM OA
    [Documentation]    Gets the hostname for the given bay
    ...   {bay} = desired bay for given device
    [Arguments]      ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}    ${INTERCONNECT_USER}    ${INTERCONNECT_PASS}
	${INTERCONNECT_HOST} =	SHOW INTERCONNECT     ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	Log to console and logfile    ${INTERCONNECT_HOST}
	Open Connection     ${INTERCONNECT_HOST}     prompt=>    timeout=30s    
	Login               ${INTERCONNECT_USER}     ${INTERCONNECT_PASS}
	Write    hostname
	sleep    ${Command_Execute_Sleep_Time}
	${Id} =  Read Until    >
	@{lines}=   Split to lines  ${Id}
    Log to console and logfile      ${lines[0]}
	
    Close All Connections
    [Return]    ${lines[0]}
	
CHANGE HOSTNAME FROM OA
    [Documentation]    Gets the hostname for the given bay
    ...   {bay} = desired bay for given device
    [Arguments]      ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}    ${INTERCONNECT_USER}    ${INTERCONNECT_PASS}     ${name}
	${INTERCONNECT_HOST} =	SHOW INTERCONNECT     ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
	Open Connection     ${INTERCONNECT_HOST}     prompt=>    timeout=10s    
    Login               ${INTERCONNECT_USER}     ${INTERCONNECT_PASS}
	Write    hostname ${name}
	sleep    ${Command_Execute_Sleep_Time}
	${Id} =  Read Until    >
	@{lines}=   Split to lines  ${Id}
	Write    hostname
	sleep    ${Command_Execute_Sleep_Time}
	${Id} =  Read Until    >
	@{lines}=   Split to lines  ${Id}
    #Log to console and logfile      ${lines[0]}
	
    Close All Connections
    [Return]    ${lines[0]}

GET SERIAL AND PART NUMBER FROM REST
	[Documentation]    gets serial number from rest
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	Log to console and logfile    ${resp}
	${SerialNumber} = 	Get From Dictionary		${resp['members'][0]}	serialNumber
	${partNumber} = 	Get From Dictionary		${resp['members'][0]}	partNumber
	${hostname} =              Get From Dictionary                       ${resp['members'][0]}   hostName
	Log to console and logfile    ${hostname}
    [Return]               ${SerialNumber}    ${partNumber}    ${hostname}

	
Disable The Auto Generated Mac,Wwn,Sn Ranges
	[Documentation]    disable the auto generated ranges
	${resp_mac} =    Fusion Api Get Vmac Range    uri=/rest/id-pools/vmac
	${mac_uri} =    Get From Dictionary    ${resp_mac}    rangeUris
	${disable_mac} =    Fusion Api Edit Vmac Range    ${dis_mac}    ${mac_uri[0]}
	Run keyword unless    ${disable_mac['status_code']} == 200    Fail    "Unable to disable Vmac range"
	${resp_wwn} =    Fusion Api Get Vwwn Range    uri=/rest/id-pools/vwwn
	${wwn_uri} =    Get From Dictionary    ${resp_wwn}    rangeUris
	${disable_wwn} =    Fusion Api Edit Vwwn Range    ${dis_wwn}    ${wwn_uri[0]}
	Run keyword unless    ${disable_wwn['status_code']} == 200    Fail    "Unable to disable Vwwn range"
	${resp_sn} =    Fusion Api Get Vsn Range    uri=/rest/id-pools/vsn
	${sn_uri} =    Get From Dictionary    ${resp_sn}    rangeUris
	${disable_sn} =    Fusion Api Edit Vmac Range    ${dis_sn}    ${sn_uri[0]}
	Run keyword unless    ${disable_sn['status_code']} == 200    Fail    "Unable to disable Vsn range"
	
Build support dump payload
	[Documentation]    support dump payload
	[Arguments]		${name}		${encrypt}
	${payload_dict}=   Create Dictionary  errorCode=${name}
    ...									  encrypt=${encrypt}
    ...									  excludeApplianceDump=false
   	Logger		The support dump payload is : ${payload_dict}		DEBUG
    [return]	${payload_dict}
	
Logger
	[Documentation]		Logs the messages for particular level mentioned. Eg: Logger *messages  DEBUG	| Now supporting INFO and DEBUG				
	[Arguments]		${message}		${Arg_log}=None
	Run Keyword If		'${Arg_log}'=='None' 	Log to console 		${message}
	Run Keyword If		'${Arg_log}'=='DEBUG' and '${loggerlevel}'=='DEBUG'		Log to console		${message}
	
Validate the response 
	[Documentation]    validation
	[Arguments]		${resp}
	${resp_uri} =	Get from dictionary		${resp}		uri
	#Wait Until Keyword Succeeds  ${timeout}    ${polling_time}  Validate computedPercentComplete   ${resp}
	${resp} =	Fusion api get resource		${resp_uri}
	${taskstate} = 		Get from dictionary		${resp}		taskState
	logger		${taskstate}		DEBUG
	${taskerror} =		Get from dictionary		${resp}		taskErrors
	Run keyword If 		'${taskstate}' != 'Completed'		 Task Error		${taskerror}	${resp_uri}
	[return]	${resp}
	
Task Error
	[Documentation]    finds task errors
	[Arguments]		${taskerror}	${resp_uri}
	Logger	taskeror : ${taskerror}		DEBUG	
	${error_code} =		Get from dictionary		${taskerror[0]} 	errorCode
	${message} =	Get from dictionary 	${taskerror[0]}		message
	Fail	msg= Failed for the uri ${resp_uri} due to ${error_code} \n Additional Info : ${message}

Pass With Warnings
	[Documentation]    pass with warnings
	[Arguments]		${msg}
	Log		${msg}		WARN
	Pass Execution		Test case skipped, check the above warning message for info

Power off server
	[Documentation]    power off a particular server
	[Arguments]     ${server}
	[Documentation]	Querys the appliance for a server by name and then Powers it off
	Log to console  Powering off ${server}
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=PressAndHold
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${s}	IN	@{servers['members']}
	\       Continue For Loop If	  '${s['name']}' != '${server}'
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${s['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	10s

OA CLI Restart Interconnect
	[Documentation]    issues an Restart command to the given Interconnect Bay.
	[Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${BAY}
	Open Connection     ${OA_HOST}
    Login               ${OA_USER}     ${OA_PASS}
    Write    RESTART INTERCONNECT ${BAY}
	Read Until    Are you sure you want to reset the Interconnect?
	Write    YES
    Close All Connections

Wait For Task1
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=600 s	${interval}=40 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate1	${resp}
	[Return]	${task}

Task Reached Endstate1
	[Documentation]	Waits for a task to reach and checks end-state
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['headers']['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}

Cleanup For Suite	
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[Cleanup]
	Login to OneView via REST
	Power off ALL Servers
	Remove All Server Profiles
	Remove ALL Enclosures
	Remove ALL Enclosure Groups
	Remove ALL LIGs
	Remove ALL Ethernet Networks
	Remove ALL FC Networks