*** Settings ***
Library			RoboGalaxyLibrary
Library			FusionLibrary
Library			OperatingSystem
Library			BuiltIn
Library			Collections
Library		    SSHLibrary
Library			String
Library 		c7000_login_redistribution

Variables		${DATA}								
#Variables		errors.py
#Variables		licenses.py
Variables		data_variables.py

*** Variables ***
${APPLIANCE_IP}     ${None}
${DATA}			data_variables.py
${VM}			${None}
${VMSETUP}		no
${FTS}			no
${CONFIGURE}		no
${None}		None

*** Keywords ***
#######################################
# SETUP WORFLOWS - Variables
#######################################
Get Logical Downlink from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${downlinkuri}
	
	
	${resp} = 	Fusion Api Get Logical Downlink		uri=${downlinkuri['enclosureTypeUri']}
	
	${li_downlink} =	Copy Dictionary		${li_downlink}
    Log to console and logfile		${li_downlink['module1']}
	${l} = 	Get Length	${resp['members']}
	
	
	:FOR	${x}	IN RANGE	0	${l}		
	\	@{words} = 	Split String	${resp['members'][${x}]['name']}	(
	\	${type} = 	Get From List	${words}	1
	\	Log to console and logfile	FFFF ${type}
	\	${Data}      Set Variable    ${resp['members'][${x}]}
	\	Log to console and logfile	FFFF1 ${li_downlink['module1']}
	\	Run keyword if	'${type}' == '${li_downlink['module1']}'	Exit For Loop
	Log to console and logfile		pppppppppppppppppppppppppp
	Log to console and logfile		${Data['downlinkPortCapability']['downlinkSubPorts']}
	Log to console and logfile		pppppppppppppppppppppppppp
	Log to console and logfile		${li_downlink['Ports']}
	Dictionaries Should Be Equal	${Data['downlinkPortCapability']['downlinkSubPorts']}	${li_downlink['Ports']}	msg=Response does not match validation dictionary	values=True
	
	Log to console and logfile  	AAAAAA
	Log to console and logfile		completed
	[Return]	${resp}
	
Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	Log to console and logfile  	Adding LICENSES	
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}
	\		Run keyword if 		${resp['status_code']} != ${201}	    Log     Error adding License Key:${license['key']}   WARN

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	Log to console and logfile  	Adding USERS	
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding ETHERNET NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FC NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}
	[Return]	${resp}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FCOE NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding NETWORK SETS	
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}		
	\		${nativeNetworkUri} = 	Run Keyword If 	'${net['nativeNetworkUri']}' != 'None'		Get Ethernet URI	${net['nativeNetworkUri']}
	\		Set To Dictionary 	${net}	nativeNetworkUri	${nativeNetworkUri}		
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}
	Log to console and logfile  	Adding RANGES	
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
	\ 	${resp} =	Run Keyword If 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range		body=${range}		
	[Return]	${resp}

Process InterconnectMapTemplate
	[Arguments]		${icmap}
	${l} = 	Get Length	${icmap['interconnectMapEntryTemplates']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	${permittedInterconnectTypeUri} = 	Get Interconnect Type URI	${permittedInterconnectTypeUri}
	\	Set to dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri		${permittedInterconnectTypeUri}
	[Return]	${icmap}

Add LIG from variable
	[Documentation]	Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ligx}
	#Log to console and logfile  	Adding LIG ${ligx['name']}
	
	${ligx} = 	Copy Dictionary	${ligx}
	#Log to console and logfile	${ligx}
    ${name} =                       Get Variable Value  ${ligx['name']}
    #Log to console and logfile	${name}
	${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
	${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
	${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
	${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
	${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
	${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
	#${uplinkSets} = 	Copy List	${ligx['uplinkSets']}
	#Log to console and logfile	${uplinkSets}
	${l} = 	Get Length	${uplinkSets}
	#Log to console and logfile	${l}
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}
	
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	    ${networkUris}
	\   ${nativeNetworkUri} = 	Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri	${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}	nativeNetworkUri     ${nativeNetworkUri}
	#Log to console and logfile	${ethernetUris}
    # Process Internal URIs
	${internalNetworkUris} = 	Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris	${internalNetworkUris}
	#Log to console and logfile	${internalNetworkUris}
	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
	#Log to console and logfile	${body}
	${resp} = 	Fusion Api Create LIG	${body}
	# to console and logfile	${resp}
	${task} =	Wait For Task	${resp} 	60s	20s
	#Log to console and logfile	${task}
	${liguri} = 	Get From Dictionary	${task['associatedResource']}	resourceUri		
	[Return]	${resp}

Add Enclosure Group from variable
	[Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${enc_group}
	#Log to console and logfile		${enc_group['name']}
	#Log to console and logfile		${enc_group}
	#Log to console and logfile  	Adding ENCLOSURE GROUP ${enc_group['name']}
	${l} = 	Get Length	${enc_group['interconnectBayMappings']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${liguri} = 	Get From Dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
	\   Continue For Loop If    '${liguri}' == 'None'
	\	${liguri} = 	Common URI Lookup by name    ${liguri}
	\	Set to dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}	
	${resp} =	Fusion Api Create Enclosure Group	${enc_group}
	[Return]	${resp}

Common URI lookup by name
	[Documentation]	Takes a string containing URI type + : + resource name, performs a lookup and returns URI
	...				Ex:    ${uri} = 	Common Lookup by name	LIG:LIG1
	[Arguments]		${uri}
	@{words} = 	Split String	${uri}	:
	${type} = 	Get From List	${words}	0
	${name} = 	Get From List	${words}	1
	${uri} = 	Run Keyword If 	'${type}' == 'EG'		Get Enclosure Group URI		${name}
	...         ELSE IF         '${type}' == 'ENC'		Get Enclosure URI		    ${name}
	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URI			${name}
	...			ELSE IF			'${type}' == 'FC'		Get FC URI					${name}
	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URI				${name}
	...			ELSE IF			'${type}' == 'LI'		Get LI URI					${name}
	...			ELSE IF			'${type}' == 'LIG'		Get LIG URI					${name}
	...			ELSE IF			'${type}' == 'NS'		Get Network Set URI			${name}
	...			ELSE IF			'${type}' == 'SH'		Get Server Hardware URI		${name}
	...			ELSE IF			'${type}' == 'US'		Get Uplink Set URI			${name}
	...			ELSE IF			'${type}' == 'LSG'		Get LSG URI					${name}
	...		    ELSE IF			'${type}' == 'switchype'    Get lsgs Member					${name}
	...			ELSE			Set variable			ResourceTypeNotFound:${type}

	[Return]	${uri}

Add Enclosures from variable
	[Documentation]	Adds Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${encs_m}
	Log to console and logfile  	Adding ENCLOSURES
	Log to console and logfile  	${encs_m}
	:FOR	${enc}	IN	@{encs_m}
	\	${encuri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	\	${encuri} = 	Common URI Lookup by name    ${encuri}
	\	Set to dictionary	${enc}	enclosureGroupUri		${encuri}
	\	${resp} =	Fusion Api Add Enclosure 	${enc}
	\	${task} =	Wait For Task1	${resp} 	40min	20s
	[Return]    ${resp}

Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}
	Log to console and logfile  	Adding LOGICAL ENCLOSURE
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	${eguri} = 	Common URI Lookup by name    ${eguri}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
	Set to dictionary	${enc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\       ${encuri} = 	Common URI Lookup by name    ${encuri}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${enc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Create Logical Enclosure 	${enc}
	${task} =		${resp} 	120min	1min
	

Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILES	
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	Log to console and logfile	${profile}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	Log to console and logfile	${eg}
	\	${uri} = 	Common URI Lookup by name    ${eg}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri
	\	Log to console and logfile	${enc} 
	\	${uri} = 	Common URI Lookup by name    ${enc}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	Log to console and logfile	${connections}
	\	${connections} = 	Lookup Connection Uris	${connections}
	\	Log to console and logfile	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	Log to console and logfile	${resp}
	\	${task} =   Wait For Task	${resp}		timeout=13 mins		interval=10s
	\	Log to console and logfile	${task}
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)
	[Return]    ${resp}

Add Server Profile Templates from variable
	[Documentation]	Adds Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILE TEMPLATES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	${sht} = 	Get from Dictionary	${profile}	serverHardwareTypeUri
	\	${uri} = 	Common URI lookup by name		${sht}
	\	Set to Dictionary	${profile}	serverHardwareTypeUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	${uri} = 	Common URI Lookup by name	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile template		body=${profile}
	\   # TODO: Change timeout!
	\	${task} =   	${resp}		timeout=1 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)


Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	Log to console and logfile    Creating connection uris
	${conns} =  Create List
	Log to console and logfile	${conns}
	:FOR	${connection}	IN	@{connections}
	\   ${connection} =     Copy dictionary     ${connection}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	Log to console and logfile    ${words}
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1	
	\	${net} = 	Create List	${net}
	\	Log to console and logfile    ${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Log to console and logfile    ${uri}
	\	Set to Dictionary	${connection}	networkUri	${uri}
	\   append to list  ${conns}    ${connection}
	[Return]	${conns}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable ALL Generated ID Ranges
	[Documentation]	Enables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Enable Generated VSN Range	${rangeUri}

Enable Generated VMAC Range
	[Documentation]	Enables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VWWN Range
	[Documentation]	Enables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VSN Range
	[Documentation]	Enables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword as user
	[Documentation]		Runs a Fusion_API keyword as a particular user.
	...					Ex:		Run Keyword As User		nat		Fusion Api Get Ethernet Networks	${empty}	param=?filter="'name'=='net_101'"
    [Arguments]     ${user}     ${keyword}      @{varargs}
    ${original_user} =   Fusion Api Get Active user
	${active_sessions} = 	Fusion Api Get Active Sessions
	Dictionary Should Contain Key	${active_sessions}	${user}
    Fusion Api Switch Active User   ${user}
    ${resp} =   Run Keyword and continue on failure     ${keyword}  @{varargs}
    Fusion Api Switch Active User   ${original_user}
    [Return]    ${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument
	[Arguments]	${list}	${keyword}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}	${x}
		
#######################################
# COMMON KEYWORDS
#######################################
Build LIG body
	[Arguments]		${xlig}
	${xlig} = 	Copy Dictionary	${xlig}
	${uplinkSets} = 	Copy List	${xlig['uplinkSets']}
	${l} = 	Get Length	${uplinkSets}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	${name} =                       Get Variable Value  ${xlig['name']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
	${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
	${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
	${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	#${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
    [Return]    ${body}

Build US body
	[Arguments]		${us}	${li_uri}
	Set to dictionary	${us}	logicalInterconnectUri	${li_uri}
	${l} = 	Get Length	${us['portConfigInfos']}
	:FOR	${x}	IN RANGE	0	${l}
	\   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}	enclosure
	\   ${enc_uri_1} =        Get Enclosure Uri   ${enc_uri}
	\	Set To Dictionary		${us['portConfigInfos'][${x}]}	enclosure	${enc_uri_1}

	# process eth
	${networks} = 		Get From Dictionary		${us}	networkUris
	${networkUris} = 	Get Ethernet Uris	${networks}
	Set to dictionary	${us}	networkUris	${networkUris}
	# process fc
	${networks} = 		Get From Dictionary		${us}	fcNetworkUris
	${networkUris} = 	Get FC Uris	${networks}
	Set to dictionary	${us}	fcNetworkUris	${networkUris}
	# process fcoe
	${networks} = 		Get From Dictionary		${us}	fcoeNetworkUris
	${networkUris} = 	Get FCoE Uris	${networks}
	Set to dictionary	${us}	fcoeNetworkUris	${networkUris}

	${body} = 		Fusion Api Create Uplink Set Payload	${us}
	[Return]	${body}



Create Network Set range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding NETWORK SET RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end
	${netlist} = 	Create List
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Append To List	${netlist}	${range['prefix']}${x}${range['suffix']}
	${networkUris} = 	Get Ethernet URIs	${netlist}
	Set To Dictionary 	${body}	networkUris	${networkUris}
	${nativeNetworkUri} = 	Run Keyword If 	'${range['nativeNetworkUri']}' != 'None'  Get Ethernet URI	${range['nativeNetworkUri']}
	Set To Dictionary 	${body}	nativeNetworkUri	${nativeNetworkUri}
	${resp} = 	Fusion Api Create Network Set		body=${body}
	[Return]	${resp}

Create Ethernet range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding ETHERNET NETWORK RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end

	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Set To Dictionary 	${body}	name	${range['prefix']}${x}${range['suffix']}
	\	Set To Dictionary 	${body}	vlanId	${x}
	\	${resp} = 	Fusion Api Create Ethernet Network	body=${body}

Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding FCOE NETWORK RANGES
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-network
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\		${resp}

Get connectionTemplateUri
	[Documentation]	Retrieves the connectionTemplateUri from a given network {name} of a given {type} where:
	...             {name} is the name of the network
	...             {type} is the type of network: [ethernet, fc, fcoe], default=ethernet
	...             Returns: connectionTemplateUri string
	[Arguments]		${name}   ${type}=ethernet
    Set Log Level	DEBUG
    ${param} =      Set Variable    ?filter="'name'=='${name}'"
	${net} =		Run Keyword If          '${type}' == 'ethernet'      Fusion Api Get Ethernet Networks    param=${param}
	...             ELSE IF                 '${type}' == 'fc'            Fusion Api Get fc Networks          param=${param}
    ...             ELSE IF                 '${type}' == 'fcoe'          Fusion Api Get fcoe Networks        param=${param}
    ...             ELSE                    Log     Invalid network type specified for 'Get connectionTemplateUri'     WARN
	${ct_uri} =     Get From Dictionary      ${net['members'][0]}    connectionTemplateUri

    [Return]    ${ct_uri}

Get Enclosure URI
	[Arguments]		${enc}
	${resp} = 	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Enclosure Group URI
	[Arguments]		${eg}
	#Log to console and logfile	Get Enclosure Group Uri
	${resp} = 	Fusion Api Get Enclosure Groups
	#Log to console and logfile	${resp}
	#Log to console and logfile	encl members
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}		
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${eg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get Ethernet URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Network Set URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}
	
Get Ethernet URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}	

Get FC URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FC URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get FCoE URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FCoE Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FCoE URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Fcoe Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get IC URI
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Get Interconnect Type URI
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect Types 		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LI member
	[Arguments]		${li}
	${resp} = 	    Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${member} = 	Get From List		${resp['members']}  ${x}
	[Return]	${member}

Get LI URI
	[Arguments]		${li}
	${resp} = 	Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LS URI
	[Arguments]		${ls}
	${resp} = 	Fusion Api Get Ls
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${ls}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LSG URI
	[Arguments]		${lsg}
	${resp} = 	Fusion Api Get Lsg
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${lsg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get Switch URI
    [Arguments]		${sw}
	${resp} = 	Fusion Api Get Switch
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${sw}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LIG member
	[Arguments]		${lig}
	${resp} = 	    Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${member} = 	Get From List		${resp['members']}  0
	[Return]	${member}

Get LIG URI
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Get Network Set URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Resource by URI
	[Documentation]    Returns any type of resource using its URI
	[Arguments]	${uri}   @{varargs}
    ${resp} =     Fusion Api Get Resource    ${uri}    @{varargs}
	[Return]    ${resp}

Get Scope URI

    [Arguments]		${scope}
	${resp}     Fusion Api Get Scope		param=?filter="'name'=='${scope}'"
	${l} =     Get Length    ${resp['members']}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${scopename} =  Get Variable value        ${resp['members'][${x}]}
	\   Run Keyword If     '${scopename['name']}' != '${scope}'        Continue For Loop
    \   ${uri} =     Get From Dictionary        ${resp['members'][${x}]}    uri
	[Return]	${uri}

Get Server Hardware URI
	[Arguments]		${enc_server}
	${resp} = 	Fusion Api Get Server Hardware
	${shlist} = 	Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} = 	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} = 	Get From dictionary 	${sh}	uri
	[Return]	${uri}

Get Server Hardware Type URI
	[Arguments]		${sht}
	Set Log Level	TRACE
	${resp} = 	Fusion Api Get Server Hardware Types    param=?filter="'name'=='${sht}'"
	${uri} = 	Get From dictionary 	${resp['members'][0]}	uri
	[Return]	${uri}


Get Uplinkset URI
	[Arguments]		${us}
	${resp} = 	Fusion Api Get Uplink Set 		param=?filter="'name'=='${us}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Log to console and logfile
	[Arguments]	${data}     ${level}=INFO
	Log	${data}     ${level}
	Log to console	${data}


Wait For Task
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	Log to console	${resp}
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate	${resp}
	Log to Console		${task}
	[Return]	${task}

Task Reached Endstate
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}

Wait For Appliance To Be Ready
	[Documentation]	Waits for an appliance reach a the ready state
	[Arguments]		${appliance}	${timeout}=25 min	${interval}=30 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance Reached Ready State	${appliance}	

Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	Log to console and logfile 		Pinging: ${appliance} ...
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance is pingable 	${appliance}	

Appliance is pingable 
	[Arguments]		${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	Windows ping	${appliance}
	...	ELSE	Unix ping	${appliance}

Unix ping
	[Arguments]		${host}
    ${Output}=    Run    ping -c 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
	[Return]	${Output}
	
Windows ping
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    TTL=
	[Return]	${Output}
		
Appliance Reached Ready State
	[Arguments]		${appliance}
	${state} = 	Fusion Api Get Resource		${appliance}/controller-state.json
	Log to console and logfile	-Appliance state: ${state['state']}
	Should Match Regexp	${state['state']}	((?i)OK)
	
First Time Setup
	[Documentation]	Changes intial administrator password, answers EULA, enables service access, adds licenses, configures appliance interfaces.
	...	If args are null, uses XML ${DATAFILE}
	[Arguments]	${DATAFILE}=${null}	${password}=${null}	${interfaces}=${null}
	#${password} =	Set Variable	${password}
	Log to console and logfile	[FIRST TIME SETUP]
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}		
	Wait For Appliance To Be Ready			${APPLIANCE_IP}
	Log to console and logfile	-Agree to EULA	
	Fusion Api Save EULA	${APPLIANCE_IP}
	Log to console and logfile	-Enable service access
	Fusion Api Set service access	${APPLIANCE_IP}

	${req} = 		Create Dictionary		newPassword=${password}
	...										oldPassword=admin
	...										userName=Administrator
	#Run Keyword If	${password} is not ${null}	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	#Add licenses from variable		${licenses}
	Configure Appliance Interfaces	
	
Configure Appliance Interfaces
	Log to console and logfile	-Configuring Appliance Interfaces, Time, Locale
	${resp} =	Fusion Api Get Appliance Interface Mac	eth0
	Set to dictionary	${appliance['applianceNetworks'][0]}	macAddress	${resp}	
	${ipv4Type} = 		Get Variable Value 	${appliance['applianceNetworks'][0]['ipv4Type']}
	${app1Ipv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['app1Ipv4Addr']}
    ${virtIpv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['virtIpv4Addr']}
	Sleep 	10s			
	${resp} = 	Fusion Api Configure Appliance Interfaces			${appliance}
	# if STATIC, get new IP and login. for 2.00, use virtIpv4Addr (Tbird), otherwise use app1Ipv4Addr
    Run Keyword If	'${virtIpv4Addr}' is not 'None'     			Set New IP and Login	${virtIpv4Addr}
	...             ELSE IF     '${app1Ipv4Addr}' is not 'None'     Set New IP and Login	${app1Ipv4Addr}
	...             ELSE    Log     Either app1Ipv4Addr or virtIpv4Addr must be provided in the 'appliance' variable in your data file     WARN

		${resp}		timeout=200s		interval=5s
	${resp} = 	Fusion Api Configure Appliance Time and Locale			${timeandlocale}
		${resp}		timeout=200s		interval=5s
	
Set New IP and Login
	[Arguments]	${IP}
	Set Suite Variable		${APPLIANCE_IP}	${IP}
	Sleep 	60s	
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	
Login all users
	[Arguments]     ${users}
	Set Log Level	TRACE
	${original_user} =    Fusion Api Get Active User
	:FOR	${user}	IN	@{users}
	\	${user_and_pass} = 	Create Dictionary	userName=${user['userName']}	password=${user['password']}
	\	Fusion Api Login Appliance 		${APPLIANCE_IP}		${user_and_pass}
	Fusion api switch active user    user=${original_user}


# -----------------------------------------------------------------------------
#   EM KEYWORDS
# -----------------------------------------------------------------------------
Get EM IP
	Set Log Level	TRACE
    # Get EM IP
    # TODO:  going to need to see how this works with multiple EM's
    ${EM_IP} =  Execute SSH Command     lldpcli show neighbors
    ${m}    ${EM_IP} =  Should Match Regexp     ${EM_IP}    (?im)MgmtIP:\\s*(\\S*:\\S*:\\S*:\\S*:\\S*:\\S*)
    Set Suite Variable    ${EM_IP}
    log to console     EM IP: ${EM_IP}
    [Return]    ${EM_IP}

Get EM Enclosures
    # Get EM enclosures
    ${EM_ENCS} =   Execute SSH Command     /ci/bin/tbird/appliance-hal.sh list-enclosures
    @{ignore last} =     Split to lines  ${EM_ENCS}  ${null}   -1
    ${EM_ENCS} =        Create List     @{ignore last}
    Set Suite Variable    ${EM_ENCS}
    log to console     Enclosures: ${EM_ENCS}
    [Return]    ${EM_ENCS}

Get EM Token
    [Arguments]     ${enc_serial}
    # Get EM token
    ${EM_TOKEN} =  Execute SSH Command     /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${enc_serial} -o token
    ${EM_TOKEN}    Should Match Regexp    ${EM_TOKEN}    (?i)\\S*
    Set Suite Variable    ${EM_TOKEN}   ${EM_TOKEN}
    log to console     EM TOKEN: ${EM_TOKEN}
    [Return]    ${EM_TOKEN}

Get EM Sessions
    # Get Sessions using session Id to test that everything is working
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Output}    Execute SSH Command
    ...    curl -ikX GET https://${EM_IP}%${FUSION_NIC}/rest/v1/Sessions -H ${Header}
    Should Contain    ${Output}    "Name": "Sessions Collection"
    ...    msg=Get Sessions action failed \n${Output}

EFuse ICM
    [Documentation]    Perform an efuse action on a ICM bay. Action = EFuseOff | EFuseOn
    [Arguments]    ${Action}    ${BayNumber}
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Data}      Set Variable    {"Action":"${Action}"}
	Log to console and logfile  	\t Issuing ${Action} for ICM:${BayNumber}
    ${Output}    Execute SSH Command
    ...    curl -ikX POST -H ${Header} --data-ascii '${data}' https://${EM_IP}%${FUSION_NIC}/rest/v1/InterconnectBays/${BayNumber}
    Should Contain    ${Output}    { "Action": "${Action}" }
    ...    msg=EFuse action failed \n${Output}

IC reached state
	[Arguments]	    ${uri}  ${state}
	Set Log Level	TRACE
    ${resp} =   fusion api get resource     ${uri}
	Log to console and logfile  	\t ${uri}: ${resp['state']}
	Should Match Regexp 	${resp['state']}    ${state}
	[Return]	${resp}

Get IC
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	${l} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${ICM_MODEL}'		Continue For Loop
	\   Append to list      ${ic_list}  ${ic}
	[Return]    ${ic_list}

Get from IC
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}
	

# -----------------------------------------------------------------------------
#   FUSION BASH SHELL INTERFACE KEYWORDS
# -----------------------------------------------------------------------------
Login to Fusion via SSH
    [Documentation]             Connect to Fusion VM Bash via SSH
    ...                         Example:\n| Login to Fusion Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}=${FUSION_IP}      ${USERNAME}=${FUSION_SSH_USERNAME}
    ...                         ${PASSWORD}=${FUSION_SSH_PASSWORD}    ${PROMPT}=${FUSION_PROMPT}
    ...                         ${TIMEOUT}=${FUSION_TIMEOUT}    ${ALIAS}=Fusion_SSH
    Log Many                    ${IP}                   ${USERNAME}     ${PASSWORD}     ${PROMPT}   ${TIMEOUT}
    Set Default Configuration   prompt=${PROMPT}        timeout=${TIMEOUT}
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    [Return]                    ${Id}

Logout of Fusion Via SSH
    [Documentation]     Exits the current Bash SSH session
    ...                 Example:\n| Logout Of Fusion Via SSH |
    Close Connection

Execute SSH Command
    [Documentation]     Executes given command on the Fusion SSH shell
    ...                 Example:\n| Execute CLI Command | show enclosure list |
    [Arguments]         ${Command}      ${PROMPT}=${FUSION PROMPT}
    Login to Fusion via SSH
    SSHLibrary.Write    ${Command}
    ${Output}=          Read until      ${PROMPT}
    Logout of Fusion Via SSH
    [Return]            ${Output}


#######################################
# TEARDOWN WORKFLOWS
#######################################
Suite Teardown
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[TEARDOWN]
	
	Run Keyword If All Tests Passed    Power off ALL Servers
	Run Keyword If All Tests Passed    Remove All Server Profiles
	Run Keyword If All Tests Passed    Remove ALL Enclosures
	Run Keyword If All Tests Passed    Remove ALL Enclosure Groups
	Run Keyword If All Tests Passed    Remove ALL LIGs
	Run Keyword If All Tests Passed    Remove ALL LS
	Run Keyword If All Tests Passed    Remove ALL LSGs
	Run Keyword If All Tests Passed    Remove ALL Ethernet Networks
	Run Keyword If All Tests Passed    Remove ALL FC Networks
	Run Keyword If All Tests Passed    Remove ALL FCoE Networks
	Run Keyword If All Tests Passed    Remove ALL Network Sets
	Run Keyword If All Tests Passed    Remove ALL Users
	Run Keyword If All Tests Passed    Remove ALL Scopes

Remove All Enclosures
	[Documentation]	Querys the appliance for all Enclosures and then removes them
	Log to console	Removing ENCLOSURES	
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} =   Fusion Api Remove Enclosure		uri=${enc['uri']}
	\		${task} =   Wait For Task1  ${resp}     4 minutes 30 seconds
	\       ${val} =       Create Dictionary   taskState=Completed
	\       ${result} =    Validate Response    ${task}	${val}

Remove All Enclosure Groups
	[Documentation]	Querys the appliance for all Enclosure Groups and then removes them
	Log to console      Removing ENCLOSURE GROUPS
	${encs} = 	Fusion Api Get Enclosure Groups
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} =   Fusion Api Delete Enclosure Group		uri=${enc['uri']}
	#\       Log to console  ${resp}
	#\       ${task} =  Wait For Task  ${resp}     240s    30s

Remove All Ethernet Networks
	[Documentation]	Querys the appliance for all Ethernet networks and then removes them
	Log to console	Removing ETHERNET NETWORKS	
	${networks} = 	Fusion Api Get Ethernet Networks
	:FOR	${net}	IN	@{networks['members']}
	\		Log to console	\n-Removing: ${net['name']}
	\		${resp} = 	Fusion Api Delete Ethernet Network		uri=${net['uri']}
	\		${task} =   Wait For Task   ${resp} 	240s	2s

Remove All FC Networks
	[Documentation]	Querys the appliance for all FC networks and then removes them
	Log to console	Removing FC NETWORKS	
	${networks} = 	Fusion Api Get FC Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FC Network		uri=${net['uri']}
	\		${task} =   Wait For Task   ${resp} 	240s	2s

Remove All FCoE Networks
	[Documentation]	Querys the appliance for all FCoE networks and then removes them
	Log to console	Removing FCoE NETWORKS	
	${networks} = 	Fusion Api Get FCoE Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} =   Fusion Api Delete FCoE Network		uri=${net['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	2s

Remove All LIGs
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console	Removing LIGs
	${ligs} = 	Fusion Api Get LIG
	:FOR	${lig}	IN	@{ligs['members']}
	\		${resp} =   Fusion Api Delete LIG		uri=${lig['uri']}
	\		${task} =   Wait For Task       ${resp} 	240s	2s

Remove All LS
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console	Removing LS
	${lsw} = 	Fusion Api Get Ls
	:FOR	${ls}	IN	@{lsw['members']}
	\		${resp} =   Fusion Api Delete LS		uri=${ls['uri']}
	\		${task} =   Wait For Task       ${resp} 	240s	2s

Remove All LSGs
	[Documentation]	Querys the appliance for all LSGs and then removes them
	Log to console	Removing LSGs
	${lsgs} = 	Fusion Api Get Lsg
	:FOR	${lsg}	IN	@{lsgs['members']}
	\		${resp} =   Fusion Api Delete Lsg		uri=${lsg['uri']}
	#\		${task} =   Wait For Task       ${resp} 	240s	2s

Remove All Network Sets
	[Documentation]	Querys the appliance for all Network Sets and then removes them
	Log to console	Removing NETWORK SETS	
	${networks} = 	Fusion Api Get Network Set
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Network Set		uri=${net['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	2s

Power off ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them off
	Log to console	Powering off SERVERS	
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=PressAndHold
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	5s

Power on server
	[Arguments]     ${server}
	[Documentation]	Querys the appliance for a server by name and then Powers it on
	Log to console  Powering on ${server}
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${s}	IN	@{servers['members']}
	\       Continue For Loop If	  '${s['name']}' != '${server}'
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${s['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	10s
	[Return]    ${resp}
	
Power off server
	[Arguments]     ${server}
	[Documentation]	Querys the appliance for a server by name and then Powers it off
	Log to console  Powering off ${server}
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=PressAndHold
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${s}	IN	@{servers['members']}
	\       Continue For Loop If	  '${s['name']}' != '${server}'
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${s['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	10s
	[Return]    ${resp}

Power on ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them on
	Log to console  Powering On SERVERS
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='Off' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	5s

powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	5s
	
Remove All Server Profiles
	[Documentation]	Querys the appliance for all Server Profiles and then removes them
	Log to console  Removing SERVER PROFILES
	${profiles} = 	Fusion Api Get Server Profiles  param=?sort=name:ascending
	:FOR	${profile}	IN	@{profiles['members']}
	\		${resp} = 	Fusion Api Delete Server Profile		uri=${profile['uri']}
	\		${task} =   Wait For Task     ${resp} 	240s	10s

Remove Custom Range
	[Documentation]	Querys the appliance for all CUSTOM vmac, vwwn, vsn ranges and then removes them
	[Arguments]		${uri}
	Log to console  Removing CUSTOM RANGES
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'     Remove VWWN Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	    Remove VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	    Remove VMAC Range	${rangeUri}

Remove VMAC Range
	[Documentation]	Removes a CUSTOM VMAC range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VMAC Range	uri=${uri}

Remove VWWN Range
	[Documentation]	Removes a CUSTOM VWWN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VWWN Range	uri=${uri}

Remove VSN Range
	[Documentation]	Removes a CUSTOM VSN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VSN Range	uri=${uri}

Remove All Users
	[Documentation]	Querys the appliance for all Users and then removes them
	Log to console  Removing USERS
	${users} =  Fusion Api Get User
	:FOR	${user}	IN	@{users['members']}
	\		Continue For Loop If	'${user['userName']}'=='Administrator'
	\		Continue For Loop If	'${user['userName']}'=='administrator'
	\		${resp} =   Fusion Api Remove User		uri=${user['uri']}

Remove All Scopes
    [Documentation]   Querys the appliance for all the scopes and Removes them
    Log to console  Removing Scopes
    ${scopes} =     Fusion Api Get Scope
    :FOR	${scope}	IN	@{scopes['members']}
	\		Log to console	\nRemoving ${scope['name']}
    \		${resp} =   Fusion Api Delete Scope	uri=${scope['uri']}	etag=${scope['eTag']}
	
#######################################
# VALIDATION
#######################################
New Validate Response
    [Documentation]	Validates data in a response body against expected values using REGEX
    ...	looks up ${validation_code} in codes dicitonary
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation_code}
	Set Log Level	TRACE
	${validation} = 	Get From Dictionary	${codes}	${validation_code}
	${validation_results} = 	Fusion Api Validate Response	${resp}	${validation}
	# Log results	
	# Fail if results['passed'] is False
	[Return]	${validation_results}
	
Validate Response
    [Documentation]	Validates data in a response body against expected values
    ...	Example:
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE	
	${response} = 	Copy Dictionary	${resp}	
	@{vkeys} =	Get Dictionary Keys	${validation}
	${rkeys} =	Get Dictionary Keys	${response}
	@{keys} =	Remove all the keys in response that are not in validation	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{keys}
	\	Remove From Dictionary	${response}	${x}
	Dictionaries Should Be Equal	${validation}	${response}	msg=Response does not match validation dictionary	values=True

Validate Response Regex
    [Documentation]	Validates data in a response body against expected values using regex
    ...    Make sure to escape your pattern strings properly!
    ...    Example:
	...    ${valDict} = 	Create Dictionary	status_code=${200}
	...                                     taskState=Error
	...									    taskStatus=Invalid uplink-set: Port: \\d+ for interconnect-type: .* is not an uplink port.
	...    Validate Response Regex		${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE
	${response} =   Copy Dictionary    ${resp}
	@{vkeys} =      Get Dictionary Keys    ${validation}
	:FOR	${x}	IN	@{vkeys}
	\   ${r} =    Convert to string    ${resp['${x}']}
	\   ${v} =    Convert to string    ${valDict['${x}']}
	\   Should Match Regexp		       ${r}   ${v}

Remove all the keys in response that are not in validation
	[Arguments]	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{vkeys}
	\	Remove Values From List	${rkeys}	${x}
	[Return]	${rkeys}

#######################################
# VM
#######################################

VM setup and FTS
	[Arguments]		${VM}
	Log to console and logfile	[VM SETUP]
	Run Keyword If 	'${VMSETUP}' == 'yes'	VM setup		${VM}
	Get VM IP	${VM}
	Run Keyword If 	'${FTS}' == 'yes'		First Time Setup	password=hpvse123

Get VM IP
	[Arguments]		${VM}
    # Skip looking up IP from vCenter if IP provided via command line\suite variable
	Return from Keyword If	'${APPLIANCE_IP}' is not 'None'

	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Retrieving IPv4 Address for ${VM}
	${IPS} = 	Get VM IPv4 Addresses	${VM}
	${APPLIANCE_IP} = 	Get From List	${IPS}	0
	Log to console and logfile	- Found ${APPLIANCE_IP}
    Set Suite Variable		${APPLIANCE_IP}	${APPLIANCE_IP}

VM setup
	[Arguments]		${VM}
	Set Log Level	TRACE
	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Creating snapshot for ${VM}
	Create VM Snapshot	${VM}	oob-snapshot	True	True
	Log to console and logfile	- Powering on ${VM}
	Power On VM 	${VM}
	Log to console and logfile	- Sleeping 2 min while ${VM} boots ...
	Sleep	2 min

#######################################
# LOGGING
#######################################
Open Connection And Log In
    [Arguments]         ${SSH_HOST}=localhost   ${SSH_USER}=root
    Open Connection     ${SSH_HOST}     timeout=180s
    Run Keyword If	    '${SSH_PASS}' is ${null}      Set Suite variable  ${SSH_PASS}     hpvse1
    Login               ${SSH_USER}     ${SSH_PASS}

Get Latest Log
   [Arguments]      ${LOG}=/ci/logs/ciDebug.*
   ${LATEST_LOG_FILE}=  Execute Command  ls \-r ${LOG} | head \-1
   [return]  ${LATEST_LOG_FILE}

Get Dump File Content
   [Arguments]    ${LATEST_LOG_FILE}
   ${Content}=    Execute Command    cat ${LATEST_LOG_FILE}
   [return]    ${Content}

Write To ciDebug Log
    [Documentation]    This example uses ssh to write out to the latest
    ...                ciDebug on on the OV appliance.
    [Arguments]	       ${TEXT_TO_LOG}=[${SUITE_NAME}:${TEST_NAME}]      ${SSH_HOST}=${APPLIANCE_IP}
    Open Connection And Log In      ${SSH_HOST}
    ${LOG}=  Get Latest Log
    ${rc}=    Execute Command    echo "\n#### ${TEXT_TO_LOG}\n" >> ${LOG}     return_stdout=False    return_rc=True
    Should Be Equal    ${rc}    ${0}
    Close All Connections

#######################################
# OA CLI Commands
#######################################
OA CLI EFUSE
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}    ${ACTION}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s
    Login               ${OA_USER}     ${OA_PASS}
    Write    ++diag--
    Read Until    diag>
    Write    efuse ${DEVICE} ${BAY} ${ACTION}
    Write    q
    Close All Connections

OA CLI POWERON
    [Documentation]    issues an POWERON command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWERON ${DEVICE} ${BAY}
    Close All Connections

OA CLI POWEROFF
    [Documentation]    issues an POWEROFF command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWEROFF ${DEVICE} ${BAY}
    Close All Connections

OA CLI Restart Interconnect
	[Documentation]    issues an Restart command to the given Interconnect Bay.
	[Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${BAY}
	Open Connection     ${OA_HOST}     prompt=VCP-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    RESTART INTERCONNECT ${BAY}
	Read Until    Are you sure you want to reset the Interconnect?
	Write    YES
    Close All Connections

Wait For Task1
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=600 s	${interval}=40 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate1	${resp}
	[Return]	${task}

Task Reached Endstate1
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['headers']['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}


Filter By

    [Arguments]     ${category}     ${scope}
	${nameList} =	Create List
    ${resp}     Fusion Api Get Resource Index   param=?category=${category}&query="scope:'${scope}'"
	${length} =		Get Length		${resp['members']}
	${nameList} =	Set Variable If	'${length}'=='0'	None
	
	:FOR	${x}	IN RANGE	0	${length}
	\   ${name} =   Get From Dictionary		${resp['members'][${x}]}	name
	\	Log to console	\n${name} is assigned to ${scope}
	[Return]	${nameList}

Filter By Any Scopes

    [Arguments]     ${category}     ${scope1}   ${scope2}
	${Namelist} =	Create List
    ${resp}     Fusion Api Get Resource Index   param=?category=${category}&query="(scope:'${scope1}' OR scope:'${scope2}')"
	${length} =		Get Length		${resp['members']}
	${NameList} =	Set Variable If	'${length}'=='0'	None
	
	${len} =	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${len}
	\	${name} =	Get From Dictionary     ${resp['members'][${x}]}    name
	\	Log to console	\n${name} is assigned either in Scope1 or Scope2
    [Return]	${Namelist}

Filter By All Scopes

    [Arguments]     ${category}     ${scope1}   ${scope2}
	${NameList} =	Create List
    ${resp}     Fusion Api Get Resource Index   param=?category=${category}&query="(scope:'${scope1}' AND scope:'${scope2}')"
	${length} =		Get Length		${resp['members']}

	${NameList} =	Set Variable If	'${length}'=='0'	None
	
	${len} =	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${len}
	\	${name} =	Get From Dictionary     ${resp['members'][${x}]}    name
	\	Log to console	\n${name} is assigned in both Scope1 and Scope2
    [Return]    ${NameList}

Add LS from variable
	[Documentation]	Adds an LS Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ls}


	${lgsuri} = 	Get From Dictionary	${ls['logicalSwitch']}	logicalSwitchGroupUri
	${lgsuri} = 	Common URI Lookup by name    ${lgsuri}
	Set to dictionary	${ls['logicalSwitch']}	logicalSwitchGroupUri		${lgsuri}
	${resp} =   Fusion Api Create LS    ${ls}
	${task} =	Wait For Task	${resp} 	60s	20s
	[Return]	${resp}
	
Wait For Task2
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate2	${resp}
	[Return]	${task}

Task Reached Endstate2
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	x-task-uri
	...                 ELSE                    Get Variable Value          ${location}
	#${task_uri} =		Get From Dictionary		${resp}	uri
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	#Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}

Get Scope Member
    [Documentation]     Negative Scenario
    [Arguments]     ${scopename}
    ${resp1}    Fusion Api Get Scope
    ${l} =     Get Length    ${resp1['members']}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${scope} =  copy Dictionary        ${resp1['members'][${x}]}
    \   Run Keyword If     '${scope['name']}' == '${scopename}'     Exit For Loop
    [Return]	${scope}

Get lsgs Member
    [Arguments]     ${type}
    ${resp} =   Fusion Api Get Switch Types
    ${l} =     Get Length    ${resp['members']}

    :FOR	${x}	IN RANGE	0	${l}
    \	@{words} = 	Split String	${resp['members'][${x}]['partNumber']}	-
	\	${type1} = 	Get From List	${words}	1
	\ 	Run Keyword If 	'${type}' != '${type1}'		Continue For Loop
	\   Set to dictionary	${lsg_1[0]['switchMapTemplate']['switchMapEntryTemplates'][0]}     permittedSwitchTypeUri		${resp['members'][${x}]['uri']}
    \   Set to dictionary	${lsg_1[1]['switchMapTemplate']['switchMapEntryTemplates'][0]}     permittedSwitchTypeUri		${resp['members'][${x}]['uri']}
    [Return]    ${lsg_1}

Wait For Task LE Update
	Sleep    ${LE_Update_Sleep_Time}
	
Wait For Task LI Update
	Sleep    ${LI_Update_Sleep_Time}
	
Wait For Restarting Interconnect
	Sleep    600
	
Wait For Disabling Ports
	Sleep    30
	
Wait For Enabling Ports
	Sleep    30
	
Wait Until Support Dump Creation
	Sleep    ${LE_Support_Dump_Time}
	
Wait For Restarting OV Appliance
	Sleep	1200
	
Open Connection And Log In OA
    [Arguments]         ${SSH_HOST}=15.186.28.6   ${SSH_USER}=Administrator
    Open Connection     ${SSH_HOST}     timeout=180s
    Set Suite variable  ${SSH_PASS}     ${OA_PASS}
    Login               ${SSH_USER}     ${SSH_PASS}
	
SSH to host and ping x
    [Documentation]    SSH's to a given host, then pings an IP from that host
    [Arguments]         ${HOST}    ${HOST2}
    Open Connection And Log In OA     ${HOST}
    #${Output}=    Execute Command        connect interconnect 5 return_stdout=True    return_rc=False
                ${Output}=         Write     connect interconnect 5
                ${o}=     Read
    Log to console and logfile    ${Output}
                #${r}=   Write Until Expected output       ${\n}      expected=Press [Enter] to display the switch console:                timeout=10s      retry_interval=0.5s
                ${r}=      Write Until Expected output       ${\n}      expected=(reverse-i-search)`':  timeout=10s                retry_interval=0.5s
                ${o}=     Read
    Log to console and logfile    ${Output}
                Log to console and logfile    ${o}
                #${Output}=      Write     root
                #${r}=   Write Until Expected output       ${\n}      expected=Password:     timeout=10s      retry_interval=0.5s
                #${Output}=      Write     6KWDJF7J
                #${s}=   Read
                ${r}=      Write Until Expected output       ${\n}      expected=VCFC3CN85030042:root>        timeout=10s                retry_interval=0.5s         
                ${r}=      Write Until Expected output       snmpconfig --show snmpv1        expected=VCFC3CN85030042:root>                timeout=10s      retry_interval=0.5s
                ${s}=      Read
                Log to console and logfile    ${s}
                ${r}=      Write Until Expected output       snmpconfig --show snmpv1        expected=VCFC3CN85030042:root>                timeout=10s      retry_interval=0.5s
                ${s}=      Read
                Log to console and logfile    ${s}
                Log to console and logfile    ${s}
                
                
    Close All Connections

Download Backup
  [Arguments]	${filename}=None
  ${Backup}	Fusion Api Get Backup
  Log To Console	${Backup}
  @{members}	Get From Dictionary	${Backup}	members
  ${file}	Run Keyword If		'${filename}'=='None'
  ...		Set Variable		${members[0]['id']}
  ...		ELSE	Set Variable	${filename}
  ${ret}	Fusion Api Download Backup	${members[0]['downloadUri']}	${file}
  log to console		${ret}
  
Upload Backup
  [Arguments]	${filename}
  ${Response}	Fusion Api Upload Backup	${filename}
  Log		${Response}
  
Login to OneView via REST	
	[Documentation]		Login to the appliance with the cred
	[Tags]  add   POSITIVE
	Set Log Level    TRACE
	${resp}     Fusion Api Login Appliance    ${appliance_IP}        ${admin_credentials}

Logout OneView via REST
	[Documentation]	log out from the appliance
	Fusion Api Logout Appliance
	
Restore From Backup
	${status}=	Set Variable    ${EMPTY}
	${Response}		Fusion Api Get Backup
	Run keyword unless	${Response['status_code']}== 200	Fail	"Unable to Get the latest backup"
	${restore_body}		Create Dictionary	type=RESTORE 	
	...										uriOfBackupToRestore=${Response['members'][0]['uri']}
	Log to console and logfile		"restore Body si"
	Log to console and logfile		${restore_body}
	${output}		Fusion Api Restore Backup		${restore_body}
	Log to console and logfile		${output}
	Sleep	200sec
	Run keyword unless	${output['status_code']}== 202	Fail	"Unable to perform the restore from backup operation"
	${restore_resp}		Fusion API Get Restore Status
	#Log to console and logfile		"Restore_resp values is "	${\n}
	Log to console and logfile		${restore_resp}
	Run keyword unless	${restore_resp['status_code']}== 200	Fail	"Unable to get the restore details"
	:FOR	${index}	IN RANGE	${restore_resp['count']}
	\	Run Keyword If	'${restore_resp['members'][${index}]['backupIdToRestore']}' != '${Response['members'][0]['id']}'		Continue For Loop
	\	${restore_id} =    Set Variable    ${restore_resp['members'][${index}]['id']}
	:FOR	${index}	IN RANGE	50
	\	sleep	60sec
	\	Log to console and logfile		"Restoring is in Progress..."
	\	${resp}		Fusion API Get Restore Status	${restore_id}
	\	Run keyword unless	${resp['status_code']}== 200	Fail	"Unable to get the restore id details"
	\	Run Keyword If	'${resp['progressStep']}' != 'COMPLETED'	Continue For Loop
	\	${status} =    Set Variable    ${resp['status']}
	\	Run Keyword If	'${resp['progressStep']}' == 'COMPLETED'	Exit For Loop
	Should Be Equal    ${status}	SUCCEEDED
	Log to console and logfile		"Exited from the for loop"
	Sleep    30
	Login to OneView via REST
	Validate IC State    ${IC_Configured}
	
SET EBIPA
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {BAY} = desired bay for given device
    ...   {IP1} = <IP gping to changed in interconnect>
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}    ${IP1}  ${bay}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s
    Login               ${OA_USER}     ${OA_PASS}
    
    Log to console and logfile	set ebipa
    ${OA_USER} =	Write    set ebipa interconnect ${IP1} 255.255.255.0 ${bay}
	Log to console and logfile		${OA_USER}
    Sleep 		${cmd_sleep_time}secs
    Write    yes
    Sleep 		${cmd_sleep_time}secs
	Log to console and logfile		ebipa enabling
	Write    enable ebipa interconnect ${bay}
    Sleep 		${cmd_sleep_time}secs
    Write    yes
    Sleep 		${cmd_sleep_time}secs
    
    Log to console and logfile		poweroff interconnect
    Write    poweroff interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    Log to console and logfile		poweron interconnect
    Write    poweron interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    
    
DISABLE EBIPA
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}	${bay}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s    
    Login               ${OA_USER}     ${OA_PASS}
    Log to console and logfile		disable ebipa
    Write   disable ebipa interconnect ${bay}
    Sleep 		${cmd_sleep_time}secs
    Write    yes
    Sleep 		${cmd_sleep_time}secs
    Log to console and logfile		poweroff interconnect
    Write    poweroff interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    Log to console and logfile		poweron interconnect
    Write    poweron interconnect ${bay}
    Sleep 		${poweron_sleep_time}secs
    
    
SHOW INTERCONNECT
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}    ${bay}
    Open Connection     ${OA_HOST}     prompt=>    timeout=20s
    Login               ${OA_USER}     ${OA_PASS}
    Log to console and logfile		show interconnect IP ${bay}
    
    Write    show interconnect list
    Sleep 		${cmd_sleep_time}secs
    ${Id}=  Read Until    Totals:
    @{lines}=   Split to lines  ${Id}
    :FOR	${line}	IN	@{lines}
	
	\   ${Lines_2}=    Get Lines Containing String     ${line}      Fibre Channe
	\   ${Count2}=    Get Line Count    ${Lines_2}
    \	Run Keyword If	'${Count_2}' != '1'	Continue For Loop
	\	Log to console and logfile	line2 is ${line}	
	\   @{words} = 	Split String	${line}   Fibre Channe
	
    \	Run Keyword If	${words[0]} == ${bay}	Exit For Loop
	
	${one_group} = 	Get Regexp Matches 	${words[1]} 	(\\d.*\\d)
    Log to console and logfile      ${one_group}	
	
	Log to console and logfile		close show interconnect IP
    Close All Connections
	[Return]    ${one_group[0]}	
	
Get interconnect ip
	[Arguments]		${ic}    ${type}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${interconnectIP} = 	Get From Dictionary		${resp['members'][0]}	ipAddressList
	${value1} =    Run Keyword If	  '${type}' == 'IPV4'   Get From List    ${interconnectIP}    0     ELSE    Get From List    ${interconnectIP}    1
	${value} =    Get From Dictionary    ${value1}    ipAddress
	[Return]	${value}
	
SHOW INTERCONNECT EBIPAV6
    [Documentation]    Gets the IPV6 address from OA
    ...   {bay} = desired bay for given device
    [Arguments]         ${OA_HOST}    ${OA_USER}                  ${OA_PASS}    ${bay}
	
    Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Process_Sleep_Time}
    write    show interconnect info ${bay}
	sleep    ${Command_Execute_Sleep_Time}
    ${Id} =  Read Until    Platform>
	write    show interconnect info ${bay}
	sleep    ${Command_Execute_Sleep_Time}
    ${Id} =  Read Until    Platform>
    Log to console and logfile      ${Id}
    @{lines}=   Split to lines  ${Id}
    :FOR  ${line}   IN           @{lines}
                
    \   ${Lines_2}=    Get Lines Containing String     ${line}      EBIPA Address
    \   ${Lines_1}=    Get Lines Containing String     ${line}     DHCPv6 Address
    \   ${Count2}=    Get Line Count    ${Lines_2}
    \   ${Count1}=    Get Line Count    ${Lines_1}
    \          Run Keyword If    '${Count2}' == '1'           Exit For Loop
    \          Run Keyword If    '${Count1}' == '1'              Exit For Loop
    Log to console and logfile      ${line}            
    @{words} =    Split String           ${line}   Address:${SPACE}
    Close All Connections
    [Return]    ${words[1]}    
 

DISABLE EBIPAV6
	[Documentation]    Used to disable ebipav6 for a particular interconnect
	...    {OA_HOST} = OA IP of the enclosure
	...    {bay} = desired bay for given device
	[Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
    Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Command_Execute_Sleep_Time}
    Write    disable ebipav6 interconnect ${bay}
	sleep    ${Command_Execute_Sleep_Time}
	Write    yes
	sleep    ${Process_Sleep_Time}
	${command_output} =	Read Until    >
	Log to console	${command_output}
	Write    poweroff interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Write    poweron interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Close All Connections
	Log to console    Successfully disabled ebipa
	
SET EBIPAV6

	[Documentation]    Used to set ebipav6 for a particular interconnect
	...    {OA_HOST} = OA IP of the enclosure
	...    {bay} = desired bay for given device
	...    {ip} = Ip that needs to be set to the interconnect
	[Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}    ${ip}
	
    Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Command_Execute_Sleep_Time}
	Write    set ebipav6 interconnect ${ip} ${bay}
	sleep    ${Command_Execute_Sleep_Time}
	Write    yes
	sleep    ${Process_Sleep_Time}
	${command_output} =	Read Until    >
	Log to console	${command_output}
	Close All Connections
	Log to console    Successfully set ebipav6 for the interconnect
	
ENABLE EBIPAV6

	[Documentation]    Used to enable ebipav6 for a particular interconnect
	...    {OA_HOST} = OA IP of the enclosure
	...    {bay} = desired bay for given device
	[Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
	Open Connection And Log In OA    ${OA_HOST}
	sleep    ${Command_Execute_Sleep_Time}
    Write    enable ebipav6 interconnect ${bay}
	sleep    ${Command_Execute_Sleep_Time}
	Write    yes
	sleep    ${Process_Sleep_Time}
	${command_output} =	Read Until    >
	Log to console	${command_output}
	Write    poweroff interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Write    poweron interconnect ${bay}
	sleep    ${poweron_sleep_time}
	Close All Connections
	Log to console    Successfully Enabled ebipa
	
####Precheck for the presence of Module#######
	
Precheck for IC in OA
	${ICtype_Uris} =	Create List  
	${resp} =    Enclosure Preview    ${APPLIANCE_IP}	${enclosure_preview}
	${interconnectMapTemplate}      Set Variable    ${resp['logicalInterconnectGroup']['interconnectMapTemplate']}
	Set Global Variable   ${interconnectMapTemplate_Global}    ${interconnectMapTemplate} 
	:FOR	${x}	IN RANGE	0	${8}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary 	${interconnectMapTemplate['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	Run Keyword If    '${permittedInterconnectTypeUri}' != 'None'    Append To List    ${ICtype_Uris}    ${permittedInterconnectTypeUri}	
	Log to console and logfile    ${ICtype_Uris}
	
	${ICtype_Names} =	Create List
	:FOR	${y}	IN    @{ICtype_Uris}
	\	${string} =    Fetch From Right    ${y}    /
	\	${param} =	Catenate	SEPARATOR=	/	${string}
	\	${IC_Details} =    Fusion Api Get Interconnect Types    param=${param}
	\	Append To List    ${ICtype_Names}    ${IC_Details['name']}
	Log to console and logfile    ${ICtype_Names}
	Should Contain    ${ICtype_Names}    ${Module_name}    --exitonfailure
	Log to console and logfile    Hill module is present in the enclosure. Hence proceeding with the test case.
	
########LI and LIG Consistency State#####

Get LI LIG Consistency
	[Arguments]    ${LI_Consistent}
	${resp} = 	Fusion Api Get Li
	#Log to console and logfile		${resp}
	${li_state} =	Get From Dictionary		${resp['members'][0]}	consistencyStatus  
	Log to console and logfile		${li_state}
	Run Keyword If    '${li_state}' == '${LI_Consistent}'    Log to console    \n\nThe LI is ${li_state} with LIG    Fail    "The LI is ${li_state} with LIG"

	
#######IC State####

Validate IC State
	[Arguments]    ${IC_State}
	${resp} =	Get IC State
	#Log to console and logfile    \n\n${resp}
	${len} = 	Get Length	${resp}
	:FOR	${x}	IN RANGE	0	${len}
	\	Run Keyword If    '${resp[${x}]}' == '${IC_State}'    Log to console    \nThe state of IC(HILL Module) is ${resp[${x}]}    Fail    "The state of IC(HILL Module) is not ${resp[${x}]}"
	
Get IC Model
	${resp} =   fusion api get interconnect
    ${ic_model} =    Create List
	${ic_uri} =    Create List
	${ic_name} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	${len} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${len}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${Module_name}'		Continue For Loop
	\   Append to list      ${ic_model}  ${ic['model']}
	\   ${uri} =     Get From Dictionary   ${ic}    uri
	\   Append to list      ${ic_uri}  ${uri}
	\	${name} =     Get From Dictionary   ${ic}    name
	\   Append to list      ${ic_name}  ${name}
	\	Log to console and logfile		\n\nPresence of Module with their respective name and uri ${ic['model']} : ${uri} : ${name}
	[Return]    ${ic_model} : ${ic_uri} : ${ic_name}

Get IC State
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	#Log to console and logfile	${ics}
	${l} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${Module_name}'		Continue For Loop
	\   ${uri} =     Get From Dictionary   ${ic}    uri
	\	${name} =     Get From Dictionary   ${ic}    name
	\	${state} =    Get From Dictionary   ${ic}    state
	\	Log to console and logfile		\n\n${ic['model']} : ${uri} : ${name} : ${state}
	\   Append to list      ${ic_list}  ${state}
	\	Log To Console		\nGet IC:${ic_list} 
	[Return]    ${ic_list}
	
###SNMP Keywords###
Open SNMP Client and Login
	[Arguments]         ${SSH_SNMP_IP}=localhost   ${SSH_USER}=root	
    Open Connection     ${SSH_SNMP_IP}     timeout=180s
    Set Suite variable  ${SSH_PASS}     ${SNMP_Password}
    Login               ${SSH_USER}     ${SSH_PASS}
	log to console    Logged into the Snmp client : ${SSH_SNMP_IP}

Clear Trap
	Write	 cd SNMP
	Write    > vcmtrap2.log
	Close All Connections
		
Get Remote files
     [Arguments]    ${host}     ${user}     ${pwd}    ${query}
     Open Connection  ${host}
     Login    ${user}    ${pwd}
     Log To Console     Logged in to SNMP Client
     SSHLibrary.Get File    ${query}
     Log To Console     Files copied to
     close all connections
	 	
Perform an LI Update From Group
	[Arguments]       ${li}=${LE}-${LIG1}     ${timeout}=5 min    ${interval}=15s
    ${resp} =       Fusion Api Update from group    ${li}
    ${task} =       Wait For Task       ${resp}     ${timeout}        ${interval}
    ${valDict} = 	Create Dictionary	status_code=${200}
	...									taskState=Completed
	Validate Response    ${task}    ${valDict}
	
GET SERIAL AND PART NUMBER FROM OA
    [Documentation]    Gets the hostname for the given bay
    ...   {bay} = desired bay for given device
    [Arguments]         ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
	Open Connection And Log In OA    ${OA_HOST}
	Write    show interconnect info ${bay}
	sleep    ${Command_Execute_Sleep_Time}
    ${Id} =  Read Until    >
    Log to console and logfile      ${Id}
    @{lines}=   Split to lines  ${Id}
    :FOR  ${line}   IN           @{lines}
                
    \   ${Lines_2}=    Get Lines Containing String     ${line}      Part Number
    \   ${Count2}=    Get Line Count    ${Lines_2}
    \          Run Keyword If    '${Count2}' == '1'              Exit For Loop

	Log to console and logfile     Part ${line}
	:FOR  ${line}   IN           @{lines}
	
    \   ${Lines_1}=    Get Lines Containing String     ${line}     Serial Number
	\   ${Count1}=    Get Line Count    ${Lines_1}
    \          Run Keyword If    '${Count1}' == '1'              Exit For Loop
	Log to console and logfile     Serial ${line}
	
    @{Serial} =    Split String           ${Lines_1}   Number:${SPACE}
	@{Part} =    Split String           ${Lines_2}   Number:${SPACE}
	
	Close All Connections
    [Return]    ${Serial[1]}    ${Part[1]}
	
GET HOSTNAME FROM OA
    [Documentation]    Gets the hostname for the given bay
    ...   {bay} = desired bay for given device
    [Arguments]      ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}    ${INTERCONNECT_USER}    ${INTERCONNECT_PASS}
	${INTERCONNECT_HOST} =	SHOW INTERCONNECT     ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	Log to console and logfile    ${INTERCONNECT_HOST}
	Open Connection     ${INTERCONNECT_HOST}     prompt=>    timeout=30s    
	Login               ${INTERCONNECT_USER}     ${INTERCONNECT_PASS}
	Write    hostname
	sleep    ${Command_Execute_Sleep_Time}
	${Id} =  Read Until    >
	@{lines}=   Split to lines  ${Id}
    Log to console and logfile      ${lines[0]}
	
    Close All Connections
    [Return]    ${lines[0]}
	
CHANGE HOSTNAME FROM OA
    [Documentation]    Gets the hostname for the given bay
    ...   {bay} = desired bay for given device
    [Arguments]      ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}    ${INTERCONNECT_USER}    ${INTERCONNECT_PASS}     ${name}
	${INTERCONNECT_HOST} =	SHOW INTERCONNECT     ${OA_HOST}    ${OA_USER}    ${OA_PASS}    ${bay}
	
	Open Connection     ${INTERCONNECT_HOST}     prompt=>    timeout=10s    
    Login               ${INTERCONNECT_USER}     ${INTERCONNECT_PASS}
	Write    hostname ${name}
	sleep    ${Command_Execute_Sleep_Time}
	${Id} =  Read Until    >
	@{lines}=   Split to lines  ${Id}
	Write    hostname
	sleep    ${Command_Execute_Sleep_Time}
	${Id} =  Read Until    >
	@{lines}=   Split to lines  ${Id}
    #Log to console and logfile      ${lines[0]}
	
    Close All Connections
    [Return]    ${lines[0]}

GET SERIAL AND PART NUMBER FROM REST
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	Log to console and logfile    ${resp}
	${SerialNumber} = 	Get From Dictionary		${resp['members'][0]}	serialNumber
	${partNumber} = 	Get From Dictionary		${resp['members'][0]}	partNumber
	${hostname} =              Get From Dictionary                       ${resp['members'][0]}   hostName
	Log to console and logfile    ${hostname}
    [Return]               ${SerialNumber}    ${partNumber}    ${hostname}

	
Disable The Auto Generated Mac,Wwn,Sn Ranges
	${resp_mac} =    Fusion Api Get Vmac Range    uri=/rest/id-pools/vmac
	${mac_uri} =    Get From Dictionary    ${resp_mac}    rangeUris
	${disable_mac} =    Fusion Api Edit Vmac Range    ${dis_mac}    ${mac_uri[0]}
	Run keyword unless    ${disable_mac['status_code']} == 200    Fail    "Unable to disable Vmac range"
	${resp_wwn} =    Fusion Api Get Vwwn Range    uri=/rest/id-pools/vwwn
	${wwn_uri} =    Get From Dictionary    ${resp_wwn}    rangeUris
	${disable_wwn} =    Fusion Api Edit Vwwn Range    ${dis_wwn}    ${wwn_uri[0]}
	Run keyword unless    ${disable_wwn['status_code']} == 200    Fail    "Unable to disable Vwwn range"
	${resp_sn} =    Fusion Api Get Vsn Range    uri=/rest/id-pools/vsn
	${sn_uri} =    Get From Dictionary    ${resp_sn}    rangeUris
	${disable_sn} =    Fusion Api Edit Vmac Range    ${dis_sn}    ${sn_uri[0]}
	Run keyword unless    ${disable_sn['status_code']} == 200    Fail    "Unable to disable Vsn range"
	
Build support dump payload
	[Arguments]		${name}		${encrypt}
	${payload_dict}=   Create Dictionary  errorCode=${name}
    ...									  encrypt=${encrypt}
    ...									  excludeApplianceDump=false
   	Logger		The support dump payload is : ${payload_dict}		DEBUG
    [return]	${payload_dict}
	
Logger
	[Documentation]		Logs the messages for particular level mentioned. Eg: Logger *messages  DEBUG	| Now supporting INFO and DEBUG				
	[Arguments]		${message}		${Arg_log}=None
	Run Keyword If		'${Arg_log}'=='None' 	Log to console 		${message}
	Run Keyword If		'${Arg_log}'=='DEBUG' and '${loggerlevel}'=='DEBUG'		Log to console		${message}
	
Validate the response 
	[Arguments]		${resp}
	${resp_uri} =	Get from dictionary		${resp}		uri
	#Wait Until Keyword Succeeds  ${timeout}    ${polling_time}  Validate computedPercentComplete   ${resp}
	${resp} =	Fusion api get resource		${resp_uri}
	${taskstate} = 		Get from dictionary		${resp}		taskState
	logger		${taskstate}		DEBUG
	${taskerror} =		Get from dictionary		${resp}		taskErrors
	Run keyword If 		'${taskstate}' != 'Completed'		 Task Error		${taskerror}	${resp_uri}
	[return]	${resp}
	
Task Error
	[Arguments]		${taskerror}	${resp_uri}
	Logger	taskeror : ${taskerror}		DEBUG	
	${error_code} =		Get from dictionary		${taskerror[0]} 	errorCode
	${message} =	Get from dictionary 	${taskerror[0]}		message
	Fail	msg= Failed for the uri ${resp_uri} due to ${error_code} \n Additional Info : ${message}

Pass With Warnings
	[Arguments]		${msg}
	Log		${msg}		WARN
	Pass Execution		Test case skipped, check the above warning message for info 
	
Cleanup For Suite	
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[Cleanup]
	Login to OneView via REST
	Power off ALL Servers
	Remove All Server Profiles
	Remove ALL Enclosures
	Remove ALL Enclosure Groups
	Remove ALL LIGs
	Remove ALL Ethernet Networks
	Remove ALL FC Networks