*** Settings ***
Documentation    OVF2724 OVF2942 OVF2726 & OVF3014-VC Edge: Gen 10 DL server profiles (DL360, DL380) Suite
Library         json
Library         FusionLibrary
Library         RoboGalaxyLibrary
Library         SSHLibrary
Library         OperatingSystem
Library         Dialogs
Library            Process
Library            OperatingSystem
Variables       VCEdge_datavariable.py
Variables       OVF2726_OVF3014_data_variables_sp.py
Variables       OVF2724_data_variables.py
Library     VCEdge_datavariable.py
Library     OVF2724_data_variables.py
Library     OVF2726_OVF3014_data_variables_sp.py
Library      back_ping.py
Library      server_to_server.py
Library      Telnet
Library      ServerOperations
Resource        ../../../../resource/fusion_api_all_resource_files.txt
Suite Setup               Clean OV
Suite Teardown     Clean OV

*** Variables ***
${number}    5
${flag}    Windows
${switch_ping_name}    switchIP_ping.txt
${server_ping_name}    serverIP_ping.txt
${time_out}    Request timed out
${terminate}    PING.EXE
${Dest_unreachable}    Destination host unreachable.
${switch_ping_file_path}    ${CURDIR}/switchIP_ping.txt
${server_ping_file_path}    ${CURDIR}/serverIP_ping.txt
${Appliance_IP1}     15.186.18.154
${APPLIANCE_IP_4_10}      15.186.16.43
${IncValue}    ${0}
${ipad}        ${0}
${HCount}      ${0}
${ip1_count}   ${0}
${Value}    ${0}
*** Test Cases ***

API_TC_Verify traffic between uplink and downlink as multithreading works even during appliance restart_TC_count_2
    [Documentation]    Verify Traffic as multithreading works even during appliance restart
    Set Log Level    Trace

    Fusion Api login Appliance    ${APPLIANCE_IP_4_10}    ${admin_credentials}
    Presetup for Profiles
    :For    ${server}    IN    @{DL_server_names}
    \    ${uri}    ${status}    Validate switchports are equal in server hardware    ${server}
    \    Run keyword If    '${status}'== 'False'    Refresh the server    ${uri}    ${server}    ElSE     Log to console and logfile     Switch ports are equal
    ${len}    Get Length    ${sp_names}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Add DL Server Profiles from variable    ${server_profiles[${x}]}
    \   Power on server    ${server_profiles[${x}][0]['serverHardwareUri']}
    \   ${interface}    Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Fetch vlan id of switch and profile     ${server_profiles[${x}]}    ${switch_ip}    ${interface}
    Sleep   200s

### code to verify IO Traffic during restart appliance ###
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}

    Server to server ping    ${IPList}
    startpingthread    ${Server_profiles_valid_ips[0][0]}    ${server_ping_name}
    ${resp}    Fusion Api Appliance Shutdown    mode=REBOOT
    Run Keyword If  '${resp['status_code']}' != '202'  Fail    ELSE  log to console   \n-Task is in progress\n
    sleep   1200s
    Wait For Appliance To Become Pingable    ${APPLIANCE_IP_4_10}    30 minutes    30 s
    Terminate Ping
    ${contents1}=    OperatingSystem.Get File    ${server_ping_name}
    ${lines}    Get lines containing string    ${contents1}    timed out
    ${len}    Get Length    ${lines}
    Run Keyword If    '${len}' == '1'    log to console and logfile    \n\n Traffic during restart appliance is successful
    ...    Else    Should Not Contain     ${contents1}     ${time_out}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Power OFF server    ${DL_server_names[${x}]}
    \   ${resp}    Fusion Api Delete Server Profile    name=${server_profiles[${x}][0]['name']}
    \   ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s
    \   ${interface}     Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Verify switch VlanID removed    ${switch_ip}      ${switch_details}     ${interface}    ${Commands}

API_TC_Assign Networks sets and verify the traffic flow Change the network sets in the server connection with the server profiles powered on and verify the traffic for all the server hardware 360 380_TC_Count_2
    [Documentation]    Verify Traffic after changing the server connections

    Set Log Level    Trace
    Power off ALL Servers
    Remove All Server Profiles
    Remove ALL Network Sets
    ${nativeurilist}     Create List
    :For    ${name}    IN    @{Nativenetwork}
    \    ${network}    Fusion Api Get Ethernet Networks    param=?filter=name=${name}
    \    ${nativeuri}    Get Variable Value    ${network['members'][0]['uri']}
    \    Append To List    ${nativeurilist}    ${nativeuri}
    Create Network Set for Profiles     ${nativeurilist}    1
    ${server_count}     Get Length    ${DL_server_names}
    :FOR   ${x}   IN RANGE    0    ${server_count}
    \    ${temp}     Copy Dictionary    ${server_profile_nwset}
    \    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${DL_server_names[${x}]}
    \    Set to Dictionary    ${temp[0]}    name    ${DL_server_names[${x}]}Profile
    \    ${task}    Add DL Server Profiles from variable     ${temp}
    \    ${task_state} =     Get From dictionary     ${task}     taskState
    \    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)
    \    Power on server    ${DL_server_names[${x}]}
    sleep    ${Timout_for_server}
    :FOR   ${x}   IN RANGE    0    ${server_count}
    \    verify networkset traffic    ${DL_server_names[${x}]}    ${ps_cmd_native}    ${delete_team_cmd_native}
    :FOR   ${x}   IN RANGE    0    ${server_count}
    \    Profile Edit with networkset    ${DL_server_names[${x}]}    ${temp}
    Power off ALL Servers
    sleep    100s
    Power ON ALL Servers
    sleep    ${Timout_for_server}
    :FOR   ${x}   IN RANGE    0    ${server_count}
    \    verify networkset traffic    ${DL_server_names[${x}]}    ${ps_cmd_native_edit}    ${delete_team_cmd_native_edit}

API_TC_Verify traffic loss for switch that is rebooted and no traffic loss for switches that are not rebooted TC_count_2
    [Documentation]    Verify Traffic during switch reboot
    Power off ALL Servers
    Remove All Server Profiles
    ${len}    Get Length    ${sp_names}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Add DL Server Profiles from variable    ${server_profiles[${x}]}
    \   Power on server    ${server_profiles[${x}][0]['serverHardwareUri']}
    \   ${interface}    Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Fetch vlan id of switch and profile     ${server_profiles[${x}]}    ${switch_ip}    ${interface}
    sleep   200s
#### code to verify Traffic ###

    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}
    Server to server ping    ${IPList}

    Reboot Arista Switch    ${switches_IP[0]}   ${reboot_command}
    Wait until Keyword Succeeds    1 min   15s    Verify Ping Fails    ${number}    ${switches_IP[0]}    ${switch_ping_name}    ${flag}    ${switch_ping_file_path}
    ###verify traffic fails for rebooted switch and for other switch traffic should pass
    :FOR   ${x}    IN RANGE    0   3
    \    Wait until Keyword Succeeds    1 min   15s    Verify Ping Fails    ${number}    ${Server_profiles_valid_ips[${x}][1]}    ${switch_ping_name}    ${flag}    ${switch_ping_file_path}
    :For    ${x}    In Range    0    3
    \    Ping Downlink from Uplink    ${Server_profiles_valid_ips[${x}][0]}
    Wait until Keyword Succeeds    3 min   15s    Verify Ping Successful    ${number}    ${ARISTA_IPS_1}    ${switch_ping_name}    ${flag}    ${switch_ping_file_path}
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    Sleep   120s
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Power OFF server    ${DL_server_names[${x}]}
    \   ${resp}    Fusion Api Delete Server Profile    name=${server_profiles[${x}][0]['name']}
    \   ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s
    \   Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="delete profile failed"
    \   ${interface}     Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Verify switch VlanID removed    ${switch_ip}      ${switch_details}     ${interface}    ${Commands}


API_TC Verify traffic before and after unassign and assigning connections and server hardware to SP with server hardware powered on TC_count_2
    [Documentation]    Verify Traffic before and after unassign and assigning connections and server hardware
    Power off ALL Servers
    Remove All Server Profiles

    ${len}    Get Length    ${sp_names}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Add DL Server Profiles from variable    ${server_profiles_network_delete_tc[${x}]}
    \   Power on server    ${server_profiles_network_delete_tc[${x}][0]['serverHardwareUri']}
    \   ${interface}    Get interface number    ${DL_server_names}    ${server_profiles_network_delete_tc[${x}]}
    \   Fetch vlan id of switch and profile     ${server_profiles_network_delete_tc[${x}]}    ${switch_ip}    ${interface}
    sleep   200s
#### code to verify Traffic ###

    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers

    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}
    Server to server ping    ${IPList}
    Power off ALL Servers
    ${List}     Create List
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${profile_uri}     Build Edit Profile body    ${sp_names[${x}]}
    \    ${temp}     Copy Dictionary     ${server_profiles_edit_body}
    \    Set to dictionary  ${temp}   serverHardwareUri     ${EMPTY}
    \    ${connections}    Lookup connection uris      ${temp['connectionSettings']['connections']}
    \    Set to dictionary     ${temp['connectionSettings']}   connections   ${connections}
    \    ${resp} =   Fusion Api Edit Server Profile   ${temp}     uri=${profile_uri}    param=?force=ignoreServerHealth
    \    ${task} =   Wait For Task   ${resp}     5 mins      10s
    \    Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="Edit profile failed"
    \    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_names[${x}]}
    \    Should Be Equal As Strings    '${resp['members'][0]['serverHardwareUri']}'      '${None}'

    \    Log to console and logfile    \n Re-assigning server hardware
    \    ${shuri}     Get from dictionary    ${server_profiles_edit_body}     serverHardwareUri
    \    Set to dictionary     ${temp}    serverHardwareUri    ${shUri}
    \    ${etag}    Get Profile ETag    ${sp_names[${x}]}
    \    Set to dictionary     ${temp}    eTag    ${etag}
    \    ${resp} =   Fusion Api Edit Server Profile   ${temp}     uri=${profile_uri}    param=?force=ignoreServerHealth
    \    ${task} =   Wait For Task   ${resp}     5 mins      10s
    \    Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="Edit profile failed"
    \    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_names[${x}]}
    \    Should Contain    ${resp['members'][0]['serverHardwareUri']}      /rest
    \    Power on server     ${server_profiles[${x}][0]['serverHardwareUri']}
    Sleep    200s

#### code to verify Traffic ###
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}
    Server to server ping    ${IPList}

    Power off ALL Servers
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${profile_uri}    Build Edit Profile body    ${sp_names[${x}]}
    \    ${temp}     Copy Dictionary     ${server_profiles_edit_body}
    \    Set to dictionary     ${temp['connectionSettings']}   connections   ${List}
    \   ${resp} =   Fusion Api Edit Server Profile   ${temp}     uri=${profile_uri}    param=?force=ignoreServerHealth
    \    ${task} =   Wait For Task   ${resp}     5 mins      10s
    \    Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="Edit profile failed"
    \    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_names[${x}]}
    \    ${conn_len}    Get Length    ${resp['members'][0]['connectionSettings']['connections']}
    \    Run keyword If    ${conn_len}==2    Fail    msg="After unassigning there should not be conections"
    \    ${temp}     Copy Dictionary     ${server_profiles_edit_body}
    \    ${connections}    Lookup connection uris      ${temp['connectionSettings']['connections']}
    \    Set to dictionary     ${temp['connectionSettings']}   connections   ${connections}

    \    ${etag}    Get Profile ETag    ${sp_names[${x}]}
    \    Set to dictionary     ${temp}    eTag    ${etag}
    \    ${resp} =   Fusion Api Edit Server Profile   ${temp}     uri=${profile_uri}    param=?force=ignoreServerHealth
    \    ${task} =   Wait For Task   ${resp}     5 mins      10s
    \    Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="Edit profile failed"
    \    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_names[0]}
    \    ${conn_len}    Get Length    ${resp['members'][0]['connectionSettings']['connections']}
    \    Run keyword If    ${conn_len}!=2    Fail    msg="After assigning there should be conections"
    \    Power on server     ${server_profiles[${x}][0]['serverHardwareUri']}
    Sleep    200s

#### code to verify Traffic ###
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}
    Server to server ping    ${IPList}

    :FOR    ${x}    IN RANGE    0   ${len}
    \   Power OFF server    ${DL_server_names[${x}]}
    \   ${resp}    Fusion Api Delete Server Profile    name=${server_profiles[${x}][0]['name']}
    \   ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s
    \   Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="delete profile failed"
    \   ${interface}     Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Verify switch VlanID removed    ${switch_ip}      ${switch_details}     ${interface}    ${Commands}

API_TC Verify the uplink and downlink connectivity before and after back up of the appliance and delete the entire configuration and then restore the configuration back with servers powered on TC_count_2
    [Documentation]    Verify Traffic before and after backup restore
    Power off ALL Servers
    Remove All Server Profiles
    ${len}    Get Length    ${sp_names}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Add DL Server Profiles from variable    ${server_profiles[${x}]}
    \   Power on server    ${server_profiles[${x}][0]['serverHardwareUri']}
    \   ${interface}    Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Fetch vlan id of switch and profile     ${server_profiles[${x}]}    ${switch_ip}    ${interface}
    sleep   200s
#### code to verify Traffic ###
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}
    Server to server ping    ${IPList}
        #Perform Backup Operation
    ${Response}     Fusion Api Create Backup
    Run keyword unless  ${Response['status_code']}== 202    Fail    "Unable to Create Backup"
    Sleep   200sec
    Log to console and logfile    \n Deleting the entire configuration
    Power off ALL Servers
    Remove All Server Profiles
    Remove All LS
    Remove All LSGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets

    Restore From Backup
    Log to console and logfile    \n Verifying the hardware configuration is restored properly
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    Run keyword unless  ${resp['count']}== 1    Fail    "Unable to verify the LS is present in the appliance

    ${len}      Get Length     ${nw_names}
    :For    ${x}    In Range    0    ${len}
    \    ${res}    Fusion Api Get Ethernet Networks    param=?filter=name=${nw_names[${x}]}
    \    Run keyword unless ${resp['count']}== 1    Fail    "Unable to verify the server Profile is present in the appliance

    ${resp} =   Fusion Api Get LSG      param=?filter="'name'=='${LSG1}'"
    Run keyword unless  ${resp['count']}== 1    Fail    "Unable to verify the LSG is present in the appliance

    #Validating the existence of already created server profiles
    ${len}      Get Length     ${sp_names}
    :FOR    ${x}    In Range     0    ${len}
    \    ${resp}=   fusion api get server profiles  param=?filter="'name'=='${sp_names[${x}]}'"
    \    Run keyword unless ${resp['count']}== 1    Fail    "Unable to verify the server Profile is present in the appliance
    \    Power on server    ${server_profiles[${x}][0]['serverHardwareUri']}
    \   Verify Server Hardware Power State    ${DL_server_names[${x}]}    On
    Sleep    200s

    ${resp} =   Fusion Api Get Server Hardware
    ${shlist} =     Get From Dictionary ${resp} members
    :FOR    ${sh}   IN  @{shlist}
    \   ${state} =  Get From Dictionary ${sh}   state
    \   Should be Equal as Strings    ${state}    ProfileApplied

#### code to verify Traffic ###
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers
    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}
    Server to server ping    ${IPList}

API_TC: Verify the uplink and downlink connectivity. Take a backup of the appliance store the backup in local disk. Then delete the entire configuration, and then restore the configuration back with servers powered off. [ TC_Count:4]
    [Documentation]    Verify Traffic before and after backup restore
    Power off ALL Servers
    Remove All Server Profiles
    ${len}    Get Length    ${sp_names}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Add DL Server Profiles from variable    ${server_profiles[${x}]}
    \   Power on server    ${server_profiles[${x}][0]['serverHardwareUri']}
    \   ${interface}    Get interface number    ${DL_server_names}    ${server_profiles[${x}]}
    \   Fetch vlan id of switch and profile     ${server_profiles[${x}]}    ${switch_ip}    ${interface}
    sleep   200s
#### code to verify Traffic ###

    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers

    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}

    Server to server ping    ${IPList}
        #Perform Backup Operation
    ${Response}     Fusion Api Create Backup
    Run keyword unless  ${Response['status_code']}== 202    Fail    "Unable to Create Backup"
    Sleep   200sec
    Log to console and logfile    \n Deleting the entire configuration
    Power off ALL Servers
    Remove All Server Profiles
    Remove All LS
    Remove All LSGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets
    Restore From Backup
    Log to console and logfile    \n Verifying the hardware configuration is restored properly

    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    Run keyword unless  ${resp['count']}== 1    Fail    "Unable to verify the LS is present in the appliance

    ${len}      Get Length     ${nw_names}
    :For    ${x}    In Range    0    ${len}
    \    ${res}    Fusion Api Get Ethernet Networks    param=?filter=name=${nw_names[${x}]}
    \    Run keyword unless ${resp['count']}== 1    Fail    "Unable to verify the server Profile is present in the appliance

    ${resp} =   Fusion Api Get LSG      param=?filter="'name'=='${LSG1}'"
    Run keyword unless  ${resp['count']}== 1    Fail    "Unable to verify the LSG is present in the appliance

    #Validating the existence of already created server profiles
    ${len}      Get Length     ${sp_names}
    :FOR    ${x}    In Range     0    ${len}
    \    ${resp}=   fusion api get server profiles  param=?filter="'name'=='${sp_names[${x}]}'"
    \    Run keyword unless ${resp['count']}== 1    Fail    "Unable to verify the server Profile is present in the appliance
    \   Verify Server Hardware Power State    ${DL_server_names[${x}]}    Off
    \    Power on server    ${server_profiles[${x}][0]['serverHardwareUri']}
    Sleep    200s

    ${resp} =   Fusion Api Get Server Hardware
    ${shlist} =     Get From Dictionary ${resp} members
    :FOR    ${sh}   IN  @{shlist}
    \   ${state} =  Get From Dictionary ${sh}   state
    \   Should be Equal as Strings    ${state}    ProfileApplied
#### code to verify Traffic ###
    ${Server_profiles_valid_ips}    verify Traffic from Downlink to Uplink for servers

    ${IPList}    Create List
    :For    ${x}    In Range    0    3
    \    ${y}    Evaluate    ${x}%2
    \    Run Keyword If    ${y} != 0    Continue For Loop
    \    ${temp_ip}    Get Variable Value    ${Server_profiles_valid_ips[${x}][0]}
    \    Append To List    ${IPList}    ${temp_ip}

    Server to server ping    ${IPList}

API_TC_Once the server profiles are created and traffic is verified for all the server hardware try to delete the LS it should throw the error message_TC_Count_2
    Set Log Level    TRACE
    Power off ALL Servers
    Remove All Server Profiles
    ${server_count}     Get Length    ${DL_server_names}
    :FOR  ${x}    IN RANGE    0    ${server_count}
    \   Add DL Server Profiles from variable     ${server_profiles[${x}]}
    \   Power on server    ${DL_server_names[${x}]}
    sleep    ${Timout_for_server}
    :FOR  ${x}    IN RANGE    0    ${server_count}
    \   Verify Traffic    ${DL_server_names[${x}]}    2
    ${lssget} =     Fusion Api Get LS
    ${resp} =    Fusion Api Delete LS        uri=${lssget['members'][0]['uri']}
    ${task} =    Wait For Task    ${resp}    240s    2s

    Run Keyword If    '${task['status_code']}' != '200'    Log to console and logfile    \n-As expected Could not delete LS.    ELSE    Fail

*** Keywords ***
Verify Alerts in Profiles page
    [Documentation]    Verify Alerts in server profiles page
    ${Alert_msg}    Create List
    ${resp}    Fusion Api Get Alerts
    ${mem_resp}    Get From Dictionary    ${resp}    members
    ${len}    Get Length    ${mem_resp}
    :FOR   ${x}    IN RANGE    0    ${len}
    \   Run Keyword If  '${mem_resp[${x}]['physicalResourceType']}' !='server-profiles'    Continue For Loop
    \   ${desc}    Get From Dictionary    ${mem_resp[${x}]}    description
    ${cmd_output}    Get Regexp Matches    ${desc}    An error has occurred on connection \\s.*
    [Return]    True

Perform Enable Switch Ports
    [Documentation]    Pass Interface number to perform Enable ports
    [Arguments]    ${interface}
    :For    ${x}    In Range    0    2
    \    Enable disable switch port    ${switches_IP[${x}]}    ${enable[1]}    ${interface}    ${x}

Perform Disable Switch Ports
    [Documentation]    Pass the Interface number for Disable ports
    [Arguments]    ${interface}
    :For    ${x}    In Range    0    2
    \    Enable disable switch port    ${switches_IP[${x}]}    ${enable[0]}    ${interface}    ${x}


Verify Switches URI from Switches Page with SH page
    ### used in ovf2724 suite
    [Documentation]    keyword to compare the switches uri from switches page with Adapter details of server in Server Hardware Page
    [Arguments]    ${sw_uri_SH}
    :For    ${x}    IN Range    0    2
    \    ${resp}    Fusion Api Get Switch    param=?filter=name=${switches_IP[${x}]}
    \    ${switch_uri}    Get Variable Value    ${resp['members'][${x}]['uri']}
    \    List Should Contain Value    ${sw_uri_SH}    ${switch_uri}

Enable disable switch port
    [Documentation]    Enable/disable switch ports on OV
    [Arguments]    ${switch_ip}    ${enable}    ${Interfaces_number}    ${x}

    ${resp}    Fusion Api Get Switch    param=?filter=name=${switch_ip}
    ${sw_uri}    Get Variable Value    ${resp['members'][${x}]['uri']}
    @{id} =     Split String    ${sw_uri}   /
    ${port_id} =    Get From List   ${id}   3
    ${porturi}       catenate    ${sw_uri}/ports/${port_id}:${Interfaces_number}
    ${res2}    Fusion Api Get Switch    uri=${porturi}
    Set To Dictionary    ${port_details[0]}    portId    ${res2['portId']}
    Set To Dictionary    ${port_details[0]}    enabled    ${enable}
    Set To Dictionary    ${port_details[0]}    portName    ${res2['portName']}
    ${uri}    catenate    ${sw_uri}/update-ports
    ${Response}    Fusion Api Edit Switch     ${port_details}    uri=${uri}
    Wait For Task    ${Response}
    sleep    120s


Verify switch hyperlink empty in Server Hardware
    [Documentation]    Verify the switch uris are disabled/absent on Server Hardware Page
    [Arguments]    ${server}
    ${sh_dict}    Create Server Hardware Dictionary    ${server}
    Refresh the server hardware    ${sh_dict['uri']}
    Refresh the server hardware    ${sh_dict['uri']}
    Refresh the server hardware    ${sh_dict['uri']}
    Refresh the server hardware    ${sh_dict['uri']}
    sleep    10s
    ${sh_dict_new}    Create Server Hardware Dictionary    ${server}
    ${sh_sw_uris}    Fetch Switch Uris from Server Hardware Page    ${sh_dict_new}
    :For    ${x}    IN    @{sh_sw_uris}
    \    Run Keyword Unless    '${x}' == 'None'    Fail    msg=Switch Uri's on Server Hardware Page should be Empty!!

Verify Server Profile Page Attributes
    [Documentation]    Verify the details of profiles like Networks/Switch ports/switch uris and MAC
    [Arguments]    ${sp_name}    ${server_name}

    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_name}
    ${Sp_connections}    Get From Dictionary    ${resp['members'][0]['connectionSettings']}    connections
    ${sp_nw_list}    Create List
    :For    ${x}    IN Range    0    2
    \    ${nw_uri}    Get Variable Value    ${Sp_connections[${x}]['networkUri']}
    \    Append To List    ${sp_nw_list}    ${nw_uri}
    ${return}    Verify Profile networks    ${sp_nw_list}
    Run Keyword Unless    '${return}' == 'True'    Fail
    ${sh_resp}    Create Server Hardware Dictionary    ${server_name}
    :For    ${x}    IN Range    0    2
    \    Run Keyword Unless    '${Sp_connections[${x}]['interconnectUri']}' == '${sh_resp['ports_info'][${x}]['interconnect_switch_uri']}'    Fail
    \    Run Keyword Unless    '${Sp_connections[${x}]['mac']}' == '${sh_resp['ports_info'][${x}]['mac']}'    Fail
    \    Run Keyword Unless    '${Sp_connections[${x}]['interconnectPort']}' == '${sh_resp['ports_info'][${x}]['switch_port']}'    Fail


Verify Profile networks
    [Documentation]    Verify network uri's from Profiles are present in Networks Page
    [Arguments]    ${sp_nw_list}
    ${nw_uri_list}    Create List
    ${resp}    Fusion Api Get Ethernet Networks
    ${len}    Get Length    ${resp['members']}
    :For    ${x}    In Range    0    ${len}
    \    ${uri}    Get Variable Value    ${resp['members'][${x}]['uri']}
    \    Append To List    ${nw_uri_list}    ${uri}
    :For    ${sp_net}    IN    @{sp_nw_list}
    \    List Should Contain Value    ${nw_uri_list}    ${sp_net}
    [Return]    True

Create Server Hardware Dictionary
    ### used in OVF2724 suite
    [Documentation]    Create a dictionary based on Server Hardware Get Request API call
    [Arguments]    ${server_name}

    ${resp}    Fusion Api Get Server Hardware    param=?filter=name=${server_name}
    ${SH_name}    Get From Dictionary    ${resp['members'][0]}    name
    ${SH_model}    Get From Dictionary    ${resp['members'][0]}    model
    ${SH_fw}    Get From Dictionary    ${resp['members'][0]}    mpFirmwareVersion
    ${SH_state}    Get From Dictionary    ${resp['members'][0]}    mpState
    ${adapter_details}    Get From Dictionary    ${resp['members'][0]}    portMap
    ${uri}     Get From Dictionary    ${resp['members'][0]}    uri
    ${ports_info}    Run Keyword If    ${adapter_details} != None    Create Port List from Adapter Details    ${adapter_details}
## Check this '${}' != 'None' for 4.0
    ${host_details}    Get From Dictionary    ${resp['members'][0]}    mpHostInfo
    :For    ${hosts}    IN    @{host_details['mpIpAddresses']}
    \    Run Keyword If    '${hosts['type']}' == 'DHCP'    Set To Dictionary    ${mphosts_addresses}    DHCP=${hosts['address']}
    \    Run Keyword If    '${hosts['type']}' == 'LinkLocal'    Set To Dictionary    ${mphosts_addresses}    LinkLocal=${hosts['address']}
    \    Run Keyword If    '${hosts['type']}' == 'Lookup'    Set To Dictionary    ${mphosts_addresses}    Lookup=${hosts['address']}
    ${temp}    Create Dictionary     name=${SH_name}
    ...                              model=${SH_model}
    ...                              firmware=${SH_fw}
    ...                              ports_info=${ports_info}
    ...                              server_state=${SH_state}
    ...                              host_details=${mphosts_addresses}
    ...                              uri=${uri}
## Check this '${}' != 'None' for 4.0
    ${adapter_name}    Run Keyword If    ${adapter_details} != None    Set To Dictionary    ${temp}    adapter_name=${adapter_details['deviceSlots'][0]['deviceName']}
    ${slotNumber}    Run Keyword If    ${adapter_details} != None    Set To Dictionary    ${temp}    slotNumber=${adapter_details['deviceSlots'][0]['slotNumber']}
    [Return]    ${temp}

Create Port List from Adapter Details
    ### used in ovf2724 suite
    [Documentation]    Create a List for port details from the Adapter Information
    [Arguments]    ${adapter_details}
    ${ports_info}    Create List
    :For    ${ports}    IN     @{adapter_details['deviceSlots'][0]['physicalPorts']}
    \    ${port_number}    Get From Dictionary    ${ports}    portNumber
    \    ${physical_switch_uri}    Get From Dictionary    ${ports}    physicalInterconnectUri
    \    ${interconnect_switch_uri}    Get From Dictionary    ${ports}    interconnectUri
    \    ${mac}    Get From Dictionary    ${ports}    mac
    \    ${switch_type}    Get From Dictionary    ${ports}    type
    \    ${switch_port}    Get From Dictionary    ${ports}    physicalInterconnectPort
    \    ${ports_dict}    Create Dictionary    portnumber=${port_number}
    \    ...                                   physical_switch_uri=${physical_switch_uri}
    \    ...                                   interconnect_switch_uri=${interconnect_switch_uri}
    \    ...                                   switch_type=${switch_type}
    \    ...                                   switch_port=${switch_port}
    \    ...                                   mac=${mac}
    \    Append To List    ${ports_info}    ${ports_dict}
    [Return]    ${ports_info}

Edit Server Profile connections
    [Documentation]    Edit the Server Profiles by changing connection vlans from 10,20 to 30,40
    [Arguments]    ${server_name}    ${sp_name}    ${nw_names}
    Power OFF server    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_name}
    Set to Dictionary    ${server_profiles_body_edit}    eTag    ${resp['members'][0]['eTag']}
    Set to Dictionary    ${server_profiles_body_edit}    name    ${resp['members'][0]['name']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareTypeUri    ${resp['members'][0]['serverHardwareTypeUri']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareUri    ${resp['members'][0]['serverHardwareUri']}
    ${sp_uri}    Get Variable Value    ${resp['members'][0]['uri']}
    ${old_connections}    Get From Dictionary    ${resp['members'][0]['connectionSettings']}    connections
    ${len}    Get Length    ${nw_names}
    :For    ${x}    In Range    0    ${len}
    \    ${res}    Fusion Api Get Ethernet Networks    param=?filter=name=${nw_names[${x}]}
    \    ${net_uri}    Get Variable Value    ${res['members'][0]['uri']}
    \    Set To Dictionary    ${server_profiles_body_edit['connectionSettings']['connections'][${x}]}    networkUri=${net_uri}
    ${resp}    Fusion Api Edit Server Profile    body=${server_profiles_body_edit}    uri=${sp_uri}
    ${task}    Wait For Task    ${resp}    250s    10s
    Power on server   ${server_name}
    Sleep    100s

Edit Server Profile connections for netset
    [Documentation]    Edit the Server Profiles by changing connection vlans from 10,20 to 30,40
    [Arguments]    ${server_name}    ${sp_name}    ${nw_uris_list}    ${net_con_uri}
    Power OFF server    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_name}
    Set to Dictionary    ${server_profiles_body_edit}    eTag    ${resp['members'][0]['eTag']}
    Set to Dictionary    ${server_profiles_body_edit}    name    ${resp['members'][0]['name']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareTypeUri    ${resp['members'][0]['serverHardwareTypeUri']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareUri    ${resp['members'][0]['serverHardwareUri']}
    ${sp_uri}    Get Variable Value    ${resp['members'][0]['uri']}
    ${old_connections}    Get From Dictionary    ${resp['members'][0]['connectionSettings']}    connections
    ${len}    Get Length    ${old_connections}
    Set To Dictionary    ${server_profiles_body_edit['connectionSettings']['connections'][0]}    networkUri=${nw_uris_list}
    Set To Dictionary    ${server_profiles_body_edit['connectionSettings']['connections'][1]}    networkUri=${net_con_uri}
    ${resp}    Fusion Api Edit Server Profile    body=${server_profiles_body_edit}    uri=${sp_uri}
    ${task}    Wait For Task    ${resp}    250s    10s
    Power on server    ${server_name}
    Sleep    100s

Verify VlanID in switch
    [Documentation]    Login to switch and fetch active VlanID
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    SSHLibrary.Open Connection    ${switch_ip}    timeout=30s
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    7s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${interface}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    SSHLibrary.Write    ${Commands[10]}
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan (\\d.*)
    ${value}    Convert To String    ${vlan}
    [Return]    ${value}

Disable VlanID in switch
    [Documentation]    Login to switch and fetch active VlanID
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    SSHLibrary.Open Connection    ${switch_ip}    timeout=30s
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    7s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${interface}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    SSHLibrary.Write    ${disable_vlan[0]}
    sleep    3s
    SSHLibrary.Write    write
    sleep    8s
    SSHLibrary.Write    ${disable_vlan[1]}
    sleep    3s
    SSHLibrary.Write    write
    sleep    8s
    SSHLibrary.Write    ${Commands[10]}
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan\\s+(\\w+)
    Run Keyword Unless    '${vlan}' == 'none'    Fail
    [Return]    True

Fetch VlanId from switches for profiles
    [Documentation]    Login to the Arista switch and execute commands to fetch active Vlans
    [Arguments]    ${switch_ip}    ${interface}
    ${data}    Verify VlanID in switch    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    [Return]    ${data}


Fetch vlanid from Profile connections
    [Documentation]    Perform a Get Request on server profile connections and fetch their vlanid's
    [Arguments]    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${server_name}
    ${nw_uri_list}    Create List
    ${len}    Get Length    ${resp['members'][0]['connectionSettings']['connections']}
    :For    ${x}    In Range    0    ${len}
    \    ${net_uri}    Get From Dictionary    ${resp['members'][0]['connectionSettings']['connections'][${x}]}    networkUri
    \    Append To List    ${nw_uri_list}    ${net_uri}
    ${sp_vlans}    Create List
    :For    ${net}    IN    @{nw_uri_list}
    \    ${resp}    Fusion Api Get Ethernet Networks    uri=${net}
    \    ${value}    Get Variable Value    ${resp['vlanId']}
    \    ${vlan}    Convert To String    ${value}
    \    Append To List    ${sp_vlans}    ${vlan}
    [Return]    ${sp_vlans}

Fetch vlanid from Profile connections for netset
    [Documentation]    Perform a Get Request on server profile connections and fetch their vlanid's
    [Arguments]    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${server_name}
    ${ns_uri}    Get From Dictionary    ${resp['members'][0]['connectionSettings']['connections'][0]}    networkUri
    ${net_uri}    Get From Dictionary    ${resp['members'][0]['connectionSettings']['connections'][1]}    networkUri
    ${sp_vlans}    Create List
    ${resp}    Fusion Api Get Network Set    uri=${ns_uri}
    ${nw_list}    Get Variable Value    ${resp['networkUris']}
    Append To List    ${nw_list}    ${net_uri}
    :For    ${net}    IN    @{nw_list}
    \    ${resp}    Fusion Api Get Ethernet Networks    uri=${net}
    \    ${value}    Get Variable Value    ${resp['vlanId']}
    \    ${vlan}    Convert To String    ${value}
    \    Append To List    ${sp_vlans}    ${vlan}
    [Return]    ${sp_vlans}


Fetch vlan id of switch and profile
    [Documentation]    Fetch the VlanIds of Profile and switches and verify them
    [Arguments]    ${server_profile}    ${switch_ip}    ${interface}
    ${sp_vlans}    Fetch vlanid from Profile connections    ${server_profile[0]['name']}
    :For    ${switch}    IN    @{switch_ip}
    \    ${switch_vlans}    Fetch VlanId from switches for profiles    ${switch}    ${interface}
    \    List Should Contain Value    ${sp_vlans}    ${switch_vlans}


Fetch vlan id of switch and profile for netset
    [Documentation]    Fetch the VlanIds of Profile and switches and verify them
    [Arguments]    ${server_profile}    ${switch_ip}    ${interface}
    ${sp_vlans}    Fetch vlanid from Profile connections for netset    ${server_profile[0]['name']}
    :For    ${switch}    IN    @{switch_ip}
    \    ${switch_vlans}    Fetch VlanId from switches for profiles    ${switch}    ${interface}
    \    ${len}    Get Length    ${switch_vlans}
    \    Run Keyword If    ${len} == 2    List Should Contain Value    ${sp_vlans}    ${switch_vlans}
    \    ...    ELSE    Validate switch vlans and profile vlans for netset    ${switch_vlans}    ${sp_vlans}

Validate switch vlans and profile vlans for netset
    [Documentation]    validate switch vlans and profile vlans for netset
    [Arguments]    ${switch_vlans}    ${sp_vlans}
    @{list}    Split String    ${switch_vlans}    ,
    :For    ${x}    In Range    0    3
    \    List Should Contain Value    ${sp_vlans}    ${list[${x}]}

Verify switch VlanID removed
    [Documentation]    Verify switch vlanID removed
    [Arguments]     ${switch_ip}      ${switch_details}     ${interface}     ${Commands}
    :For    ${switch}    IN    @{switch_ip}
    \    Verify switch VlanID empty    ${switch}    ${switch_details}    ${interface}    ${Commands}

Verify switch VlanID empty
    [Documentation]    Login to switch and check active VlanID is none
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    SSHLibrary.Open Connection    ${switch_ip}    timeout=30s
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    7s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${interface}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    SSHLibrary.Write    ${Commands[10]}
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan\\s+(\\w+)
    Run Keyword Unless    '${vlan}' == 'none'    Fail
    [Return]    True

Presetup for Profiles
    [Documentation]    Presetup for profile creation Includes creation of Networks, LSG, LS and Importing Server Hardwares
    ${resp}    Add Logical Switch Group from variable    ${lsgs[2]}
    Set to dictionary     ${username}    value    ${SWITCH1_USER}
    Set to dictionary     ${password}    value    ${SWITCH1_PASS}
    ${temp}     Copy Dictionary    ${lss[2]}
    ${resp}     Add Logical Switch from variable    ${temp}
    Create Networks for Profiles
    Create Network Set for Profiles
    :For    ${switch}    IN    @{switch_ip}
    \    Set VlanID in Switch    ${switch}    ${Commands}    ${switch_vlan}
    ${len}    Get Length    ${DL_SH_IP}
    ${temp}    Copy Dictionary    ${DL_SH_body}
    :For    ${x}    In Range    0    ${len}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    Run Keyword If  '${resp['status_code']}' == '202'    Log to console and logfile  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Imported the DL server with IP ${DL_SH_IP[${x}]}\n
    \    ...    ELSE    FAIL
    \    ${task1} =   Get Variable value     ${resp['uri']}
    \    Sleep    60s
    \    ${task} =   Fusion Api Get Task     uri=${task1}
    \    ${msg} =    Get Variable value  ${task['taskState']}
    \    Should Match Regexp    ${msg}  ((?i)Completed|Warning)
    #setting vlan in switches
    :For    ${switch}    IN    @{switch_ip}
    \    Set VlanID in Switch    ${switch}    ${Commands}    ${set_vlan[0]}

Create Networks for Profiles
    [Documentation]    Create 6 networks with Vlans 10 20 30 40 50 60
    ${temp}    Copy Dictionary    ${Network_body}
    :For    ${vlan}    IN    @{Vlans}
    \    Set To Dictionary    ${temp}    vlanId    ${vlan}
    \    Set To Dictionary    ${temp}    name    Net_Vlan${vlan}
    \    ${nw}    Fusion Api Create Ethernet Network    ${temp}
    \    Run Keyword If  '${nw['status_code']}' == '202'    Log to console  \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    \    ...    ELSE    FAIL
    \    ${task}    fusion_api_appliance_setup.Wait For Task    ${nw}    60 s    10 s

Create Network Set for Profiles
    [Documentation]    Create different Network Sets for Server Profiles
    [Arguments]      ${nativeurilist}=${NONE}    ${nativeyes}=0
    :For    ${x}    In Range    0    2
    \    Run Keyword If  '${nativeyes}' == '1'    Create Network Sets    ${Network_sets[${x}]}    ${x}    ${nativeurilist[${x}]}
    \    ...    ELSE    Create Network Sets    ${Network_sets[${x}]}    ${x}    ${nativeurilist}

Create Network Sets
    [Documentation]    Create Network Sets
    [Arguments]    ${nw_set_vlans}    ${x}    ${nativeuri}=${NONE}
    ${nw_uri_list}    Create List
    ${y}    Evaluate    ${x}+1
    ${temp}    Copy Dictionary    ${Network_set_body}
    :For    ${name}    IN    @{nw_set_vlans}
    \    ${net}    Fusion Api Get Ethernet Networks    param=?filter=name=${name}
    \    ${uri}    Get Variable Value    ${net['members'][0]['uri']}
    \    Append To List    ${nw_uri_list}    ${uri}
    Set To Dictionary    ${temp}    networkUris    ${nw_uri_list}
    Set To Dictionary    ${temp}    name    Net_Set${y}
    Set To Dictionary    ${temp}    nativeNetworkUri    ${nativeuri}
    ${resp}    Fusion Api Create Network Set    ${temp}
    Run Keyword If  '${resp['status_code']}' == '202'    Log to console  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Created Network Set\n
    ...    ELSE    FAIL
    ${Task}    Wait For Task And Validate Response    ${resp}    ${valDict}    180 s    10 s    True

Add DL Server Profiles from variable
    [Documentation]    Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
    [Arguments]     ${profiles}   ${timeout}=15m    ${interval}=10s   ${endstate}=((?i)Warning|Completed)   ${param}=?force=ignoreServerHealth
    :FOR    ${profile}    IN    @{profiles}
    \   ${profile}    fusion_api_appliance_setup.Copy Dictionary    ${profile}
        \       ${space}    Check For Whitespace From String    ${profile['name']}
        \       Run Keyword If   ${space} is ${True}   Fail   msg=Profile name contains whitespace. This is not allowed in CI-FIT naming convention.
    \   ${shuri}    Get from Dictionary    ${profile}    serverHardwareUri
    \   ${uri}    Get Server Hardware URI    ${shuri}
    \   Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    \   ${profile}    Update connections in profile    ${profile}
    \   ${resp}    Fusion Api Create Server Profile    body=${profile}    param=${param}
    \   ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    timeout=${timeout}    interval=${interval}
    [Return]    ${task}

Get interface number
    [Documentation]    Get Interface Number
    [Arguments]    ${DL_server_names}    ${server_profile}
    ${len}    Get Length    ${DL_server_names}
    :For    ${x}    In Range    0    ${len}
    \    Run Keyword If    '${DL_server_names[${x}]}' != '${server_profile[0]['serverHardwareUri']}'    Continue For Loop
    \    ...    ELSE    Run Keywords    Set Global Variable    ${interface}    ${Interfaces_number[${x}]}    AND    Exit For Loop
    [Return]    ${interface}

Validate switchports are equal in server hardware
    [Documentation]    Validate switchports are equal in server hardware
    [Arguments]    ${server}
    ${SH_dict}    Create Server Hardware Dictionary    ${server}
    ${uri}    Get From Dictionary    ${SH_dict}    uri
    ${Ports}    ${switch_ports}    Validate Port Info    ${SH_dict['ports_info']}
    ${status}    Validate switch ports are equal     ${switch_ports}
    [return]    ${uri}   ${status}

Fetch Switch Uris from Server Hardware Page
    ### used in ovf2724 suite
    [Documentation]    Keyword to Fetch a list of switch uri's for each Server Hardware
    [Arguments]    ${SH_dict}
    ${sw_uri_SH}    Create List
    :For    ${port}    IN    @{SH_dict['ports_info']}
    \    ${physical_switch_uri}    Get Variable Value    ${port['physical_switch_uri']}
    \    Append To List    ${sw_uri_SH}    ${physical_switch_uri}
    #Log to console and logfile    \n\n The Switch uri's of ${SH_dict['name']} are : ${sw_uri_SH}
    [Return]    ${sw_uri_SH}

Validate Port Info
    ### used in OVF2724 suite
    [Documentation]    Validate Port Info of a server adapters
    [Arguments]    ${SH_ports}
    ${sw_uri_list}    Create List
    ${switch_ports}    Create List
    :For    ${ports}    IN    @{SH_ports}
    \    Run Keyword Unless   '${ports['switch_type']}' == '${sw_type}'    FAIL
    \    ${port_number}    Convert To String    ${ports['portnumber']}
    \    ${switch_port}    Convert To String    ${ports['switch_port']}
    \    Append To List    ${switch_ports}    ${switch_port}
    \    Should Match Regexp    ${port_number}    \\d+
    \    Should Match Regexp    ${switch_port}    \\d+
    \    ${sw_uri}    Get Variable Value    ${ports['physical_switch_uri']}
    \    Run Keyword If    '${sw_uri}' == '${ports['interconnect_switch_uri']}'
    \    ...    Append To List    ${sw_uri_list}    ${sw_uri}
    [Return]    ${sw_uri_list}  ${switch_ports}

Validate switch ports are equal
     ### used in ovf2724 suite
    [Documentation]    Verify switch ports are equal
    [Arguments]    ${switch_ports}
    ${status}    Evaluate  '${switch_ports[0]}' == '${switch_ports[1]}'
    [return]    ${status}

Refresh the server
    [Documentation]    Refresh the server until ports on both switches in server hardware page are same
    [Arguments]    ${uri}    ${server}
    ${resp}    Fusion Api Refresh Server Hardware    uri=${uri}
    ${task}    Wait For Task    ${resp}    250s    10s
    ${out1}    ${status}    Validate switchports are equal in server hardware    ${server}
    Run keyword If    '${status}'== 'False'    Refresh the server     ElSE     Log to console and logfile     Switch ports are equal

Refresh the server hardware
    [Documentation]    Refresh the server hardware after disabling switch port
    [Arguments]    ${uri}
    ${resp}    Fusion Api Refresh Server Hardware    uri=${uri}
    ${task}    Wait For Task    ${resp}    250s    10s


Clean OV
    [Documentation]    Clean Up the Appliance
    Log to console and logfile    \nCleaning the OV
    Fusion Api Login Appliance    ${APPLIANCE_IP_4_10}    ${admin_credentials}
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Server Profile Template
    Remove All Server Hardware
    Remove All LS
    Remove All LSGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets
    Remove ALL Users

Remove All Server Hardware
    [Documentation]    Removes server Hardware
    #Log to console and logfile    \n Removes server Hardware\n
    ${SH}    Fusion Api Get Server Hardware
    :FOR    ${server}    IN     @{SH['members']}
    \    ${resp} =    Fusion Api delete Server Hardware        uri=${server['uri']}
    \    ${task} =    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s

Remove All Server Profile Template
    [Documentation]    Removes all Server Profile Template
    ${SP_temp}    Fusion Api Get Server Profile Templates
    :FOR    ${template}    IN     @{SP_temp['members']}
    \    ${resp} =    Fusion Api Delete Server Profile Template        uri=${template['uri']}
    \    ${task} =    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s

Get Redhat IP Old
    [Documentation]    ssh login to Redhat DL 380 Server using eno4 interface to fetch IPs of eno5 & eno6
    [Arguments]    ${redhat_ip}
    ${ips}    Create List
    SSHLibrary.Open Connection    ${redhat_ip}    timeout=30s
    SSHLibrary.Login    root    hpvse123
    #SSHLibrary.Read Until    #
    sleep    5s
    SSHLibrary.Write    ip addr
    sleep    5s
    ${Output}=    SSHLibrary.Read
    Log to console and logfile    \n\n${Output}
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    scope global dynamic
    Log to console and logfile    \n\n${lines}
    ${match1}    ${redhatip1}     Should Match Regexp    ${lines}    inet (192.\\d+.\\d+.\\d+)/\\d+.*eno5
    ${match2}    ${redhatip2}     Should Match Regexp    ${lines}    inet (192.\\d+.\\d+.\\d+)/\\d+.*eno6
    Log to console and logfile    \n\nlines ${match1}
    Log to console and logfile    \n\nlines ${redhatip1}
    Log to console and logfile    \n\nlines ${match2}
    Log to console and logfile    \n\nlines ${redhatip2}
    Append To List    ${ips}    ${redhatip1}
    Append To List    ${ips}    ${redhatip2}
    [Return]    ${ips}

Get Server Hardware OS type and ILO IP
    [Documentation]    Get server hardware OS type and ILO IP
    [Arguments]     ${server_name}
    ${resp}    Fusion Api Get Server Hardware    param=?filter=name=${server_name}
    ${SH_name}    Get From Dictionary    ${resp['members'][0]}    serverName
    ${ip}=      Get From Dictionary     ${resp['members'][0]['mpHostInfo']['mpIpAddresses'][0]}   address
    [return]   ${SH_name}    ${ip}

Get Windows Server IP
    [Documentation]    Gets the valid ip and gateway ip of the server.
    [Arguments]     ${win_server_details}   ${ip}

    SSHLibrary.Open Connection    ${ip}
    SSHLibrary.Login    ${win_server_details['username']}    ${win_server_details['password']}
    Sleep    5
    ${windows_ips}      Create List
    #SSHLibrary.Read Until    hpiLO->
    #Sleep    5
    SSHLibrary.Write    stop /system1/oemhp_VSP1
    Sleep    5
    SSHLibrary.Write    vsp
    Sleep    5
    SSHLibrary.Read Until    SAC>
    Sleep    5
    SSHLibrary.Write    i
    Sleep    5
    ${output1}=    SSHLibrary.Read
    ${cmd_output}=    Get Regexp Matches    ${output1}    192\\.\\d+\\.\\d+\\.\\d+
    ${IP_Count}=    Get Length    ${cmd_output}
    :FOR     ${x}   IN RANGE    0    ${IP_Count}
    \    ${Server_IP}=    convert_unicode_to_string    ${cmd_output[${x}]}
    \    Append To List    ${windows_ips}   ${Server_IP}
    SSHLibrary.Close All Connections
    [Return]  ${windows_ips}


Ping Downlink from Uplink
    [Documentation]    Ping downlink from uplink to verify traffic
    [Arguments]    ${server_ip}
    ${result1}    Run    ping ${server_ip}
    ${cmd_output1}    Get Regexp Matches    ${result1}    Lost = \\d
    ${data_loss}    Get Variable Value    ${cmd_output1[0]}
    Run Keyword If    '${data_loss}' == '0'    log to console    \n Expected Failure - Ping succeeds  !!!
    ...    Else    FAIL

Verify Port Status
    [Documentation]    Verify Port Status
    ...             Example:
    ...             Verify Port Status    ${ports}
    [Arguments]         ${switchUris}    ${portid}    ${ports}     ${status}
    ${length}     Get Length       ${ports}
    :FOR    ${x}    IN RANGE     0     ${length}
    \   ${resp}    fusion_api_get_interconnect_ports      uri=${switchUris}     param=/${portid}:${ports[${x}]}
    \    Should be Equal    ${resp['portStatus']}     ${status}

Reboot Arista Switch
    [Documentation]    Reboots the arista switch
    ...             Example:
    ...             Reboot Arista Switch    ${Arista_switch_ip}   ${reboot_command}
    [Arguments]         ${Arista_switch_ip}   ${command}    ${SSH_USER}=admin
    SSHLibrary.Open Connection     ${Arista_switch_ip}     timeout=60s
    Set Suite variable  ${SSH_PASS}     password
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    5s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    en
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${command}
    sleep    5s
    #SSHLibrary.Read Until    [confirm]
    SSHLibrary.Write    y

Verify Switch State
    [Documentation]    Verifying switch state
    ...             Example:
    ...             Verify Switch State    ${LSname}
    [Arguments]         ${LSname}    ${state}
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LSname}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}    Get Length    ${switchUris}
    :FOR    ${x}    IN RANGE   0    ${length}
    \    ${resp}    Fusion Api Get Switch     uri=${switchUris[${x}]}
    \    Should Be Equal    ${resp['state']}     ${state}
    #\    Log to console and logfile    \n The switch state is ${resp['state']}

Verify Server Hardware Power State
    [Documentation]    Get ALL Appliance Server Hardware URI
    [Arguments]     ${DL_server_names}    ${state}
    ${resp} =   Fusion Api Get Server Hardware    param=?filter="'name'=='${DL_server_names}'"
    Should be Equal    ${resp['members'][0]['powerState']}     ${state}
    #Log to console and logfile    \n The server hardware power state is ${resp['members'][0]['powerState']}

Ping IP
    [Documentation]    Pinging the given server ip
    ...             Example:
    ...             Ping Server IP    ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    [Arguments]         ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    startthread    ${number}    ${server_ip}    ${name}    ${flag}
    Sleep    20
    ${contents1}=    OperatingSystem.Get File    ${name}
    [Return]     ${contents1}

Verify Ping Successful
    [Documentation]    Verifying if the server ping is successful by checking if loss is 0% and if it does not contain destination unreachable or Request timed out
    ...             Example:
    ...             Verify Server Ping Successful    ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    [Arguments]         ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    ${l} =  Get Length  ${server_ip}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    ${loss} =    Ping IP    ${number}    ${server_ip[${x}]}    ${name}    ${flag}    ${file_path}
    \    ${match}   ${ret1}    Should Match Regexp    ${loss}    Lost\\s+=\\s+\\d+\\s+\\((\\d+%)\\s+loss\\)
    \    Should Not Contain    ${loss}    ${time_out}
    \    Should Not Contain    ${loss}    ${Dest_unreachable}
    \    Run Keyword If    '${ret1}' == '0%'    Log to console and logfile    \n Pinging is successful    ELSE    Fail


Verify Ping Fails
    [Documentation]    Verifying if server ping fails by checking if the response does not contain TTL=
    ...             Example:
    ...             Verify Ping Fails    ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    [Arguments]         ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}

    ${loss} =    Ping IP    ${number}    ${server_ip}    ${name}    ${flag}     ${file_path}
    Should Not Contain    ${loss}    TTL=

Build Edit Profile body
    [Documentation]   Editing the existing Server Profiles
    ...             Example:
    ...             Build Edit Profile body    ${profiles}
    [Arguments]     ${profiles}
    Log to console and logfile      Editing SERVER PROFILES

    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${profiles}
    ${connections} =  Get from Dictionary     ${resp['members'][0]['connectionSettings']}    connections
    ${profile_uri} =  Get from Dictionary     ${resp['members'][0]}    uri

    Set to Dictionary   ${server_profiles_edit_body}  name   ${resp['members'][0]['name']}
    Set to Dictionary   ${server_profiles_edit_body}  serverHardwareUri   ${resp['members'][0]['serverHardwareUri']}
    Set to Dictionary   ${server_profiles_edit_body}  eTag   ${resp['members'][0]['eTag']}
    Set to Dictionary   ${server_profiles_edit_body}  serverHardwareTypeUri   ${resp['members'][0]['serverHardwareTypeUri']}
    [Return]     ${profile_uri}

Edit Server Profile
    [Documentation]     Edit server profile
    ...             Example:
    ...             Edit Server Profile    ${edit_profile_body}     ${name}
    [Arguments]    ${edit_profile_body}    ${name}
    ${uri}    Get Profile Uri    ${name}
    ${etag}    Get Profile ETag    ${name}
    Set to dictionary   ${edit_profile_body}    eTag        ${etag}
    ${resp} =   Fusion Api Edit Server Profile   ${edit_profile_body}     uri=${uri}    param=?force=ignoreServerHealth
    ${task} =   Wait For Task   ${resp}     5 mins      10s
    Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="Edit profile failed"
    [Return]     ${resp}

Validate Alert Message
    [Documentation]    Validating the 'Active' alert message with a variable which contains the expected alert message
    ...             Example:
    ...             Validate Alert Message    ${UPLINK_MSG}    ${varTrue}    ${Alert[0]}
    [Arguments]     ${msg}    ${flag}    ${Alerts}
    ${Response}    Fusion Api Get Alerts    /rest/alerts?filter="alertState EQ '${Alerts}'"
    ${Count}    Get From Dictionary    ${Response}    count
    Run Keyword If    '${Count}'=='0'    Fail    "Failed as alert message is not found"
    ${Members}    Get From Dictionary    ${Response}    members
    :FOR    ${Index}    IN RANGE    0    ${Count}
    \    ${Alert}        Get From List    ${Members}    ${Index}
    \    ${AlertDesc}    Get From Dictionary    ${Alert}    description
    \    ${AlertDesc1}    Get Lines containing string    ${AlertDesc}    ${msg}
    \    Exit for loop if    '${AlertDesc1}'!='${Empty}'
    run keyword if    '${flag}'=='True'   Should Contain     ${AlertDesc1}    ${msg}    ELSE   Should Not Contain     ${AlertDesc}    ${msg}

Get Profile Uri
    [Documentation]     Getting Server Profile URI
    ...             Example:
    ...             Get Profile Uri    ${name}
    [Arguments]    ${name}
    ${profiles} =   Fusion Api Get Server Profiles  param=?sort=name:ascending
    ${l} =  Get Length  ${profiles['members']}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   Run Keyword If  '${profiles['members'][${x}]['name']}' != '${name}'        Continue For Loop
    \   ${uri} =    Get From Dictionary     ${profiles['members'][${x}]}    uri
    [Return]    ${uri}

Get Profile ETag
    [Documentation]     Getting Server Profile Etag
    ...             Example:
    ...             Get Profile ETag    ${name}
    [Arguments]    ${name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${name}
    ${eTag} =   Get From Dictionary     ${resp['members'][${x}]}    eTag
    [Return]    ${eTag}

Get Advanced Statistics
    [Documentation]    Verifying switch state
    ...             Example:
    ...             Get Advanced Statistics    ${switchUris}
    [Arguments]         ${switchUris}
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE     0     ${length}
    \   ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}    param=${Port_Name[${x}]}
    \   ${initial_ifInOctets}    Get from Dictionary    ${resp}    ifInOctets
    \   ${initial_ifOutOctets}    Get from Dictionary    ${resp}    ifOutOctets
    \   ${initial_ifInUcastPkts}    Get from Dictionary    ${resp}    ifInUcastPkts
    \   ${initial_fOutUcastPkts}    Get from Dictionary    ${resp}    ifOutUcastPkts
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifInOctets    ${initial_ifInOctets}
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifOutOctets    ${initial_ifOutOctets}
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifInUcastPkts    ${initial_ifInUcastPkts}
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifOutUcastPkts    ${initial_fOutUcastPkts}
    \    ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}
    \    ${uplink_resp}    Get Port Data From Port Name    ${resp}    ${uplink_stacking_port}
    \   ${initial_ifInOctets}    Get from Dictionary    ${uplink_resp}    ifInOctets
    \   ${initial_ifOutOctets}    Get from Dictionary    ${uplink_resp}    ifOutOctets
    \   ${initial_ifInUcastPkts}    Get from Dictionary    ${uplink_resp}    ifInUcastPkts
    \   ${initial_fOutUcastPkts}    Get from Dictionary    ${uplink_resp}    ifOutUcastPkts
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifInOctets    ${initial_ifInOctets}
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifOutOctets    ${initial_ifOutOctets}
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifInUcastPkts    ${initial_ifInUcastPkts}
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifOutUcastPkts    ${initial_fOutUcastPkts}

Match vlanid of switch and profile
    [Documentation]    Compare the VlanID obtained from switch with that of the profiles
    [Arguments]    ${switch_ip}    ${interface}    ${sp_vlans}
    ${switch_vlans}    Fetch VlanId from switches for profiles    ${switch_ip}    ${interface}
    List Should Contain Value    ${sp_vlans}    ${switch_vlans}

Get Port Data From Port Name
    [Documentation]    Get port data
    [Arguments]        ${data}    ${portName}
    ${ports} =  Get From Dictionary     ${data}    genericPortStatistics
    ${l} =     Get Length    ${ports}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${port} =     Get From List   ${ports}    ${x}
    \     Exit For Loop If     '${port['portName']}' == '${portName}'
    [Return]    ${port}

Get switch details
    [Documentation]    Get switch data
    [Arguments]        ${x}
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${Switch_validate_list}     Create List
    ${ipAddress}=    Get From Dictionary    ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    ipAddress
    Append to List    ${Switch_validate_list}     ${ipAddress}
    ${vpcRole}=    Get From Dictionary  ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}  vpcRole
    Append to List    ${Switch_validate_list}     ${vpcRole}
    ${memberId}=    Get From Dictionary ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}  memberId
    Append to List    ${Switch_validate_list}     ${memberId}
    ${fw_version}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    firmwareVersion
    Append to List    ${Switch_validate_list}     ${fw_version}
    ${state}=    Get From Dictionary    ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    state
    Append to List    ${Switch_validate_list}     ${state}
    [Return]     ${Switch_validate_list}

Verify Output
    [Documentation]    Get switch data and verify the data
    [Arguments]    ${ip}    ${port_details}    ${port_uri}    ${port_id}    ${port_no}    ${Enable}
    ${Response}=     fusion_api_edit_switch_ports    ${port_details}    ${port_uri}
    ${task}    Wait For Task    ${Response}
    sleep    120s
    ${status}=    Get Status    ${port_uri}/ports/${port_id}
    Verify Enable/Disable Port in Switch    ${ip}    ${Commands}    ${port_no}    ${Enable}
    #${server_resp}=    fusion_api_get_server_profiles
    #Check Alert Message    ${Enable}      ${Alert_switchport}

Verify Enable/Disable Port in Switch
    [Documentation]    Verify disable enable port status
    [Arguments]    ${ip}    ${Commands}    ${Port_No}    ${Enable}
    SSHLibrary.Open Connection    ${ip}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    Sleep    10s
    #${Output}=    SSHLibrary.Read Until    )#
    ${Output}=    SSHLibrary.Read
    Run Keyword If    '${Enable}' != '1'    Should Contain    ${Output}    ${Commands[4]}
    ...    ELSE    Should not Contain    ${Output}    ${Commands[4]}
    #Log to console and logfile    \n-Port status changed in switch.
    SSHLibrary.Close Connection

Get Status
    [Documentation]    Fetch the status of the resource
    [Arguments]    ${uri}
    ${resp} =    Fusion Api Get Resource    uri=${uri}
    ${status}=    Get from Dictionary    ${resp}    portStatus
    #[Return]   ${status}

Get Uri of Switch
    [Documentation]    Fetch the uri of the switch
    ${lss_name}=    Get From Dictionary    ${lss[0]['logicalSwitch']}    name
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${lss_name}'"
    ${uris}=    Get From Dictionary ${resp['members'][0]}    switchUris
    [Return]    ${uris}

Verify Parameters
   [Documentation]    Validates data in a response body against expected values
   [Arguments]    ${resp}   @{Val_list}
    ${type}=    Get From Dictionary ${resp}    type
    Should Be Equal    ${type}    ${Val_list[0]}    values=true
    ${consistency_status}=    Get From Dictionary   ${resp['members'][0]}    consistencyStatus
    Should Be Equal    ${consistency_status}    ${Val_list[1]}    values=true
    ${domainId}=    Get From Dictionary ${resp['members'][0]['logicalSwitchDomainInfo']}    domainId
    Should Be Equal    ${domainId}    ${Val_list[2]}    values=true
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE    0    2
    \    ${switchdetails} =     Fusion Api Get Switch       uri=${switchUris[${x}]}
    \    ${state}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    state
    \    Should Be Equal    ${state}    ${Val_list[5]}    values=true
    \    ${firmwareVersion}=    Get From Dictionary ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    firmwareVersion
    \    Should Be Equal    ${firmwareVersion}    ${Val_list[6]}    values=true
    \    ${model}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    model
    \    Should Be Equal    ${model}    ${Val_list[7]}    values=true
    \    ${destPortUri}=    Get From Dictionary ${resp['members'][0]['switchStackingInfo'][0]['switchStackingElements'][${x}]}    destPortUri
    \    ${srcPortUri}=    Get From Dictionary  ${resp['members'][0]['switchStackingInfo'][0]['switchStackingElements'][${x}]}    srcPortUri

Ports For Loop
    [Documentation]    Fetch the port names
    [Arguments]    ${count}    ${resp}
    ${Port_number_list}=    Create List
    :FOR    ${x}    IN RANGE    0    ${count}
    \    ${speed}=    Get From Dictionary    ${resp['ports'][${x}]}    operationalSpeed
    \    ${portType}=    Get From Dictionary    ${resp['ports'][${x}]}    portType
    \    ${portStatus}=    Get From Dictionary    ${resp['ports'][${x}]}    portStatus
    \    ${portName}=    Get From Dictionary    ${resp['ports'][${x}]}    portName
    \    ${remotePortId}=    Run Keyword If    '${portStatus}' == 'Linked'    Get From Dictionary    ${resp['ports'][${x}]['neighbor']}    remotePortId
    \    ${servername}=    Run Keyword If    '${portStatus}' == 'Linked' and '${portType}'!='Uplink'    Get From Dictionary    ${resp['ports'][${x}]['neighbor']}    linkLabel
    \    ${remoteMgmtAddress}=    Run Keyword If    '${portStatus}' == 'Linked' and '${portType}'=='Uplink'    Get From Dictionary    ${resp['ports'][${x}]['neighbor']}    remoteMgmtAddress
    \    ...    ELSE IF    '${portStatus}' == 'Linked' and '${portType}'!='Uplink'    Log to console and logfile    \nConnected To:${remotePortId}${servername}
    \    ...    ELSE    Log to console and logfile    \nPort${x} is unlinked no connected to information
    \    ${Port_number}=    Run Keyword If    '${portStatus}' == 'Linked'    Get From Dictionary    ${resp['ports'][${x}]}    portName
    \    Append to List    ${Port_number_list}    ${Port_number}
    [Return]    ${Port_number_list}

Enable/Disable VlanID in Switch
    [Documentation]    Enable disable vlan ID in switch
    [Arguments]    ${ip}    ${Commands}    ${Port_No}    ${Vlan_Id}    ${Enable}
    SSHLibrary.Open Connection    ${ip}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    Run Keyword If    '${Enable}' == '1'    Run Keywords
    ...    SSHLibrary.Write    ${Commands[8]} 2-4093
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]})#
    ...    AND    SSHLibrary.Write    ${Commands[5]} ${Vlan_Id}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-${Commands[5]}-${Vlan_Id})#
    ...    AND    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    ...    AND    SSHLibrary.Write    ${Commands[6]}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    ...    AND    SSHLibrary.Write    ${Commands[7]} ${Vlan_Id}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    ...    ELSE   Run Keywords
    ...    SSHLibrary.Write    ${Commands[8]} ${Vlan_Id}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[9]}
    ${Output}=    SSHLibrary.Read Until    )#
    SSHLibrary.Close Connection
    ${Line1}    Get Lines Containing String    ${Output}    VLAN${Vlan_Id_Format}
    ${New_Line1}    Run Keyword If    '${Enable}' == '1'    Remove String    ${Line1}    ,
    ${List1}    Run Keyword If    '${Enable}' == '1'    Split String    ${New_Line1}
    Run Keyword If    '${Enable}' == '1'    List Should Contain Value   ${List1}    Et${Port_No}    ELSE    Should Be Empty    ${Line1}

Get VlanID
    [Documentation]    Fetch the vlan ID
    [Arguments]    ${uri}
    ${resp} =    Fusion Api Get Resource    uri=${uri}
    ${vlan}=    Get from Dictionary    ${resp}    vlans
    ${remote_conn}=    Get from Dictionary    ${resp}    neighbor
    [Return]    ${vlan}    ${remote_conn}

##### server hardware ######

Verify Adapter name
    [Documentation]    Verify the adapter name of server
    [Arguments]    ${servermodel}    ${server_adapter}
    ${len}    Get Length    ${server_models}
    :For    ${x}    In Range    0    ${len}
    \    Run Keyword If    '${servermodel}' == '${server_models[${x}]}'    Should Be Equal As Strings    ${server_adapter}    ${adapter_models[${x}]}

Verify ILO names with Switch list
    [Documentation]    Compare names of each ILO with switch data
    [Arguments]    ${switch_list}    ${ilo_names}
    :For    ${name}    IN    @{ilo_names}
    \    List Should Contain Value    ${switch_list}    ${name}    message=switch doesnt contain data

Verify ILO names absent with Switch list
    [Documentation]    Compare names of each ILO with switch data
    [Arguments]    ${switch_list}    ${ilo_names}
    :For    ${name}    IN    @{ilo_names}
    \    List Should Not Contain Value    ${switch_list}    ${name}    message=switch Contains

Verify SH Switch Data Empty
    [Documentation]    Verify the Switch data in Server Hardware Page is null
    [Arguments]    ${ports_info}
    #log to console    \n ports data :${ports_info}
    :For    ${port}    IN    @{ports_info}
    \    Run Keyword If    ${port['physical_switch_uri']} != None    Fail    message="Switch uri should be empty"

Fetch ILO Names From Switches
    [Documentation]    Fetch the ILO names in each downlink port of the switch
    [Arguments]    ${switch}
    ${ilo_list}    Create List
    ${resp}    Fusion Api Get Switch    param=?filter=name=${switch}
    ${ports}    Get Variable Value    ${resp['members'][0]['ports']}
    :For    ${port}    IN    @{ports}
    \    ${linkLabel}    Run Keyword If    '${port['portStatus']}' != 'Unlinked'    Get Variable Value    ${port['neighbor']['linkLabel']}
    \    Append To List    ${ilo_list}    ${linkLabel}
    [Return]    ${ilo_list}

Match Hardware and Hardware Type
    [Documentation]    Validating the hardware and hardware type
    [Arguments]    ${Hardware_Type}
    ${model_list}    Create List
    ${uri_list}    Create List
    @{id} =     Split String    ${Hardware_Type}
    ${server_type_no} =    Get From List   ${id}   0
    ${server_type}=    Get From List   ${id}   1
    ${resp} =   Fusion Api Get Server Hardware
    ${memcount}    Get Length    ${resp['members']}
    :FOR    ${x}    IN RANGE    0    ${memcount}
    \    ${model} =     Get From Dictionary    ${resp['members'][${x}]}    model
    \    Append to List    ${model_list}    ${model}
    \    ${state} =     Get From Dictionary    ${resp['members'][${x}]}    state
    \    ${uri}    Run Keyword If    '${state}' != 'ProfileApplied'    Get From Dictionary    ${resp['members'][${x}]}    uri
    \    Append to List    ${uri_list}    ${uri}
    :FOR    ${sh}   IN RANGE    0    ${memcount}
    \     @{id} =     Split String    ${model_list[${sh}]}
    \    ${serverhardware_type_no} =    Get From List   ${id}   1
    \    ${serverhardware_type}=    Get From List   ${id}   2
    \    ${uri}    Run Keyword If    '${server_type_no}' == '${serverhardware_type_no}' and '${server_type}' == '${serverhardware_type}'    Get from List    ${uri_list}    ${sh}
    \    Exit For Loop If   '${uri}' != 'None'
    :FOR    ${x}    IN RANGE    0    ${memcount}
    \    ${name} =  Run Keyword If    '${resp['members'][${x}]['uri']}' == '${uri}'    Get From Dictionary    ${resp['members'][${x}]}    name
    \    Exit For Loop If   '${name}' != 'None'
    [Return]    ${uri}    ${name}

Get Server Profile Template URI
    [Documentation]    Get Server Profile Template URI
    [Arguments]     ${sp_temp}
    ${resp} =    fusion_api_get_server_profile_templates    param=?filter="'name'=='${sp_temp}'"
    ${uri} =    Get From dictionary    ${resp['members'][0]}    uri
    [Return]    ${uri}

Networks For Loop
    [Documentation]    create profile with network list
    [Arguments]    ${profile1}
    ${resp}    fusion_api_get_ethernet_networks
    ${nwlist} =     Get From Dictionary    ${resp}    members
    :FOR    ${x}    IN RANGE    0    2
    \  ${network_uri}=    Get From Dictionary    ${nwlist[${x}]}    uri
    \  Set to dictionary    ${profile1['connectionSettings']['connections'][0]}    networkUri    ${network_uri}
    \  ${resp} =   Fusion Api Create Server Profile        body=${profile1}     param=?force=ignoreServerHealth
    \  ${task} =   Wait For Task   ${resp}     timeout=13 mins     interval=10s
    \  Validate Response    ${task}    ${Valdict_profile}

Create Profile from Template
    [Documentation]    Get Server Profile from server template
    [Arguments]     ${profile_from_temp}    ${power}
    ${HCount}    Get Length    ${Hardware_Type}
    :FOR    ${x}    IN RANGE    0    ${HCount}
    \    ${profile1} =    Copy Dictionary     ${profile_from_temp}
    \    ${uri}    ${name}    Match Hardware and Hardware Type    ${Hardware_Type[${x}]}
    \    Run Keyword If    '${power}' == '1'    Power on server    ${name}
    \    Set to Dictionary   ${profile1}  serverHardwareUri   ${uri}
    \    ${uri} =   Get Server Hardware Type URI        ${Hardware_Type[${x}]}
    \    Set to Dictionary  ${profile1} serverHardwareTypeUri   ${uri}
    \    Run Keyword If    '${power}' == '0'    Set to Dictionary   ${profile1}    name    ${name}_Profile    ELSE    Set to Dictionary ${profile1}    name    ${name}_Profile_poweron
    \    ${uri} =    Get Server Profile Template URI     ${Hardware_Type[${x}]}_Profile
    \    Set to Dictionary   ${profile1}  serverProfileTemplateUri    ${uri}
    \    ${profile1} =    Update connections in profile    ${profile1}
    \    ${resp} =   Fusion Api Create Server Profile        body=${profile1}    param=?force=ignoreServerHealth
    \    ${task} =   Wait For Task   ${resp}     timeout=13 mins     interval=10s
    \    ${task_state} =     Get From dictionary     ${task}     taskState
    \    Run Keyword If    '${power}' == '0'    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)    ELSE    Should Match Regexp    ${task_state}   ((?i)Error)
    \    Run Keyword If    '${power}' == '1'    Should Match    ${task['taskErrors'][0]['errorCode']}    SERVER_NOT_OFF

Profile Creation with networkset
    [Documentation]    Creating server profile with networkset
    [Arguments]    ${server}    ${nativeuri}=${NONE}
    :FOR   ${x}   IN RANGE    0    2
    \    Create Network Sets    ${Network_sets[0]}    0    ${nativeuri}
    \    ${temp}     Copy Dictionary    ${server_profile_nwset}
    \    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${server}
    \    Set to Dictionary    ${temp[0]}    name    ${server}:Profile
    \    ${task}    Add DL Server Profiles from variable     ${temp}
    \    ${task_state} =     Get From dictionary     ${task}     taskState
    \    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)
    \    ${alert}    Fusion Api Delete Alert
    \    Wait For Task    ${alert}    200s    10s
    \    ${nsetresp}    Fusion Api Get Network Set
    \    ${nsetname}    Get Variable Value    ${nsetresp['members'][0]['name']}
    \    ${resp}    Fusion Api Delete Network Set    ${nsetname}
    \    ${task} =    Wait For Task    ${resp}    240s    2s}
   #\    Run Keyword If    '${task['status_code']}' == '200'    Log to console and logfile    \n-Successfully deleted network set.    ELSE    Fail
    \    Check Alert Message    0     ${Alert_Nset_delete}
    \    Remove All Server Profiles
    \    ${nativeuri}=    Set Variable    ${NONE}

Check Alert Message
    [Documentation]    Verify the alert messages
    [Arguments]    ${Enable}    ${Alert_Messages}
    ${alert_resp}    fusion_api_get_alerts    /rest/alerts?filter="alertState EQ 'Active'"
    ${Count}    Get From Dictionary    ${alert_resp}    count
    Run Keyword If    '${Count}'=='0'    Fail    "Failed as alert message is not found"
    ${Members}=    Get From Dictionary    ${alert_resp}    members
    :FOR    ${Index}    IN RANGE    0    ${Count}
    \    ${Alert}        Get From List    ${Members}    ${Index}
    \    ${AlertDesc}    Get From Dictionary    ${Alert}    description
    \    ${Value}    ${Count_Input}    Check Alert Message Inner    ${AlertDesc}     ${Alert_Messages}
    \    ${IncValue}    Set Variable If    '${Value}' == '1'     ${IncValue + 1}    ${IncValue}
    Run Keyword If    '${Enable}' == '0'    Should be equal    ${Count_Input}    ${IncValue}       ELSE    Should Be Equal As Integers    ${IncValue}    0

Check Alert Message Inner
    [Documentation]    Check the alert messages
    [Arguments]    ${Alert}     ${Alert_Messages}
    ${Count_Input}=    Get Length    ${Alert_Messages}
    :FOR    ${Index}    IN RANGE    0    ${Count_Input}
    \    ${AlertDesc1}    Get Lines containing string    ${Alert}    ${Alert_Messages[${Index}]}
    \    ${Value}=     Set Variable If     '${AlertDesc1}'!='${Empty}'     1    ${Value}
    [Return]    ${Value}    ${Count_Input}

Profile Edit with networkset
    [Documentation]    Editing the server profile with networkset
    [Arguments]    ${server}    ${tempin}
    ${networkset}    Fusion Api Get Network Set    param=?filter=name=${Edit_nset}
    ${netseturi}    Get Variable Value    ${networkset['members'][0]['uri']}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${server}Profile
    ${sp_uri}    Get Variable Value    ${resp['members'][0]['uri']}
    Set to Dictionary    ${tempin[0]['connectionSettings']['connections'][0]}    networkUri    ${netseturi}
    Set to Dictionary    ${tempin[0]}    eTag    ${resp['members'][0]['eTag']}
    Set to Dictionary    ${tempin[0]}    name    ${resp['members'][0]['name']}
    Set to Dictionary    ${tempin[0]}    serverHardwareTypeUri    ${resp['members'][0]['serverHardwareTypeUri']}
    Set to Dictionary    ${tempin[0]}    serverHardwareUri    ${resp['members'][0]['serverHardwareUri']}
    ${resp} =   Fusion Api Edit Server Profile    uri=${sp_uri}     body=${tempin[0]}
    ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}
    ${task_state} =     Get From dictionary     ${task}     taskState
    Should Match    ${task_state}   Completed

Verify Traffic
    [Documentation]    Verify traffic
    [Arguments]    ${servername}    ${No_of_connections}    ${server_to_server_yes}=0
    ${server_name}    ${ip}    Get Server Hardware OS type and ILO IP    ${servername}
    ${splitstring}    Set Variable    ${server_name[0:2]}
    ${Server_profiles_valid_ips}     Create List
    ${Server_profiles_valid_ips}    Run keyword If    '${splitstring}'== 'WS'  Get Windows Server IP   ${win_server_details}  ${ip}
    ...   ELSE IF    '${splitstring}'== 'rh'  Get Redhat IP    ${redhat_ip}
    ...   ELSE    Get ESXI IP
    #Log to console and logfile    \n\n The IPs:${Server_profiles_valid_ips}
    Run Keyword If     '${Server_profiles_valid_ips[0]}' != 'NO_IP'   Run Keywords
    ...     Run Keyword If    '${server_to_server_yes}' == '1'    Append to List     ${IPList}     ${Server_profiles_valid_ips[0]}    AND
    ...     PingUD     ${Server_profiles_valid_ips}      ${No_of_connections}

PingUD
    [Documentation]    Server to server ping
    [Arguments]    ${validips}    ${No_of_connections}
    ${ip_count}    Get Length    ${validips}
    Run keyword If    '${ip_count}' == '${No_of_connections}'    Log to console and logfile    \nSuccessfully obtained Valid number of IPs    ELSE     Fail
    :FOR     ${x}   IN RANGE    0     ${No_of_connections}
    \  Ping Downlink from Uplink    ${validips[${x}]}

Server to server ping old
    [Documentation]    Server to server ping
    [Arguments]      ${server_iplist}
    ${ilo_count}    Get Length    ${ilo_details}
    :FOR     ${ipad}    IN RANGE    0     ${ilo_count}
    \    Open Connection    ${ilo_details[${x}]['ip']}     timeout=20s
    \    Log to console  \nSuccessfully opened connection to the server
    \    sleep    10sec
    \    Login    ${ilo_details[${x}]['username']}     ${ilo_details[${x}['password']}
    \    Ping all servers from one host    ${server_iplist}

Ping all servers from one host
    [Documentation]    Server to server ping
    [Arguments]      ${server_iplist}
    ${ip1_count}    Get Length    ${server_iplist}
    :FOR     ${ipad}    IN RANGE    0     ${ip1_count}
    \    SSHLibrary.Write    ping ${server_iplist[${ipad}]}
    \    Sleep    15s
    \    ${Output}=    SSHLibrary.Read
    \    Close Connection
    \    Close All Connections
    \    ${Output1}    Get Regexp Matches    ${Output}    Lost = \\d
    \    ${data_loss}    Get Variable Value    ${Output1[0]}
    \    Run Keyword If    '${data_loss}' == '0'    Log to console and logfile    \n Ping succeeds  !!!
    \    ...     ELSE     FAIL

Profile with same vlan
    [Documentation]    Server profile with same vlan
    [Arguments]    ${server}
    ${temp}     Copy Dictionary    ${server_profile_samevlan}
    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${server}
    Set to Dictionary    ${temp[0]}    name    ${server}Profile
    ${task}    Add DL Server Profiles from variable    ${temp}
    ${task_state} =     Get From dictionary     ${task}     taskState
    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)

Terminate Ping
    [Documentation]    Terminate Ping
    ${result1}    Run    taskkill /f /im ping.exe


Change VlanID in Switch
    [Documentation]    changing vlan ID in switch
    [Arguments]    ${Arista_login_details}    ${Commands}    ${Port_No}    ${Vlan_Id}
    SSHLibrary.Open Connection    ${Arista_login_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_login_details['userName']}    ${Arista_login_details['password']}
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[11]} ${Vlan_Id}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[12]} ${Vlan_Id}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[13]}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    Sleep    10sec
    #${Output}=    SSHLibrary.Read Until    )#
    ${Output}=    SSHLibrary.Read
    Should Contain    ${Output}   ${Commands[11]} ${Vlan_Id}
    SSHLibrary.Close Connection

verification of vlans_switch after LS_Refresh in OV
    [Documentation]    Verification of vlans in switch after refresh
    [Arguments]    ${Arista_login_details}    ${Commands}    ${Port_No}    ${Original_Vlan_Id}
    SSHLibrary.Open Connection    ${Arista_login_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_login_details['userName']}    ${Arista_login_details['password']}
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    sleep    10sec
    #${Output}=    SSHLibrary.Read Until    )#
    ${Output}=    SSHLibrary.Read
    Should Contain    ${Output}   ${Commands[11]} ${Original_Vlan_Id}
    SSHLibrary.Close Connection

Create VNetworks for Profiles
    [Documentation]    Create 6 networks with Vlans 10 20 30 40 50 60
    ${temp}    Copy Dictionary    ${Network_body}
    :For    ${vlan}    IN RANGE    2    164
    \    Set To Dictionary    ${temp}    vlanId    ${vlan}
    \    Set To Dictionary    ${temp}    name    Network_${vlan}
    \    ${nw}    Fusion Api Create Ethernet Network    ${temp}
    \    Run Keyword If   '${nw['status_code']}' == '202'    Log to console    \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    \    ...    ELSE    FAIL
    \    ${task}    fusion_api_appliance_setup.Wait For Task    ${nw}    60 s    10 s

Create MaxNetwork Sets
    [Documentation]    Create Network Sets
    [Arguments]    ${name}    ${Negative}=0
    ${nw_uri_list}    Create List
    ${temp}    Copy Dictionary    ${Network_set_body}
    ${network}    Fusion Api Get Ethernet Networks
    ${Count}   Get Length     ${network['members']}
    :For    ${x}    IN RANGE    0    ${Count}
    \    ${uri}    Get Variable Value    ${network['members'][${x}]['uri']}
    \    Append To List    ${nw_uri_list}    ${uri}
    Set To Dictionary    ${temp}    networkUris    ${nw_uri_list}
    Set To Dictionary    ${temp}    name    ${name}
    ${resp}    Fusion Api Create Network Set    ${temp}
    Run Keyword If    '${Negative}' == '0'    Run Keywords
    ...    Should be equal as strings    ${resp['status_code']}    202   AND
    ...    Wait For Task And Validate Response    ${resp}    ${valDict}    180 s    10 s    True
    ...    ELSE    Log to console    \nNegative test
    [Return]    ${resp}

Profile max networkset
    [Documentation]    Profile creation with maximum networkset
    [Arguments]    ${server}    ${nativeuri}=${NONE}
    ${temp}     Copy Dictionary    ${server_profile_maxvlan}
    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${server}
    Set to Dictionary    ${temp[0]}    name    ${server}Profile
    :FOR    ${x}   IN RANGE     0    2
    \   ${switch_ip}    Get from Dictionary    ${Arista_login_details[${x}]}    ip
    \   Set VlanID in Switch    ${switch_ip}    ${Commands}    ${Vlan_range}
    sleep    60s
    ${task}    Add DL Server Profiles from variable    ${temp}
    ${task_state} =     Get From dictionary     ${task}     taskState
    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)
    ${Output}    fusion_api_get_server_profiles    param=?filter="'name'=='${server}Profile'"
    :FOR    ${x}   IN RANGE     0    2
    \   ${Profileport}=    Get from Dictionary    ${Output['members'][0]['connectionSettings']['connections'][${x}]}    interconnectPort
    \   ${Profileporturi}=    Get from Dictionary    ${Output['members'][0]['connectionSettings']['connections'][${x}]}    interconnectUri
    \   ${ipAddress}    Get IP Address    ${Profileporturi}
    \   ${temp}    Copy Dictionary    ${Arista_switch_details}
    \   Set to Dictionary    ${temp}    ip    ${ipAddress}
    \   ${vlan_range}     verify vlan in Switch    ${temp}    ${Commands}    ${Profileport}
    \   Run Keyword If  '${vlan_range}' == '2-163'    Log to console  \nSuccessfully verified vlan
    \   ...    ELSE    FAIL

Negative Test
    [Documentation]    Networkset negative creation
    ${temp}    Copy Dictionary    ${Network_body}
    Set To Dictionary    ${temp}    vlanId    164
    Set To Dictionary    ${temp}    name    Network_164
    ${nw}    Fusion Api Create Ethernet Network    ${temp}
    Run Keyword If   '${nw['status_code']}' == '202'    Log to console  \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    ...    ELSE    FAIL
    ${resp}    Create MaxNetwork Sets     Net_Set2    1
    Run Keyword If    '${resp['status_code']}' == '400' and '${resp['errorCode']}' == '${Nset_Max_Error_Message}'    Log to console    \nSuccessfully verified Max Ethernet Network in Network set\n    ELSE    Fail

verify vlan in Switch
    [Documentation]    verifying vlan in switch
    [Arguments]    ${Arista_switch_details}    ${Commands}    ${Uplink_Port_No}
    SSHLibrary.Open Connection    ${Arista_switch_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    localhost>
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Uplink_Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Uplink_Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    ${Output}=    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Uplink_Port_No})#
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan (\\d.*)
    ${value}    Convert To String    ${vlan}
    [Return]    ${value}

Restore From Backup
    [Documentation]    Restoring from backup
    ${status}=  Set Variable    ${EMPTY}
    ${Response}     Fusion Api Get Backup
    Run keyword unless  ${Response['status_code']}== 200    Fail    "Unable to Get the latest backup"
    ${restore_body}     Create Dictionary   type=RESTORE
    ...                                     uriOfBackupToRestore=${Response['members'][0]['uri']}
    ${output}       Fusion Api Restore Backup       ${restore_body}
    Sleep   200sec
    Run keyword unless  ${output['status_code']}== 202  Fail    "Unable to perform the restore from backup operation"
    ${restore_resp}     Fusion API Get Restore Status
    Run keyword unless  ${restore_resp['status_code']}== 200    Fail    "Unable to get the restore details"
    :FOR    ${index}    IN RANGE    ${restore_resp['count']}
    \   Run Keyword If  '${restore_resp['members'][${index}]['backupIdToRestore']}' != '${Response['members'][0]['id']}'        Continue For Loop
    \   ${restore_id} =    Set Variable    ${restore_resp['members'][${index}]['id']}
    Log to console and logfile      "Restoring is in Progress..\n
    :FOR    ${index}    IN RANGE    50
    \   sleep   60sec
    \   ${resp}     Fusion API Get Restore Status   ${restore_id}
    \   Run keyword unless  ${resp['status_code']}== 200    Fail    "Unable to get the restore id details"
    \   Run Keyword If  '${resp['restorePhase']}' != 'COMPLETED'    Continue For Loop
    \   ${status} =    Set Variable    ${resp['status']}
    \   Run Keyword If  '${resp['restorePhase']}' == 'COMPLETED'    Exit For Loop
    Should Be Equal    ${status}    SUCCEEDED
    Sleep    30
    Fusion Api Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}

Set VlanID in Switch
    [Documentation]    Setting vlan id in switch
    [Arguments]    ${ip}    ${Commands}    ${Vlan_Id}
    SSHLibrary.Open Connection    ${ip}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    sleep    7s
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[5]} ${Vlan_Id}
    SSHLibrary.Read Until    localhost(${Commands[1]}-${Commands[5]}-${Vlan_Id})#
    SSHLibrary.Close Connection

Get IP Address
    [Documentation]    Fetching Switch IP address
   [Arguments]     ${uri}
   ${temp}    Copy Dictionary    ${lss[0]}
   ${lss_name}=    Get From Dictionary    ${temp['logicalSwitch']}    name
   ${resp} =    Fusion Api Get LS       param=?filter="'name'=='${lss_name}'"
   ${uris}=    Get From Dictionary  ${resp['members'][0]}    switchUris
   #Log to console and logfile    \n${uris}
   ${Count_uri}    Get Length    ${uris}
   :FOR    ${Index}    IN RANGE    0    ${Count_uri}
   \    ${ipAddress}    Run Keyword If     '${uri}' == '${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${Index}]['uri']}'    Get From Dictionary    ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${Index}]}    ipAddress
   \    Exit For Loop If    '${ipAddress}' != 'None'
   [Return]    ${ipAddress}

Enable/Disable Port in Switch
    [Documentation]    Enabling disabling ports in switches
    [Arguments]    ${Arista_switch_details}    ${Commands}    ${Uplink_Port_No}    ${Enable}
    SSHLibrary.Open Connection    ${Arista_switch_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Uplink_Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Uplink_Port_No})#
    Run Keyword If    '${Enable}' == '1'    SSHLibrary.Write    ${Commands[3]}   ELSE    SSHLibrary.Write    ${Commands[4]}
    #Log to console and logfile    \n-Port status changed in switch.Waiting for a minute for the changes to reflect in One-View.
    sleep    60s
    SSHLibrary.Close Connection

Get Redhat IP
    [Documentation]    ssh login to Redhat DL 380 Server using eno4 interface to fetch IPs of eno5 & eno6
    [Arguments]    ${redhat_ip}    ${y}=5
    ${ips}    Create List
    SSHLibrary.Open Connection    ${redhat_ip}    timeout=30s
    SSHLibrary.Login    root    hpvse123
    #SSHLibrary.Read Until    #
    sleep    5s
    SSHLibrary.Write    ip addr
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    ${no_of_matches}    get_matching_lines_with_number    ${Output}    scope global dynamic
    :FOR     ${x}   IN RANGE    0    ${no_of_matches}
    \   ${match1}    ${redhatip1}     Should Match Regexp    ${lines}    inet (192.\\d+.\\d+.\\d+)/\\d+.*eno${y}
    \   Append To List    ${ips}    ${redhatip1}
    \   ${y}    Evaluate     ${y} + 1
    [Return]    ${ips}

Server to server ping
    [Documentation]    Server to server ping
    [Arguments]      ${server_iplist}
    ${ip1_count}    Get Length    ${server_iplist}
    :FOR     ${ipad}    IN RANGE    0     ${ip1_count-1}
    \    ${Output}=    execute_commands    ${server_iplist[${ipad}]}    ${server_Auth_details}    ${server_iplist[${ipad+1}]}
    \    Should Match Regexp    ${Output}    (?i)TTL

Enable VlanID in switch
    [Documentation]    Login to switch and fetch active VlanID
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}    ${vlan_enable}
    ${List1}    Create List
    ${length}    Get length    ${switch_ip}
    :FOR    ${x}     in range    0     ${length}
    \    Open Connection    ${switch_ip[${x}]}    timeout=30s
    \    Login    ${switch_details['userName']}    ${switch_details['password']}
    \    sleep    7s
    \    #SSHLibrary.Read Until    >
    \    SSHLibrary.Write    ${Commands[0]}
    \    SSHLibrary.Read Until    localhost#
    \    SSHLibrary.Write    ${Commands[1]}
    \    SSHLibrary.Read Until    localhost(${Commands[1]})#
    \    SSHLibrary.Write    ${Commands[2]} ${interface}
    \    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    \    SSHLibrary.Write    ${enable_vlan[0]} ${vlan_enable[${x}]}
    \    sleep    3s
    \    SSHLibrary.Write    write
    \    sleep    8s
    \    SSHLibrary.Write    ${Commands[10]}
    \    sleep    5s
    \    ${Output}=    SSHLibrary.Read
    \    Close Connection
    \    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    \    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan (\\d.*)
    \    ${value}    Convert To String    ${vlan}
    \    Append to List     ${List1}     ${value}
    [Return]    ${List1}

Network Set Teaming
    [Documentation]    Function to Execute powershell script for Teaming on the servers
    [Arguments]    ${linux_details}    ${ilo_details}    ${module_file_path}     ${ps_cmd1}    ${server_details}    ${win_server_details}
    ${IP}=      get_server_ip_win      ${linux_details}    ${ilo_details}    ${module_file_path}
    ${str}    Convert To String    ${IP}
    ${valid_ip}    Get Regexp Matches    ${str}    192\\.\\d+\\.\\d+\\.\\d+
    ${Team}    execute_teaming    ${valid_ip[0]}    ${server_details[0]}    ${server_details[1]}    ${ps_cmd1}
    Sleep    30s
    ${ip_list_new}    Get Server Ip Windows    ${win_server_details}
    ${count}    Get Length    ${ip_list_new}
    [Return]    ${ip_list_new}    ${count}

Delete Network Set Teaming
    [Documentation]    Function to Execute powershell script for Delete Teaming on the servers
    [Arguments]    ${linux_details}    ${ilo_details}    ${module_file_path}     ${delete_team_cmd}
    ${IP}=      get_server_ip_win      ${linux_details}    ${ilo_details}    ${module_file_path}
    ${str}    Convert To String    ${IP}
    ${valid_ips}    Get Regexp Matches    ${str}    192\\.\\d+\\.\\d+\\.\\d+
    Telnet.Open Connection     ${valid_ips[0]}     prompt=>     timeout=20s
    Telnet.Write    a
    ${login}    Telnet.Login               ${win_server_telnet_details['username']}     ${win_server_telnet_details['password']}    login_prompt=login:    password_prompt=password:
    Sleep    10sec
    Telnet.Write    powershell
    Telnet.Write    ${delete_team_cmd}
    Sleep    30sec
    Telnet.Write    y
    Sleep    30sec
    ${stdout} =  Telnet.Read
    Telnet.Close Connection
    Telnet.Close All Connections
    Log to Console    \nteaming deleted

Verify Networkset Downlink Traffic from Uplink
    [Documentation]    Verify the Server IPs are pinging from Test Head
    [Arguments]    ${ip_list_new}    ${count}
    :For    ${x}    In Range    0    ${count}
    \    Ping Downlink from Uplink    ${ip_list_new[${x}]}

Get Server Ip Windows
    [Documentation]    Gets the valid ip of the server
    [Arguments]        ${win_server_details}
    ${serverip_List}=   Create List
    ${serverip_List1}=   Create List
    SSHLibrary.Open Connection     ${win_server_details['ip']}     prompt=>     timeout=20s
    SSHLibrary.Login    ${win_server_details['username']}    ${win_server_details['password']}
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Read Until    SAC>
    Sleep    5sec
    SSHLibrary.Write    i
    Sleep    5sec
    ${stdout}    SSHLibrary.Read
    ${cmd_output}=    Get Regexp Matches    ${stdout}    Ip=192\\.\\d+\\.\\d+\\.\\d+
    ${ip_list_new}    Create List
    ${len}    Get Length    ${cmd_output}
    :FOR    ${x}    IN RANGE    ${len}
    \    ${ip_lists}    Remove String    ${cmd_output[${x}]}    Ip=
    \    Log to console    ip is ${ip_lists}
    \    Append To List   ${ip_list_new}    ${ip_lists}
    SSHLibrary.Close All Connections
    [Return]    ${ip_list_new}

verify networkset traffic
    [Documentation]    Verifying networkset traffic
    [Arguments]    ${name_server}    ${pscommand_for_execution}     ${delete_ps_cmd}
    ${server_name}    ${ip}    Get Server Hardware OS type and ILO IP    ${name_server}
    ${temp}    Copy Dictionary    ${ilo_details[0]}
    ${temp1}    Copy Dictionary    ${win_ilo_details[0]}
    Set to Dictionary    ${temp}    ilo_ip    ${ip}
    Set to Dictionary    ${temp1}    ip    ${ip}
    ${splitstring}    Set Variable    ${server_name[0:2]}
    ${ip_list_new}    ${count}=    Run keyword If    '${splitstring}'== 'WS'    Network Set Teaming    ${linux_details}    ${temp}    ${module_file_path}     ${pscommand_for_execution}   ${server_details}    ${temp1}
    Run keyword If    '${splitstring}'== 'WS'    Run Keywords
    ...    Run Keyword Unless    ${count} == 3    Fail    msg=3 Valid IP's not obtained after Teaming    AND
    ...    Verify Networkset Downlink Traffic from Uplink    ${ip_list_new}    ${count}    AND
    ...    Delete Network Set Teaming    ${linux_details}    ${temp}    ${module_file_path}     ${delete_ps_cmd}

Get ESXI IP
    [Documentation]    Fetching ESXI IP
    ${list}    Create List
    Append to List    ${list}    NO_IP
   [Return]    ${list}

Edit Downlinkport and Verify
    [Documentation]    Editing and verifying downlink port
    [Arguments]    ${Outputin}
    :FOR    ${x}    IN RANGE    0    2
    \   ${downlink_Port_No}=    Get from Dictionary    ${Outputin['members'][0]['connectionSettings']['connections'][${x}]}    interconnectPort
    \   ${interconnecturi}=    Get from Dictionary    ${Outputin['members'][0]['connectionSettings']['connections'][${x}]}    interconnectUri
    \   ${resp}=    Fusion Api Get Switch    ${interconnecturi}
    \   ${name}    Get from dictionary    ${resp}    name
    \   @{id} =     Split String    ${interconnecturi}   /
    \   ${portId} =    Get From List   ${id}   3
    \   ${Port_modify}     catenate     ${portId}:${downlink_Port_No}
    \   Set to Dictionary    ${port_details[0]}    portId     ${portId}:${downlink_Port_No}
    \   Set to Dictionary    ${port_details[0]}    portName    ${downlink_Port_No}
    \   Set to Dictionary    ${port_details[0]}    enabled    false
    \   Verify Output    ${name}    ${port_details}    ${interconnecturi}    ${Port_modify}    ${downlink_Port_No}    0
    \   Set to Dictionary    ${port_details[0]}    enabled    true
    \   Verify Output    ${name}    ${port_details}    ${interconnecturi}    ${Port_modify}    ${downlink_Port_No}    1

verify Traffic from Downlink to Uplink for servers
    [Documentation]    Verify Sr=erver IP's are reachable from the Test Heads
    ${Server_profiles_valid_ips}    Create List
    :FOR   ${x}    IN RANGE    0   4
    \   ${server_name}    ${ip}    Get Server Hardware OS type and ILO IP    ${DL_server_names[${x}]}
    \   ${splitstring}    Set Variable    ${server_name[0:2]}
    \   ${output1}    Run keyword If    '${splitstring}'== 'WS'  Get Windows Server IP   ${win_server_details}  ${ip}
    \    ...   ELSE IF    '${splitstring}'== 'rh'  Get Redhat IP    ${redhat_ip}
    \    ...   ELSE    log to console and logfile    "We are not fetching for ESXI"
    \    Append To List    ${Server_profiles_valid_ips}    ${output1}

    ### Since ESXI return is NONE ###

    :For    ${x}    In Range    0    3
    \    Ping Downlink from Uplink    ${Server_profiles_valid_ips[${x}][0]}
    \    Ping Downlink from Uplink    ${Server_profiles_valid_ips[${x}][1]}
    [Return]     ${Server_profiles_valid_ips}
