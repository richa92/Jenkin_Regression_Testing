*** Settings ***
Documentation    OVF2724 OVF2942 OVF2726 & OVF3014-VC Edge: Gen 10 DL server profiles (DL360, DL380) Suite
Library         json
Library         FusionLibrary
Library         RoboGalaxyLibrary
Library         SSHLibrary
Library         OperatingSystem
Library         Dialogs
Library            Process
Library            OperatingSystem
Variables       VCEdge_datavariable.py
Variables       OVF2726_OVF3014_data_variables_sp.py
Variables       OVF2724_data_variables.py
Library     VCEdge_datavariable.py
Library     OVF2724_data_variables.py
Library     OVF2726_OVF3014_data_variables_sp.py
Library      back_ping.py
Library      server_to_server.py
Library      Telnet
Library      ServerOperations
Resource        ../../../../resource/fusion_api_all_resource_files.txt
Suite Setup               Clean OV
Suite Teardown     Clean OV

*** Variables ***
${number}    5
${flag}    Windows
${switch_ping_name}    switchIP_ping.txt
${server_ping_name}    serverIP_ping.txt
${time_out}    Request timed out
${terminate}    PING.EXE
${Dest_unreachable}    Destination host unreachable.
${switch_ping_file_path}    ${CURDIR}/switchIP_ping.txt
${server_ping_file_path}    ${CURDIR}/serverIP_ping.txt
${Appliance_IP1}     15.186.18.154
${Appliance_IP}      15.186.16.43
${IncValue}    ${0}
${ipad}        ${0}
${HCount}      ${0}
${ip1_count}   ${0}
${Value}    ${0}
*** Test Cases ***

API_TC_ Remove the server hardware from the oneview with unforce option and verify the server hardware is getting removed and verify the server information is removed form the downlink port_TC_count_2
    [Documentation]    Verify the server hardware removal with unforce option

    Set Log Level    Trace
    Fusion Api Login Appliance    ${APPLIANCE_IP_4_10}    ${admin_credentials}
    ${temp}    Copy Dictionary    ${lsgs[0]}
    ${lsgs}    Add Logical Switch Group from variable    ${temp}
    ${temp}    Copy Dictionary    ${lss[0]}
    ${lss}     Add Logical Switch from variable    ${temp}

    ${len}    Get Length    ${DL_SH_IP}
    ${temp}    Copy Dictionary    ${DL_SH_body}
    :For    ${x}    In Range    0    ${len}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    Run Keyword If  '${resp['status_code']}' == '202'    Log to console and logfile  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Imported the DL server with IP ${DL_SH_IP[${x}]}\n
    \    ...    ELSE    FAIL
    \    ${task1} =   Get Variable value     ${resp['uri']}
    \    Sleep    60s
    \    ${task} =   Fusion Api Get Task     uri=${task1}
    \    ${msg} =    Get Variable value  ${task['taskState']}
    \    Should Match Regexp    ${msg}  ((?i)Completed|Warning)

    ${ilo_names}    Create List
    :For    ${server}    IN    @{DL_server_names}
    \    ${SH_dict}    Create Server Hardware Dictionary    ${server}
    \    ${name}    Get From Dictionary    ${SH_dict}    name
    \    Append To List    ${ilo_names}    ${name}

    Log to console and logfile    \n\n fetch the Switch Downlink for server hardware information\n
    ${switches_list}    Create List
    :For    ${x}    In Range    0    2
    \    ${resp}    Fetch ILO Names From Switches    ${switches_IP[${x}]}
    \    Append To List    ${switches_list}    ${resp}

    :For    ${list}    IN    @{switches_list}
    \    verify ILO names with Switch list    ${list}    ${ilo_names}

    Remove All Server Hardware

    Log to console and logfile    \n\n fetch the Switch Downlink for server hardware information\n
    ${switches_list}    Create List
    :For    ${x}    In Range    0    2
    \    ${resp}    Fetch ILO Names From Switches    ${switches_IP[${x}]}
    \    Append To List    ${switches_list}    ${resp}

    :For    ${switch}    IN    @{switches_list}
    \    Verify ILO names absent with Switch list    ${switches_list}    ${ilo_names}
    Log to console and logfile    \n\n Successfully verified ILO names disappearance in Switches Page after removing the server hardwares\n


API_TC_Verify the Switch hyperlink availability and unavailability in Server hardware page before and after Deleting the LS_TC_count_2
    [Documentation]    Verify whether the Server Hardware page in OV lists the switch uri's for each servers when the switches are imported to OV
    Remove All Server Hardware
    ${len}    Get Length    ${DL_SH_IP}
    ${temp}    Copy Dictionary    ${DL_SH_body}
    :For    ${x}    In Range    0    ${len}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    Run Keyword If  '${resp['status_code']}' == '202'    Log to console and logfile  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Imported the DL server with IP ${DL_SH_IP[${x}]}\n
    \    ...    ELSE    FAIL
    \    ${task1} =   Get Variable value     ${resp['uri']}
    \    Sleep    60s
    \    ${task} =   Fusion Api Get Task     uri=${task1}
    \    ${msg} =    Get Variable value  ${task['taskState']}
    \    Should Match Regexp    ${msg}  ((?i)Completed|Warning)

    :For    ${server}    IN    @{DL_server_names}
    \    ${SH_dict}    Create Server Hardware Dictionary    ${server}
    \    ${SH_switch_uri_list}    Fetch Switch Uris from Server Hardware Page    ${SH_dict}
    \    ${verify}    Verify Switches URI from Switches Page with SH page    ${SH_switch_uri_list}

    Remove All LS
    Remove All LSGs
    :For    ${server}    IN    @{DL_server_names}
    \    ${SH_dict}    Create Server Hardware Dictionary    ${server}
    \    Verify SH Switch Data Empty    ${SH_dict['ports_info']}


API_TC_Negative Scenario_Verify Adding Server Hardware with the invalid password and invalid IP for server
    [Documentation]    Negative Scenario to verify the invalid password and invalid IP for server

    Remove All Server Hardware
    :For    ${x}    In Range    0    1
    \    ${temp}    Copy Dictionary    ${DL_SH_body}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[0]}
    \    Run Keyword If    '${x}' == '0'     Set To Dictionary    ${temp}    password=${invalid_SH[${x}]}
    \    ...    ELSE    Set To Dictionary    ${temp}    hostname=${invalid_SH[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    ${task}    Wait For Task    ${resp}    120s
    \    Run Keyword If  '${task['taskErrors'][0]['errorCode']}' == '${SH_error_msg[${x}]}'    Log to console and logfile  \nmessage: ${task['taskErrors'][0]['message']}\n Expected failure\n
    \    ...    ELSE    FAIL

API_TC_Negative Scenario _ Verify Adding Server Hardware without selecting license option
    [Documentation]    Negative Scenario to verify the behavior without license parameter
    ${temp}    Copy Dictionary    ${DL_SH_body}
    Set To Dictionary    ${temp}    licensingIntent=
    ${resp}    Fusion Api Add Server Hardware    ${temp}
    Run Keyword If  '${resp['status_code']}' == '400'    Log to console and logfile  \nExpected Failure: ${resp['recommendedActions']} \n Errorcode is ${resp['errorCode']}\n
    ...    ELSE    FAIL


API_TC_Add the DL servers with the ILO address by giving the credentials by choosing the mode as manged mode TC_count_2
    [Documentation]    Scenario to  Import different types of DL Server Hardwares DL 360 & DL 380 into 4.10 OV

    Remove All Server Hardware
    ${OV_version}    Fusion Api Get Appliance Version
    Log to console and logfile    \n\n The Appliance Compatibility is :${OV_version['compatibility']}\n
    Log to console and logfile    \n\n The Appliance PB is :${OV_version['softwareVersion']}\n
    Run Keyword If    '${OV_version['compatibility']}' != '${OV_4_10}'    FAIL    ELSE    Log to console and logfile    \n Adding DL Servers\n
    ${len}    Get Length    ${DL_SH_IP}
    ${temp}    Copy Dictionary    ${DL_SH_body}
    :For    ${x}    In Range    0    ${len}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    Run Keyword If  '${resp['status_code']}' == '202'    Log to console and logfile  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Imported the DL server with IP ${DL_SH_IP[${x}]}\n
    \    ...    ELSE    FAIL

    \    ${task1} =   Get Variable value     ${resp['uri']}
    \    Sleep    60s
    \    ${task} =   Fusion Api Get Task     uri=${task1}
    \    ${msg} =    Get Variable value  ${task['taskState']}
    \    Should Match Regexp    ${msg}  ((?i)Completed|Warning)


API_TC_Negative Scenario _ Verify Adding 2 servers with same IP is not allowed
    [Documentation]    Negative Scenario to verify that 2 servers with same IP is not allowed on OV

    ${temp}    Copy Dictionary    ${DL_SH_body}
    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[0]}
    ${resp}    Fusion Api Add Server Hardware    ${temp}
    ${task}    Wait For Task    ${resp}    60s
    Log to console and logfile    \n the resp is :${task}\n
    Run Keyword If  '${task['taskErrors'][0]['errorCode']}' == 'SERVER_ALREADY_ADDED'    Log to console and logfile  \nmessage: ${task['taskErrors'][0]['message']}\n Expected failure\n
    ...    ELSE    FAIL


API_TC_Verify and validate the adapter and hardware details in Server Hardware page TC_count_2
    [Documentation]    Verify the the details of adapters, model, port information, Physical port number switch type, linked ip address, switch port and server state.

    :For    ${server}    IN    @{DL_server_names}
    \    ${SH_dict}    Create Server Hardware Dictionary    ${server}
    \    Log to console and logfile    \n The details are :${SH_dict}
    \    Should Match Regexp    ${SH_dict['firmware']}    \\d+.\\d+
    \    Verify Adapter name    ${SH_dict['model']}    ${SH_dict['adapter_name']}
    \    Run Keyword Unless    '${SH_dict['server_state']}' == '${serverState}'    FAIL    Bad Server State
    \    Run Keyword Unless    '${SH_dict['name']}' == '${server}'    FAIL    Server Name Mismatch
    \    Run Keyword Unless    '${SH_dict['slotNumber']}' == '${slotNumber}'    FAIL    Improper Slot Number
    \    Should Match Regexp    ${SH_dict['host_details']['DHCP']}    \\d+.\\d+.\\d+.\\d+
    \    Should Match Regexp    ${SH_dict['host_details']['Lookup']}    \\s*
    \    Should Match Regexp    ${SH_dict['host_details']['LinkLocal']}    \\s*
    \    ${Ports}    ${switch_ports}   Validate Port Info    ${SH_dict['ports_info']}
    \    ${status}    Validate switch ports are equal    ${switch_ports}
    \    Run Keyword Unless   '${status}' == 'True'     FAIL


################## LS and Switch ######################

API_TC_Neg_Negative and values greater than 2 for the number of switches attribute in LSG
    [Documentation] Verifies that Negative and values greater than 2 for the number of switches attribute in LSG provides error
    [Tags]  1    THINSLICE
    Set Log Level    TRACE
    #Run Keyword and Ignore Error    Write To ciDebug Log
    Log to console and logfile     \n Initial Cleanup
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Server Hardware
    Remove All LS
    Remove All LSGs
    Remove ALL Ethernet Networks
    ${task}    ${resp} =    Add Logical Switch Group from variable    ${Neg_lsg_invalid}    1
    Validate Response    ${resp}    ${Valdict_invalid}
    ${task}    ${resp} =    Add Logical Switch Group from variable    ${Neg_lsg_negative}    1
    Validate Response    ${resp}    ${Valdict_negative}

API_TC_Add Logical switch group and verify the Aritsa switch type and the count of the switches
    [Documentation] Adding Logical switch group and verify the Aritsa switch type and the count of the switches
    ${resp}    Add Logical Switch Group from variable    ${lsgs[0]}
    ${LSG_details} =    Fusion Api Get LSG      param=?filter="'name'=='${LSG1}'"
    ${switchmapTemplate} =  Get from Dictionary    ${LSG_details['members'][0]['switchMapTemplate']}    switchMapEntryTemplates
    ${length}    Get Length    ${switchmapTemplate}
    Run Keyword If    ${length}!=2    Fail    msg="The number of switches allowed is 2"
    ${uri} =    Get from Dictionary    ${switchmapTemplate[0]}    permittedSwitchTypeUri
    ${switch_uri}     Get Switch Type URI     ${Switch_type}

    Should be Equal As Strings     ${uri}    ${switch_uri}

API_TC_Neg_Create LS with Invalid Switch Credentials and wrong Switch IP and verify the error code and message
    [Documentation] Creating LS with Invalid Switch Credentials and wrong Switch IP and verifying the error code and message
    Set to dictionary     ${username}    value    ${invalid_username[0]}
    Set to dictionary     ${password}    value    ${invalid_password[0]}
    ${temp}     Copy Dictionary    ${lss[0]}
    ${resp}     Add Logical Switch from variable    ${temp}
    Run Keyword If     '${resp['taskErrors'][0]['errorCode']}'!='CRM_INVALID_SWITCH_CREDENTIALS' or ${resp['status_code']}!=200 or '${resp['taskState']}'!='Error' or '${resp['taskStatus']}'!='${invalid_switch_cred_err_msg}'     Fail    msg="LS cannot be created due to invalid credentials"
    Log to console and logfile    \n As expected unable to create LS with invalid switch credentials\n message:${resp['taskErrors'][0]['message']}\n

#######Neg : Create LS with Wrong Switch IP and verify the error code and error message
    ${temp}     Copy Dictionary    ${lss[0]}
    Set to dictionary     ${username}    value    ${SWITCH1_USER}
    Set to dictionary     ${password}    value    ${SWITCH1_PASS}
    Set to dictionary     ${temp['logicalSwitch']['switchCredentialConfiguration'][0]}    logicalSwitchManagementHost    15.186.10.14
    ${resp}     Add Logical Switch from variable    ${temp}
    Run Keyword If     '${resp['taskErrors'][0]['errorCode']}'!='CRM_INVALID_SWITCH_CREDENTIALS' or ${resp['status_code']}!=200 or '${resp['taskState']}'!='Error' or '${resp['taskStatus']}'!='${invalid_switch_ip_err_msg}'     Fail    msg="LS cannot be created due to invalid credentials"
    Log to console and logfile    \n As expected unable to create LS with wrong Switch IP\n message:${resp['taskErrors'][0]['message']}\n


API_TC_Edit LS and verify the error message with invalid credentials for the switch
    [Documentation] Editing Logical switch with invalid switch credentials
    ${resp}     Add Logical Switch from variable    ${lss[0]}
    Run Keyword If     ${resp['status_code']}!=200 or '${resp['taskState']}'!='Completed'     Fail    msg="LS creation is unsuccessful"
    ${ls_uri}    Get LS URI    ${lss[0]['logicalSwitch']['name']}
    Set Global Variable     ${LS_URI}     ${ls_uri}
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${lss[0]['logicalSwitch']['name']}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${uri}    Get from Dictionary    ${resp['members'][0]}    uri
    Set to dictionary   ${lss[0]['logicalSwitch']}    uri   ${uri}
    ${length}     Get Length       ${lss[0]['logicalSwitch']['switchCredentialConfiguration']}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${switchdetails} =     Fusion Api Get Switch       uri=${switchUris[${x}]}
    \    ${name}     Get from Dictionary   ${switchdetails}     name
    \    ${uri}     Get from Dictionary   ${switchdetails}     uri
    \    Set to dictionary   ${lss[0]['logicalSwitch']['switchCredentialConfiguration'][${x}]}    logicalSwitchManagementHost   ${name}
    \    Set to dictionary   ${lss[0]['logicalSwitch']['switchCredentialConfiguration'][${x}]}    switchUri   ${uri}
    ${ls_uri}    Get LS URI    ${lss[0]['logicalSwitch']['name']}
    Set to dictionary     ${username}    value    ${invalid_username[0]}
    Set to dictionary     ${password}    value    ${invalid_password[0]}

    ${resp}    Fusion Api Update LS     ${lss[0]}    ${LS_URI}
    ${task}    Wait for Task    ${resp}    2min    15s
    Run Keyword If     '${task['taskErrors'][0]['errorCode']}'!='CRM_INVALID_SWITCH_CREDENTIALS' or ${task['status_code']}!=200 or '${task['taskState']}'!='Error' or '${task['taskStatus']}'!='${invalid_switch_cred_err_msg}'     Fail    msg="LS cannot be created due to invalid credentials"
    Log to console and logfile    \n As expected Editing LS with invalid credentials for the switch failed\n message:${task['taskErrors'][0]['message']}\n

API_TC_Edit the LS and give the incorrect username and passwords and verify the error messages for both the switches
    [Documentation] Editing Logical switch with incorrect username and passwords
    ${length}    Get length    ${invalid_username}
    :FOR     ${x}    in Range    1    ${length}
    \    Set to dictionary     ${username}    value    ${invalid_username[${x}]}
    \    ${resp} =  Fusion Api Update LS    ${lss[0]}    ${LS_URI}
    \    ${task} =  fusion_api_appliance_setup.Wait For Task    ${resp}     5min    15s
    \    Run Keyword If     '${task['taskErrors'][0]['errorCode']}'!='CRM_INVALID_SWITCH_CREDENTIALS' or ${task['status_code']}!=200 or '${task['taskState']}'!='Error' or '${task['taskStatus']}'!='${invalid_switch_cred_err_msg}'     Fail    msg="LS cannot be created due to invalid credentials"
    \    Log to console and logfile    \n As expected Editing LS with incorrect username for the switch failed\n message:${task['taskErrors'][0]['message']}\n

    ${length}    Get length    ${invalid_password}
    :FOR     ${x}    in Range    1    ${length}
    \    Set to dictionary     ${password}    value    ${invalid_password[${x}]}
    \    ${resp} =  Fusion Api Update LS    ${lss[0]}    ${LS_URI}
    \    ${task} =  fusion_api_appliance_setup.Wait For Task    ${resp}     5min    15s
    \    Run Keyword If     '${task['taskErrors'][0]['errorCode']}'!='CRM_INVALID_SWITCH_CREDENTIALS' or ${task['status_code']}!=200 or '${task['taskState']}'!='Error' or '${task['taskStatus']}'!='${invalid_switch_cred_err_msg}'     Fail    msg="LS cannot be created due to invalid credentials"
    \    Log to console and logfile    \n As expected Editing LS with incorrect password for the switch failed\n message:${task['taskErrors'][0]['message']}\n

API_TC_Edit the LS and change the LS name and verify the switches comes to configured state
    [Documentation] Editing Logical switch and changing the LS name
    Log to console and logfile    \n Editing LS name to ${LS_new} and verifying the switch state
    ${ls_uri}    Get LS URI    ${lss[0]['logicalSwitch']['name']}
    Set to dictionary   ${lss[0]['logicalSwitch']}    name   ${LS_new}
    Set to dictionary     ${username}    value    ${SWITCH1_USER}
    Set to dictionary     ${password}    value    ${SWITCH1_PASS}
    ${resp} =   Fusion Api Update LS    ${lss[0]}    ${ls_uri}
    ${task} =   fusion_api_appliance_setup.Wait For Task    ${resp}     5min    15s
    Run Keyword If     ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="LS is not edited"
    Verify Switch State     ${LS_new}     Configured

    Log to console and logfile    \n Editing LS name again to old name
    ${name}    Set to dictionary   ${lss[0]['logicalSwitch']}    name   ${LS1}
    ${resp} =   Fusion Api Update LS    ${lss[0]}    ${ls_uri}
    ${task} =   fusion_api_appliance_setup.Wait For Task    ${resp}     5min    15s
    Run Keyword If     ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="LS is not edited"
    Verify Switch State     ${LS1}     Configured


API_TC_Verify Reset statistics will only clear the downlink ports and statistics should not reset when the switch is added into the oneview
    [Documentation] Verifying Reset statistics will only clear the downlink ports and statistics
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    Get Advanced Statistics    ${switchUris}
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE     0     ${length}
    \   ${body}        Create Dictionary
    \   ${resp}        Fusion Api clear Interconnect Ports    ${body}    ${switchUris[${x}]}
    \   ${task} =   fusion_api_appliance_setup.Wait For Task    ${resp}     2min    15s
    \   Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed' or '${task['taskStatus']}'!='Switch configuration succeeded'    Fail    msg="Clear port counters failed"
    \   ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}    param=${Port_Name[1]}
    \   Run Keyword If    ${resp['ifInOctets']}>${advanced_statistics[${x}]['ifInOctets']} or ${resp['ifOutOctets']}>${advanced_statistics[${x}]['ifOutOctets']} or ${resp['ifInUcastPkts']}>${advanced_statistics[${x}]['ifInUcastPkts']}  Fail    msg="After reset counters should be cleared"
    \    ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}
    \    ${uplink_resp}    Get Port Data From Port Name    ${resp}    ${uplink_stacking_port}
    \   Run Keyword If    ${uplink_resp['ifInOctets']}<${advanced_statistics_uplink[${x}]['ifInOctets']} or ${uplink_resp['ifOutOctets']}<${advanced_statistics_uplink[${x}]['ifOutOctets']} or ${uplink_resp['ifInUcastPkts']}<${advanced_statistics_uplink[${x}]['ifInUcastPkts']}  Fail    msg="After reset uplink counters should not be cleared"
    \   Log to console and logfile   \n Successfully Verified Reset statistics will only clear the downlink ports and not on uplink ports
    Get Advanced Statistics    ${switchUris}
    Power off ALL Servers
    Remove All Server Profiles
    Remove All LS
    Set to dictionary     ${username}    value    ${SWITCH1_USER}
    Set to dictionary     ${password}    value    ${SWITCH1_PASS}
    ${temp}     Copy Dictionary    ${lss[1]}
    ${resp} =   Add Logical Switch from Variable    ${temp}
    Run Keyword If     ${resp['status_code']}!=200 or '${resp['taskState']}'!='Completed'    FAIL

        ##Adding server hardware
    ${len}    Get Length    ${DL_SH_IP}
    ${temp}    Copy Dictionary    ${DL_SH_body}
    :For    ${x}    In Range    0    ${len}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    Run Keyword If  '${resp['status_code']}' == '202'    Log to console and logfile  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Imported the DL server with IP ${DL_SH_IP[${x}]}\n
    \    ...    ELSE    FAIL
    \    ${task1} =   Get Variable value     ${resp['uri']}
    \    Sleep    60s
    \    ${task} =   Fusion Api Get Task     uri=${task1}
    \    ${msg} =    Get Variable value  ${task['taskState']}
    \    Should Match Regexp    ${msg}  ((?i)Completed|Warning)

    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE     0     ${length}
    \   ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}    param=${Port_Name[${x}]}
    \   Run Keyword If    ${advanced_statistics[${x}]['ifInOctets']}>${resp['ifInOctets']} or ${advanced_statistics[${x}]['ifOutOctets']}>${resp['ifOutOctets']} or ${advanced_statistics[${x}]['ifInUcastPkts']}>${resp['ifInUcastPkts']}  Fail    msg="Removing LS should not affect the statistics"
    Log to console and logfile   \n Successfully verified Reset statistics does not clear when the switch is added into the oneview

API_TC_Neg_Create LS in second appliance where Switch is already imported in another appliance and verify the LS creation should fail
    [Documentation] Creating LS in second appliance where Switch is already imported in another appliance
    ${Login_response} =    Fusion Api Login Appliance    ${Appliance_IP1}       ${admin_credentials}
    Run keyword unless  ${Login_response[0]['status_code']}== 200    Fail    "Unable to Login"
    Power off ALL Servers
    Remove All Server Profiles
    Remove All LS
    Remove All LSGs
    ${resp}    Add Logical Switch Group from variable    ${lsgs[1]}
    ${resp}     Add Logical Switch from variable    ${lss[1]}
    ${Error_Message}=    Get from Dictionary    ${resp['taskErrors'][0]}    errorCode
    ${resp_code}=    Get from Dictionary    ${resp}    status_code
    Run Keyword If    '${resp_code}'=='${status_code}' and '${Error_Message}'=='${Err_Msg}'    Log to console and logfile    \n-As expected the switches could not be added to second appliance\n message:${Error_Message}    ELSE    Fail


API_TC_Verify all the attributes are displayed after LS creation
    [Documentation] Creates LS and verifies the parameters
    [Tags]  2    THINSLICE
    Set Log Level    TRACE
    ${Login_response} =    Fusion Api Login Appliance    ${APPLIANCE_IP_4_10}       ${admin_credentials}
    ${lss_name}=    Get From Dictionary    ${lss[0]['logicalSwitch']}    name
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${lss_name}'"
    ${name}=    Get From Dictionary ${resp['members'][0]}    name
    Should Be Equal    ${name}    ${lss_name}    values=true
    Verify Parameters    ${resp}    @{Val_list}
    Log to console and logfile    \nSuccessfully verified all parameters are displayed after LS creation

API_TC_After the LS Creation verify the uplink port and downlink port details on both the switches
    [Documentation] verifying the uplink port and downlink port details on both the switches
    [Tags]  3    THINSLICE
    Set Log Level    TRACE
    ${PList}=    Create List
    Set Global Variable    ${PList}
    ${uris}    Get Uri of Switch
    ${count}=    Get Length    ${uris}
    :FOR    ${y}    IN RANGE    0    ${count}
    \    ${resp}=    Fusion Api Get Switch    ${uris[${y}]}
    \    ${count}=    Get Length   ${resp['ports']}
    \    ${Port_List}=    Ports For Loop    ${count}    ${resp}
    \    Append to List    ${PList}    ${Port_List}
    Log to console and logfile    \n Successfully verified the uplink port and downlink port details on both the switches

API_TC_Verify the connector information is available for all the ports uplink and downlink
    [Documentation] Verifying the connector information is available for all the ports uplink and downlink
    [Tags]  3    THINSLICE
    Set Log Level    TRACE
    ${uris}    Get Uri of Switch
    ${resp_ports}=    fusion_api_get_interconnect_pluggable_module_info    ${uris[0]}
    ${output}=    evaluate    json.loads('''${resp_ports['_content']}''')    json
    :FOR    ${x}    IN    @{output}
    \    ${portName}=    Get From Dictionary    ${x}    portName
    \    Log to console and logfile    \nport name for port ${portName}:${portName}
    \    ${identifier}=    Get From Dictionary    ${x}    identifier
    \    Log to console and logfile    \nSpeed for port ${portName}:${identifier}
    \    ${extIdentifier}=    Get From Dictionary    ${x}    extIdentifier
    \    Log to console and logfile    \nport type for port ${portName}:${extIdentifier}
    \    ${connector}=    Get From Dictionary    ${x}    connector
    \    Log to console and logfile    \nport status for port ${portName}:${connector}
    \    ${vendorName}=    Get From Dictionary    ${x}    vendorName
    \    Log to console and logfile    \nport name for port ${portName}:${vendorName}
    \    Run Keyword If    '${portName}' in ${PList[0]}    Should not contain    ${vendorName}    'NOT PRESENT'
    \    ${vendorOui}=    Get From Dictionary    ${x}    vendorOui
    \    Log to console and logfile    \nport name for port ${portName}:${vendorOui}
    \    ${vendorPartNumber}=    Get From Dictionary    ${x}    vendorPartNumber
    \    Log to console and logfile    \nport name for port ${portName}:${vendorPartNumber}
    \    ${vendorRevision}=    Get From Dictionary    ${x}    vendorRevision
    \    Log to console and logfile    \nport name for port ${portName}:${vendorRevision}
    Log to console and logfile    \n Successfully verified the connector information is available for all the ports uplink and downlink.

API_TC_After LS creation verify all the attributes and its values Try to assign and remove vlan id in the switch and verify the value in the vlanids section in oneview
    [Documentation] Verifying all attributes are available and assigning and removing vlan id
    [Tags]  1    THINSLICE
    Set Log Level    Trace
    Remove All Server Profiles
    ${uris}    Get Uri of Switch
    ${resp}=    Fusion Api Get Switch    ${uris[0]}
    ${name}    Get from dictionary    ${resp}    name
    ${Port_No_new}=    Replace String Using Regexp    ${Port_No}    /    \.
    ${Length}=    Get Length    ${resp['ports']}
    :FOR     ${x}   IN RANGE    0    ${Length}
    \  ${portName}=    Get From Dictionary    ${resp['ports'][${x}]}    portName
    \  ${port_uri}=    Run Keyword If  '${Port_No}' == '${portName}'    Get From Dictionary    ${resp['ports'][${x}]}    uri
    \   Exit For Loop If   '${Port_No}' == '${portName}'
    ${VID}    ${Remote}=    Get VlanID    ${port_uri}
    Enable/Disable VlanID in Switch    ${name}    ${Commands}    ${Port_No}    ${Vlan_Id}    1
    sleep    120s
    ${VID}    ${Remote}=    Get VlanID    ${port_uri}
    Run Keyword If    '${VID[0]}'=='${Vlan_Id}'    Log to console and logfile    \n-The Vlan ID in One-View has been changed to ${VID} after assigning vlan in switch    ELSE    Fail
    Enable/Disable VlanID in Switch    ${name}    ${Commands}    ${Port_No}    ${Vlan_Id}    0
    sleep    120s
    ${VID}    ${Remote}=    Get VlanID    ${port_uri}
    Run Keyword If    '${VID}'=='None'    Log to console and logfile    \n-The vlan ID in One-View has been changed to ${VID} after removing vlan in switch    ELSE    Fail
    Enable/Disable VlanID in Switch    ${name}    ${Commands}    ${Port_No}    ${Vlan_Id}    1
    sleep    120s
    ${VID}    ${Remote}=    Get VlanID    ${port_uri}
    Run Keyword If    '${VID[0]}'=='${Vlan_Id}'    Log to console and logfile    \n-The Vlan ID in One-View has been changed to ${VID} after assigning vlan in switch    ELSE    Fail

API_TC_Verify the Vlan id information is displayed for all ports and Verify the network hyperlink is provided for the ports configured with Vlan
    [Documentation] Verifying the vlan ID information is available for all the ports
    [Tags]  3    THINSLICE
    Set Log Level    TRACE
    ${uris}    Get Uri of Switch
    ${resp}=    Fusion Api Get Switch    ${uris[0]}
    ${count}=    Get Length   ${resp['ports']}
    :FOR    ${x}    IN RANGE    0    ${count}
    \    ${Vlan_Id}=    Get From Dictionary    ${resp['ports'][${x}]}    vlans
    ${nw}    Fusion Api Create Ethernet Network    ${Network_1}
    Run Keyword If  '${nw['status_code']}' == '202'    Log to console  \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    ${temp}     Copy Dictionary    ${server_profile_1}

    ${uri}    Get Server Hardware URI    ${DL_server_names[0]}
    Set to Dictionary    ${temp}    serverHardwareUri    ${uri}
    ${temp}    Update connections in profile    ${temp}
    ${resp}    Fusion Api Create Server Profile    body=${temp}    param=?force=ignoreServerHealth
    ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    timeout=15m   interval=10s
    ${Output}    fusion_api_get_server_profiles    param=?filter="'name'=='${temp['name']}'"
    ${Profileport}=    Get from Dictionary    ${Output['members'][0]['connectionSettings']['connections'][0]}    interconnectPort
    ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${uris[0]}
    ${resp}    Get Port Data From Port Name    ${resp}    ${Profileport}
    ${network_name}    Get From Dictionary    ${Network_1}    name
    ${netdet}    Fusion Api Get Ethernet Networks    param=?filter=name=${network_name}
    ${netw_uri}    Get Variable Value    ${netdet['members'][0]['uri']}
    Should contain    ${resp['vlanId'][0]['restUri'][0]['uri']}     ${netw_uri}


API_TC_Disable and enable the downlink ports from the switch page Verify the ports get disabled in the in the switch as well downlink port status in the server page Validate the alert message in the switch TC_Count_2
    [Documentation] Verifying the port status on disabling and enabling port
    [Tags]  1    THINSLICE
    Set Log Level    TRACE
    Remove All Server Profiles
    ${countse}=    Get Length   ${DL_server_names1}
    :FOR    ${x}    IN RANGE    0    ${countse}
    \   ${temp}     Copy Dictionary    ${server_profile_1}
    \   ${profile_name}    Get from Dictionary    ${temp}    name
    \   ${uri}    Get Server Hardware URI    ${DL_server_names1[${x}]}
    \   Set to Dictionary    ${temp}    serverHardwareUri    ${uri}
    \   Set to Dictionary    ${temp}    name    ${DL_server_names1[${x}]}:${profile_name}
    \   ${temp}    Update connections in profile    ${temp}
    \   ${resp}    Fusion Api Create Server Profile    body=${temp}    param=?force=ignoreServerHealth
    \   ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    timeout=15m   interval=10s
    \   ${Output}    fusion_api_get_server_profiles    param=?filter="'name'=='${temp['name']}'"
    \   Edit Downlinkport and Verify    ${Output}
    Remove All Server Profiles

API_TC_Verify and validate the switch type and MLAG configurations attributes and its values for both switches
    [Documentation] Verifying and validating the switch type and MLAG configurations attributes and its values for both switches
    Remove All Server Profiles
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}     Get Length       ${switchUris}
    Log to console and Logfile    \nVerifying the switch type and MLAG configurations attributes and its values for both switches
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${switchdetails} =     Fusion Api Get Switch       uri=${switchUris[${x}]}
    \    ${domainID}     Get from Dictionary     ${switchdetails['logicalSwitchVPC']}     domainId
    \    ${vpc_peer}     Get from Dictionary     ${switchdetails['logicalSwitchVPC']}     peer
    \    ${name}     Get from Dictionary     ${switchdetails}     name
    \    ${values}    Get dictionary values     ${vpc_peer}
    \    ${chassisID}    Get from Dictionary     ${switchdetails}     chassisId
    \    Append To List   ${values}   ${chassisID}
    \    Append to List    ${values}    ${domainId}
    \    Run Keyword If    '${name}'=='${Switch1_validate_list[3]}'    List Should Contain Sub list     ${values}     ${vpc_peer_mlag_switch1}
    \    ...     ELSE    List Should Contain Sub list     ${values}     ${vpc_peer_mlag_switch2}
    Log to console and logfile   \n Successfully verified the switch type and MLAG configurations attributes and its values for both switches

API_TC_Verify the various details in switch page like model chassis id FW location powered by state ip address vpc memberid role peer LS name or hyperlink used by for both the switches
    [Documentation] Verifying various details in switch page
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${List1} =   Create List
    \    ${switchdetails} =     Fusion Api Get Switch       uri=${switchUris[${x}]}
    \    ${name}     Get from Dictionary     ${switchdetails}     name
    \    Append To List   ${List1}   ${name}
    \    ${ipAddress}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    ipAddress
    \    ${chassisID}    Get from Dictionary     ${switchdetails}     chassisId
    \    Append To List   ${List1}   ${chassisID}
    \    ${FW}    Get from Dictionary     ${switchdetails}     firmwareVersion
    \    Append To List   ${List1}   ${FW}
    \    ${state}     Get from Dictionary     ${switchdetails}     state
    \    Append To List   ${List1}   ${state}
    \    ${vpc_member_id}     Get from Dictionary     ${switchdetails['logicalSwitchVPC']}     memberId
    \    Append To List   ${List1}   ${vpc_member_id}
    \    ${vpc_role}     Get from Dictionary     ${switchdetails['logicalSwitchVPC']}     role
    \    Append To List   ${List1}   ${vpc_role}
    \    List Should contain sub list     ${Switch_validate_list}     ${List1}

API_TC_Verify the advanced statistics information is unavailable for unlinked ports
    [Documentation] Verifying the advanced statistics information is unavailable for unlinked ports
    #Get the  advance statistics for 2 ports and infoctes
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    Get Advanced Statistics    ${switchUris}
    ${length}     Get Length       ${switchUris}
        :FOR    ${x}    IN RANGE     0     ${length}
    \   ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}    param=${UnlinkedPort_Name[${x}]}
    \   Run Keyword If    ${resp['ifOutOctets']}!=0     FAIL     msg="ifOutOctets should not be available for unlinked port"
    Log to console and logfile    \n Successfully verified advanced statistics is not available for unlinked ports

API_TC_Reboot the arista switch by login to the switch and veirfy the state of the switch
    [Documentation] Verifying switch state after reboot
    ${Arista_IP}    Get Length     ${ARISTA_IPS}
    :FOR    ${x}    IN RANGE   0    ${Arista_IP}
    \    Reboot Arista Switch    ${ARISTA_IPS[${x}]}   ${reboot_command}
    Wait until Keyword Succeeds    1 min   15s    Verify Ping Fails    ${number}    ${ARISTA_IPS[${x}]}    ${switch_ping_name}    ${flag}    ${switch_ping_file_path}
    Wait until Keyword Succeeds    3 min   15s    Verify Ping Successful    ${number}    ${ARISTA_IPS}    ${switch_ping_name}    ${flag}    ${switch_ping_file_path}
    Sleep   120s
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}    Get Length    ${switchUris}
    :FOR    ${x}    IN RANGE   0    ${length}
    \    ${resp}    Fusion Api Get Switch     uri=${switchUris[${x}]}
    \    Should Be Equal As Strings    '${resp['state']}'     'Configured'


API_TC_After the LS creation Change the LIG name and verify the consistency state and LS is automatically updated
    [Documentation] Verifying consistency state after changing LIG name
    ${resp}    Fusion Api Get LSG    param=?filter=name=${LSG1}
    ${lsg_uri}    Get LSG URI    ${LSG1}
    Set to dictionary    ${lsgs[0]}    switchMapTemplate   ${resp['members'][0]['switchMapTemplate']}
    Set to dictionary    ${lsgs[0]}    name   ${LSG_new}
    ${resp}   Fusion Api Edit LSG    ${lsgs[0]}   ${lsg_uri}
    ${task} =   Wait For Task   ${resp}     1min    15s
    Run Keyword If     ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="LSG is not edited successfully"
    ${LSG_details} =    Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    Run Keyword If    '${LSG_details['members'][0]['consistencyStatus']}'!='${consistencyStatus}'   Fail   msg="After LSG edit LS should be consistent"
    ${resp}    Fusion Api Get LSG    param=?filter=name=${LSG_new}
    ${lsg_uri}    Get LSG URI    ${LSG_new}
    Set to dictionary    ${lsgs[0]}    switchMapTemplate   ${resp['members'][0]['switchMapTemplate']}
    Set to dictionary    ${lsgs[0]}    name   ${LSG1}
    ${resp}   Fusion Api Edit LSG    ${lsgs[0]}   ${lsg_uri}
    ${task} =   Wait For Task   ${resp}     1min    15s
    Run Keyword If     ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="LSG is not edited successfully"
    ${LSG_details} =    Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    Run Keyword If    '${LSG_details['members'][0]['consistencyStatus']}'!='${consistencyStatus}'   Fail   msg="After LSG edit LS should be consistent"

API_TC_Delete the LS with unforce option Verify the delete LS activity is completed without error message and switch data
    [Documentation] Verifying LS deletion with unforce option
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}    Get Length    ${switchUris}
    Run Keyword If     ${length}!=2     Fail    msg="No of switches should be equal to 2"
    Remove All LS
    :FOR    ${x}    IN RANGE   0    ${length}
    \    ${resp}    Fusion Api Get Switch     uri=${switchUris[${x}]}
    \    Run Keyword If     '${resp['errorCode']}'!='CRM_SWITCH_ENTITY_ID_INVALID' or ${resp['status_code']}!=404    Fail   msg="After removing the LS switch details should not be available"
    Log to console and logfile     \n Successfully deleted LS and switch information is not available

*** Keywords ***
Verify Alerts in Profiles page
    [Documentation]    Verify Alerts in server profiles page
    ${Alert_msg}    Create List
    ${resp}    Fusion Api Get Alerts
    ${mem_resp}    Get From Dictionary    ${resp}    members
    ${len}    Get Length    ${mem_resp}
    :FOR   ${x}    IN RANGE    0    ${len}
    \   Run Keyword If  '${mem_resp[${x}]['physicalResourceType']}' !='server-profiles'    Continue For Loop
    \   ${desc}    Get From Dictionary    ${mem_resp[${x}]}    description
    ${cmd_output}    Get Regexp Matches    ${desc}    An error has occurred on connection \\s.*
    [Return]    True

Perform Enable Switch Ports
    [Documentation]    Pass Interface number to perform Enable ports
    [Arguments]    ${interface}
    :For    ${x}    In Range    0    2
    \    Enable disable switch port    ${switches_IP[${x}]}    ${enable[1]}    ${interface}    ${x}

Perform Disable Switch Ports
    [Documentation]    Pass the Interface number for Disable ports
    [Arguments]    ${interface}
    :For    ${x}    In Range    0    2
    \    Enable disable switch port    ${switches_IP[${x}]}    ${enable[0]}    ${interface}    ${x}


Verify Switches URI from Switches Page with SH page
    ### used in ovf2724 suite
    [Documentation]    keyword to compare the switches uri from switches page with Adapter details of server in Server Hardware Page
    [Arguments]    ${sw_uri_SH}
    :For    ${x}    IN Range    0    2
    \    ${resp}    Fusion Api Get Switch    param=?filter=name=${switches_IP[${x}]}
    \    ${switch_uri}    Get Variable Value    ${resp['members'][${x}]['uri']}
    \    List Should Contain Value    ${sw_uri_SH}    ${switch_uri}

Enable disable switch port
    [Documentation]    Enable/disable switch ports on OV
    [Arguments]    ${switch_ip}    ${enable}    ${Interfaces_number}    ${x}

    ${resp}    Fusion Api Get Switch    param=?filter=name=${switch_ip}
    ${sw_uri}    Get Variable Value    ${resp['members'][${x}]['uri']}
    @{id} =     Split String    ${sw_uri}   /
    ${port_id} =    Get From List   ${id}   3
    ${porturi}       catenate    ${sw_uri}/ports/${port_id}:${Interfaces_number}
    ${res2}    Fusion Api Get Switch    uri=${porturi}
    Set To Dictionary    ${port_details[0]}    portId    ${res2['portId']}
    Set To Dictionary    ${port_details[0]}    enabled    ${enable}
    Set To Dictionary    ${port_details[0]}    portName    ${res2['portName']}
    ${uri}    catenate    ${sw_uri}/update-ports
    ${Response}    Fusion Api Edit Switch     ${port_details}    uri=${uri}
    Wait For Task    ${Response}
    sleep    120s

Verify switch hyperlink empty in Server Hardware
    [Documentation]    Verify the switch uris are disabled/absent on Server Hardware Page
    [Arguments]    ${server}
    ${sh_dict}    Create Server Hardware Dictionary    ${server}
    Refresh the server hardware    ${sh_dict['uri']}
    Refresh the server hardware    ${sh_dict['uri']}
    Refresh the server hardware    ${sh_dict['uri']}
    Refresh the server hardware    ${sh_dict['uri']}
    sleep    10s
    ${sh_dict_new}    Create Server Hardware Dictionary    ${server}
    ${sh_sw_uris}    Fetch Switch Uris from Server Hardware Page    ${sh_dict_new}
    :For    ${x}    IN    @{sh_sw_uris}
    \    Run Keyword Unless    '${x}' == 'None'    Fail    msg=Switch Uri's on Server Hardware Page should be Empty!!

Verify Server Profile Page Attributes
    [Documentation]    Verify the details of profiles like Networks/Switch ports/switch uris and MAC
    [Arguments]    ${sp_name}    ${server_name}

    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_name}
    ${Sp_connections}    Get From Dictionary    ${resp['members'][0]['connectionSettings']}    connections
    ${sp_nw_list}    Create List
    :For    ${x}    IN Range    0    2
    \    ${nw_uri}    Get Variable Value    ${Sp_connections[${x}]['networkUri']}
    \    Append To List    ${sp_nw_list}    ${nw_uri}
    ${return}    Verify Profile networks    ${sp_nw_list}
    Run Keyword Unless    '${return}' == 'True'    Fail
    ${sh_resp}    Create Server Hardware Dictionary    ${server_name}
    :For    ${x}    IN Range    0    2
    \    Run Keyword Unless    '${Sp_connections[${x}]['interconnectUri']}' == '${sh_resp['ports_info'][${x}]['interconnect_switch_uri']}'    Fail
    \    Run Keyword Unless    '${Sp_connections[${x}]['mac']}' == '${sh_resp['ports_info'][${x}]['mac']}'    Fail
    \    Run Keyword Unless    '${Sp_connections[${x}]['interconnectPort']}' == '${sh_resp['ports_info'][${x}]['switch_port']}'    Fail

Verify Profile networks
    [Documentation]    Verify network uri's from Profiles are present in Networks Page
    [Arguments]    ${sp_nw_list}
    ${nw_uri_list}    Create List
    ${resp}    Fusion Api Get Ethernet Networks
    ${len}    Get Length    ${resp['members']}
    :For    ${x}    In Range    0    ${len}
    \    ${uri}    Get Variable Value    ${resp['members'][${x}]['uri']}
    \    Append To List    ${nw_uri_list}    ${uri}
    :For    ${sp_net}    IN    @{sp_nw_list}
    \    List Should Contain Value    ${nw_uri_list}    ${sp_net}
    [Return]    True

Create Server Hardware Dictionary
    ### used in OVF2724 suite
    [Documentation]    Create a dictionary based on Server Hardware Get Request API call
    [Arguments]    ${server_name}

    ${resp}    Fusion Api Get Server Hardware    param=?filter=name=${server_name}
    ${SH_name}    Get From Dictionary    ${resp['members'][0]}    name
    ${SH_model}    Get From Dictionary    ${resp['members'][0]}    model
    ${SH_fw}    Get From Dictionary    ${resp['members'][0]}    mpFirmwareVersion
    ${SH_state}    Get From Dictionary    ${resp['members'][0]}    mpState
    ${adapter_details}    Get From Dictionary    ${resp['members'][0]}    portMap
    ${uri}     Get From Dictionary    ${resp['members'][0]}    uri
    ${ports_info}    Run Keyword If    ${adapter_details} != None    Create Port List from Adapter Details    ${adapter_details}
## Check this '${}' != 'None' for 4.0
    ${host_details}    Get From Dictionary    ${resp['members'][0]}    mpHostInfo
    :For    ${hosts}    IN    @{host_details['mpIpAddresses']}
    \    Run Keyword If    '${hosts['type']}' == 'DHCP'    Set To Dictionary    ${mphosts_addresses}    DHCP=${hosts['address']}
    \    Run Keyword If    '${hosts['type']}' == 'LinkLocal'    Set To Dictionary    ${mphosts_addresses}    LinkLocal=${hosts['address']}
    \    Run Keyword If    '${hosts['type']}' == 'Lookup'    Set To Dictionary    ${mphosts_addresses}    Lookup=${hosts['address']}
    ${temp}    Create Dictionary     name=${SH_name}
    ...                              model=${SH_model}
    ...                              firmware=${SH_fw}
    ...                              ports_info=${ports_info}
    ...                              server_state=${SH_state}
    ...                              host_details=${mphosts_addresses}
    ...                              uri=${uri}
## Check this '${}' != 'None' for 4.0
    ${adapter_name}    Run Keyword If    ${adapter_details} != None    Set To Dictionary    ${temp}    adapter_name=${adapter_details['deviceSlots'][0]['deviceName']}
    ${slotNumber}    Run Keyword If    ${adapter_details} != None    Set To Dictionary    ${temp}    slotNumber=${adapter_details['deviceSlots'][0]['slotNumber']}
    [Return]    ${temp}

Create Port List from Adapter Details
    ### used in ovf2724 suite
    [Documentation]    Create a List for port details from the Adapter Information
    [Arguments]    ${adapter_details}
    ${ports_info}    Create List
    :For    ${ports}    IN     @{adapter_details['deviceSlots'][0]['physicalPorts']}
    \    ${port_number}    Get From Dictionary    ${ports}    portNumber
    \    ${physical_switch_uri}    Get From Dictionary    ${ports}    physicalInterconnectUri
    \    ${interconnect_switch_uri}    Get From Dictionary    ${ports}    interconnectUri
    \    ${mac}    Get From Dictionary    ${ports}    mac
    \    ${switch_type}    Get From Dictionary    ${ports}    type
    \    ${switch_port}    Get From Dictionary    ${ports}    physicalInterconnectPort
    \    ${ports_dict}    Create Dictionary    portnumber=${port_number}
    \    ...                                   physical_switch_uri=${physical_switch_uri}
    \    ...                                   interconnect_switch_uri=${interconnect_switch_uri}
    \    ...                                   switch_type=${switch_type}
    \    ...                                   switch_port=${switch_port}
    \    ...                                   mac=${mac}
    \    Append To List    ${ports_info}    ${ports_dict}
    [Return]    ${ports_info}

Edit Server Profile connections
    [Documentation]    Edit the Server Profiles by changing connection vlans from 10,20 to 30,40
    [Arguments]    ${server_name}    ${sp_name}    ${nw_names}
    Power OFF server    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_name}
    Set to Dictionary    ${server_profiles_body_edit}    eTag    ${resp['members'][0]['eTag']}
    Set to Dictionary    ${server_profiles_body_edit}    name    ${resp['members'][0]['name']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareTypeUri    ${resp['members'][0]['serverHardwareTypeUri']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareUri    ${resp['members'][0]['serverHardwareUri']}
    ${sp_uri}    Get Variable Value    ${resp['members'][0]['uri']}
    ${old_connections}    Get From Dictionary    ${resp['members'][0]['connectionSettings']}    connections
    ${len}    Get Length    ${nw_names}
    :For    ${x}    In Range    0    ${len}
    \    ${res}    Fusion Api Get Ethernet Networks    param=?filter=name=${nw_names[${x}]}
    \    ${net_uri}    Get Variable Value    ${res['members'][0]['uri']}
    \    Set To Dictionary    ${server_profiles_body_edit['connectionSettings']['connections'][${x}]}    networkUri=${net_uri}
    ${resp}    Fusion Api Edit Server Profile    body=${server_profiles_body_edit}    uri=${sp_uri}
    ${task}    Wait For Task    ${resp}    250s    10s
    Power on server   ${server_name}
    Sleep    100s

Edit Server Profile connections for netset
    [Documentation]    Edit the Server Profiles by changing connection vlans from 10,20 to 30,40
    [Arguments]    ${server_name}    ${sp_name}    ${nw_uris_list}    ${net_con_uri}
    Power OFF server    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${sp_name}
    Set to Dictionary    ${server_profiles_body_edit}    eTag    ${resp['members'][0]['eTag']}
    Set to Dictionary    ${server_profiles_body_edit}    name    ${resp['members'][0]['name']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareTypeUri    ${resp['members'][0]['serverHardwareTypeUri']}
    Set to Dictionary    ${server_profiles_body_edit}    serverHardwareUri    ${resp['members'][0]['serverHardwareUri']}
    ${sp_uri}    Get Variable Value    ${resp['members'][0]['uri']}
    ${old_connections}    Get From Dictionary    ${resp['members'][0]['connectionSettings']}    connections
    ${len}    Get Length    ${old_connections}
    Set To Dictionary    ${server_profiles_body_edit['connectionSettings']['connections'][0]}    networkUri=${nw_uris_list}
    Set To Dictionary    ${server_profiles_body_edit['connectionSettings']['connections'][1]}    networkUri=${net_con_uri}
    ${resp}    Fusion Api Edit Server Profile    body=${server_profiles_body_edit}    uri=${sp_uri}
    ${task}    Wait For Task    ${resp}    250s    10s
    Power on server    ${server_name}
    Sleep    100s

Verify VlanID in switch
    [Documentation]    Login to switch and fetch active VlanID
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    SSHLibrary.Open Connection    ${switch_ip}    timeout=30s
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    7s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${interface}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    SSHLibrary.Write    ${Commands[10]}
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan (\\d.*)
    ${value}    Convert To String    ${vlan}
    [Return]    ${value}

Disable VlanID in switch
    [Documentation]    Login to switch and fetch active VlanID
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    SSHLibrary.Open Connection    ${switch_ip}    timeout=30s
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    7s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${interface}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    SSHLibrary.Write    ${disable_vlan[0]}
    sleep    3s
    SSHLibrary.Write    write
    sleep    8s
    SSHLibrary.Write    ${disable_vlan[1]}
    sleep    3s
    SSHLibrary.Write    write
    sleep    8s
    SSHLibrary.Write    ${Commands[10]}
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan\\s+(\\w+)
    Run Keyword Unless    '${vlan}' == 'none'    Fail
    [Return]    True

Fetch VlanId from switches for profiles
    [Documentation]    Login to the Arista switch and execute commands to fetch active Vlans
    [Arguments]    ${switch_ip}    ${interface}
    ${data}    Verify VlanID in switch    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    [Return]    ${data}

Fetch vlanid from Profile connections
    [Documentation]    Perform a Get Request on server profile connections and fetch their vlanid's
    [Arguments]    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${server_name}
    ${nw_uri_list}    Create List
    ${len}    Get Length    ${resp['members'][0]['connectionSettings']['connections']}
    :For    ${x}    In Range    0    ${len}
    \    ${net_uri}    Get From Dictionary    ${resp['members'][0]['connectionSettings']['connections'][${x}]}    networkUri
    \    Append To List    ${nw_uri_list}    ${net_uri}
    ${sp_vlans}    Create List
    :For    ${net}    IN    @{nw_uri_list}
    \    ${resp}    Fusion Api Get Ethernet Networks    uri=${net}
    \    ${value}    Get Variable Value    ${resp['vlanId']}
    \    ${vlan}    Convert To String    ${value}
    \    Append To List    ${sp_vlans}    ${vlan}
    [Return]    ${sp_vlans}

Fetch vlanid from Profile connections for netset
    [Documentation]    Perform a Get Request on server profile connections and fetch their vlanid's
    [Arguments]    ${server_name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${server_name}
    ${ns_uri}    Get From Dictionary    ${resp['members'][0]['connectionSettings']['connections'][0]}    networkUri
    ${net_uri}    Get From Dictionary    ${resp['members'][0]['connectionSettings']['connections'][1]}    networkUri
    ${sp_vlans}    Create List
    ${resp}    Fusion Api Get Network Set    uri=${ns_uri}
    ${nw_list}    Get Variable Value    ${resp['networkUris']}
    Append To List    ${nw_list}    ${net_uri}
    :For    ${net}    IN    @{nw_list}
    \    ${resp}    Fusion Api Get Ethernet Networks    uri=${net}
    \    ${value}    Get Variable Value    ${resp['vlanId']}
    \    ${vlan}    Convert To String    ${value}
    \    Append To List    ${sp_vlans}    ${vlan}
    [Return]    ${sp_vlans}

Fetch vlan id of switch and profile
    [Documentation]    Fetch the VlanIds of Profile and switches and verify them
    [Arguments]    ${server_profile}    ${switch_ip}    ${interface}
    ${sp_vlans}    Fetch vlanid from Profile connections    ${server_profile[0]['name']}
    :For    ${switch}    IN    @{switch_ip}
    \    ${switch_vlans}    Fetch VlanId from switches for profiles    ${switch}    ${interface}
    \    List Should Contain Value    ${sp_vlans}    ${switch_vlans}


Fetch vlan id of switch and profile for netset
    [Documentation]    Fetch the VlanIds of Profile and switches and verify them
    [Arguments]    ${server_profile}    ${switch_ip}    ${interface}
    ${sp_vlans}    Fetch vlanid from Profile connections for netset    ${server_profile[0]['name']}
    :For    ${switch}    IN    @{switch_ip}
    \    ${switch_vlans}    Fetch VlanId from switches for profiles    ${switch}    ${interface}
    \    ${len}    Get Length    ${switch_vlans}
    \    Run Keyword If    ${len} == 2    List Should Contain Value    ${sp_vlans}    ${switch_vlans}
    \    ...    ELSE    Validate switch vlans and profile vlans for netset    ${switch_vlans}    ${sp_vlans}

Validate switch vlans and profile vlans for netset
    [Documentation]    validate switch vlans and profile vlans for netset
    [Arguments]    ${switch_vlans}    ${sp_vlans}
    @{list}    Split String    ${switch_vlans}    ,
    :For    ${x}    In Range    0    3
    \    List Should Contain Value    ${sp_vlans}    ${list[${x}]}

Verify switch VlanID removed
    [Documentation]    Verify switch vlanID removed
    [Arguments]     ${switch_ip}      ${switch_details}     ${interface}     ${Commands}
    :For    ${switch}    IN    @{switch_ip}
    \    Verify switch VlanID empty    ${switch}    ${switch_details}    ${interface}    ${Commands}

Verify switch VlanID empty
    [Documentation]    Login to switch and check active VlanID is none
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}
    SSHLibrary.Open Connection    ${switch_ip}    timeout=30s
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    7s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${interface}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    SSHLibrary.Write    ${Commands[10]}
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan\\s+(\\w+)
    Run Keyword Unless    '${vlan}' == 'none'    Fail
    [Return]    True

Presetup for Profiles
    [Documentation]    Presetup for profile creation Includes creation of Networks, LSG, LS and Importing Server Hardwares
    ${resp}    Add Logical Switch Group from variable    ${lsgs[2]}
    Set to dictionary     ${username}    value    ${SWITCH1_USER}
    Set to dictionary     ${password}    value    ${SWITCH1_PASS}
    ${temp}     Copy Dictionary    ${lss[2]}
    ${resp}     Add Logical Switch from variable    ${temp}
    Create Networks for Profiles
    Create Network Set for Profiles
    :For    ${switch}    IN    @{switch_ip}
    \    Set VlanID in Switch    ${switch}    ${Commands}    ${switch_vlan}
    ${len}    Get Length    ${DL_SH_IP}
    ${temp}    Copy Dictionary    ${DL_SH_body}
    :For    ${x}    In Range    0    ${len}
    \    Set To Dictionary    ${temp}    hostname=${DL_SH_IP[${x}]}
    \    ${resp}    Fusion Api Add Server Hardware    ${temp}
    \    Run Keyword If  '${resp['status_code']}' == '202'    Log to console and logfile  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Imported the DL server with IP ${DL_SH_IP[${x}]}\n
    \    ...    ELSE    FAIL
    \    ${task1} =   Get Variable value     ${resp['uri']}
    \    Sleep    60s
    \    ${task} =   Fusion Api Get Task     uri=${task1}
    \    ${msg} =    Get Variable value  ${task['taskState']}
    \    Should Match Regexp    ${msg}  ((?i)Completed|Warning)
    #setting vlan in switches
    :For    ${switch}    IN    @{switch_ip}
    \    Set VlanID in Switch    ${switch}    ${Commands}    ${set_vlan[0]}

Create Networks for Profiles
    [Documentation]    Create 6 networks with Vlans 10 20 30 40 50 60
    ${temp}    Copy Dictionary    ${Network_body}
    :For    ${vlan}    IN    @{Vlans}
    \    Set To Dictionary    ${temp}    vlanId    ${vlan}
    \    Set To Dictionary    ${temp}    name    Net_Vlan${vlan}
    \    ${nw}    Fusion Api Create Ethernet Network    ${temp}
    \    Run Keyword If  '${nw['status_code']}' == '202'    Log to console  \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    \    ...    ELSE    FAIL
    \    ${task}    fusion_api_appliance_setup.Wait For Task    ${nw}    60 s    10 s

Create Network Set for Profiles
    [Documentation]    Create different Network Sets for Server Profiles
    [Arguments]      ${nativeurilist}=${NONE}    ${nativeyes}=0
    :For    ${x}    In Range    0    2
    \    Run Keyword If  '${nativeyes}' == '1'    Create Network Sets    ${Network_sets[${x}]}    ${x}    ${nativeurilist[${x}]}
    \    ...    ELSE    Create Network Sets    ${Network_sets[${x}]}    ${x}    ${nativeurilist}

Create Network Sets
    [Documentation]    Create Network Sets
    [Arguments]    ${nw_set_vlans}    ${x}    ${nativeuri}=${NONE}
    ${nw_uri_list}    Create List
    ${y}    Evaluate    ${x}+1
    ${temp}    Copy Dictionary    ${Network_set_body}
    :For    ${name}    IN    @{nw_set_vlans}
    \    ${net}    Fusion Api Get Ethernet Networks    param=?filter=name=${name}
    \    ${uri}    Get Variable Value    ${net['members'][0]['uri']}
    \    Append To List    ${nw_uri_list}    ${uri}
    Set To Dictionary    ${temp}    networkUris    ${nw_uri_list}
    Set To Dictionary    ${temp}    name    Net_Set${y}
    Set To Dictionary    ${temp}    nativeNetworkUri    ${nativeuri}
    ${resp}    Fusion Api Create Network Set    ${temp}
    Run Keyword If  '${resp['status_code']}' == '202'    Log to console  \nStatus Code: ${resp['status_code']} \nSuccessfully!! Created Network Set\n
    ...    ELSE    FAIL
    ${Task}    Wait For Task And Validate Response    ${resp}    ${valDict}    180 s    10 s    True

Add DL Server Profiles from variable
    [Documentation]    Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
    [Arguments]     ${profiles}   ${timeout}=15m    ${interval}=10s   ${endstate}=((?i)Warning|Completed)   ${param}=?force=ignoreServerHealth
    :FOR    ${profile}    IN    @{profiles}
    \   ${profile}    fusion_api_appliance_setup.Copy Dictionary    ${profile}
        \       ${space}    Check For Whitespace From String    ${profile['name']}
        \       Run Keyword If   ${space} is ${True}   Fail   msg=Profile name contains whitespace. This is not allowed in CI-FIT naming convention.
    \   ${shuri}    Get from Dictionary    ${profile}    serverHardwareUri
    \   ${uri}    Get Server Hardware URI    ${shuri}
    \   Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    \   ${profile}    Update connections in profile    ${profile}
    \   ${resp}    Fusion Api Create Server Profile    body=${profile}    param=${param}
    \   ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}    timeout=${timeout}    interval=${interval}
    [Return]    ${task}

Get interface number
    [Documentation]    Get Interface Number
    [Arguments]    ${DL_server_names}    ${server_profile}
    ${len}    Get Length    ${DL_server_names}
    :For    ${x}    In Range    0    ${len}
    \    Run Keyword If    '${DL_server_names[${x}]}' != '${server_profile[0]['serverHardwareUri']}'    Continue For Loop
    \    ...    ELSE    Run Keywords    Set Global Variable    ${interface}    ${Interfaces_number[${x}]}    AND    Exit For Loop
    [Return]    ${interface}

Validate switchports are equal in server hardware
    [Documentation]    Validate switchports are equal in server hardware
    [Arguments]    ${server}
    ${SH_dict}    Create Server Hardware Dictionary    ${server}
    ${uri}    Get From Dictionary    ${SH_dict}    uri
    ${Ports}    ${switch_ports}    Validate Port Info    ${SH_dict['ports_info']}
    ${status}    Validate switch ports are equal     ${switch_ports}
    [return]    ${uri}   ${status}

Fetch Switch Uris from Server Hardware Page
    ### used in ovf2724 suite
    [Documentation]    Keyword to Fetch a list of switch uri's for each Server Hardware
    [Arguments]    ${SH_dict}
    ${sw_uri_SH}    Create List
    :For    ${port}    IN    @{SH_dict['ports_info']}
    \    ${physical_switch_uri}    Get Variable Value    ${port['physical_switch_uri']}
    \    Append To List    ${sw_uri_SH}    ${physical_switch_uri}
    #Log to console and logfile    \n\n The Switch uri's of ${SH_dict['name']} are : ${sw_uri_SH}
    [Return]    ${sw_uri_SH}

Validate Port Info
    ### used in OVF2724 suite
    [Documentation]    Validate Port Info of a server adapters
    [Arguments]    ${SH_ports}
    ${sw_uri_list}    Create List
    ${switch_ports}    Create List
    :For    ${ports}    IN    @{SH_ports}
    \    Run Keyword Unless   '${ports['switch_type']}' == '${sw_type}'    FAIL
    \    ${port_number}    Convert To String    ${ports['portnumber']}
    \    ${switch_port}    Convert To String    ${ports['switch_port']}
    \    Append To List    ${switch_ports}    ${switch_port}
    \    Should Match Regexp    ${port_number}    \\d+
    \    Should Match Regexp    ${switch_port}    \\d+
    \    ${sw_uri}    Get Variable Value    ${ports['physical_switch_uri']}
    \    Run Keyword If    '${sw_uri}' == '${ports['interconnect_switch_uri']}'
    \    ...    Append To List    ${sw_uri_list}    ${sw_uri}
    [Return]    ${sw_uri_list}  ${switch_ports}

Validate switch ports are equal
     ### used in ovf2724 suite
    [Documentation]    Verify switch ports are equal
    [Arguments]    ${switch_ports}
    ${status}    Evaluate  '${switch_ports[0]}' == '${switch_ports[1]}'
    [return]    ${status}

Refresh the server
    [Documentation]    Refresh the server until ports on both switches in server hardware page are same
    [Arguments]    ${uri}    ${server}
    ${resp}    Fusion Api Refresh Server Hardware    uri=${uri}
    ${task}    Wait For Task    ${resp}    250s    10s
    ${out1}    ${status}    Validate switchports are equal in server hardware    ${server}
    Run keyword If    '${status}'== 'False'    Refresh the server     ElSE     Log to console and logfile     Switch ports are equal

Refresh the server hardware
    [Documentation]    Refresh the server hardware after disabling switch port
    [Arguments]    ${uri}
    ${resp}    Fusion Api Refresh Server Hardware    uri=${uri}
    ${task}    Wait For Task    ${resp}    250s    10s


Clean OV
    [Documentation]    Clean Up the Appliance
    Log to console and logfile    \nCleaning the OV
    Fusion Api Login Appliance    ${APPLIANCE_IP_4_10}    ${admin_credentials}
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Server Profile Template
    Remove All Server Hardware
    Remove All LS
    Remove All LSGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets
    Remove ALL Users

Remove All Server Hardware
    [Documentation]    Removes server Hardware
    #Log to console and logfile    \n Removes server Hardware\n
    ${SH}    Fusion Api Get Server Hardware
    :FOR    ${server}    IN     @{SH['members']}
    \    ${resp} =    Fusion Api delete Server Hardware        uri=${server['uri']}
    \    ${task} =    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s

Remove All Server Profile Template
    [Documentation]    Removes all Server Profile Template
    ${SP_temp}    Fusion Api Get Server Profile Templates
    :FOR    ${template}    IN     @{SP_temp['members']}
    \    ${resp} =    Fusion Api Delete Server Profile Template        uri=${template['uri']}
    \    ${task} =    fusion_api_appliance_setup.Wait For Task    ${resp}    100s    10s

Get Redhat IP Old
    [Documentation]    ssh login to Redhat DL 380 Server using eno4 interface to fetch IPs of eno5 & eno6
    [Arguments]    ${redhat_ip}
    ${ips}    Create List
    SSHLibrary.Open Connection    ${redhat_ip}    timeout=30s
    SSHLibrary.Login    root    hpvse123
    #SSHLibrary.Read Until    #
    sleep    5s
    SSHLibrary.Write    ip addr
    sleep    5s
    ${Output}=    SSHLibrary.Read
    Log to console and logfile    \n\n${Output}
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    scope global dynamic
    Log to console and logfile    \n\n${lines}
    ${match1}    ${redhatip1}     Should Match Regexp    ${lines}    inet (192.\\d+.\\d+.\\d+)/\\d+.*eno5
    ${match2}    ${redhatip2}     Should Match Regexp    ${lines}    inet (192.\\d+.\\d+.\\d+)/\\d+.*eno6
    Log to console and logfile    \n\nlines ${match1}
    Log to console and logfile    \n\nlines ${redhatip1}
    Log to console and logfile    \n\nlines ${match2}
    Log to console and logfile    \n\nlines ${redhatip2}
    Append To List    ${ips}    ${redhatip1}
    Append To List    ${ips}    ${redhatip2}
    [Return]    ${ips}

Get Server Hardware OS type and ILO IP
    [Documentation]    Get server hardware OS type and ILO IP
    [Arguments]     ${server_name}
    ${resp}    Fusion Api Get Server Hardware    param=?filter=name=${server_name}
    ${SH_name}    Get From Dictionary    ${resp['members'][0]}    serverName
    ${ip}=      Get From Dictionary     ${resp['members'][0]['mpHostInfo']['mpIpAddresses'][0]}   address
    [return]   ${SH_name}    ${ip}

Get Windows Server IP
    [Documentation]    Gets the valid ip and gateway ip of the server.
    [Arguments]     ${win_server_details}   ${ip}

    SSHLibrary.Open Connection    ${ip}
    SSHLibrary.Login    ${win_server_details['username']}    ${win_server_details['password']}
    Sleep    5
    ${windows_ips}      Create List
    #SSHLibrary.Read Until    hpiLO->
    #Sleep    5
    SSHLibrary.Write    stop /system1/oemhp_VSP1
    Sleep    5
    SSHLibrary.Write    vsp
    Sleep    5
    SSHLibrary.Read Until    SAC>
    Sleep    5
    SSHLibrary.Write    i
    Sleep    5
    ${output1}=    SSHLibrary.Read
    ${cmd_output}=    Get Regexp Matches    ${output1}    192\\.\\d+\\.\\d+\\.\\d+
    ${IP_Count}=    Get Length    ${cmd_output}
    :FOR     ${x}   IN RANGE    0    ${IP_Count}
    \    ${Server_IP}=    convert_unicode_to_string    ${cmd_output[${x}]}
    \    Append To List    ${windows_ips}   ${Server_IP}
    SSHLibrary.Close All Connections
    [Return]  ${windows_ips}


Ping Downlink from Uplink
    [Documentation]    Ping downlink from uplink to verify traffic
    [Arguments]    ${server_ip}
    ${result1}    Run    ping ${server_ip}
    ${cmd_output1}    Get Regexp Matches    ${result1}    Lost = \\d
    ${data_loss}    Get Variable Value    ${cmd_output1[0]}
    Run Keyword If    '${data_loss}' == '0'    log to console    \n Expected Failure - Ping succeeds  !!!
    ...    Else    FAIL

Verify Port Status
    [Documentation]    Verify Port Status
    ...             Example:
    ...             Verify Port Status    ${ports}
    [Arguments]         ${switchUris}    ${portid}    ${ports}     ${status}
    ${length}     Get Length       ${ports}
    :FOR    ${x}    IN RANGE     0     ${length}
    \   ${resp}    fusion_api_get_interconnect_ports      uri=${switchUris}     param=/${portid}:${ports[${x}]}
    \    Should be Equal    ${resp['portStatus']}     ${status}

Reboot Arista Switch
    [Documentation]    Reboots the arista switch
    ...             Example:
    ...             Reboot Arista Switch    ${Arista_switch_ip}   ${reboot_command}
    [Arguments]         ${Arista_switch_ip}   ${command}    ${SSH_USER}=admin
    SSHLibrary.Open Connection     ${Arista_switch_ip}     timeout=60s
    Set Suite variable  ${SSH_PASS}     password
    SSHLibrary.Login    ${switch_details['userName']}    ${switch_details['password']}
    sleep    5s
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    en
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${command}
    sleep    5s
    #SSHLibrary.Read Until    [confirm]
    SSHLibrary.Write    y

Verify Switch State
    [Documentation]    Verifying switch state
    ...             Example:
    ...             Verify Switch State    ${LSname}
    [Arguments]         ${LSname}    ${state}
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LSname}'"
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}    Get Length    ${switchUris}
    :FOR    ${x}    IN RANGE   0    ${length}
    \    ${resp}    Fusion Api Get Switch     uri=${switchUris[${x}]}
    \    Should Be Equal    ${resp['state']}     ${state}
    #\    Log to console and logfile    \n The switch state is ${resp['state']}

Verify Server Hardware Power State
    [Documentation]    Get ALL Appliance Server Hardware URI
    [Arguments]     ${DL_server_names}    ${state}
    ${resp} =   Fusion Api Get Server Hardware    param=?filter="'name'=='${DL_server_names}'"
    Should be Equal    ${resp['members'][0]['powerState']}     ${state}
    #Log to console and logfile    \n The server hardware power state is ${resp['members'][0]['powerState']}

Ping IP
    [Documentation]    Pinging the given server ip
    ...             Example:
    ...             Ping Server IP    ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    [Arguments]         ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    startthread    ${number}    ${server_ip}    ${name}    ${flag}
    Sleep    20
    ${contents1}=    OperatingSystem.Get File    ${name}
    [Return]     ${contents1}

Verify Ping Successful
    [Documentation]    Verifying if the server ping is successful by checking if loss is 0% and if it does not contain destination unreachable or Request timed out
    ...             Example:
    ...             Verify Server Ping Successful    ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    [Arguments]         ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    ${l} =  Get Length  ${server_ip}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    ${loss} =    Ping IP    ${number}    ${server_ip[${x}]}    ${name}    ${flag}    ${file_path}
    \    ${match}   ${ret1}    Should Match Regexp    ${loss}    Lost\\s+=\\s+\\d+\\s+\\((\\d+%)\\s+loss\\)
    \    Should Not Contain    ${loss}    ${time_out}
    \    Should Not Contain    ${loss}    ${Dest_unreachable}
    \    Run Keyword If    '${ret1}' == '0%'    Log to console and logfile    \n Pinging is successful    ELSE    Fail


Verify Ping Fails
    [Documentation]    Verifying if server ping fails by checking if the response does not contain TTL=
    ...             Example:
    ...             Verify Ping Fails    ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}
    [Arguments]         ${number}    ${server_ip}    ${name}    ${flag}    ${file_path}

    ${loss} =    Ping IP    ${number}    ${server_ip}    ${name}    ${flag}     ${file_path}
    Should Not Contain    ${loss}    TTL=

Build Edit Profile body
    [Documentation]   Editing the existing Server Profiles
    ...             Example:
    ...             Build Edit Profile body    ${profiles}
    [Arguments]     ${profiles}
    Log to console and logfile      Editing SERVER PROFILES

    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${profiles}
    ${connections} =  Get from Dictionary     ${resp['members'][0]['connectionSettings']}    connections
    ${profile_uri} =  Get from Dictionary     ${resp['members'][0]}    uri

    Set to Dictionary   ${server_profiles_edit_body}  name   ${resp['members'][0]['name']}
    Set to Dictionary   ${server_profiles_edit_body}  serverHardwareUri   ${resp['members'][0]['serverHardwareUri']}
    Set to Dictionary   ${server_profiles_edit_body}  eTag   ${resp['members'][0]['eTag']}
    Set to Dictionary   ${server_profiles_edit_body}  serverHardwareTypeUri   ${resp['members'][0]['serverHardwareTypeUri']}
    [Return]     ${profile_uri}

Edit Server Profile
    [Documentation]     Edit server profile
    ...             Example:
    ...             Edit Server Profile    ${edit_profile_body}     ${name}
    [Arguments]    ${edit_profile_body}    ${name}
    ${uri}    Get Profile Uri    ${name}
    ${etag}    Get Profile ETag    ${name}
    Set to dictionary   ${edit_profile_body}    eTag        ${etag}
    ${resp} =   Fusion Api Edit Server Profile   ${edit_profile_body}     uri=${uri}    param=?force=ignoreServerHealth
    ${task} =   Wait For Task   ${resp}     5 mins      10s
    Run Keyword If    ${task['status_code']}!=200 or '${task['taskState']}'!='Completed'     Fail    msg="Edit profile failed"
    [Return]     ${resp}

Validate Alert Message
    [Documentation]    Validating the 'Active' alert message with a variable which contains the expected alert message
    ...             Example:
    ...             Validate Alert Message    ${UPLINK_MSG}    ${varTrue}    ${Alert[0]}
    [Arguments]     ${msg}    ${flag}    ${Alerts}
    ${Response}    Fusion Api Get Alerts    /rest/alerts?filter="alertState EQ '${Alerts}'"
    ${Count}    Get From Dictionary    ${Response}    count
    Run Keyword If    '${Count}'=='0'    Fail    "Failed as alert message is not found"
    ${Members}    Get From Dictionary    ${Response}    members
    :FOR    ${Index}    IN RANGE    0    ${Count}
    \    ${Alert}        Get From List    ${Members}    ${Index}
    \    ${AlertDesc}    Get From Dictionary    ${Alert}    description
    \    ${AlertDesc1}    Get Lines containing string    ${AlertDesc}    ${msg}
    \    Exit for loop if    '${AlertDesc1}'!='${Empty}'
    run keyword if    '${flag}'=='True'   Should Contain     ${AlertDesc1}    ${msg}    ELSE   Should Not Contain     ${AlertDesc}    ${msg}

Get Profile Uri
    [Documentation]     Getting Server Profile URI
    ...             Example:
    ...             Get Profile Uri    ${name}
    [Arguments]    ${name}
    ${profiles} =   Fusion Api Get Server Profiles  param=?sort=name:ascending
    ${l} =  Get Length  ${profiles['members']}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   Run Keyword If  '${profiles['members'][${x}]['name']}' != '${name}'        Continue For Loop
    \   ${uri} =    Get From Dictionary     ${profiles['members'][${x}]}    uri
    [Return]    ${uri}

Get Profile ETag
    [Documentation]     Getting Server Profile Etag
    ...             Example:
    ...             Get Profile ETag    ${name}
    [Arguments]    ${name}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${name}
    ${eTag} =   Get From Dictionary     ${resp['members'][${x}]}    eTag
    [Return]    ${eTag}

Get Advanced Statistics
    [Documentation]    Verifying switch state
    ...             Example:
    ...             Get Advanced Statistics    ${switchUris}
    [Arguments]         ${switchUris}
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE     0     ${length}
    \   ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}    param=${Port_Name[${x}]}
    \   ${initial_ifInOctets}    Get from Dictionary    ${resp}    ifInOctets
    \   ${initial_ifOutOctets}    Get from Dictionary    ${resp}    ifOutOctets
    \   ${initial_ifInUcastPkts}    Get from Dictionary    ${resp}    ifInUcastPkts
    \   ${initial_fOutUcastPkts}    Get from Dictionary    ${resp}    ifOutUcastPkts
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifInOctets    ${initial_ifInOctets}
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifOutOctets    ${initial_ifOutOctets}
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifInUcastPkts    ${initial_ifInUcastPkts}
    \   Set to Dictionary    ${advanced_statistics[${x}]}    ifOutUcastPkts    ${initial_fOutUcastPkts}
    \    ${resp}    Fusion Api Get Interconnect Port Statistics     uri=${switchUris[${x}]}
    \    ${uplink_resp}    Get Port Data From Port Name    ${resp}    ${uplink_stacking_port}
    \   ${initial_ifInOctets}    Get from Dictionary    ${uplink_resp}    ifInOctets
    \   ${initial_ifOutOctets}    Get from Dictionary    ${uplink_resp}    ifOutOctets
    \   ${initial_ifInUcastPkts}    Get from Dictionary    ${uplink_resp}    ifInUcastPkts
    \   ${initial_fOutUcastPkts}    Get from Dictionary    ${uplink_resp}    ifOutUcastPkts
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifInOctets    ${initial_ifInOctets}
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifOutOctets    ${initial_ifOutOctets}
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifInUcastPkts    ${initial_ifInUcastPkts}
    \   Set to Dictionary    ${advanced_statistics_uplink[${x}]}    ifOutUcastPkts    ${initial_fOutUcastPkts}

Match vlanid of switch and profile
    [Documentation]    Compare the VlanID obtained from switch with that of the profiles
    [Arguments]    ${switch_ip}    ${interface}    ${sp_vlans}
    ${switch_vlans}    Fetch VlanId from switches for profiles    ${switch_ip}    ${interface}
    List Should Contain Value    ${sp_vlans}    ${switch_vlans}

Get Port Data From Port Name
    [Documentation]    Get port data
    [Arguments]        ${data}    ${portName}
    ${ports} =  Get From Dictionary     ${data}    genericPortStatistics
    ${l} =     Get Length    ${ports}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${port} =     Get From List   ${ports}    ${x}
    \     Exit For Loop If     '${port['portName']}' == '${portName}'
    [Return]    ${port}

Get switch details
    [Documentation]    Get switch data
    [Arguments]        ${x}
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${LS1}'"
    ${Switch_validate_list}     Create List
    ${ipAddress}=    Get From Dictionary    ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    ipAddress
    Append to List    ${Switch_validate_list}     ${ipAddress}
    ${vpcRole}=    Get From Dictionary  ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}  vpcRole
    Append to List    ${Switch_validate_list}     ${vpcRole}
    ${memberId}=    Get From Dictionary ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}  memberId
    Append to List    ${Switch_validate_list}     ${memberId}
    ${fw_version}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    firmwareVersion
    Append to List    ${Switch_validate_list}     ${fw_version}
    ${state}=    Get From Dictionary    ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    state
    Append to List    ${Switch_validate_list}     ${state}
    [Return]     ${Switch_validate_list}

Verify Output
    [Documentation]    Get switch data and verify the data
    [Arguments]    ${ip}    ${port_details}    ${port_uri}    ${port_id}    ${port_no}    ${Enable}
    ${Response}=     fusion_api_edit_switch_ports    ${port_details}    ${port_uri}
    ${task}    Wait For Task    ${Response}
    sleep    120s
    ${status}=    Get Status    ${port_uri}/ports/${port_id}
    Verify Enable/Disable Port in Switch    ${ip}    ${Commands}    ${port_no}    ${Enable}
    #${server_resp}=    fusion_api_get_server_profiles
    #Check Alert Message    ${Enable}      ${Alert_switchport}

Verify Enable/Disable Port in Switch
    [Documentation]    Verify disable enable port status
    [Arguments]    ${ip}    ${Commands}    ${Port_No}    ${Enable}
    SSHLibrary.Open Connection    ${ip}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    Sleep    10s
    #${Output}=    SSHLibrary.Read Until    )#
    ${Output}=    SSHLibrary.Read
    Run Keyword If    '${Enable}' != '1'    Should Contain    ${Output}    ${Commands[4]}
    ...    ELSE    Should not Contain    ${Output}    ${Commands[4]}
    #Log to console and logfile    \n-Port status changed in switch.
    SSHLibrary.Close Connection

Get Status
    [Documentation]    Fetch the status of the resource
    [Arguments]    ${uri}
    ${resp} =    Fusion Api Get Resource    uri=${uri}
    ${status}=    Get from Dictionary    ${resp}    portStatus
    #[Return]   ${status}

Get Uri of Switch
    [Documentation]    Fetch the uri of the switch
    ${lss_name}=    Get From Dictionary    ${lss[0]['logicalSwitch']}    name
    ${resp} =   Fusion Api Get LS       param=?filter="'name'=='${lss_name}'"
    ${uris}=    Get From Dictionary ${resp['members'][0]}    switchUris
    [Return]    ${uris}

Verify Parameters
   [Documentation]  Validates data in a response body against expected values
   [Arguments]    ${resp}   @{Val_list}
    ${type}=    Get From Dictionary ${resp}    type
    Should Be Equal    ${type}    ${Val_list[0]}    values=true
    ${consistency_status}=    Get From Dictionary   ${resp['members'][0]}    consistencyStatus
    Should Be Equal    ${consistency_status}    ${Val_list[1]}    values=true
    ${domainId}=    Get From Dictionary ${resp['members'][0]['logicalSwitchDomainInfo']}    domainId
    Should Be Equal    ${domainId}    ${Val_list[2]}    values=true
    ${switchUris}    Get from Dictionary    ${resp['members'][0]}    switchUris
    ${length}     Get Length       ${switchUris}
    :FOR    ${x}    IN RANGE    0    2
    \    ${switchdetails} =     Fusion Api Get Switch       uri=${switchUris[${x}]}
    \    ${state}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    state
    \    Should Be Equal    ${state}    ${Val_list[5]}    values=true
    \    ${firmwareVersion}=    Get From Dictionary ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    firmwareVersion
    \    Should Be Equal    ${firmwareVersion}    ${Val_list[6]}    values=true
    \    ${model}=    Get From Dictionary   ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${x}]}    model
    \    Should Be Equal    ${model}    ${Val_list[7]}    values=true
    \    ${destPortUri}=    Get From Dictionary ${resp['members'][0]['switchStackingInfo'][0]['switchStackingElements'][${x}]}    destPortUri
    \    ${srcPortUri}=    Get From Dictionary  ${resp['members'][0]['switchStackingInfo'][0]['switchStackingElements'][${x}]}    srcPortUri

Ports For Loop
    [Documentation]    Fetch the port names
    [Arguments]    ${count}    ${resp}
    ${Port_number_list}=    Create List
    :FOR    ${x}    IN RANGE    0    ${count}
    \    ${speed}=    Get From Dictionary    ${resp['ports'][${x}]}    operationalSpeed
    \    ${portType}=    Get From Dictionary    ${resp['ports'][${x}]}    portType
    \    ${portStatus}=    Get From Dictionary    ${resp['ports'][${x}]}    portStatus
    \    ${portName}=    Get From Dictionary    ${resp['ports'][${x}]}    portName
    \    ${remotePortId}=    Run Keyword If    '${portStatus}' == 'Linked'    Get From Dictionary    ${resp['ports'][${x}]['neighbor']}    remotePortId
    \    ${servername}=    Run Keyword If    '${portStatus}' == 'Linked' and '${portType}'!='Uplink'    Get From Dictionary    ${resp['ports'][${x}]['neighbor']}    linkLabel
    \    ${remoteMgmtAddress}=    Run Keyword If    '${portStatus}' == 'Linked' and '${portType}'=='Uplink'    Get From Dictionary    ${resp['ports'][${x}]['neighbor']}    remoteMgmtAddress
    \    ...    ELSE IF    '${portStatus}' == 'Linked' and '${portType}'!='Uplink'    Log to console and logfile    \nConnected To:${remotePortId}${servername}
    \    ...    ELSE    Log to console and logfile    \nPort${x} is unlinked no connected to information
    \    ${Port_number}=    Run Keyword If    '${portStatus}' == 'Linked'    Get From Dictionary    ${resp['ports'][${x}]}    portName
    \    Append to List    ${Port_number_list}    ${Port_number}
    [Return]    ${Port_number_list}

Enable/Disable VlanID in Switch
    [Documentation]    Enable disable vlan ID in switch
    [Arguments]    ${ip}    ${Commands}    ${Port_No}    ${Vlan_Id}    ${Enable}
    SSHLibrary.Open Connection    ${ip}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    Run Keyword If    '${Enable}' == '1'    Run Keywords
    ...    SSHLibrary.Write    ${Commands[8]} 2-4093
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]})#
    ...    AND    SSHLibrary.Write    ${Commands[5]} ${Vlan_Id}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-${Commands[5]}-${Vlan_Id})#
    ...    AND    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    ...    AND    SSHLibrary.Write    ${Commands[6]}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    ...    AND    SSHLibrary.Write    ${Commands[7]} ${Vlan_Id}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    ...    ELSE   Run Keywords
    ...    SSHLibrary.Write    ${Commands[8]} ${Vlan_Id}
    ...    AND    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[9]}
    ${Output}=    SSHLibrary.Read Until    )#
    SSHLibrary.Close Connection
    ${Line1}    Get Lines Containing String    ${Output}    VLAN${Vlan_Id_Format}
    ${New_Line1}    Run Keyword If    '${Enable}' == '1'    Remove String    ${Line1}    ,
    ${List1}    Run Keyword If    '${Enable}' == '1'    Split String    ${New_Line1}
    Run Keyword If    '${Enable}' == '1'    List Should Contain Value   ${List1}    Et${Port_No}    ELSE    Should Be Empty    ${Line1}

Get VlanID
    [Documentation]    Fetch the vlan ID
    [Arguments]    ${uri}
    ${resp} =    Fusion Api Get Resource    uri=${uri}
    ${vlan}=    Get from Dictionary    ${resp}    vlans
    ${remote_conn}=    Get from Dictionary    ${resp}    neighbor
    [Return]    ${vlan}    ${remote_conn}

##### server hardware ######

Verify Adapter name
    [Documentation]    Verify the adapter name of server
    [Arguments]    ${servermodel}    ${server_adapter}
    ${len}    Get Length    ${server_models}
    :For    ${x}    In Range    0    ${len}
    \    Run Keyword If    '${servermodel}' == '${server_models[${x}]}'    Should Be Equal As Strings    ${server_adapter}    ${adapter_models[${x}]}

Verify ILO names with Switch list
    [Documentation]    Compare names of each ILO with switch data
    [Arguments]    ${switch_list}    ${ilo_names}
    :For    ${name}    IN    @{ilo_names}
    \    List Should Contain Value    ${switch_list}    ${name}    message=switch doesnt contain data

Verify ILO names absent with Switch list
    [Documentation]    Compare names of each ILO with switch data
    [Arguments]    ${switch_list}    ${ilo_names}
    :For    ${name}    IN    @{ilo_names}
    \    List Should Not Contain Value    ${switch_list}    ${name}    message=switch Contains

Verify SH Switch Data Empty
    [Documentation]    Verify the Switch data in Server Hardware Page is null
    [Arguments]    ${ports_info}
    #log to console    \n ports data :${ports_info}
    :For    ${port}    IN    @{ports_info}
    \    Run Keyword If    ${port['physical_switch_uri']} != None    Fail    message="Switch uri should be empty"

Fetch ILO Names From Switches
    [Documentation]    Fetch the ILO names in each downlink port of the switch
    [Arguments]    ${switch}
    ${ilo_list}    Create List
    ${resp}    Fusion Api Get Switch    param=?filter=name=${switch}
    ${ports}    Get Variable Value    ${resp['members'][0]['ports']}
    :For    ${port}    IN    @{ports}
    \    ${linkLabel}    Run Keyword If    '${port['portStatus']}' != 'Unlinked'    Get Variable Value    ${port['neighbor']['linkLabel']}
    \    Append To List    ${ilo_list}    ${linkLabel}
    [Return]    ${ilo_list}

Match Hardware and Hardware Type
    [Documentation]    Validating the hardware and hardware type
    [Arguments]    ${Hardware_Type}
    ${model_list}    Create List
    ${uri_list}    Create List
    @{id} =     Split String    ${Hardware_Type}
    ${server_type_no} =    Get From List   ${id}   0
    ${server_type}=    Get From List   ${id}   1
    ${resp} =   Fusion Api Get Server Hardware
    ${memcount}    Get Length    ${resp['members']}
    :FOR    ${x}    IN RANGE    0    ${memcount}
    \    ${model} =     Get From Dictionary    ${resp['members'][${x}]}    model
    \    Append to List    ${model_list}    ${model}
    \    ${state} =     Get From Dictionary    ${resp['members'][${x}]}    state
    \    ${uri}    Run Keyword If    '${state}' != 'ProfileApplied'    Get From Dictionary    ${resp['members'][${x}]}    uri
    \    Append to List    ${uri_list}    ${uri}
    :FOR    ${sh}   IN RANGE    0    ${memcount}
    \     @{id} =     Split String    ${model_list[${sh}]}
    \    ${serverhardware_type_no} =    Get From List   ${id}   1
    \    ${serverhardware_type}=    Get From List   ${id}   2
    \    ${uri}    Run Keyword If    '${server_type_no}' == '${serverhardware_type_no}' and '${server_type}' == '${serverhardware_type}'    Get from List    ${uri_list}    ${sh}
    \    Exit For Loop If   '${uri}' != 'None'
    :FOR    ${x}    IN RANGE    0    ${memcount}
    \    ${name} =  Run Keyword If    '${resp['members'][${x}]['uri']}' == '${uri}'    Get From Dictionary    ${resp['members'][${x}]}    name
    \    Exit For Loop If   '${name}' != 'None'
    [Return]    ${uri}    ${name}

Get Server Profile Template URI
    [Documentation]    Get Server Profile Template URI
    [Arguments]     ${sp_temp}
    ${resp} =    fusion_api_get_server_profile_templates    param=?filter="'name'=='${sp_temp}'"
    ${uri} =    Get From dictionary    ${resp['members'][0]}    uri
    [Return]    ${uri}

Networks For Loop
    [Documentation]    create profile with network list
    [Arguments]    ${profile1}
    ${resp}    fusion_api_get_ethernet_networks
    ${nwlist} =     Get From Dictionary    ${resp}    members
    :FOR    ${x}    IN RANGE    0    2
    \  ${network_uri}=    Get From Dictionary    ${nwlist[${x}]}    uri
    \  Set to dictionary    ${profile1['connectionSettings']['connections'][0]}    networkUri    ${network_uri}
    \  ${resp} =   Fusion Api Create Server Profile        body=${profile1}     param=?force=ignoreServerHealth
    \  ${task} =   Wait For Task   ${resp}     timeout=13 mins     interval=10s
    \  Validate Response    ${task}    ${Valdict_profile}

Create Profile from Template
    [Documentation]    Get Server Profile from server template
    [Arguments]     ${profile_from_temp}    ${power}
    ${HCount}    Get Length    ${Hardware_Type}
    :FOR    ${x}    IN RANGE    0    ${HCount}
    \    ${profile1} =    Copy Dictionary     ${profile_from_temp}
    \    ${uri}    ${name}    Match Hardware and Hardware Type    ${Hardware_Type[${x}]}
    \    Run Keyword If    '${power}' == '1'    Power on server    ${name}
    \    Set to Dictionary   ${profile1}  serverHardwareUri   ${uri}
    \    ${uri} =   Get Server Hardware Type URI        ${Hardware_Type[${x}]}
    \    Set to Dictionary  ${profile1} serverHardwareTypeUri   ${uri}
    \    Run Keyword If    '${power}' == '0'    Set to Dictionary   ${profile1}    name    ${name}_Profile    ELSE    Set to Dictionary ${profile1}    name    ${name}_Profile_poweron
    \    ${uri} =    Get Server Profile Template URI     ${Hardware_Type[${x}]}_Profile
    \    Set to Dictionary   ${profile1}  serverProfileTemplateUri    ${uri}
    \    ${profile1} =    Update connections in profile    ${profile1}
    \    ${resp} =   Fusion Api Create Server Profile        body=${profile1}    param=?force=ignoreServerHealth
    \    ${task} =   Wait For Task   ${resp}     timeout=13 mins     interval=10s
    \    ${task_state} =     Get From dictionary     ${task}     taskState
    \    Run Keyword If    '${power}' == '0'    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)    ELSE    Should Match Regexp    ${task_state}   ((?i)Error)
    \    Run Keyword If    '${power}' == '1'    Should Match    ${task['taskErrors'][0]['errorCode']}    SERVER_NOT_OFF

Profile Creation with networkset
    [Documentation]    Creating server profile with networkset
    [Arguments]    ${server}    ${nativeuri}=${NONE}
    :FOR   ${x}   IN RANGE    0    2
    \    Create Network Sets    ${Network_sets[0]}    0    ${nativeuri}
    \    ${temp}     Copy Dictionary    ${server_profile_nwset}
    \    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${server}
    \    Set to Dictionary    ${temp[0]}    name    ${server}:Profile
    \    ${task}    Add DL Server Profiles from variable     ${temp}
    \    ${task_state} =     Get From dictionary     ${task}     taskState
    \    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)
    \    ${alert}    Fusion Api Delete Alert
    \    Wait For Task    ${alert}    200s    10s
    \    ${nsetresp}    Fusion Api Get Network Set
    \    ${nsetname}    Get Variable Value    ${nsetresp['members'][0]['name']}
    \    ${resp}    Fusion Api Delete Network Set    ${nsetname}
    \    ${task} =    Wait For Task    ${resp}    240s    2s}
   #\    Run Keyword If    '${task['status_code']}' == '200'    Log to console and logfile    \n-Successfully deleted network set.    ELSE    Fail
    \    Check Alert Message    0     ${Alert_Nset_delete}
    \    Remove All Server Profiles
    \    ${nativeuri}=    Set Variable    ${NONE}

Check Alert Message
    [Documentation]    Verify the alert messages
    [Arguments]    ${Enable}    ${Alert_Messages}
    ${alert_resp}    fusion_api_get_alerts    /rest/alerts?filter="alertState EQ 'Active'"
    ${Count}    Get From Dictionary    ${alert_resp}    count
    Run Keyword If    '${Count}'=='0'    Fail    "Failed as alert message is not found"
    ${Members}=    Get From Dictionary    ${alert_resp}    members
    :FOR    ${Index}    IN RANGE    0    ${Count}
    \    ${Alert}        Get From List    ${Members}    ${Index}
    \    ${AlertDesc}    Get From Dictionary    ${Alert}    description
    \    ${Value}    ${Count_Input}    Check Alert Message Inner    ${AlertDesc}     ${Alert_Messages}
    \    ${IncValue}    Set Variable If    '${Value}' == '1'     ${IncValue + 1}    ${IncValue}
    Run Keyword If    '${Enable}' == '0'    Should be equal    ${Count_Input}    ${IncValue}       ELSE    Should Be Equal As Integers    ${IncValue}    0

Check Alert Message Inner
    [Documentation]    Check the alert messages
    [Arguments]    ${Alert}     ${Alert_Messages}
    ${Count_Input}=    Get Length    ${Alert_Messages}
    :FOR    ${Index}    IN RANGE    0    ${Count_Input}
    \    ${AlertDesc1}    Get Lines containing string    ${Alert}    ${Alert_Messages[${Index}]}
    \    ${Value}=     Set Variable If     '${AlertDesc1}'!='${Empty}'     1    ${Value}
    [Return]    ${Value}    ${Count_Input}

Profile Edit with networkset
    [Documentation]    Editing the server profile with networkset
    [Arguments]    ${server}    ${tempin}
    ${networkset}    Fusion Api Get Network Set    param=?filter=name=${Edit_nset}
    ${netseturi}    Get Variable Value    ${networkset['members'][0]['uri']}
    ${resp}    Fusion Api Get Server Profiles    param=?filter=name=${server}Profile
    ${sp_uri}    Get Variable Value    ${resp['members'][0]['uri']}
    Set to Dictionary    ${tempin[0]['connectionSettings']['connections'][0]}    networkUri    ${netseturi}
    Set to Dictionary    ${tempin[0]}    eTag    ${resp['members'][0]['eTag']}
    Set to Dictionary    ${tempin[0]}    name    ${resp['members'][0]['name']}
    Set to Dictionary    ${tempin[0]}    serverHardwareTypeUri    ${resp['members'][0]['serverHardwareTypeUri']}
    Set to Dictionary    ${tempin[0]}    serverHardwareUri    ${resp['members'][0]['serverHardwareUri']}
    ${resp} =   Fusion Api Edit Server Profile    uri=${sp_uri}     body=${tempin[0]}
    ${task}    fusion_api_appliance_setup.Wait For Task    ${resp}
    ${task_state} =     Get From dictionary     ${task}     taskState
    Should Match    ${task_state}   Completed

Verify Traffic
    [Documentation]    Verify traffic
    [Arguments]    ${servername}    ${No_of_connections}    ${server_to_server_yes}=0
    ${server_name}    ${ip}    Get Server Hardware OS type and ILO IP    ${servername}
    ${splitstring}    Set Variable    ${server_name[0:2]}
    ${Server_profiles_valid_ips}     Create List
    ${Server_profiles_valid_ips}    Run keyword If    '${splitstring}'== 'WS'  Get Windows Server IP   ${win_server_details}  ${ip}
    ...   ELSE IF    '${splitstring}'== 'rh'  Get Redhat IP    ${redhat_ip}
    ...   ELSE    Get ESXI IP
    #Log to console and logfile    \n\n The IPs:${Server_profiles_valid_ips}
    Run Keyword If     '${Server_profiles_valid_ips[0]}' != 'NO_IP'   Run Keywords
    ...     Run Keyword If    '${server_to_server_yes}' == '1'    Append to List     ${IPList}     ${Server_profiles_valid_ips[0]}    AND
    ...     PingUD     ${Server_profiles_valid_ips}      ${No_of_connections}

PingUD
    [Documentation]    Server to server ping
    [Arguments]    ${validips}    ${No_of_connections}
    ${ip_count}    Get Length    ${validips}
    Run keyword If    '${ip_count}' == '${No_of_connections}'    Log to console and logfile    \nSuccessfully obtained Valid number of IPs    ELSE     Fail
    :FOR     ${x}   IN RANGE    0     ${No_of_connections}
    \  Ping Downlink from Uplink    ${validips[${x}]}

Server to server ping old
    [Documentation]    Server to server ping
    [Arguments]      ${server_iplist}
    ${ilo_count}    Get Length    ${ilo_details}
    :FOR     ${ipad}    IN RANGE    0     ${ilo_count}
    \    Open Connection    ${ilo_details[${x}]['ip']}     timeout=20s
    \    Log to console  \nSuccessfully opened connection to the server
    \    sleep    10sec
    \    Login    ${ilo_details[${x}]['username']}     ${ilo_details[${x}['password']}
    \    Ping all servers from one host    ${server_iplist}

Ping all servers from one host
    [Documentation]    Server to server ping
    [Arguments]      ${server_iplist}
    ${ip1_count}    Get Length    ${server_iplist}
    :FOR     ${ipad}    IN RANGE    0     ${ip1_count}
    \    SSHLibrary.Write    ping ${server_iplist[${ipad}]}
    \    Sleep    15s
    \    ${Output}=    SSHLibrary.Read
    \    Close Connection
    \    Close All Connections
    \    ${Output1}    Get Regexp Matches    ${Output}    Lost = \\d
    \    ${data_loss}    Get Variable Value    ${Output1[0]}
    \    Run Keyword If    '${data_loss}' == '0'    Log to console and logfile    \n Ping succeeds  !!!
    \    ...     ELSE     FAIL

Profile with same vlan
    [Documentation]    Server profile with same vlan
    [Arguments]    ${server}
    ${temp}     Copy Dictionary    ${server_profile_samevlan}
    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${server}
    Set to Dictionary    ${temp[0]}    name    ${server}Profile
    ${task}    Add DL Server Profiles from variable    ${temp}
    ${task_state} =     Get From dictionary     ${task}     taskState
    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)

Terminate Ping
    [Documentation]    Terminate Ping
    ${result1}    Run    taskkill /f /im ping.exe


Change VlanID in Switch
    [Documentation]    changing vlan ID in switch
    [Arguments]    ${Arista_login_details}    ${Commands}    ${Port_No}    ${Vlan_Id}
    SSHLibrary.Open Connection    ${Arista_login_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_login_details['userName']}    ${Arista_login_details['password']}
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[11]} ${Vlan_Id}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[12]} ${Vlan_Id}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[13]}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    Sleep    10sec
    #${Output}=    SSHLibrary.Read Until    )#
    ${Output}=    SSHLibrary.Read
    Should Contain    ${Output}   ${Commands[11]} ${Vlan_Id}
    SSHLibrary.Close Connection

verification of vlans_switch after LS_Refresh in OV
    [Documentation]    Verification of vlans in switch after refresh
    [Arguments]    ${Arista_login_details}    ${Commands}    ${Port_No}    ${Original_Vlan_Id}
    SSHLibrary.Open Connection    ${Arista_login_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_login_details['userName']}    ${Arista_login_details['password']}
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    sleep    10sec
    #${Output}=    SSHLibrary.Read Until    )#
    ${Output}=    SSHLibrary.Read
    Should Contain    ${Output}   ${Commands[11]} ${Original_Vlan_Id}
    SSHLibrary.Close Connection

Create VNetworks for Profiles
    [Documentation]    Create 6 networks with Vlans 10 20 30 40 50 60
    ${temp}    Copy Dictionary    ${Network_body}
    :For    ${vlan}    IN RANGE    2    164
    \    Set To Dictionary    ${temp}    vlanId    ${vlan}
    \    Set To Dictionary    ${temp}    name    Network_${vlan}
    \    ${nw}    Fusion Api Create Ethernet Network    ${temp}
    \    Run Keyword If   '${nw['status_code']}' == '202'    Log to console    \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    \    ...    ELSE    FAIL
    \    ${task}    fusion_api_appliance_setup.Wait For Task    ${nw}    60 s    10 s

Create MaxNetwork Sets
    [Documentation]    Create Network Sets
    [Arguments]    ${name}    ${Negative}=0
    ${nw_uri_list}    Create List
    ${temp}    Copy Dictionary    ${Network_set_body}
    ${network}    Fusion Api Get Ethernet Networks
    ${Count}   Get Length     ${network['members']}
    :For    ${x}    IN RANGE    0    ${Count}
    \    ${uri}    Get Variable Value    ${network['members'][${x}]['uri']}
    \    Append To List    ${nw_uri_list}    ${uri}
    Set To Dictionary    ${temp}    networkUris    ${nw_uri_list}
    Set To Dictionary    ${temp}    name    ${name}
    ${resp}    Fusion Api Create Network Set    ${temp}
    Run Keyword If    '${Negative}' == '0'    Run Keywords
    ...    Should be equal as strings    ${resp['status_code']}    202   AND
    ...    Wait For Task And Validate Response    ${resp}    ${valDict}    180 s    10 s    True
    ...    ELSE    Log to console    \nNegative test
    [Return]    ${resp}

Profile max networkset
    [Documentation]    Profile creation with maximum networkset
    [Arguments]    ${server}    ${nativeuri}=${NONE}
    ${temp}     Copy Dictionary    ${server_profile_maxvlan}
    Set to Dictionary    ${temp[0]}    serverHardwareUri    ${server}
    Set to Dictionary    ${temp[0]}    name    ${server}Profile
    :FOR    ${x}   IN RANGE     0    2
    \   ${switch_ip}    Get from Dictionary    ${Arista_login_details[${x}]}    ip
    \   Set VlanID in Switch    ${switch_ip}    ${Commands}    ${Vlan_range}
    sleep    60s
    ${task}    Add DL Server Profiles from variable    ${temp}
    ${task_state} =     Get From dictionary     ${task}     taskState
    Should Match Regexp    ${task_state}   ((?i)Warning|Completed)
    ${Output}    fusion_api_get_server_profiles    param=?filter="'name'=='${server}Profile'"
    :FOR    ${x}   IN RANGE     0    2
    \   ${Profileport}=    Get from Dictionary    ${Output['members'][0]['connectionSettings']['connections'][${x}]}    interconnectPort
    \   ${Profileporturi}=    Get from Dictionary    ${Output['members'][0]['connectionSettings']['connections'][${x}]}    interconnectUri
    \   ${ipAddress}    Get IP Address    ${Profileporturi}
    \   ${temp}    Copy Dictionary    ${Arista_switch_details}
    \   Set to Dictionary    ${temp}    ip    ${ipAddress}
    \   ${vlan_range}     verify vlan in Switch    ${temp}    ${Commands}    ${Profileport}
    \   Run Keyword If  '${vlan_range}' == '2-163'    Log to console  \nSuccessfully verified vlan
    \   ...    ELSE    FAIL

Negative Test
    [Documentation]    Networkset negative creation
    ${temp}    Copy Dictionary    ${Network_body}
    Set To Dictionary    ${temp}    vlanId    164
    Set To Dictionary    ${temp}    name    Network_164
    ${nw}    Fusion Api Create Ethernet Network    ${temp}
    Run Keyword If   '${nw['status_code']}' == '202'    Log to console  \nStatus Code: ${nw['status_code']} \nSuccessfully!! Created Ethernet Network\n
    ...    ELSE    FAIL
    ${resp}    Create MaxNetwork Sets     Net_Set2    1
    Run Keyword If    '${resp['status_code']}' == '400' and '${resp['errorCode']}' == '${Nset_Max_Error_Message}'    Log to console    \nSuccessfully verified Max Ethernet Network in Network set\n    ELSE    Fail

verify vlan in Switch
    [Documentation]    verifying vlan in switch
    [Arguments]    ${Arista_switch_details}    ${Commands}    ${Uplink_Port_No}
    SSHLibrary.Open Connection    ${Arista_switch_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    localhost>
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Uplink_Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Uplink_Port_No})#
    SSHLibrary.Write    ${Commands[10]}
    ${Output}=    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Uplink_Port_No})#
    SSHLibrary.Close Connection
    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan (\\d.*)
    ${value}    Convert To String    ${vlan}
    [Return]    ${value}

Restore From Backup
    [Documentation]    Restoring from backup
    ${status}=  Set Variable    ${EMPTY}
    ${Response}     Fusion Api Get Backup
    Run keyword unless  ${Response['status_code']}== 200    Fail    "Unable to Get the latest backup"
    ${restore_body}     Create Dictionary   type=RESTORE
    ...                                     uriOfBackupToRestore=${Response['members'][0]['uri']}
    ${output}       Fusion Api Restore Backup       ${restore_body}
    Sleep   200sec
    Run keyword unless  ${output['status_code']}== 202  Fail    "Unable to perform the restore from backup operation"
    ${restore_resp}     Fusion API Get Restore Status
    Run keyword unless  ${restore_resp['status_code']}== 200    Fail    "Unable to get the restore details"
    :FOR    ${index}    IN RANGE    ${restore_resp['count']}
    \   Run Keyword If  '${restore_resp['members'][${index}]['backupIdToRestore']}' != '${Response['members'][0]['id']}'        Continue For Loop
    \   ${restore_id} =    Set Variable    ${restore_resp['members'][${index}]['id']}
    Log to console and logfile      "Restoring is in Progress..\n
    :FOR    ${index}    IN RANGE    50
    \   sleep   60sec
    \   ${resp}     Fusion API Get Restore Status   ${restore_id}
    \   Run keyword unless  ${resp['status_code']}== 200    Fail    "Unable to get the restore id details"
    \   Run Keyword If  '${resp['restorePhase']}' != 'COMPLETED'    Continue For Loop
    \   ${status} =    Set Variable    ${resp['status']}
    \   Run Keyword If  '${resp['restorePhase']}' == 'COMPLETED'    Exit For Loop
    Should Be Equal    ${status}    SUCCEEDED
    Sleep    30
    Fusion Api Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}

Set VlanID in Switch
    [Documentation]    Setting vlan id in switch
    [Arguments]    ${ip}    ${Commands}    ${Vlan_Id}
    SSHLibrary.Open Connection    ${ip}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    sleep    7s
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[5]} ${Vlan_Id}
    SSHLibrary.Read Until    localhost(${Commands[1]}-${Commands[5]}-${Vlan_Id})#
    SSHLibrary.Close Connection

Get IP Address
    [Documentation]    Fetching Switch IP address
   [Arguments]     ${uri}
   ${temp}    Copy Dictionary    ${lss[0]}
   ${lss_name}=    Get From Dictionary    ${temp['logicalSwitch']}    name
   ${resp} =    Fusion Api Get LS       param=?filter="'name'=='${lss_name}'"
   ${uris}=    Get From Dictionary  ${resp['members'][0]}    switchUris
   #Log to console and logfile    \n${uris}
   ${Count_uri}    Get Length    ${uris}
   :FOR    ${Index}    IN RANGE    0    ${Count_uri}
   \    ${ipAddress}    Run Keyword If     '${uri}' == '${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${Index}]['uri']}'    Get From Dictionary    ${resp['members'][0]['logicalSwitchDomainInfo']['perSwitchDomain'][${Index}]}    ipAddress
   \    Exit For Loop If    '${ipAddress}' != 'None'
   [Return]    ${ipAddress}

Enable/Disable Port in Switch
    [Documentation]    Enabling disabling ports in switches
    [Arguments]    ${Arista_switch_details}    ${Commands}    ${Uplink_Port_No}    ${Enable}
    SSHLibrary.Open Connection    ${Arista_switch_details['ip']}    timeout=30s
    SSHLibrary.Login    ${Arista_switch_details['userName']}    ${Arista_switch_details['password']}
    #SSHLibrary.Read Until    >
    SSHLibrary.Write    ${Commands[0]}
    SSHLibrary.Read Until    localhost#
    SSHLibrary.Write    ${Commands[1]}
    SSHLibrary.Read Until    localhost(${Commands[1]})#
    SSHLibrary.Write    ${Commands[2]} ${Uplink_Port_No}
    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${Uplink_Port_No})#
    Run Keyword If    '${Enable}' == '1'    SSHLibrary.Write    ${Commands[3]}   ELSE    SSHLibrary.Write    ${Commands[4]}
    #Log to console and logfile    \n-Port status changed in switch.Waiting for a minute for the changes to reflect in One-View.
    sleep    60s
    SSHLibrary.Close Connection

Get Redhat IP
    [Documentation]    ssh login to Redhat DL 380 Server using eno4 interface to fetch IPs of eno5 & eno6
    [Arguments]    ${redhat_ip}    ${y}=5
    ${ips}    Create List
    SSHLibrary.Open Connection    ${redhat_ip}    timeout=30s
    SSHLibrary.Login    root    hpvse123
    #SSHLibrary.Read Until    #
    sleep    5s
    SSHLibrary.Write    ip addr
    sleep    5s
    ${Output}=    SSHLibrary.Read
    SSHLibrary.Close Connection
    ${lines}    ${no_of_matches}    get_matching_lines_with_number    ${Output}    scope global dynamic
    :FOR     ${x}   IN RANGE    0    ${no_of_matches}
    \   ${match1}    ${redhatip1}     Should Match Regexp    ${lines}    inet (192.\\d+.\\d+.\\d+)/\\d+.*eno${y}
    \   Append To List    ${ips}    ${redhatip1}
    \   ${y}    Evaluate     ${y} + 1
    [Return]    ${ips}

Server to server ping
    [Documentation]    Server to server ping
    [Arguments]      ${server_iplist}
    ${ip1_count}    Get Length    ${server_iplist}
    :FOR     ${ipad}    IN RANGE    0     ${ip1_count-1}
    \    ${Output}=    execute_commands    ${server_iplist[${ipad}]}    ${server_Auth_details}    ${server_iplist[${ipad+1}]}
    \    Should Match Regexp    ${Output}    (?i)TTL

Enable VlanID in switch
    [Documentation]    Login to switch and fetch active VlanID
    [Arguments]    ${switch_ip}    ${switch_details}    ${interface}    ${Commands}    ${vlan_enable}
    ${List1}    Create List
    ${length}    Get length    ${switch_ip}
    :FOR    ${x}     in range    0     ${length}
    \    Open Connection    ${switch_ip[${x}]}    timeout=30s
    \    Login    ${switch_details['userName']}    ${switch_details['password']}
    \    sleep    7s
    \    #SSHLibrary.Read Until    >
    \    SSHLibrary.Write    ${Commands[0]}
    \    SSHLibrary.Read Until    localhost#
    \    SSHLibrary.Write    ${Commands[1]}
    \    SSHLibrary.Read Until    localhost(${Commands[1]})#
    \    SSHLibrary.Write    ${Commands[2]} ${interface}
    \    SSHLibrary.Read Until    localhost(${Commands[1]}-if-Et${interface})#
    \    SSHLibrary.Write    ${enable_vlan[0]} ${vlan_enable[${x}]}
    \    sleep    3s
    \    SSHLibrary.Write    write
    \    sleep    8s
    \    SSHLibrary.Write    ${Commands[10]}
    \    sleep    5s
    \    ${Output}=    SSHLibrary.Read
    \    Close Connection
    \    ${lines}    Get Lines Containing String    ${Output}    ${pattern}
    \    ${match}    ${vlan}     Should Match Regexp    ${lines}    vlan (\\d.*)
    \    ${value}    Convert To String    ${vlan}
    \    Append to List     ${List1}     ${value}
    [Return]    ${List1}

Network Set Teaming
    [Documentation]    Function to Execute powershell script for Teaming on the servers
    [Arguments]    ${linux_details}    ${ilo_details}    ${module_file_path}     ${ps_cmd1}    ${server_details}    ${win_server_details}
    ${IP}=      get_server_ip_win      ${linux_details}    ${ilo_details}    ${module_file_path}
    ${str}    Convert To String    ${IP}
    ${valid_ip}    Get Regexp Matches    ${str}    192\\.\\d+\\.\\d+\\.\\d+
    ${Team}    execute_teaming    ${valid_ip[0]}    ${server_details[0]}    ${server_details[1]}    ${ps_cmd1}
    Sleep    30s
    ${ip_list_new}    Get Server Ip Windows    ${win_server_details}
    ${count}    Get Length    ${ip_list_new}
    [Return]    ${ip_list_new}    ${count}

Delete Network Set Teaming
    [Documentation]    Function to Execute powershell script for Delete Teaming on the servers
    [Arguments]    ${linux_details}    ${ilo_details}    ${module_file_path}     ${delete_team_cmd}
    ${IP}=      get_server_ip_win      ${linux_details}    ${ilo_details}    ${module_file_path}
    ${str}    Convert To String    ${IP}
    ${valid_ips}    Get Regexp Matches    ${str}    192\\.\\d+\\.\\d+\\.\\d+
    Telnet.Open Connection     ${valid_ips[0]}     prompt=>     timeout=20s
    Telnet.Write    a
    ${login}    Telnet.Login               ${win_server_telnet_details['username']}     ${win_server_telnet_details['password']}    login_prompt=login:    password_prompt=password:
    Sleep    10sec
    Telnet.Write    powershell
    Telnet.Write    ${delete_team_cmd}
    Sleep    30sec
    Telnet.Write    y
    Sleep    30sec
    ${stdout} =  Telnet.Read
    Telnet.Close Connection
    Telnet.Close All Connections
    Log to Console    \nteaming deleted

Verify Networkset Downlink Traffic from Uplink
    [Documentation]    Verify the Server IPs are pinging from Test Head
    [Arguments]    ${ip_list_new}    ${count}
    :For    ${x}    In Range    0    ${count}
    \    Ping Downlink from Uplink    ${ip_list_new[${x}]}

Get Server Ip Windows
    [Documentation]    Gets the valid ip of the server
    [Arguments]        ${win_server_details}
    ${serverip_List}=   Create List
    ${serverip_List1}=   Create List
    SSHLibrary.Open Connection     ${win_server_details['ip']}     prompt=>     timeout=20s
    SSHLibrary.Login    ${win_server_details['username']}    ${win_server_details['password']}
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Read Until    SAC>
    Sleep    5sec
    SSHLibrary.Write    i
    Sleep    5sec
    ${stdout}    SSHLibrary.Read
    ${cmd_output}=    Get Regexp Matches    ${stdout}    Ip=192\\.\\d+\\.\\d+\\.\\d+
    ${ip_list_new}    Create List
    ${len}    Get Length    ${cmd_output}
    :FOR    ${x}    IN RANGE    ${len}
    \    ${ip_lists}    Remove String    ${cmd_output[${x}]}    Ip=
    \    Log to console    ip is ${ip_lists}
    \    Append To List   ${ip_list_new}    ${ip_lists}
    SSHLibrary.Close All Connections
    [Return]    ${ip_list_new}

verify networkset traffic
    [Documentation]    Verifying networkset traffic
    [Arguments]    ${name_server}    ${pscommand_for_execution}     ${delete_ps_cmd}
    ${server_name}    ${ip}    Get Server Hardware OS type and ILO IP    ${name_server}
    ${temp}    Copy Dictionary    ${ilo_details[0]}
    ${temp1}    Copy Dictionary    ${win_ilo_details[0]}
    Set to Dictionary    ${temp}    ilo_ip    ${ip}
    Set to Dictionary    ${temp1}    ip    ${ip}
    ${splitstring}    Set Variable    ${server_name[0:2]}
    ${ip_list_new}    ${count}=    Run keyword If    '${splitstring}'== 'WS'    Network Set Teaming    ${linux_details}    ${temp}    ${module_file_path}     ${pscommand_for_execution}   ${server_details}    ${temp1}
    Run keyword If    '${splitstring}'== 'WS'    Run Keywords
    ...    Run Keyword Unless    ${count} == 3    Fail    msg=3 Valid IP's not obtained after Teaming    AND
    ...    Verify Networkset Downlink Traffic from Uplink    ${ip_list_new}    ${count}    AND
    ...    Delete Network Set Teaming    ${linux_details}    ${temp}    ${module_file_path}     ${delete_ps_cmd}

Get ESXI IP
    [Documentation]    Fetching ESXI IP
    ${list}    Create List
    Append to List    ${list}    NO_IP
   [Return]    ${list}

Edit Downlinkport and Verify
    [Documentation]    Editing and verifying downlink port
    [Arguments]    ${Outputin}
    :FOR    ${x}    IN RANGE    0    2
    \   ${downlink_Port_No}=    Get from Dictionary    ${Outputin['members'][0]['connectionSettings']['connections'][${x}]}    interconnectPort
    \   ${interconnecturi}=    Get from Dictionary    ${Outputin['members'][0]['connectionSettings']['connections'][${x}]}    interconnectUri
    \   ${resp}=    Fusion Api Get Switch    ${interconnecturi}
    \   ${name}    Get from dictionary    ${resp}    name
    \   @{id} =     Split String    ${interconnecturi}   /
    \   ${portId} =    Get From List   ${id}   3
    \   ${Port_modify}     catenate     ${portId}:${downlink_Port_No}
    \   Set to Dictionary    ${port_details[0]}    portId     ${portId}:${downlink_Port_No}
    \   Set to Dictionary    ${port_details[0]}    portName    ${downlink_Port_No}
    \   Set to Dictionary    ${port_details[0]}    enabled    false
    \   Verify Output    ${name}    ${port_details}    ${interconnecturi}    ${Port_modify}    ${downlink_Port_No}    0
    \   Set to Dictionary    ${port_details[0]}    enabled    true
    \   Verify Output    ${name}    ${port_details}    ${interconnecturi}    ${Port_modify}    ${downlink_Port_No}    1

verify Traffic from Downlink to Uplink for servers
    [Documentation]    Verify Sr=erver IP's are reachable from the Test Heads
    ${Server_profiles_valid_ips}    Create List
    :FOR   ${x}    IN RANGE    0   4
    \   ${server_name}    ${ip}    Get Server Hardware OS type and ILO IP    ${DL_server_names[${x}]}
    \   ${splitstring}    Set Variable    ${server_name[0:2]}
    \   ${output1}    Run keyword If    '${splitstring}'== 'WS'  Get Windows Server IP   ${win_server_details}  ${ip}
    \    ...   ELSE IF    '${splitstring}'== 'rh'  Get Redhat IP    ${redhat_ip}
    \    ...   ELSE    log to console and logfile    "We are not fetching for ESXI"
    \    Append To List    ${Server_profiles_valid_ips}    ${output1}

    ### Since ESXI return is NONE ###

    :For    ${x}    In Range    0    3
    \    Ping Downlink from Uplink    ${Server_profiles_valid_ips[${x}][0]}
    \    Ping Downlink from Uplink    ${Server_profiles_valid_ips[${x}][1]}
    [Return]     ${Server_profiles_valid_ips}
