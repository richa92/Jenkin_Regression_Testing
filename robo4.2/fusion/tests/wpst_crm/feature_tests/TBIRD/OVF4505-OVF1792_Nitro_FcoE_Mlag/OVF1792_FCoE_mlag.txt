**** Settings ****
# Usage: pybot -v APPLIANCE_IP:xx.xxx.xxx.xxx \
#  [-i <tags> ] feature_test_OVF2163.txt
Documentation       FCoE Mlag
Suite Setup         Run FTS and test-specific setup
Suite Teardown    Suite Teardown Tasks
Variables           data_variables.py
Resource            ../../../../../Resources/api/fusion_api_resource.txt
Library             FusionLibrary
Library             Collections
Library             json
Library             Dialogs
Library             validate.py
*** Variables ***
${SSH_PASS}                     hpvse1
@{ILO_IPS}
*** Test Cases ***
1_Should be able to Create 256 FCoE Networks (2-256)
    [Tags]   comware  POSITIVE  FCOE
    [Documentation]    Should be able to Create 256 FCoE Networks (2-256)
    Set Log Level    TRACE
    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Create Fcoe Range    ${fcoe_ranges['fcoe-range-256']}

2_Should not be able to Create FCoE Network >256
    [Tags]   comware  POSITIVE  FCOE_MAX
    [Documentation]    Should not be able to Create FCoE Network >256
    ${resp} =  Fusion Api Create Fcoe Network  body=${fcoe_networks['fcoe-258']}
    ${valDict} =   Create Dictionary  status_code=${400}
    ...                               errorCode=CRM_MAX_FCOE_NETWORKS_REACHED
    Validate Response    ${resp}  ${valDict}

3_Should be able to Create LIG without FCoE Mlag settings
    [Tags]   comware  create-lig-no-mlag  comware-demo
    [Documentation]    Should be able to Create LIG without FCoE Mlag settings
    ${body} =   Build Logical Interconnect Group body      ${ligs['${LIG1}']}
    ${resp} =   Fusion Api Create LIG   ${body}
    ${task} =   Wait For Task   ${resp}     60s 2s

4_Should be able to Create an LE/EG using both Comware and Cisco LIGs on an 2 Node ME
    [Tags]   comware  cc-me-lig  cc-me-lig-1
    [Documentation]    Should be able to Create an LE/EG using both Comware and Cisco LIGs on an 2 Node ME
    ${body} =  Build Logical Interconnect Group body        ${ligs['${BothLIG1}']}
    ${resp} =  Fusion Api Create LIG   ${body}
    ${task} =  Wait For Task  ${resp}       60s 5s

    Run Keyword for List    ${enc_groups_me}   Add Enclosure Group from variable
    Add Logical Enclosure from variable     ${les[1]}

5_Should be able to Create Comware LIG and EG
    [Tags]   comware  comware-lig  comware-lig-1
    [Documentation]    Should be able to Create Comware LIG and EG
    ${body} =  Build Logical Interconnect Group body        ${ligs['${CLIG1}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    ${task} =  Wait For Task  ${resp}    60s    5s

    Run Keyword for List    ${enc_groups}   Add Enclosure Group from variable

6_Should not be able to Create Comware LIG with greater than 32 FCoE Networks
    [Tags]   comware  comware-lig  comware-lig-33  comware-demo
    [Documentation]    Should not be able to Create Comware LIG with greater than 32 FCoE Networks
    ${body} =  Build Logical Interconnect Group body         ${ligs['${CLIG2}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    ${task} =  Wait for Task  ${resp}    60s    2s
    ${valDict} =   Create Dictionary  taskState=Error
    ...                               taskStatus=Too many FCoE networks have been specified for the uplink set.
    Validate Response    ${task}  ${valDict}

7_Should be able to Create Comware LIG with 32 FCoE Networks
    [Tags]   comware  comware-lig  comware-lig-32  comware-demo
    [Documentation]    Should be able to Create Comware LIG with 32 FCoE Networks
    ${body} =  Build Logical Interconnect Group body         ${ligs['${CLIG3}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    ${task} =  Wait for Task  ${resp}    60s    5s
    ${valDict} =   Create Dictionary  taskState=Completed
    Validate Response    ${task}  ${valDict}

8_Should not be able to Create Comware LIG with more than 16 uplink ports
    [Tags]   comware  comware-lig  comware-gt-16-ports  comware-demo
    [Documentation]    Should not be able to Create Comware LIG with more than 16 uplink ports
    ${body} =  Build Logical Interconnect Group body        ${ligs['${CLIG4}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    ${valDict} =   Create Dictionary  status_code=${400}
    ...                               errorCode=CRM_PORTS_EXCEED_MAX_PER_UPLINKSET
    Validate Response    ${resp}  ${valDict}

9_Should be able to add an fcoe network to a MLAG US
    [Tags]   comware  edit-mlag-us  add-fcoenet-mlag-us  modify-mlag-us
    [Documentation]    Should be able to add an fcoe network to a MLAG US
    ${li_uri} =           Get LI URI  ${LE2}-${BothLIG1}
    ${us} =               Copy Dictionary  ${li_uplink_sets['IBS3-Aside-add-fcoe-2']}
    ${body} =             Build uplinkset body    ${us}    ${li_uri}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${fcoenets} =         Get From Dictionary   ${resp['members'][0]}  fcoeNetworkUris
    ${start_fcoenets} =   Get Length  ${fcoenets}
    ${start_fcoenets} =   Evaluate  ${start_fcoenets} + 1
    ${uri} =              Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =             Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    ${task} =             Wait for Task  ${resp}       5 min  15s
    ${valDict} =          Create Dictionary   status_code=${200}
    ...                                       taskState=Completed
    Validate Response     ${task}  ${valDict}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${fcoenets} =         Get From Dictionary   ${resp['members'][0]}  fcoeNetworkUris
    ${end_fcoenets} =     Get Length  ${fcoenets}
    Should Be Equal As Integers  ${end_fcoenets}  ${start_fcoenets}
    Log to Console and Logfile     \n Edited uplinkset added fcoe network successfully

10_Should be able to remove an fcoe network from a MLAG US
    [Tags]   comware  edit-mlag-us  remove-fcoenet-mlag-us  modify-mlag-us
    [Documentation]    Should be able to remove an fcoe network from a MLAG US
    ${li_uri} =           Get LI URI  ${LE2}-${BothLIG1}
    ${us} =               Copy Dictionary  ${li_uplink_sets['IBS3-Aside-minus-fcoe-2']}
    ${body} =             Build uplinkset body  ${us}   ${li_uri}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${fcoenets} =         Get From Dictionary   ${resp['members'][0]}  fcoeNetworkUris
    ${start_fcoenets} =   Get Length  ${fcoenets}
    ${start_fcoenets} =   Evaluate  ${start_fcoenets} - 1
    ${uri} =              Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =             Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    ${task} =             Wait for Task  ${resp}       5 min  15s
    ${valDict} =          Create Dictionary   status_code=${200}
    ...                                       taskState=Completed
    Validate Response     ${task}  ${valDict}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${fcoenets} =         Get From Dictionary   ${resp['members'][0]}  fcoeNetworkUris
    ${end_fcoenets} =     Get Length  ${fcoenets}
    Should Be Equal As Integers  ${end_fcoenets}  ${start_fcoenets}
    Log to Console and Logfile     \n Edited uplinkset removed fcoe network successfully

11_Should be able to add a port to an MLAG US
    [Tags]   comware  edit-mlag-us  add-port-mlag-us  modify-mlag-us
    [Documentation]    Should be able to add a port to an MLAG US
    ${li_uri} =           Get LI URI  ${LE2}-${BothLIG1}
    ${us} =               Copy Dictionary  ${li_uplink_sets['IBS3-Aside-add-port']}
    ${body} =             Build uplinkset body    ${us}   ${li_uri}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${start_ports} =      Get From Dictionary   ${resp['members'][0]}  portConfigInfos
    ${start_port_num} =   Get Length  ${start_ports}
    ${start_port_num} =   Evaluate  ${start_port_num} + 2
    ${uri} =              Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =             Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    ${task} =             Wait for Task  ${resp}       5 min  15s
    ${valDict} =          Create Dictionary   status_code=${200}
    ...                                       taskState=Completed
    Validate Response     ${task}  ${valDict}

    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${ports} =            Get From Dictionary   ${resp['members'][0]}  portConfigInfos
    ${end_port_num} =     Get Length  ${ports}
    Should Be Equal As Integers  ${end_port_num}  ${start_port_num}
    Log    \n Edited uplinkset added port successfully    console=true

12_Should be able to remove a port from an MLAG US
    [Tags]   comware  edit-mlag-us  remove-port-mlag-us  modify-mlag-us
    [Documentation]    Should be able to remove a port from an MLAG US
    ${li_uri} =           Get LI URI  ${LE2}-${BothLIG1}
    ${us} =               Copy Dictionary  ${li_uplink_sets['IBS3-Aside-minus-port']}
    ${body} =             Build uplinkset body    ${us}   ${li_uri}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${start_ports} =      Get From Dictionary   ${resp['members'][0]}  portConfigInfos
    ${start_port_num} =   Get Length  ${start_ports}
    ${start_port_num} =   Evaluate  ${start_port_num} - 2
    ${uri} =              Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =             Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    ${task} =             Wait for Task  ${resp}       5 min  15s
    ${valDict} =          Create Dictionary   status_code=${200}
    ...                                       taskState=Completed
    Validate Response     ${task}  ${valDict}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${ports} =            Get From Dictionary   ${resp['members'][0]}  portConfigInfos
    ${end_port_num} =     Get Length  ${ports}
    Should Be Equal As Integers  ${end_port_num}  ${start_port_num}
    Log to Console and Logfile     \n Edited uplinkset removed port successfully

13_Should be able to create MLAG US
    [Tags]   comware    comware-us  create-us-2icm
    [Documentation]    Should be able to create MLAG US
    ${li_uri} =         Get LI URI  ${LE2}-${BothLIG1}
    ${us} =             Copy Dictionary  ${li_uplink_sets['us1-2icm']}
    ${body} =           Build uplinkset body    ${us}    ${li_uri}
    ${resp} =           Fusion Api Create Uplink Set   body=${body}
    ${task} =           Wait For Task   ${resp}    5 min  5s
    ${valDict} =        Create Dictionary  status_code=${200}
    ...                                    taskState=Completed
    Validate Response   ${task}  ${valDict}

14_Should be able to delete an MLAG US
    [Tags]   comware    comware-us  delete-us-2icm
    [Documentation]    Should be able to delete an MLAG US
    ${resp} =           Fusion Api Delete Uplink Set  name=us1-2icm
    ${task} =           Wait For Task   ${resp}    120s  5s
    ${valDict} =        Create Dictionary  status_code=${200}
    ...                                    taskState=Completed
    Validate Response   ${task}  ${valDict}

15_Should not be able to create MLAG US with only 1 ICM
    [Tags]   comware    comware-us  create-us-1icm
    [Documentation]    Should not be able to create MLAG US with only 1 ICM
    ${li_uri} =         Get LI URI  ${LE2}-${BothLIG1}
    ${us} =             Copy Dictionary  ${li_uplink_sets['us1-1icm']}
    ${body} =           Build uplinkset body    ${us}  ${li_uri}
    ${resp} =           Fusion Api Create Uplink Set   body=${body}
    ${valDict} =        Create Dictionary  status_code=${400}
    ...                                    errorCode=CRM_FCOE_MLAG_NETWORKS_NOT_ASSIGNED_TO_BAY
    Validate Response   ${resp}  ${valDict}

16_Should be able to perform an Update From Group on the LI
    [Tags]   comware    cleanup  cleanup-li  update-from-group
    [Documentation]    Should be able to perform an Update From Group on the LI
    ${li_uri} =         Get LI URI  ${LE2}-${BothLIG1}
    ${resp} =           Fusion Api Update From Group   uri=${li_uri}
    Run Keyword If      ${resp['status_code']} !=202    fail   Update from group
    ${task} =           Wait For Task   ${resp}     5 min      15 s
    ${valDict} =        Create Dictionary  status_code=${200}
    ...                                    taskState=Completed
    Validate Response   ${task}  ${valDict}

17_Should be able to create non-MLAG US
    [Tags]   comware    comware-us  create-us-nomlag
    [Documentation]    Should be able to create non-MLAG US
    ${li_uri} =         Get LI URI  ${LE2}-${BothLIG1}
    ${us} =             Copy Dictionary  ${li_uplink_sets['us3']}
    ${body} =           Build uplinkset body    ${us}  ${li_uri}
    ${resp} =           Fusion Api Create Uplink Set   body=${body}
    ${task} =           Wait For Task   ${resp}    5 min  5s
    ${valDict} =        Create Dictionary  status_code=${200}
    ...                                    taskState=Completed
    Validate Response   ${task}  ${valDict}

18_Should be able to Create Cisco LIG
    [Tags]   cisco  cisco-lig
    [Documentation]    Should be able to Create Cisco LIG
    ${body} =  Build Logical Interconnect Group body        ${ligs['${CiscoLIG2}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    ${task} =  Wait For Task  ${resp}    60s    2s

19_Should not be able to Create Cisco LIG with greater than 32 FCoE Networks
    [Tags]   cisco  cisco-lig-33
    [Documentation]    Should not be able to Create Cisco LIG with greater than 32 FCoE Networks
    ${body} =  Build Logical Interconnect Group body         ${ligs['${CLIG5}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    ${task} =  Wait for Task  ${resp}    60s    2s
    ${valDict} =   Create Dictionary  taskState=Error
    ...                               taskStatus=Too many FCoE networks have been specified for the uplink set.
    Validate Response    ${task}  ${valDict}

20_Edit LIG with 2enet,2fcoe networks with mlag disabled and do UFG
    [Tags]    20
    [Documentation]    Edit LIG with 2enet,2fcoe networks with mlag disabled and do UFG
    ${body}    Get From Dictionary    ${ligs}    LIG_FCOE_MLAG_DISABLED
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    Run Keyword If  '${resp[0]['status_code']}' == '202'    Wait For Task2    ${resp[0]}    10min    10    ELSE    Fail    Log    failed    console=True

    ${resp}     Get LIG member    ${BothLIG1}
    ${mode} =            Get From Dictionary   ${resp['uplinkSets'][0]}  fcoeMlagMode
    Should be Equal As Strings    ${mode}    None

    Update Logical Interconnect from Group    ${LI}
    ${resp} =    Fusion Api Get Uplink Set   param=?filter="'name'=='us1-comware'"
    ${mode} =    Get From Dictionary   ${resp['members'][0]}  fcoeMlagMode
    Should be Equal As Strings    ${mode}    None

21_Edit LIG with 2enet,2fcoe networks with mlag enbled(Interface + mac binding) and do UFG
    [Tags]    21
    [Documentation]    Edit LIG with 2enet,2fcoe networks with mlag enbled(Interface + mac binding) and do UFG
    ${body}    Get From Dictionary    ${ligs}    LIG_FCOE_MLAG
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    Run Keyword If  '${resp[0]['status_code']}' == '202'    Wait For Task2    ${resp[0]}    10min    10    ELSE    Fail    Log    failed    console=True

    ${resp}     Get LIG member    ${BothLIG1}
    ${mode} =            Get From Dictionary   ${resp['uplinkSets'][0]}  fcoeMlagMode
    Should be Equal As Strings    ${mode}    ${uplink_sets['us1-default']['fcoeMlagMode']}

    Update Logical Interconnect from Group    ${LI}
    ${resp} =    Fusion Api Get Uplink Set   param=?filter="'name'=='us1-comware'"
    ${mode} =    Get From Dictionary   ${resp['members'][0]}  fcoeMlagMode
    Should be Equal As Strings    ${mode}    ${li_uplink_sets['US_enable_mlag']['fcoeMlagMode']}

22_Edit LI upliksets and change FCOE pinned port and do UFG
    [Tags]   comware  edit-mlag-us  add-port-mlag-us  modify-mlag-us
    [Documentation]    Edit LI upliksets and change FCOE pinned port and do UFG
    ${li_uri} =    Get LI URI  ${LE2}-${BothLIG1}
    ${us} =    Copy Dictionary  ${li_uplink_sets['US_change_port']}
    ${body} =    Build uplinkset body    ${us}   ${li_uri}
    ${resp} =    Fusion Api Get Uplink Set   param=?filter="'name'=='us1-comware'"
    ${uri} =     Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =    Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    Wait For Task2    ${resp}    10min    10
    #UFG
    Update Logical Interconnect from Group    ${LI}

23_Edit LI uplikset to disable fcoe MLAG and do UFG
    [Tags]   comware  edit-mlag-us  add-port-mlag-us  modify-mlag-us
    [Documentation]    Edit LI uplikset to disable fcoe MLAG and do UFG
    ${li_uri} =           Get LI URI  ${LE2}-${BothLIG1}
    ${us} =               Copy Dictionary  ${li_uplink_sets['US_disable_mlag']}
    ${body} =             Build uplinkset body    ${us}   ${li_uri}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='us1-comware'"
    ${uri} =              Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =             Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    Wait For Task2    ${resp}    10min    10

    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='IBS3-Aside-Q6-40gb'"
    ${mode} =            Get From Dictionary   ${resp['members'][0]}  fcoeMlagMode
    Should be Equal As Strings    ${mode}    None
    #UFG
    Update Logical Interconnect from Group    ${LI}

24_Edit LI upliksets enable fcoe MLAG and do UFG
    [Tags]   comware  edit-mlag-us  add-port-mlag-us  modify-mlag-us
    [Documentation]    Edit LI upliksets enable fcoe MLAG and do UFG
    ${li_uri} =           Get LI URI  ${LE2}-${BothLIG1}
    ${us} =               Copy Dictionary  ${li_uplink_sets['US_enable_mlag']}
    ${body} =             Build uplinkset body    ${us}   ${li_uri}
    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='us1-comware'"
    ${uri} =              Get From Dictionary   ${resp['members'][0]}  uri
    ${resp} =             Fusion Api Edit Uplink Set  body=${body}   uri=${uri}
    Wait For Task2    ${resp}    10min    10

    ${resp} =             Fusion Api Get Uplink Set   param=?filter="'name'=='us1-comware'"
    ${mode} =            Get From Dictionary   ${resp['members'][0]}  fcoeMlagMode
    Should be Equal As Strings    ${mode}    ${li_uplink_sets['US_enable_mlag']['fcoeMlagMode']}

    #UFG
    Update Logical Interconnect from Group    ${LI}

25_Delete network from network page which is already present in MLAG uplinkset
    [Tags]    25
    [Documentation]    Delete network from network page which is already present in MLAG uplinkset
    ${len}    Get Length    ${fcoe_networks1}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${resp}    Fusion Api Delete FCoE Network     ${fcoe_networks1[${x}][0]['name']}
    \    ${valDict}    Create Dictionary    status_code=${400}
    \    ...                                errorCode=CRM_FCOE_NETWORK_MLAG_IN_USE
    \    Validate Response    ${resp}  ${valDict}

26_FCOE_Network_Limit_Scenarios
    [Tags]    26
    [Documentation]    FCOE_Network_Limit_Scenarios
    ${body} =  Build Logical Interconnect Group body         ${ligs['${FCOE_limit}']}

    ${resp} =  Fusion Api Create LIG   ${body}
    Wait for Task2  ${resp}    10min    2

    #Edit uplink set to change one network from bay3 to bay6

    ${body}    Get From Dictionary    ${ligs}    LIG_neg1
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    ${valDict}    Create Dictionary    status_code=${400}
    ...                                 errorCode=CRM_EXCEEDS_MAX_ALLOWED_FCOE_NETWORKS_PER_BAY
    ...                                 message=The interconnect in bay 6 has exceeded the maximum number of allowed FCoE networks.
    Validate Response    ${resp[0]}  ${valDict}

    #Edit uplink set to change one network from bay6 to bay3

    ${body}    Get From Dictionary    ${ligs}    LIG_neg2
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    ${valDict}    Create Dictionary    status_code=${400}
    ...                                 errorCode=CRM_EXCEEDS_MAX_ALLOWED_FCOE_NETWORKS_PER_BAY
    ...                                 message=The interconnect in bay 3 has exceeded the maximum number of allowed FCoE networks.
    Validate Response    ${resp[0]}  ${valDict}

    #Add one uplink set with MLAG disabled,  one FCoE network, one port from bay3
    ${body}    Get From Dictionary    ${ligs}    LIG_neg3
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    ${valDict}    Create Dictionary    status_code=${400}
    ...                                 errorCode=CRM_EXCEEDS_MAX_ALLOWED_FCOE_NETWORKS_PER_BAY
    ...                                 message=The interconnect in bay 3 has exceeded the maximum number of allowed FCoE networks.
    Validate Response    ${resp[0]}  ${valDict}

    #Add one uplink set with MLAG disabled,  one FCoE network, one port from bay3
    ${body}    Get From Dictionary    ${ligs}    LIG_neg4
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    ${valDict}    Create Dictionary    status_code=${400}
    ...                                 errorCode=CRM_EXCEEDS_MAX_ALLOWED_FCOE_NETWORKS_PER_BAY
    ...                                 message=The interconnect in bay 6 has exceeded the maximum number of allowed FCoE networks.
    Validate Response    ${resp[0]}  ${valDict}
    #Add one uplink set with MLAG enabled, 2 FCoE network, 2 ports
    ${body}    Get From Dictionary    ${ligs}    LIG_neg5
    ${lig_body}    Create List    ${body}
    ${resp}    Edit LIG    ${lig_body}
    ${valDict}    Create Dictionary    status_code=${400}
    ...                                 errorCode=CRM_EXCEEDS_MAX_ALLOWED_FCOE_NETWORKS_PER_BAY
    ...                                 message=The interconnect in bay 3 has exceeded the maximum number of allowed FCoE networks.
    Validate Response    ${resp[0]}  ${valDict}

27_Happy Path - Create 4 server profile with FcoE connection (2 profile has BFS[1 Win OS + 1 Esxi OS] connection) and pass traffic on all the servers

    [Documentation]    Happy Path - Create 4 server profile with FcoE connection (2 profile has BFS[1 Win OS + 1 Esxi OS] connection) and pass traffic on all the servers
    [Tags]  27
    ${resp}    Add Server Profiles from variable   ${server_profiles}

    ${l}    Get Length    ${resp}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    Run Keyword If  '${resp[${x}]['status_code']}' == '202'    Wait For Task2    ${resp[${x}]}    20m    1m    ELSE    Fail    Log    failed    console=True
    \    Power on server    ${server_profiles[${x}]['serverHardwareUri']}

    Sleep    10min

    Log    Fetching ICM URI    console=True
    ${ic_uris}    Create List
    :FOR    ${icm}    IN    @{Interconnect_name}
    \    ${uri} =    Get IC URI    ${icm}
    \    Run Keyword If    '${icm}' == '${Interconnect_name[0]}'    Set Suite Variable    ${ICM3_uri}    ${uri}
    \    ...    ELSE IF    '${icm}' == '${Interconnect_name[1]}'   Set Suite Variable    ${ICM6_uri}    ${uri}
    \    Append To List    ${ic_uris}    ${uri}
    Log     ${ICM3_uri}    console=True
    Log     ${ICM6_uri}    console=True
    Set Suite Variable    ${ICM_uris}    ${ic_uris}

    Log    Verify if uplink ports are linked    console=True
    Wait Until Keyword Succeeds    10 min    20s    Verify Ports Status    ${ICM_uris}    ${port_name}

    Log    Verify if downlink ports are linked    console=True
    ${l} =  Get Length    ${dw_ports_3}
    :FOR    ${x}    IN RANGE    0    ${l}
    \       Verify the port status for given interconnect and port    ${Interconnect_name[0]}    ${dw_ports_3[${x}]}

    ${l} =  Get Length    ${dw_ports_6}
    :FOR    ${x}    IN RANGE    0    ${l}
    \       Verify the port status for given interconnect and port    ${Interconnect_name[0]}    ${dw_ports_6[${x}]}

    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}


    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}
    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    Set Suite Variable    ${esxi_lun_BFS}    ${lun_count}

    ${lun_count_list}    Create List
    ${l}    Get Length    ${ilo_details}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    ${serverIp}    Get Server Ip Windows    ${ilo_details[${x}]}
    \    Wait For Appliance To Become Pingable    ${serverIp[0]}
    \    ${output}    execute_windows_commands    ${serverIp[0]}    ${server_credentials[${x}]['userName']}    ${server_credentials[${x}]['password']}    ${diskspd_cmd[${x}]}
    \    Run Keyword If  ${output} == 0    Log    \n Successfully passed the traffic    console=True    ELSE    Fail    Log    Unable to pass traffic    console=True

    \    ${lun_count}    validate_windows_lun_count    ${serverIp[0]}    ${server_credentials[${x}]['userName']}    ${server_credentials[${x}]['password']}
    \    Append To List    ${lun_count_list}    ${lun_count}

    \    Set Suite Variable    ${win_lun_count}    ${lun_count_list}

28_Disable/Enable uplink ports – Disable/ enable uplink ports in Interconnects and verify BFS and LUN
    [Documentation]    Disable/Enable uplink ports – Disable/ enable uplink ports in Interconnects and verify BFS and LUN
    [Tags]  28
    ${len}    Get Length    ${ICM_uris}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${Resp}    Get IC Port    ${ICM_uris[${x}]}    ${port_name[${x}]}
    \    ${enabled_portStatusReason} =    Set Variable If    '${Resp['portStatus']}' == 'Linked'    ActiveFcoeActive    Unknown
    \    ${enabled_portStatus} =    Set Variable If    '${Resp['portStatus']}' == 'Linked'    Linked    Unlinked

    \    Log    Disabling the uplink port    console=True
    \    Set to Dictionary   ${Resp}   enabled    False
    \    ${Return}    Update IC Port    ${Interconnect_name[${x}]}    ${port_name[${x}]}    ${Resp}
    \    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[${x}]}    Configured
    \    Log    Verifying if Port is disabled    console=True
    \    Sleep    200s
    \    ${Disabled_Resp}    Get IC Port    ${ICM_uris[${x}]}    ${port_name[${x}]}
    \    Should be Equal As Strings    ${Disabled_Resp['portStatusReason']}    AdminDisabled

    # Verifying alerts in Interconnects and profiles
    \    Verify Alerts    ${alertstate_ICM}    ${alertType_ICM}    ${interconnect_alert}
    \    Verify Alerts    ${alertstate_profiles}    ${alertType_profiles}    ${profile_alert}

    # Passing traffic and verifying LUN in both local and BFS servers - Failover - After Disabling one fcoe uplink port traffic is flowing through another por
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}

    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True

    \    Log    Enabling the uplink port    console=True
    \    ${Resp}    Get IC Port    ${ICM_uris[${x}]}    ${port_name[${x}]}
    \    Set to Dictionary   ${Resp}   enabled    True
    \    ${Return}    Update IC Port    ${Interconnect_name[${x}]}    ${port_name[${x}]}    ${Resp}
    \    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[${x}]}    Configured
    \    Log    Verifying if Port is Enabled    console=True
    \    Sleep    240s
    \    ${Enabled_Resp}    Get IC Port    ${ICM_uris[${x}]}    ${port_name[${x}]}
    \    Should be Equal As Strings    ${Enabled_Resp['portStatusReason']}    ${enabled_portStatusReason}
    \    Should be Equal As Strings    ${Enabled_Resp['portStatus']}    ${enabled_portStatus}

    # Passing traffic and verifying LUN in both local and BFS servers - After enabling fcoe port, it is regained to original
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}

    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True

29_Power off /on Nitro Module and verify traffic for FCoE network
    [Documentation]    Power off /on Nitro Module and verify traffic for FCoE network
    [Tags]  29

    ${len}    Get Length    ${Interconnect_dto}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    Patch Interconnect     ${Interconnect_dto[${x}]}    op=replace  path=/powerState  value=Off  timeout=60  interval=10
    \    Wait Until Keyword Succeeds    10 min    20s      IC reached state    ${ICM_uris[${x}]}    Maintenance
    \    Sleep    100sec

    # Passing traffic and verifying LUN in server - Failover - While Powering off one Nitro ICM traffic is flowing through another Nitro ICM
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[1]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}


    \    Patch Interconnect     ${Interconnect_dto[${x}]}    op=replace  path=/powerState  value=On  timeout=60  interval=10
    \    Wait Until Keyword Succeeds    20 min    20s      IC reached state    ${ICM_uris[${x}]}    Configured
    \    Sleep    100sec

    # Passing traffic and verifying LUN in both local and BFS servers - After power on Nitro ICM, it is regained to original
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[1]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}


    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True


30_Reset Nitro ICM - verify traffic for FCoE network
    [Documentation]    Reset Nitro ICM - verify traffic for FCoE network
    [Tags]  30

    ${len}    Get Length    ${Interconnect_dto}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    Log    Reseting interconnect     console=True

    \    Patch Interconnect     ${Interconnect_dto[${x}]}    op=replace  path=/deviceResetState  value=Reset  timeout=600  interval=10
    \    Sleep    30sec

    # Passing traffic and verifying LUN in server - Failover - After resetting one Nitro ICM traffic is flowing through another Nitro ICM
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[1]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}

    #\    Wait Until Keyword Succeeds     5 min   10s      Get Interconnect stackingDomainRole    ${Interconnect_name[0]}    ${IC_stacking_domain_role[${x}][0]}
    #\    Wait Until Keyword Succeeds     5 min   10s      Get Interconnect stackingDomainRole    ${Interconnect_name[1]}    ${IC_stacking_domain_role[${x}][1]}

    \    Verify Alerts    ${alertstate_ICM}    ${alertType_ICM}    ${interconnect_alert}
    \    Verify Alerts    ${alertstate_profiles}    ${alertType_profiles}    ${profile_alert}

    # Passing traffic and verifying LUN in both local and BFS servers - After reset Nitro ICM, it is regained to original
    \    Sleep    2min
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[1]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}

    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True

31_Efuse Remove / Insert Nitro Module and verify traffic for FCoE network
    [Documentation]    Efuse Remove / Insert Nitro Module and verify traffic for FCoE network
    [Tags]  31


    ${len}    Get Length    ${ICM_uris}
    :FOR    ${x}    IN RANGE    0   ${len}

    \    Get EM IP    ${ENCs[${x}]}
    \    Get EM Token    ${ENCs[${x}]}
    \    Efuse ICM    EFuseOn    ${bay_numbers[${x}]}
    \    Wait Until Keyword Succeeds    10 min    20s      IC reached state    ${ICM_uris[${x}]}    Absent

    \    Verify Alerts    ${alertstate_ICM}    ${alertType_ICM}    ${interconnect_alert}
    \    Verify Alerts    ${alertstate_profiles}    ${alertType_profiles}    ${profile_alert}

    # Passing traffic and verifying LUN in server - Failover - After removing one Nitro ICM traffic is flowing through another Nitro ICM
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[1]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}

    \    Get EM IP    ${ENCs[${x}]}
    \    Get EM Token    ${ENCs[${x}]}
    \    Efuse ICM    EFuseOff    ${bay_numbers[${x}]}
    \    Wait Until Keyword Succeeds    20 min    20s      IC reached state    ${ICM_uris[${x}]}    Configured
    \    Sleep    120sec

    # Passing traffic and verifying LUN in both local and BFS servers - After adding Nitro ICM, it is regained to original
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[1]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}

    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True

32_Disable/Enable downlink ports – Disable/ enable downlink ports in Interconnects 3 and verify BFS and LUN
    [Documentation]    Disable/Enable uplink ports – Disable/ enable downlink ports in Interconnect 3and verify BFS and LUN
    [Tags]  32
    #Disable enable downlinks for interconnect 6
    ${len}    Get Length    ${dw_ports_3}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${Resp}    Get IC Port    ${ICM_uris[0]}    ${dw_ports_3[${x}]}
    \    ${enabled_portStatusReason} =    Set Variable If    '${Resp['portStatus']}' == 'Linked'    Ok    Unknown
    \    ${enabled_portStatus} =    Set Variable If    '${Resp['portStatus']}' == 'Linked'    Linked    Unlinked

    \    Log    Disabling the uplink port    console=True
    \    Set to Dictionary   ${Resp}   enabled    False
    \    ${Return}    Update IC Port    ${Interconnect_name[0]}    ${dw_ports_3[${x}]}    ${Resp}
    \    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[0]}    Configured
    \    Log    Verifying if Port is disabled    console=True
    \    Sleep    200s
    \    ${Disabled_Resp}    Get IC Port    ${ICM_uris[0]}    ${dw_ports_3[${x}]}
    \    Should be Equal As Strings    ${Disabled_Resp['portStatusReason']}    AdminDisabled

    # Verifying alerts in Interconnects and profiles
    \    Verify Alerts    ${alertstate_ICM}    ${alertType_ICM}    ${interconnect_alert}
    \    Verify Alerts    ${alertstate_profiles}    ${alertType_profiles}    ${profile_alert}

    # Passing traffic and verifying LUN in both local and BFS servers - Failover - After Disabling one fcoe uplink port traffic is flowing through another por
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}


    \    Log    Enabling the uplink port    console=True
    \    ${Resp}    Get IC Port    ${ICM_uris[0]}    ${dw_ports_3[${x}]}
    \    Set to Dictionary   ${Resp}   enabled    True
    \    ${Return}    Update IC Port    ${Interconnect_name[0]}    ${dw_ports_3[${x}]}    ${Resp}
    \    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[0]}    Configured
    \    Log    Verifying if Port is Enabled    console=True
    \    Sleep    240s
    \    ${Enabled_Resp}    Get IC Port    ${ICM_uris[0]}    ${dw_ports_3[${x}]}
    \    Should be Equal As Strings    ${Enabled_Resp['portStatusReason']}    ${enabled_portStatusReason}
    \    Should be Equal As Strings    ${Enabled_Resp['portStatus']}    ${enabled_portStatus}

    # Passing traffic and verifying LUN in both local and BFS servers - After enabling fcoe port, it is regained to original
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}

    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True

    #Disable enable downlinks for interconnect 6
    ${len}    Get Length    ${dw_ports_3}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${Resp}    Get IC Port    ${ICM_uris[1]}    ${dw_ports_3[${x}]}
    \    ${enabled_portStatusReason} =    Set Variable If    '${Resp['portStatus']}' == 'Linked'    Ok    Unknown
    \    ${enabled_portStatus} =    Set Variable If    '${Resp['portStatus']}' == 'Linked'    Linked    Unlinked

    \    Log    Disabling the uplink port    console=True
    \    Set to Dictionary   ${Resp}   enabled    False
    \    ${Return}    Update IC Port    ${Interconnect_name[1]}    ${dw_ports_3[${x}]}    ${Resp}
    \    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[1]}    Configured
    \    Log    Verifying if Port is disabled    console=True
    \    Sleep    200s
    \    ${Disabled_Resp}    Get IC Port    ${ICM_uris[1]}    ${dw_ports_3[${x}]}
    \    Should be Equal As Strings    ${Disabled_Resp['portStatusReason']}    AdminDisabled

    # Verifying alerts in Interconnects and profiles
    \    Verify Alerts    ${alertstate_ICM}    ${alertType_ICM}    ${interconnect_alert}
    \    Verify Alerts    ${alertstate_profiles}    ${alertType_profiles}    ${profile_alert}

    # Passing traffic and verifying LUN in both local and BFS servers - Failover - After Disabling one fcoe uplink port traffic is flowing through another por
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}


    \    Log    Enabling the uplink port    console=True
    \    ${Resp}    Get IC Port    ${ICM_uris[1]}    ${dw_ports_3[${x}]}
    \    Set to Dictionary   ${Resp}   enabled    True
    \    ${Return}    Update IC Port    ${Interconnect_name[1]}    ${dw_ports_3[${x}]}    ${Resp}
    \    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[1]}    Configured
    \    Log    Verifying if Port is Enabled    console=True
    \    Sleep    240s
    \    ${Enabled_Resp}    Get IC Port    ${ICM_uris[1]}    ${dw_ports_3[${x}]}
    \    Should be Equal As Strings    ${Enabled_Resp['portStatusReason']}    ${enabled_portStatusReason}
    \    Should be Equal As Strings    ${Enabled_Resp['portStatus']}    ${enabled_portStatus}

    # Passing traffic and verifying LUN in both local and BFS servers - After enabling fcoe port, it is regained to original
    \    Validate Windows BFS Disk Size    ${ilo_details[1]}    ${server_credentials[0]}
    \    Execute Traffic And Validate Windows LUN    ${ilo_details}    ${server_credentials}    ${win_lun_count}
    \    Wait For Appliance To Become Pingable    ${server_BFS_Enc1_bay1['ip']}

    \    ${lun_count}    Get ESXI LUN Count    ${server_BFS_Enc1_bay1}    ${cmd1}
    \    Run Keyword If  '${lun_count}' == '${esxi_lun_BFS}'    Log    Expected LUN disks are available in BFS     console=True    ELSE    Fail    Log    Failed    console=True
***Keywords*****
FTS
    [Documentation]  First Time Setup
    Set Log Level    DEBUG
    Get VM IP
    First Time Setup    password=hpvse123

Test Specific Teardown
    [Documentation]  Teardown case
    Power Off All Servers
    Remove All Server Profiles
    Remove ALL Users
    Remove All Ethernet Networks
    Remove ALL FCoE Networks

Test Specific Setup
    [Documentation]  General Setup case
    Set Log Level    TRACE
    ${TEST_NAME} =      Set Variable    TEST-SPECIFIC SETUP
    Run Keyword and Ignore Error    Write To ciDebug Log
    Log to console and logfile    [TEST-SPECIFIC SETUP]
    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Test Specific Teardown
    ${users} =    Get Variable Value    ${users}
    Run Keyword If    ${users} is not ${null}    Add Users from variable    ${users}
    ${ethernet_ranges} =    Get Variable Value    ${ethernet_ranges}
    Run Keyword If  ${ethernet_ranges} is not ${null}       Run Keyword for List     ${ethernet_ranges}  Create Ethernet Range


    Power Off All Servers

Run FTS and test-specific setup
    [Documentation]  Run the FTS case and test specific
    Set Log Level    TRACE
    Test Specific Setup

Build Logical Interconnect Group body
    [Documentation]    Build Logical Interconnect Group body
    [Arguments]     ${xlig}
    ${xlig} =    Copy Dictionary    ${xlig}
    ${uplinkSets} =     Copy List   ${xlig['uplinkSets']}
    ${l} =  Get Length  ${uplinkSets}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${networkType} =    Get From Dictionary     ${uplinkSets[${x}]} networkType
    \   ${networks} =       Get From Dictionary     ${uplinkSets[${x}]} networkUris
    \   Run Keyword If  '${networkType}' == 'Ethernet'      Continue For Loop
    \   ${networkUris} =    Get FC Uris ${networks}
    \   Set to dictionary   ${uplinkSets[${x}]} networkUris ${networkUris}

    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${networkType} =    Get From Dictionary     ${uplinkSets[${x}]} networkType
    \   ${networks} =       Get From Dictionary     ${uplinkSets[${x}]} networkUris
    \   Run Keyword If  '${networkType}' == 'FibreChannel'  Continue For Loop
    \   ${networkUris} =    Get FCoE Uris   ${networks}
    \   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
    \   Set to dictionary   ${uplinkSets[${x}]} networkUris ${networkUris}

    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${status}  ${fcoeMlagMode} =   Run Keyword and Ignore Error  Get From Dictionary    ${uplinkSets[${x}]}  fcoeMlagMode
    \   continue for loop if   '${status}'=='FAIL'
    \   Run Keyword if  '${fcoeMlagMode}' == 'None'  Continue For Loop
    \   ${fcoeMlagNetworksUris} =  Get fcoeMlagNetwork Uris  ${uplinkSets[${x}]['fcoeNetworkMlagBays']}
    \   Set to dictionary   ${uplinkSets[${x}]}  fcoeNetworkMlagBays     ${fcoeMlagNetworksUris}

    ${name} =                       Get Variable Value  ${xlig['name']}
    ${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
    ${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
    ${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
    ${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
    ${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
    ${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
    ${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
    ${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
    ${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
    ${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
    ${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
    #${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}
    ${downlinkSpeedMode} =          Get Variable Value  ${xlig['downlinkSpeedMode']}

    ${body} =   Fusion Api Create LIG Payload   name=${name}
    ...                                         enclosureIndexes=${enclosureIndexes}
    ...                                         enclosureType=${enclosureType}
    ...                                         ethernetSettings=${ethernetSettings}
    ...                                         fcoeSettings=${fcoeSettings}
    ...                                         interconnectBaySet=${interconnectBaySet}
    ...                                         interconnectMapTemplate=${interconnectMapTemplate}
    ...                                         redundancyType=${redundancyType}
    ...                                         stackingMode=${stackingMode}
    ...                                         telemetryConfiguration=${telemetryConfiguration}
    ...                                         snmpConfiguration=${snmpConfiguration}
    ...                                         uplinkSets=${uplinkSets}
    ...                                         downlinkSpeedMode=${downlinkSpeedMode}


    [Return]    ${body}

Get fcoeMlagNetwork Uris
    [Documentation]    Build FCoE Mlag Network URIs
    [Arguments]     ${fcoeMlagNetworkBays}

    #fusion_api_appliance_setup.Log to console and logfile   ${fcoeMlagNetworkBays}

    ${l} =     Get Length  ${fcoeMlagNetworkBays}

    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${fcoeMlagList} =       Get From Dictionary     ${fcoeMlagNetworkBays[${x}]}    networkUris
    \   ${networkUris} =    Get FCoE Uris   ${fcoeMlagList}
    \   Set To Dictionary    ${fcoeMlagNetworkBays[${x}]}  networkUris  ${networkUris}

    [Return]    ${fcoeMlagNetworkBays}
Build uplinkset body
    [Documentation]    Build UplinkSet body
    [Arguments]     ${us}   ${li_uri}
    Set to dictionary   ${us}   logicalInterconnectUri  ${li_uri}
    ${l} =  Get Length  ${us['portConfigInfos']}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}  enclosure
    \   ${enc_uri} =        Get Enclosure Uri   ${enc_uri}
    \   Set To Dictionary       ${us['portConfigInfos'][${x}]}  enclosure   ${enc_uri}
    ${status}  ${fcoeNetworkMlagBays} =   Run Keyword and Ignore Error  Get From Dictionary   ${us}  fcoeNetworkMlagBays

    # process fcoenetworkmlagbays
    ${fcoeMlagNetworkUris} =  Run Keyword if  '${status}'=='PASS'  Get fcoeMlagNetwork uris  ${fcoeNetworkMlagBays}

    #Log  ${fcoeMlagNetworkUris}     console=True

    # process eth
    ${networks} =       Get From Dictionary     ${us}   networkUris
    ${networkUris} =    Get Ethernet Uris   ${networks}
    Set to dictionary   ${us}   networkUris ${networkUris}
    # process fc
    ${networks} =       Get From Dictionary     ${us}   fcNetworkUris
    ${networkUris} =    Get FC Uris ${networks}
    Set to dictionary   ${us}   fcNetworkUris   ${networkUris}
    # process fcoe
    ${networks} =       Get From Dictionary     ${us}   fcoeNetworkUris
    ${networkUris} =    Get FCoE Uris   ${networks}
    Set to dictionary   ${us}   fcoeNetworkUris ${networkUris}

    ${body} =       Fusion Api Create Uplink Set Payload    ${us}
    [Return]    ${body}

Get Server Ip Windows
    [Documentation]    Gets the valid ip of the server
    [Arguments]         ${ilo_details}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=20s
    ${login}    SSHLibrary.Login               ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    10sec
    SSHLibrary.Read Until    SAC>
    Sleep    5sec
    SSHLibrary.Write    i
    Sleep    5sec
    ${stdout}    SSHLibrary.Read
    ${cmd_output}=    Get Regexp Matches    ${stdout}    Ip=10\\.\\d+\\.\\d+\\.\\d+
    ${ip_list_new}    Create List
    ${len}    Get Length    ${cmd_output}
    :FOR    ${x}    IN RANGE    ${len}
    \    ${ip_lists}    Remove String    ${cmd_output[${x}]}    Ip=
    \    Append To List   ${ip_list_new}    ${ip_lists}
    Log    \n IP's are is ${ip_list_new}    console=True
    SSHLibrary.Close All Connections
    [Return]    ${ip_list_new}

Validate Windows BFS Disk Size
    [Documentation]    Verify Windows BFS Disk Size
    [Arguments]     ${ilo_details}    ${server_credentials}
    ${serverIp}    Get Server Ip Windows    ${ilo_details}
    ${size}    validate_windows_BFS    ${serverIp[0]}    ${server_credentials['userName']}    ${server_credentials['password']}
    ${disk_size}    Split String    ${size}    .
    Run Keyword If  ${disk_size[0]} <= 100    Log    SWIn OS BFS    console=True    ELSE    Fail    Log    Windows OS BFS lost connections    console=True    Successfully booted up with

Get ESXI LUN Count
    [Documentation]    Gets the available lun counts from the server
    [Arguments]     ${server_BFS}    ${cmd}
    ${output}    discover_lun_esxi    ${server_BFS}    ${cmd}
    ${lun}    Create List
    ${y}    Set Variable    0
    ${l}    Get Length    ${output}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    Should Not Contain    ${output[${x}]}    error
    \    ${y}    Evaluate    ${y} + 1
    [Return]    ${y}

Get IC Port
    [Documentation]    Returns the port info of the named port of specified interconnect uri
    [Arguments]     ${uri}    ${portName}

    ${return} =    Create List
    ${resp} =    fusion api get interconnect ports    uri=${uri}
    ${ports} =    Get From Dictionary    ${resp}    members
    :FOR    ${port}    IN    @{ports}
    \    ${return} =    Run Keyword If    '${port['portName']}' == '${portName}'    set variable    ${port}
    \    Exit for loop if    '${port['portName']}' == '${portName}'
    [Return]    ${return}

Verify Ports Status
    [Documentation]    Verify Ports Status
    [Arguments]     ${ICM_uris}    ${port_name}
    ${len}    Get Length    ${ICM_uris}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    ${Port_Resp}    Get IC Port    ${ICM_uris[${x}]}    ${port_name[${x}]}
    \    Run Keyword If    '${Port_Resp['portStatus']}' != 'Linked'    Fail    msg=Port ${port_name} is unlinked
    \    ...    ELSE    Log    Successfully verified that ${port_name} is Linked    console=True

Execute Traffic And Validate Windows LUN
    [Documentation]    Execute Traffic And Validate Windows LUN
    [Arguments]     ${ilo_details}    ${server_credentials}    ${lun_count_total}
    ${l}    Get Length    ${ilo_details}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    ${serverIp}    Get Server Ip Windows    ${ilo_details[${x}]}
    \    Wait For Appliance To Become Pingable    ${serverIp[0]}

    \    ${output}    execute_windows_commands    ${serverIp[0]}    ${server_credentials[${x}]['userName']}    ${server_credentials[${x}]['password']}    ${diskspd_cmd[${x}]}
    \    Run Keyword If  ${output} == 0    Log    \n Successfully passed the traffic    console=True    ELSE    Fail    Log    Unable to pass traffic    console=True

    \    ${lun_count}    validate_windows_lun_count    ${serverIp[0]}    ${server_credentials[${x}]['userName']}    ${server_credentials[${x}]['password']}
    \    Run Keyword If    ${lun_count}== ${lun_count_total[${x}]}    Log    \n Expected LUN disks are available in local server   console=True    ELSE    Fail    Log    LUN's are not available    console=True

Verify Alerts
    [Documentation]    Verify Alerts
    [Arguments]     ${alertState}    ${alertTypeID}    ${alert_message}
    ${Alert_msg}    Create List
    ${resp}    Fusion Api Get Alerts   /rest/alerts?filter="alertState EQ '${alertState}'"
    ${mem_resp}    Get From Dictionary    ${resp}    members
    ${len}    Get Length    ${mem_resp}
    :FOR   ${x}    IN RANGE    0    ${len}
    \   Run Keyword If  '${mem_resp[${x}]['alertTypeID']}' !='${alertTypeID}'    Continue For Loop
    \   ${desc}    Get From Dictionary    ${mem_resp[${x}]}    description
    \   Append To List    ${Alert_msg}    ${desc}

    ${len}    Get Length    ${Alert_msg}
    :FOR   ${x}    IN RANGE    0    ${len}
    \    Should Contain    ${Alert_msg[${x}]}    ${alert_message}
    Log    \n Successfully verified alert messages    console=True

Verify the port status for given interconnect and port
   [Documentation]   Verify the port status for given interconnect and port
   [Arguments]   ${interconnect_name}    ${port}
   ${resp} =    Fusion Api Get Interconnect        param=?filter="'name'=='${interconnect_name}'"
    ${ports} =    Get from Dictionary    ${resp['members'][0]}    ports
    ${len} =    Get Length    ${ports}
    Log to Console      ${len}  ${\n}

    :FOR    ${z}    IN RANGE    0    ${len}
    \    Exit For Loop If     '${ports[${z}]['portName']}' == '${port}'
    ${u_portinfo} =    Copy Dictionary    ${ports[${z}]}
    Log to Console  ${u_port_info}
    Run Keyword If    '${u_portinfo['portStatus']}' != 'Linked'    fail    msg=Not found linked port in IC
    ...         ELSE    Log    \n Successfully verified the linked state for given port in IC !!    console=true

Get Interconnect StackingDomainRole
    [Documentation]    Get Interconnect StackingDomainRole
    [Arguments]     ${ic_name}    ${expected_role}
    ${resp} =   Get Interconnect    ${ic_name}
    ${Role}    Get From Dictionary    ${resp}    stackingDomainRole
    Should Be Equal As Strings    ${Role}    ${expected_role}
    [Return]    ${Role}

Suite Teardown Tasks
    [Documentation]  Clean OV
    Power off ALL servers
    Remove All Server Profiles
    Remove All LEs
    Remove All Enclosure Groups
    Remove All LIGs
    Remove All Ethernet Networks
    Remove ALL FCoE Networks
    Remove All FC Networks