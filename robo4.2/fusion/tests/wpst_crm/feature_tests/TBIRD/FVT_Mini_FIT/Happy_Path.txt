***Settings***
Documentation   Mini FIT Regression Suite_Happy Path
#Variables       FC_FCoE_Common_Variables.py
#Variables       FC_FCoE_Data_Variable.py
Variables       data_variables_ethernet.py
Library         json
Library         FusionLibrary
Library         RoboGalaxyLibrary
Library         Collections
Library         SSHLibrary
Library         String
Library         server_operations
Library         data_variables_ethernet
Resource            ../../../../../Resources/api/fusion_api_resource.txt
Resource           common_keywords.txt
Library         Telnet

***Variables***

***Test Cases***
Login to OV
    [Tags]    Common
    [Documentation]    Login to OV
    Set Log Level    TRACE

    ${resp}    Fusion Api Login Appliance    ${appliance_ip}    ${admin_credentials}
    Run Keyword If    ${resp[0]['status_code']} != 200    FAIL
    ...    ELSE    Log    Successfully logged in to the appliance    console=True

    Clean OV

Adding FC License
    [Tags]    Common
    [Documentation]    Checks if the License is avilable and adds the FC license

    :FOR    ${license}  IN  @{fc_Potash_licenses}
    \       ${resp} =   Fusion Api Add License      key=${license}
    \       Run keyword if      ${resp['status_code']} != ${201}        Log     Error adding License Key:${license}   WARN


Creating FC networks
    [Tags]    Common
    [Documentation]    Creates FC FA and FC DA networks

    Log    Creating networks    console=True
    Add FC Networks from variable    ${fc_networks}

Create 256 FCoE networks
    [TAGS]    Storage    non-critical
    [Documentation]    Creates 256 Fcoe networks
    Set Log Level   TRACE



    ${resp}    Create FCoE Networks In range    ${fcoe_ranges['fcoe-range32a']}
    Wait For Task2    ${resp}    5min    10
    ${resp}    Create FCoE Networks In range    ${fcoe_ranges['fcoe-range32b']}
    Wait For Task2    ${resp}    5min    10
    ${resp}    Create FCoE Networks In range    ${fcoe_ranges['fcoe-range32c']}
    Wait For Task2    ${resp}    5min    10
    ${resp}    Create FCoE Networks In range    ${fcoe_ranges['fcoe-range32d']}
    Wait For Task2    ${resp}    5min    10
    ${resp}    Create FCoE Networks In range    ${fcoe_ranges['fcoe-range128']}
    Wait For Task2    ${resp}    5min    10

Creating Ethernet networks
    [Tags]    Common
    [Documentation]    Creating Ethernet networks

    Log    Creating networks    console=True
    Add Ethernet Networks from variable    ${ethernet_networks}

Create NetworkSet
    [Tags]    Common
    [Documentation]    Creates a network set

    Add Network Sets from variable    ${network_sets}

Adding Different Users
    [Tags]    Common
    [Documentation]    Adds different user in OneView
    ${resp}    Add Users from variable    ${users}
    ${l}    Get Length    ${resp}
    :FOR    ${x}    IN RANGE    0    ${l}
    \    Run Keyword If    '${resp[${x}]['status_code']}' == '200'    Wait For Task2    ${resp[${x}]}    2m    1m
    \    ...    ELSE    Fail    Log    '${resp[${x}]['errorCode']}'    Console = True

Fetch ICM URI And Verify If ICM is in Monitored State
    [Tags]    Common
    [Documentation]    fetches the interconnect's uri and verify if the interconnects are in monitored state before LE creation
    Log    Fetching ICM URI    console=True
    ${ic_uris}    Create List
    :FOR    ${icm}    IN    @{Interconnect_name}
    \    ${uri} =    Get IC URI    ${icm}
    \    Run Keyword If    '${icm}' == '${Interconnect_name[0]}'    Set Suite Variable    ${ICM3_uri}    ${uri}
    \    ...    ELSE IF    '${icm}' == '${Interconnect_name[1]}'   Set Suite Variable    ${ICM6_uri}    ${uri}
    \    Append To List    ${ic_uris}    ${uri}
    Set Suite Variable    ${ICM_uris}    ${ic_uris}
    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[0]}    Monitored
    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[1]}    Monitored

Create LIG
    [Tags]    Common
    [Documentation]    Creates LIG
    Log    Creating LIG    console=True

    # Create the LIGs based on data file definition
    :FOR    ${lig}    IN    @{ligs}
    \    Add LIG from variable    ${lig}

Verify sampling values are reflected properly in LIG
    [Tags]    Common
    [Documentation]    Verify sampling values are reflected properly in LIG


    ${sCount}    ${sInterval}   Check Sampling value in LIG    ${ligs[0]['name']}
    Set Global Variable    ${sampleCount}    ${sCount}
    Set Global Variable    ${sampleInterval}    ${sInterval}
    Log    \n Verifying the sample count value is reflected properly in LIG    console=True
    ${sampleCount_lig}    Get From Dictionary    ${ligs[0]['telemetryConfiguration']}    sampleCount
    Should Be Equal    ${sampleCount}    ${sampleCount_lig}

    Log    \n Verifying the sample interval value is reflected properly in LIG    console=True
    ${sampleInterval_lig}    Get From Dictionary    ${ligs[0]['telemetryConfiguration']}    sampleInterval
    Should Be Equal    ${sampleInterval}    ${sampleInterval_lig}

Create EG
    [Tags]    Common
    [Documentation]    Create EG with the above LIG
    Log    creating EG    console=True
    Run Keyword for List    ${enc_groups}    Add Enclosure Group from variable

Create LE
    [Tags]    Common
    [Documentation]    Add logical enclosure and verify the LE consistency status
    Log    creating LE    console=True
    Add Logical Enclosure from variable    ${les['${LE}']}

    Log to Console     ${\n}Wait for all uplinks to reach final status
    Sleep    ${UPLINK_STATUS_WAIT}

    Log to Console     ${\n}Verify LE and LI status OK and Consistent
    ${resp} =    Get Logical Enclosure By Name    ${LE}
    Run Keyword If    ${resp} != None    Set Suite Variable    ${LE_URI}    ${resp['uri']}
    Should Be Equal As Strings    ${resp['name']}    ${LE}
    Should Be Equal As Strings    ${resp['status']}    OK
    Should Be Equal As Strings    ${resp['state']}    Consistent

Fetch ICM URI and Verify If ICM is Configured
    [Tags]    Common
    [Documentation]    fetches the interconnect's uri and Verify If ICM is Configured
    Log    Fetching ICM URI    console=True
    ${ic_uris}    Create List
    :FOR    ${icm}    IN    @{Interconnect_name}
    \    ${uri} =    Get IC URI    ${icm}
    \    Run Keyword If    '${icm}' == '${Interconnect_name[0]}'    Set Suite Variable    ${ICM3_uri}    ${uri}
    \    ...    ELSE IF    '${icm}' == '${Interconnect_name[1]}'   Set Suite Variable    ${ICM6_uri}    ${uri}
    \    Append To List    ${ic_uris}    ${uri}
    Log     ${ICM3_uri}    console=True
    Log     ${ICM6_uri}    console=True
    Set Suite Variable    ${ICM_uris}    ${ic_uris}
    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[0]}    Configured
    Wait Until Keyword Succeeds    5 min    20s      IC reached state    ${ICM_uris[1]}    Configured

Verify FC port status
    [TAGS]    Storage    non-critical
    [Documentation]    Check if the uplink ports are linked



    Log    Verify Aside FA Uplinks portStatus, operationalSpeed and connectedTo    console=True
    :FOR    ${uplink}    IN    @{US_FA1_UPLINKS}
    \    Wait Until Keyword Succeeds     10 min   10s     Verify Port    ${ICM3_uri}    ${uplink}    status=OK    portStatus=Linked
    \    ...            opSpeed=Speed8G    connectedTo=${CONNECTED_TO_WWN}

    Log    Verify Bside FA Uplinks portStatus, operationalSpeed and connectedTo    console=True
    :FOR    ${uplink}    IN    @{US_FA2_UPLINKS}
    \    Wait Until Keyword Succeeds     10 min   10s     Verify Port    ${ICM6_uri}    ${uplink}    status=OK    portStatus=Linked
    \    ...            opSpeed=Speed8G    connectedTo=${CONNECTED_TO_WWN}

    Log    Verify Aside DA Uplinks portStatus and operationalSpeed    console=True
    :FOR    ${uplink}    IN    @{IC3_DA_UPLINKS}
    \    Wait Until Keyword Succeeds     10 min   10s     Verify Port    ${ICM3_uri}    ${uplink}    status=OK    portStatus=Linked    opSpeed=Speed8G

    Log    Verify Bside DA Uplinks portStatus and operationalSpeed    console=True
    :FOR    ${uplink}    IN    @{IC6_DA_UPLINKS}
    \    Wait Until Keyword Succeeds     10 min   10s     Verify Port    ${ICM6_uri}    ${uplink}    status=OK    portStatus=Linked    opSpeed=Speed8G

Check LI consistency and Port status
    [Tags]    Common
    [Documentation]    Check the consistency of LI and checks if the uplink ports are linked

    Log    Verify if LI is consistent    console=True
    Wait Until Keyword Succeeds    15 min    20s      Verify LI Status    ${LIs}

    Log    Verify if Uplinkset status are ok    console=True
    Log to Console     ${\n}Verify All uplinksets status OK
    :FOR    ${us}    IN    @{ASIDE_UPLINK_SETS}
    \    Wait Until Keyword Succeeds    5 min    20s    Verify Uplinkset Status    ${LIs[0]}    ${us}    OK
    :FOR    ${us}    IN    @{BSIDE_UPLINK_SETS}
    \    Wait Until Keyword Succeeds    5 min    20s    Verify Uplinkset Status    ${LIs[1]}    ${us}    OK

Verify Ethernet port status
    [Documentation]    Check if the uplink ports are linked
    [TAGS]    Ethernet    non_critical



    Log    Verify if ports are linked    console=True
    ${len}    Get Length    ${ICM_uris}
    :FOR    ${x}    IN RANGE    0   ${len}
    \    Wait Until Keyword Succeeds    2 min    20s    Verify Ports Status    ${ICM_uris[${x}]}    ${Uplink_ports[${x}]}

Verifying Sampling values reflected properly in LI
    [TAGS]    Ethernet    critical
    [Documentation]    Verifying Sampling values reflected properly in LI


    ${sampleCount_li}    ${sampleInterval_li}   Check Sampling value in LI    ${LIs[0]}

    Log to console    \n Verifying the sample count value is reflected properly in LI
    Should Be Equal    ${sampleCount_li}    ${sampleCount}

    Log to console    \n Verifying the sample interval value is reflected properly in LI
    Should Be Equal    ${sampleInterval_li}    ${sampleInterval}

Validation Connector Information In Supported Tranreceiver
    [TAGS]    Ethernet    critical
    [Documentation]   Verifies if there is digital diagnostic information for supported transceiver



    ${diagnostics}    GET PLUGGABLE MODULE INFORMATION    ${ICM3_uri}
    Set Suite Variable    ${diagnostic_info}    ${diagnostics}

    ${message}    Set Variable    Successfully verified if connector info is available
    Validate Connector Informations    ${ICM3_uri}    ${Supported_transreceiver_SFP}    ${message}    True

Verify Digital Diagnostic Info For Supported Transrecevier
    [TAGS]    Ethernet    critical
    [Documentation]   Verifies if there is digital diagnostic information for supported transceiver



    ${message}    Set Variable    Successfully verified if digital diagnostic info is available
    Validate Digital Diagnostics    ${ICM3_uri}    ${Supported_transreceiver_SFP}    ${message}    True    ${DDMI_values_SFP_SR}

Digital Diagnostic Information Range Validation
    [TAGS]    Ethernet    critical
    [Documentation]   Digital Diagnostic Information Range Validation



    ${diagnostics}    Get Pluggable Module Information    ${ICM3_uri}
    Validate Range    ${diagnostics['_content']}    ${ports[0]['port_name']}    ${DDMI_values_SFP_SR}

Verify that Decibal milliwatts for Rxpower and Txpower show up precision of 4 decimal points
    [TAGS]    Ethernet    critical
    [Documentation]   Verifies if no Digital Diagnostic and connector information is displayed if no transceiver is connected



    ${diagnostic_info}    GET PLUGGABLE MODULE INFORMATION    ${ICM3_uri}
    Validate Decimal Range    ${diagnostic_info['_content']}    ${ports[0]['port_name']}    ${DDMI_values_SFP_SR}

Verify that no Digital Diagnostic and connector information is displayed if no transceiver is connected
    [TAGS]    Ethernet    critical
    [Documentation]   Verifies if no Digital Diagnostic and connector information is displayed if no transceiver is connected



    ${sfp}    Set Variable    False

    ${message}    Set Variable    Successfully verified if digital diagnostic info is not available
    Validate Digital Diagnostics    ${ICM3_uri}    ${No_SFP}    ${message}    False

    ${message}    Set Variable    Successfully verified if connector info is not available
    Validate Connector Informations    ${ICM3_uri}    ${No_SFP}    ${message}    True    ${sfp}

Verify Digital Diagnostic information is not disaplyed when connecting a transceiver which does not support DDMI values
    [TAGS]    Ethernet    critical
    [Documentation]   Verifies Digital Diagnostic and connector information when unsupported transceiver is plugged in



    ${message}    Set Variable    Successfully verified if digital diagnostic info is not available when unsupported transceiver is connected
    Validate Digital Diagnostics    ${ICM3_uri}    ${unsupported_sfp}    ${message}    False

Create Server profiles
    [Tags]    Common
    [Documentation]    Create server profiles
    :FOR    ${pro}    IN    @{server_profiles}
    \    Set To Dictionary    ${pro}    enclosureGroupUri    EG:${EG}

    ${resp}    Add Server Profiles from variable    ${server_profiles}
    ${l}    Get Length    ${resp}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    Run Keyword If    '${resp[${x}]['status_code']}' == '202'    Wait For Task2    ${resp[${x}]}    20m    1m
    \    ...    ELSE    Fail    Log    failed    console=True
    Sleep    5min

Power on Servers
    [Tags]    Common
    [Documentation]    Power on Servers
    Run Keyword for List    ${servers}    Power on Server
    Sleep    ${SERVER_BOOT_WAIT}

Get Server IP For Storage Servers
    [TAGS]    Storage    non-critical
    [Documentation]    Fetches the IP for all the FC and FcoE servers and sets suite variable


    ${Windows_FA_DA_server_details}    ${Linux_FA_DA_servers_details}    ${Esxi_FA_DA_servers_details}    ${Windows_FA_DA_ILO_details}    ${Linux_FA_DA_ILO_details}    ${Esxi_FA_DA_ILO_details}    Set Server Details For Storage Servers    ${FA_DA_server_ilo_list}    ${FA_DA_server_details}    ${linux_cmd}    ${esxi_cmd}    ${kill_diskspd}

    Set Suite Variable    ${FA_DA_server_details}    ${FA_DA_server_details}
    Set Suite Variable    ${Windows_FA_DA_server_details}    ${Windows_FA_DA_server_details}
    Set Suite Variable    ${Linux_FA_DA_servers_details}    ${Linux_FA_DA_servers_details}
    Set Suite Variable    ${Esxi_FA_DA_servers_details}    ${Esxi_FA_DA_servers_details}
    Set Suite Variable    ${Windows_FA_DA_ILO_details}    ${Windows_FA_DA_ILO_details}
    Set Suite Variable    ${Linux_FA_DA_ILO_details}    ${Linux_FA_DA_ILO_details}
    Set Suite Variable    ${Esxi_FA_DA_ILO_details}    ${Esxi_FA_DA_ILO_details}

    Log    \nFA DA server details\n ${Windows_FA_DA_server_details}    console=True
    Log    \nFA DA server details\n ${Linux_FA_DA_servers_details}    console=True
    Log    \nFA DA server details\n ${Esxi_FA_DA_servers_details}    console=True

    Log    \nFetch FCoE server details    console=True

    ${Windows_FCoE_servers_details}    ${Linux_FCoE_servers_details}    ${Esxi_FCoE_servers_details}        ${Windows_FCoE_ILO_details}    ${Linux_FCoE_ILO_details}    ${Esxi_FCoE_ILO_details}    Set Server Details For Storage Servers    ${Fcoe_server_ilo_list}    ${Fcoe_server_details}    ${linux_cmd}    ${esxi_cmd}    ${kill_diskspd}

    Set Suite Variable    ${Fcoe_server_details}    ${Fcoe_server_details}
    Set Suite Variable    ${Windows_FCoE_servers_details}    ${Windows_FCoE_servers_details}
    Set Suite Variable    ${Linux_FCoE_servers_details}    ${Linux_FCoE_servers_details}
    Set Suite Variable    ${Esxi_FCoE_servers_details}    ${Esxi_FCoE_servers_details}
    Set Suite Variable    ${Windows_FCoE_ILO_details}    ${Windows_FCoE_ILO_details}
    Set Suite Variable    ${Linux_FCoE_ILO_details}    ${Linux_FCoE_ILO_details}
    Set Suite Variable    ${Esxi_FCoE_ILO_details}    ${Esxi_FCoE_ILO_details}

1_Validating FipSnooping Data
    [Tags]    Storage    critical
    [Documentation]    validates the fipsnooping data for fcoe connections in uplink and downlink port of Bside ICM


    Wait Until Keyword Succeeds     10 min   10s     Verify Fipsnooping data with validation     ${ICM3_uri}
    ...    ${ICM3_Fcoe_uplink_list}    ${Aside_Uplink_FIPS_Data_List}    uplink    True

    Wait Until Keyword Succeeds     10 min   10s     Verify Fipsnooping data with validation     ${ICM3_uri}
    ...    ${ASIDE_Fcoe_SERVER_DOWNLINKS}    ${Aside_Downlink_FIPS_Data_List}    downlink    True

2_Verify traffic for Fcoe servers
    [TAGS]    Storage    Non_BFS    critical
    [Documentation]    Verify traffic for Fcoe server. This test will be skipped for BFS connections


    execute_command_in_tcs    ${kill_paexec}
    Kill_traffic    ${Windows_FCoE_servers_details}

    ${return}    execute_traffic    ${Windows_FCoE_servers_details}
    ${len}    Get Length    ${return}
    :FOR    ${x}    IN RANGE    0    ${len}
    \    Run Keyword If    ${return[${x}]} != 0    fail    Log    Fcoe network Traffic failed    console=True
    \    ...    ELSE    Log    Fcoe network Traffic is successful    console=True

3_Validate FC DA nameserver information
    [Tags]    Storage    critical
    [Documentation]    verifies the nameserver information for both Aside and Bside ICM


    Log    Verify the uplink wwn and name server information    console=True
    Verify Happy Uplinks DA ports    ${ICM3_uri}    ${ICM6_uri}

    Log    Verify the servers dowlink connection mp information    console=True
    Verify Happy Servers DA Connections    ${ICM3_uri}    ${ICM6_uri}

4_Validate FC FA Login informations
    [Tags]    Storage    critical
    [Documentation]    Verify if the logins information on Aside and Bside ports


    Log    Verify login count for Bside ports are not affected    console=True
    Verify Happy Servers FA Connections    ${ICM3_uri}    ${ICM6_uri}

5_Verify traffic for FC FA and DA servers
   [TAGS]    Storage    Non_BFS    critical
   [Documentation]    Verify traffic for Fc FA and DA server. This test will be skipped for BFS connections


    execute_command_in_tcs    ${kill_paexec}
    Kill_traffic    ${Windows_FA_DA_server_details}

    ${Windows_FA_DA_server_details}    Set Diskspd Command    ${Windows_FA_DA_server_details}    ${diskspd_cmd_fc_60s}

    ${return}    execute_traffic    ${Windows_FA_DA_server_details}
    ${len}    Get Length    ${return}
    :FOR    ${x}    IN RANGE    0    ${len}
    \    Run Keyword If    ${return[${x}]} != 0    fail    Log    FC network Traffic failed    console=True
    \    ...    ELSE    Log    FC network Traffic is successful    console=True
    Kill_traffic    ${Windows_FA_DA_server_details}
    execute_command_in_tcs    ${kill_paexec}

6_Verify FC Port statistics with different packet size
    [TAGS]    Storage    Non_BFS    critical
    [Documentation]    Pass the traffic for both FA and DA networks and verify the fc port statistics


    execute_command_in_tcs    ${kill_paexec}
    ${len}    Get Length    ${diskspd_list}
    :FOR    ${x}    IN RANGE    0    ${len}
    \    ${Windows_FA_DA_server_details}    Set Diskspd Command    ${Windows_FA_DA_server_details}    ${diskspd_list[${x}]}
    \    Execute Traffic In Thread    ${Windows_FA_DA_server_details}
    \    Wait Until Keyword Succeeds    15 min    20s    Verify Port statistics    ${ICM3_uri}    ${Aside_FC_ports}    ${FC_counters_Keys}    ${fc_counters_to_validate}    Packet_Interval=200    stats_flag=fc_stats   check_flag=increase    subport_no=1
    \    execute_command_in_tcs    ${kill_paexec}
    Kill_traffic    ${Windows_FA_DA_server_details}
    execute_command_in_tcs    ${kill_paexec}

7_Clear Port Counter and Verify if the counters are cleared
    [TAGS]    Storage    Non_BFS    critical
    [Documentation]    Clears the port counter and verifies if the counter values are cleared


    Kill_traffic    ${Windows_FA_DA_server_details}
    Kill_traffic    ${Windows_FCoE_servers_details}
    execute_command_in_tcs    ${kill_paexec}

    Clear Port Counters    ${ICM3_uri}
    Clear Port Counters    ${ICM3_uri}
    Wait Until Keyword Succeeds    10 min    20s    Verify Port statistics    ${ICM3_uri}    ${Aside_FC_ports}    ${FC_counters_Keys}    ${fc_counters_to_validate}    Packet_Interval=200    stats_flag=fc_stats   check_flag=minimum    subport_no=1

8_Pass Continuous Traffic for One hour and Verify FC Port statistics
    [TAGS]    Storage    Non_BFS    critical
    [Documentation]    Pass continuous traffic for both FA and DA networks and verify the fc port statistics


    execute_command_in_tcs    ${kill_paexec}

    ${Windows_FA_DA_server_details}    Set Diskspd Command    ${Windows_FA_DA_server_details}    ${diskspd_cmd_fc_3600s}
    Execute Traffic In Thread    ${Windows_FA_DA_server_details}

    :FOR    ${x}    IN RANGE    0    3
    \    Wait Until Keyword Succeeds    15 min    20s    Verify Port statistics    ${ICM3_uri}    ${Aside_FC_ports}    ${FC_counters_Keys}    ${fc_counters_to_validate}    Packet_Interval=200    stats_flag=fc_stats   check_flag=increase    subport_no=1
    Kill_traffic    ${Windows_FA_DA_server_details}
    execute_command_in_tcs    ${kill_paexec}

9_Validate s-channel statistics for FC and FCoE connections
    [TAGS]    Storage    Non_BFS    critical
    [Documentation]    Pass FC and FCoE traffic and verifies the s-channel statistics

    Kill_traffic    ${Windows_FA_DA_server_details}
    Kill_traffic    ${Windows_FCoE_servers_details}
    execute_command_in_tcs    ${kill_paexec}
    ${s_channel_stats_fc_fcoe_servers}    Create List

    ${Windows_FCoE_servers_details}    Set Diskspd Command    ${Windows_FCoE_servers_details}    ${diskspd_cmd_fcoe_3600}
    ${Windows_FA_DA_server_details}    Set Diskspd Command    ${Windows_FA_DA_server_details}    ${diskspd_cmd_fc_3600s}
    :FOR    ${fcoe_server}    IN    @{Windows_FCoE_servers_details}
    \    Append To List    ${s_channel_stats_fc_fcoe_servers}    ${fcoe_server}

    :FOR    ${fc_server}    IN    @{Windows_FA_DA_server_details}
    \    Append To List    ${Windows_FA_DA_server_details}    ${fc_server}

    Execute Traffic In Thread    ${s_channel_stats_fc_fcoe_servers}
    Execute Traffic In Thread    ${Windows_FA_DA_server_details}

    ${Port_List}    Create List
    Append To List    ${Port_List}    ${ENC1_SERVER_FcoE_DL_ICM3}
    Append To List    ${Port_List}    ${ENC1_SERVER_DA_DL_ICM3}
    Append To List    ${Port_List}    ${ENC1_SERVER_FA_DL_ICM3}
    Wait Until Keyword Succeeds    15 min    60 sec    Verify Port statistics    ${ICM3_uri}    ${Port_List}    ${schannel_counters_Keys}    ${schannel_counters_Keys}    Packet_Interval=200    stats_flag=s_channel    check_flag=increase    subport_no=2

    Wait Until Keyword Succeeds    12 min    60 sec    Validate Sample Values    ${ICM3_uri}    ${Port_List}    ${samples_key_list}    total_samples=12    check_flag=increase    stats_flag=s_channel    subport_no=2
    Kill_traffic    ${s_channel_stats_fc_fcoe_servers}
    execute_command_in_tcs    ${kill_paexec}

FCoE Windows BFS Verification
    [TAGS]    Storage    BFS    critical
    [Documentation]    Verifies the FCoE BFS servers LUN count and traffic

    ${win_server_len}    Get Length    ${Windows_FCoE_servers_details}
    Run Keyword If    ${win_server_len} != 0    Execute FC FCoE Traffic in Windows    ${kill_paexec}    ${Windows_FCoE_servers_details}    ${BFS_diskspd_cmd}
    ...    ELSE    Log    There are No Windows server    console=True

FCoE Linux BFS Verification
    [TAGS]    Storage    BFS    critical
    [Documentation]    Verifies the FCoE BFS servers LUN count and traffic

    ${linux_server_len}    Get Length    ${Linux_FCoE_servers_details}
    Run Keyword If    ${linux_server_len} != 0    Get_Linux_Lun_Count    ${Linux_FCoE_servers_details}
    ...    ELSE    Log    There are No Linux server    console=True

FCoE Esxi BFS Verification
    [TAGS]    Storage    BFS    critical
    [Documentation]    Verifies the FCoE BFS servers LUN count and traffic

    ${esxi_server_len}    Get Length    ${Esxi_FCoE_servers_details}
    #Run Keyword If    ${esxi_server_len} != 0    Esxi_Ping_Test    ${Esxi_FCoE_servers_details}
    Run Keyword If    ${esxi_server_len} != 0    Esxi_fc_fcoe_volume_validation    ${Esxi_FCoE_servers_details}

FA DA Windows BFS Verification
    [TAGS]    Storage    BFS    critical
    [Documentation]    Verifies the FCoE BFS servers LUN count and traffic

    ${win_server_len}    Get Length    ${Windows_FA_DA_server_details}
    Run Keyword If    ${win_server_len} != 0    Execute FC FCoE Traffic in Windows    ${kill_paexec}    ${Windows_FA_DA_server_details}    ${BFS_diskspd_cmd}
    ...    ELSE    Log    There are No Windows server    console=True

FA DA Linux BFS Verification
    [TAGS]    Storage    BFS    critical
    [Documentation]    Verifies the FCoE BFS servers LUN count and traffic

    ${linux_server_len}    Get Length    ${Linux_FA_DA_servers_details}
    Run Keyword If    ${linux_server_len} != 0    Get_Linux_Lun_Count    ${Linux_FA_DA_servers_details}
    ...    ELSE    Log    There are No Linux server    console=True

FA DA Esxi BFS Verification
    [TAGS]    Storage    BFS    critical
    [Documentation]    Verifies the FCoE BFS servers LUN count and traffic

    ${esxi_server_len}    Get Length    ${Esxi_FA_DA_servers_details}
    #Run Keyword If    ${esxi_server_len} != 0    Esxi_Ping_Test    ${Esxi_FA_DA_servers_details}
    Run Keyword If    ${esxi_server_len} != 0    Esxi_fc_fcoe_volume_validation    ${Esxi_FA_DA_servers_details}


1_Verify existing non-LAG'd connections can be edited by PUT method to LAG the connections
    [TAGS]    Ethernet    critical
    [Documentation]    Verify existing non-LAG'd connections can be edited by PUT method to LAG the connections

    Run Keyword for List    ${servers_LAG}    Power off Server

    ${resp}    Edit Server Profiles from variable    ${sp_lag}
    ${l}    Get Length    ${resp}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    Run Keyword If  '${resp[${x}]['status_code']}' == '202'    Wait For Task2    ${resp[${x}]}    20m    1m    ELSE    Fail    Log    failed    console=True
    Run Keyword for List    ${servers_LAG}    Power on Server
    Sleep    ${SERVER_BOOT_WAIT}

2_Verify LAG creation without teaming configured on OS
    [TAGS]    Ethernet    critical
    [Documentation]    Verify LAG creation without teaming configured on OS

    Wait Until Keyword Succeeds    15 min    20s    Verify Server profile Alerts    8

2_1_Verify Traffic before Teaming
    [TAGS]    Ethernet    critical
    [Documentation]    Verify Traffic before Teaming


    ${length}    Get Length    ${ILO_List_LAG_8_con}
    :FOR    ${x}    IN RANGE    0    ${length}
    \    Getting Server Ip And Verifying Traffic    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}    ${ping_file}    ${server_details_LAG_8_con[${x}]['OS']}    ${Ping_Lost}    ${percentage_loss[0]}

3_Verify all S-Channels on a downlink can pass user traffic as part of VP-LAG connections For a single pair of server downlink ports
    [TAGS]    Ethernet    critical
    [Documentation]    Verify all S-Channels on a downlink can pass user traffic as part of VP-LAG connections For a single pair of server downlink ports

    ${length}    Get Length    ${ILO_List_LAG_8_con}
    Set Suite Variable    ${len}    ${length}
    :FOR    ${x}    IN RANGE    0    ${len}
    \    ${adapter_name_list}    Getting Server Adapter Names    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}    ${server_profile_names_LAG_8_con[${x}]}    ${Powershell_get_mac}    ${server_details_LAG_8_con[${x}]['username']}    ${server_details_LAG_8_con[${x}]['password']}    ${file1}    ${ILO_List_LAG_8_con[${x}]['type']}

    \    ${server_details}    Get IP For All Servers    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}
    \    Create Teaming windows     ${adapter_name_list[0]}    ${adapter_name_list[1]}   ${Powershell_get_mac1}    ${server_details_LAG_8_con[${x}]}    ${server_details['ip'][0]}
    \    ${server_details}    Get IP For All Servers    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}
    \    Create Teaming windows     ${adapter_name_list[2]}    ${adapter_name_list[3]}   ${Powershell_get_mac2}    ${server_details_LAG_8_con[${x}]}    ${server_details['ip'][0]}
    \    ${server_details}    Get IP For All Servers    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}
    \    Create Teaming windows     ${adapter_name_list[4]}    ${adapter_name_list[5]}   ${Powershell_get_mac3}    ${server_details_LAG_8_con[${x}]}    ${server_details['ip'][0]}
    \    ${server_details}    Get IP For All Servers    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}
    \    Create Teaming windows     ${adapter_name_list[6]}    ${adapter_name_list[7]}   ${Powershell_get_mac4}    ${server_details_LAG_8_con[${x}]}    ${server_details['ip'][0]}

    Wait Until Keyword Succeeds    10 min    20s    Verify Server profile Alerts    0

3_1_Verify Traffic after Teaming
    [TAGS]    Ethernet    critical
    [Documentation]    Verify Traffic after Teaming

    ${length}    Get Length    ${ILO_List_LAG_8_con}
    :FOR    ${x}    IN RANGE    0    ${length}
    \    Getting Server Ip And Verifying Traffic    ${ILO_List_LAG_8_con[${x}]}    ${server_details_LAG_8_con[${x}]}    ${ping_file}    ${server_details_LAG_8_con[${x}]['OS']}    ${Ping_Lost}    ${percentage_loss[0]}

Kill Traffic in TCS
    [TAGS]    Ethernet    non_critical
    [Documentation]    Verify traffic flows correctly form Non-LAG to LAG server and vice-versa

    execute_command_in_tcs    ${kill_paexec}

4_Verify traffic flows correctly form Non-LAG to LAG server and vice-versa
    [TAGS]    Ethernet    critical
    [Documentation]    Verify traffic flows correctly form Non-LAG to LAG server and vice-versa

    ${ip_length}    Get Length    ${ILO_List_NON_LAG}
    :FOR    ${x}    IN RANGE    0   ${ip_length}
    \    ${server_details}    Get IP For All Servers    ${ILO_List_NON_LAG[${x}]}    ${NON_LAG_server_details[${x}]}
    \    Wait For Appliance To Become Pingable    ${server_details['ip'][0]}

    ${Windows_server_details}    ${Linux_servers_details}    ${Esxi_servers_details}    Set Server Detail    ${ILO_List_LAG_8_con}    ${server_details_LAG_8_con}    ${ping_windows}    ${ping_linux}    ${ping_esxi}    ${kill_cmd_ping_windows}    ${kill_cmd_ping_linux}    ${kill_cmd_ping_esxi}
    Set Suite Variable    ${Windows_server_details_LAG}    ${Windows_server_details}

    ${Windows_server_details}    ${Linux_servers_details}    ${Esxi_servers_details}    Set Server Detail    ${ILO_List_NON_LAG}    ${NON_LAG_server_details}    ${ping_windows}    ${ping_linux}    ${ping_esxi}    ${kill_cmd_ping_windows}    ${kill_cmd_ping_linux}    ${kill_cmd_ping_esxi}
    Set Suite Variable    ${Linux_servers_details_Non_LAG}    ${Linux_servers_details}

    ${ip_length}    Get Length    ${Windows_server_details_LAG}
    :FOR    ${x}    IN RANGE    0   ${ip_length}
    \    ${LAG_IP}    Get From Dictionary    ${Windows_server_details_LAG[${x}]}    ip
    \    ${LAG_IP_len}    Get Length    ${LAG_IP}
    \    Server to Server Ping    ${LAG_IP_len}    ${Windows_server_details_LAG[${x}]['OS']}    ${Windows_server_details_LAG[${x}]['ip']}    ${server_details_LAG_8_con[${x}]}    ${Windows_server_details_LAG[${x}]['cmd']}    ${Linux_servers_details_Non_LAG[${x}]['ip']}    ${file_name}
    \    Server to Server Ping    ${LAG_IP_len}    ${Linux_servers_details_Non_LAG[${x}]['OS']}    ${Linux_servers_details_Non_LAG[${x}]['ip']}    ${NON_LAG_server_details[${x}]}    ${Linux_servers_details_Non_LAG[${x}]['cmd']}    ${Windows_server_details_LAG[${x}]['ip']}    None

5_Verifying S-Channel common and advanced statistics vaules for LAG servers
    [TAGS]    Ethernet    critical
    [Documentation]    Verifying S-Channel common and advanced statistics vaules for LAG servers


    ${Windows_server_details}    ${Linux_servers_details}    ${Esxi_servers_details}    Set Server Details    ${ILO_List_LAG_8_con}    ${server_details_LAG_8_con}   ${ping_type[1]}    ${ping_windows}    ${ping_linux}    ${ping_esxi}    ${gateway_ping_cmd_windows}    ${gateway_ping_cmd_linux}    ${gateway_ping_cmd_esxi}    ${kill_cmd_ping_windows}    ${kill_cmd_ping_linux}    ${kill_cmd_ping_esxi}
    Set Suite Variable    ${Windows_LAG_server_details}    ${Windows_server_details}

    Execute Traffic In Thread    ${Windows_LAG_server_details}

    :FOR     ${x}   IN RANGE   0   3
    \    Wait Until Keyword Succeeds    15 min    60 sec    Verify Port statistics    ${ICM3_uri}    ${downlink_lag_Aside}    ${schannel_counters_Keys}    ${schannel_counters_Keys}    Packet_Interval=250    stats_flag=s_channel    check_flag=increase    subport_no=1

    Wait Until Keyword Succeeds    12 min    60 sec    Validate Sample Values    ${ICM3_uri}    ${downlink_lag_Aside}    ${samples_key_list}    total_samples=12    check_flag=increase    stats_flag=s_channel    subport_no=1

6_Verifying S-Channel common and advanced statistics vaules for Non LAG servers
    [TAGS]    Ethernet    critical
    [Documentation]    Verifying S-Channel common and advanced statistics vaules for Non LAG servers


    ${Windows_server_details}    ${Linux_servers_details}    ${Esxi_servers_details}    Set Server Details    ${ILO_List_NON_LAG}    ${NON_LAG_server_details}   ${ping_type[1]}    ${ping_windows}    ${ping_linux}    ${ping_esxi}    ${gateway_ping_cmd_windows}    ${gateway_ping_cmd_linux}    ${gateway_ping_cmd_esxi}    ${kill_cmd_ping_windows}    ${kill_cmd_ping_linux}    ${kill_cmd_ping_esxi}
    Set Suite Variable    ${Linux_Non_LAG_servers_details}    ${Linux_servers_details}

    ${len}    Get Length    ${NON_LAG_server_details}
    :FOR     ${x}   IN RANGE   0   ${len}
    \    Create Linux Bonding    ${Linux_Non_LAG_servers_details[${x}]['ip']}    ${Linux_Non_LAG_servers_details[${x}]}    ${bond_name}    ${bond_mode}

    ${Windows_server_details}    ${Linux_servers_details}    ${Esxi_servers_details}    Set Server Details    ${ILO_List_NON_LAG}    ${NON_LAG_server_details}   ${ping_type[1]}    ${ping_windows}    ${ping_linux}    ${ping_esxi}    ${gateway_ping_cmd_windows}    ${gateway_ping_cmd_linux}    ${gateway_ping_cmd_esxi}    ${kill_cmd_ping_windows}    ${kill_cmd_ping_linux}    ${kill_cmd_ping_esxi}
    Set Suite Variable    ${Linux_Non_LAG_servers_details}    ${Linux_servers_details}

    Execute Traffic In Thread    ${Linux_Non_LAG_servers_details}
    :FOR     ${x}   IN RANGE   0   3
    \    Wait Until Keyword Succeeds    15 min    60 sec        Verify Port statistics    ${ICM3_uri}    ${downlink_Aside}    ${schannel_counters_Keys}    ${schannel_counters_Keys}    Packet_Interval=250    stats_flag=s_channel    check_flag=increase    subport_no=1

    Wait Until Keyword Succeeds    12 min    60 sec    Validate Sample Values    ${ICM3_uri}    ${downlink_Aside}    ${samples_key_list}    total_samples=12    check_flag=increase    stats_flag=s_channel    subport_no=1

7_Verify that the egress counter values are not available in S-channel statistics through API call
    [TAGS]    Ethernet    critical
    [Documentation]    Verify that the egress counter values are not available in S-channel statistics through API call

    ${subportStatistics}    ${subport_commonstat}    ${subport_advancedstat}    Get s-channel statistics    ${ICM3_uri}    ${stat}    ${downlink_Aside[0]}    ${sub_port_number[0]}
    ${len}    Get Length   ${subportCommon_egress_counters}
    :FOR     ${x}   IN RANGE   0   ${len}
    \    ${subport_commonstats}    Get From Dictionary    ${subport_commonstat}    ${subportCommon_egress_counters[${x}]}
    \    Run Keyword If  '${subport_commonstats}' != 'None'    Fail    ELSE    Log    \n Egress counter values are not available.    console=True

8_Get gateway ip of the server and passing traffic and Verifying new counters in stacking link ports
    [TAGS]    Ethernet    critical
    [Documentation]    Get gateway ip of the server and passing traffic and Verifying new counters in stacking link ports

    ${len}    Get Length   ${stacking_link_port}
    :FOR     ${x}   IN RANGE   0   ${len}
    \    Get Port statistics    ${ICM3_uri}    ${stat}    ${stacking_link_port[${x}]}    ${stacking_port_counters}

9_Get server IP and pass traffic for same physical port connections with same networks
    [TAGS]    Ethernet    critical
    [Documentation]    Get server IP and pass traffic for same physical port connections with same networks


    ${server_details_same_phy_port}    Get IP For All Servers    ${ENC1_SERVER_SAME_PHY_PORT_ILO}    ${ENC1_SERVER_SAME_PHY_PORT_win_cred}
    ${ip}    Get From Dictionary    ${server_details_same_phy_port}    ip
    ${ip_len}    Get Length    ${ip}
    Sort List    ${ip}

    ${adapter_name_list}    Getting Server Adapter Names    ${ENC1_SERVER_SAME_PHY_PORT_ILO}    ${ENC1_SERVER_SAME_PHY_PORT_win_cred}    ${ENC1_SERVER_SAME_PHY_PORT}    ${Powershell_get_mac}    ${server_details_same_phy_port['username']}    ${server_details_same_phy_port['password']}    ${file1}    ${ENC1_SERVER_SAME_PHY_PORT_ILO['type']}    mac_length=${mac_len_same_phy_port[0]}
    Log    ${adapter_name_list}    console=True

    #Delete Static ip
    Delete_Static_ip    ${mac_len_same_phy_port[0]}    ${adapter_name_list}    ${delete_static_ip}    ${server_details_same_phy_port}    ${ip[0]}
    #Set Static ip
    Set_Static_ip    ${mac_len_same_phy_port[0]}    ${adapter_name_list}    ${Powershell_set_static_enc1}    ${server_details_same_phy_port}    ${ip[0]}

    #Ping ip and validate the traffic flow
    Ping_Server_ip_validate_packet_loss    ${ping_cmd_enc1_same_phy_port}    ${ENC1_SERVER_SAME_PHY_PORT_win_cred}   ${ip[0]}    ${file_name}

    #Delete Static ip
    Delete_Static_ip    ${mac_len_same_phy_port[0]}    ${adapter_name_list}    ${delete_static_ip}    ${server_details_same_phy_port}    ${ip[0]}

10_Get server IP and pass traffic for same physical port connections with different networks
    [TAGS]    Ethernet    critical
    [Documentation]    Get server IP and pass traffic for same physical port connections with different networks

    ${server_details_same_phy_port}    Get IP For All Servers    ${ENC2_SERVER_SAME_PHY_PORT_ILO}    ${ENC2_SERVER_SAME_PHY_PORT_win_cred}
    ${ip}    Get From Dictionary    ${server_details_same_phy_port}    ip
    ${ip_len}    Get Length    ${ip}
    Sort List    ${ip}

    ${adapter_name_list}    Getting Server Adapter Names    ${ENC2_SERVER_SAME_PHY_PORT_ILO}    ${ENC2_SERVER_SAME_PHY_PORT_win_cred}    ${ENC2_SERVER_SAME_PHY_PORT}    ${Powershell_get_mac}    ${server_details_same_phy_port['username']}    ${server_details_same_phy_port['password']}    ${file1}    ${ENC2_SERVER_SAME_PHY_PORT_ILO['type']}    mac_length=${mac_len_same_phy_port[1]}
    Log    ${adapter_name_list}    console=True

    #Delete Static ip
    Delete_Static_ip    ${mac_len_same_phy_port[1]}    ${adapter_name_list}    ${delete_static_ip}    ${server_details_same_phy_port}    ${ip[0]}

    #Set Static ip
    Set_Static_ip    ${mac_len_same_phy_port[1]}    ${adapter_name_list}    ${Powershell_set_static_enc2}    ${server_details_same_phy_port}    ${ip[0]}

    #Verify traffic flow should be unsuccessful
    Ping_Server_ip_validate_packet_loss_neg      ${ip[0]}    ${ping_cmd_enc2_same_phy_port}    ${ENC2_SERVER_SAME_PHY_PORT_win_cred}     ${file_name}    ${General_failure}    ${General_failure}

    #Delete Static ip
    Delete_Static_ip    ${mac_len_same_phy_port[1]}    ${adapter_name_list}    ${delete_static_ip}    ${server_details_same_phy_port}    ${ip[0]}

11_Kill Traffic
    [TAGS]    Ethernet    non_critical
    [Documentation]    Kill Traffic


    Kill_traffic    ${Linux_Non_LAG_servers_details}
    Kill_traffic    ${Windows_LAG_server_details}
    execute_command_in_tcs    ${kill_paexec}
