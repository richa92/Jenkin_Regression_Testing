*** Settings ***
Documentation       OVF1816_Negative_Scenarios
#Variables       data_variables.py
Variables       data_variables_Nitro_Porting.py
Library         json
Library         FusionLibrary
Library         RoboGalaxyLibrary
Library         Collections
Library         SSHLibrary
Library         String
Resource        ../../../../../Resources/api/fusion_api_resource.txt
Library         data_variables
Library         Telnet
Library         backping.py
Library         Dialogs
Suite Teardown  Clean OV

*** Variables ***
${APPLIANCE_IP}     15.245.131.251
${number1}                   2
${number}                    5
${flag}                      Windows
${Port_status_trap_name}     Lost

${Ping_Lost}    Lost


*** Test Cases ***
Login to Appliance
    [Documentation]    Login to Appliance
    [Tags]  add   POSITIVE
    Set Log Level    TRACE
    ${Login_response}=    Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}
    Run keyword unless  ${Login_response[0]['status_code']}== 200    Fail    "Unable to Login"

    Clean OV
    Remove All Alerts


############################### Create profiles with s-lags from templates #######################
Create Networks for creating profiles with s-lags from templates
    [Documentation]    Create ethernet Networks
    Log        \n-Creating Ethernet Networks    console=True
    ${resp}    Add Ethernet Networks from variable   ${Enet}
    Wait For Task2    ${resp}    120

Create LIG, EG and LE for creating profiles with s-lags from templates
    [Documentation]    Create LIG, EG and LE
    Log      \n Creating LIG    console=True
    Add LIG from variable   ${LIGS_TB[2]}

    Log      \n Creating EG    console=True
    ${Resp}    Add Enclosure Group from variable    ${enc_group}
    Wait For Task2    ${Resp}    200

    Log      \n Creating LE    console=True
    Add Logical Enclosure from variable     ${les}

Create server Profiles Template
    [Documentation]    Create server Profiles
    ${resp}    Add Server Profile Templates from variable    ${SP_template}
    Wait For Task2    ${resp}    120
    ${spt_uri}    Get Server Profile Template URI    ${SP_template[0]['name']}
    Set to Dictionary    ${Server_profile1_temp[0]}    serverProfileTemplateUri    ${spt_uri}
    Create Server Profile from SPT    ${Server_profile1_temp}
    Wait For Task2    ${Resp}    200    20
    Sleep   2min
    Log      \n Server profiles created successfully    console=True
    Power on server     ${server6}
    Log        \n Power on servers    console=True
    Log        \n Waiting 10 minutes for the server to boot    console=True
    Sleep   10min

Verifying alert message on server profile page
    [Documentation]    Verifying alert message on server profile page
    ${Alert_msg}    Get Server profile Alerts
    ${Count_2}=    Get Length    ${Alert_msg}
    Run Keyword If  '${Count_2}' != '2'  Fail    ELSE  Log       \n-Verified the alerts msg of server profiles    console=True

Geting server ip's and checking if IP's are pinging
    [Documentation]    Geting server ip's and checking if IP's are pinging
    ${IP}    Get Server Ip Windows    ${ilo_details_enc2_bay6}
    Set Global Variable    ${serverip_List1_global}    ${IP}
    ${ret1} =    Ping Server IP    ${number}    ${serverip_List1_global}    ${ping_file}    ${flag}    ${Ping_Lost}
    Run Keyword If  '${ret1}' != '0%'  Fail    ELSE  Log      \n 0 percent packet loss is observed    console=True
    Log         All the IP's are reachable    console=True

Get MAC Address of the server & Windows Teaming
    [Documentation]    Get MAC Address of the server & Windows Teaming
    ${IP}    Get Server Ip Windows    ${ilo_details_enc2_bay6}
    Set Global Variable    ${serverip_List1_global}    ${IP}
    ${resp}=    Fusion Api Get Server Profiles
    ${mac_addr_list}=    Create List
    ${mac} =    Get Profile Details    ${resp}    ${Server_profile1_temp[0]['name']}
    ${mac_length}=    Get Length    ${mac}
    :FOR    ${x}    IN RANGE    ${mac_length}
    \   ${mac_address} =    Replace String Using Regexp    ${mac[${x}]}    :    -
    \   Append To List   ${mac_addr_list}    ${mac_address}
    Log        \n mac address ${mac_addr_list}    console=True
    ${mac_addr_len}    Get Length    ${mac_addr_list}
    # Compare mac address with server
    ${adapter_name_list} =    Create List
    :FOR    ${x}    IN RANGE    ${mac_addr_len}
    \   ${replaced_cmd} = Replace String Using Regexp    ${Powershell_get_mac}    pppppppp      ${mac_addr_list[${x}]}
    \  # calling Get Mac Address from server
    \   Log      \n the server details is ${server_details_enc2_bay6}    console=True
    \   Log      \n the ip is ${serverip_List1_global[0]}    console=True
    \   ${output}    Get Mac Address from server    ${server_details_enc2_bay6}    ${serverip_List1_global[0]}    ${replaced_cmd}
    \   ${string}    Convert To String    ${output}
    \   ${match}   ${adapter_name}    Should Match Regexp    ${string}    (.*PCIe Slot\\s+\\d+.*)
    \   Append to List   ${adapter_name_list}   ${adapter_name}
    Log      \nadapter names list ${adapter_name_list}    console=True
    Create Teaming windows     ${adapter_name_list[0]}    ${adapter_name_list[1]}   ${Powershell_get_mac1}    ${server_details_enc2_bay6}    ${serverip_List1_global[1]}
    Create Teaming windows     ${adapter_name_list[2]}    ${adapter_name_list[3]}   ${Powershell_get_mac2}    ${server_details_enc2_bay6}    ${serverip_List1_global[1]}

Verify if IP is pinging after teaming
    [Documentation]    Verify if IP is pinging after teaming
    ${ip_team}    Get Server Ip Windows    ${ilo_details_enc2_bay6}
    Set Global Variable    ${Team_ip}    ${ip_team}
    ${ret} =    Ping Server IP    ${number}    ${serverip_List1_global}    ${team}    ${flag}    ${Ping_Lost}
    Log         successfully pinged ip's    console=True

Verifying alert message on server profile page after teaming
    [Documentation]    Verifying alert message on server profile page after teaming
    ${Alert_msg}    Get Server profile Alerts
    ${Count}    Get Length    ${Alert_msg}
    Run Keyword If  '${Count}' != '0'  Fail    ELSE  Log       \n-Verified the alerts msg of server profiles    console=True

Removing Teaming on server profile1
    [Documentation]    Removing Teaming on server profile1 and deleting the profile
    ${iplength} =    Get Length    ${Team_ip}
    :FOR    ${x}    IN RANGE    0   ${iplength}
    \   Log      \n deleting teaming${Team_ip[${x}]}    console=True
    \   Delete Windows Teaming    ${Team_ip[${x}]}    ${server_details_enc2_bay6}    ${detlete_team_cmd${x}}
    \   Sleep    120sec


***Keywords***
Clean OV
    [Documentation]    Cleans the appliance
    Log    \nCleaning the OV    console=True
    Power off ALL Servers
    Remove All Server Profiles
    Remove All LEs
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets
    Remove ALL Users

Get Server profile Alerts
    [Documentation]    Get Server profile Alerts
    ${y} =    Set Variable    0
    ${Alert_msg} =    Create List
    ${resp} =    Fusion Api Get Alerts    /rest/alerts?filter="alertState EQ 'Active'"
    ${mem_resp} =    Get From Dictionary    ${resp}    members
    ${len} =    Get Length    ${mem_resp}
    :FOR   ${x}    IN RANGE    0    ${len}
    \   Run Keyword If  '${mem_resp[${x}]['alertTypeID']}' !='crm.connectionStateChange'    Continue For Loop
    \   ${desc} =    Get From Dictionary    ${mem_resp[${x}]}    description
    \   Log    description'${desc}'    console=True
    \    ${match}   ${status}    Should Match Regexp    ${desc}    (Connection\\s+on\\s+downlink\\s+port\\s+\\d+\\,.*LAG\\d+.)
    \  Append To List    ${Alert_msg}    ${desc}
    \  ${y} =    Evaluate    ${y} + 1
    \   Log    ${status}    console=True
    Log    ${Alert_msg}    console=True
    [Return]    ${Alert_msg}


Get Server Ip Windows
    [Documentation]    Gets the valid ip of the server.
    [Arguments]         ${ilo_details}
    Log    \nstdout is ${ilo_details}    console=True
    ${serverip_List}=    Create List
    ${serverip_List1}=    Create List
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=20s
    ${login}    SSHLibrary.Login               ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop/system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Read Until    SAC>
    Sleep    5sec
    SSHLibrary.Write    i
    Sleep    5sec
    ${stdout}    SSHLibrary.Read
    Log        \nstdout is ${stdout}    console=True
    ${cmd_output}=    Get Regexp Matches    ${stdout}    Ip=172\\.\\d+\\.\\d+\\.\\d+
    Log        \nstdout is ${cmd_output}    console=True
    ${ip_list_new}    Create List
    ${len}    Get Length    ${cmd_output}
    :FOR    ${x}    IN RANGE    ${len}
    \    ${ip_lists}    Remove String    ${cmd_output[${x}]}    Ip=
    \    Log        ip is ${ip_lists}    console=True
    \    Append To List   ${ip_list_new}    ${ip_lists}
    Log        \n IP's are is ${ip_list_new}    console=True
    SSHLibrary.Close All Connections
    [Return]    ${ip_list_new}

Ping Server IP
    [Documentation]    Pinging Server IP
    [Arguments]         ${number}    ${serverip_List1_global}    ${ping_file}    ${flag}    ${Ping_Lost}
    ${l} =    Get Length    ${serverip_List1_global}
    Set Global Variable    ${iplength}    ${l}
    Log        \n pinging started    console=True
    :FOR    ${x}    IN RANGE    0   ${iplength}
    \    startthread    ${number}    ${serverip_List1_global[${x}]}    ${ping_file[${x}]}    ${flag}
    \    Sleep    30
    \    ${contents}=    OperatingSystem.Get File    ${ping_file[${x}]}
    \    ${Lines} =    Get Lines Containing String    ${contents}    ${Ping_Lost}
    \    Log        \ncontents are ${Lines}    console=True
    \    ${match}   ${ret1}    Should Match Regexp    ${Lines}    Lost\\s+=\\s+\\d+\\s+\\((\\d+%)\\s+loss\\)
    \    Log         ${ret1}    console=True
    [Return]    ${ret1}

Create Windows Teaming
    [Documentation]    Create Windows Teaming
    [Arguments]         ${server_ip}    ${server_details}    ${team_cmd}
    Telnet.Open Connection     ${server_ip}     prompt=>     timeout=20s
    Log      \nSuccessfully opened connection to the server    console=True
    Telnet.Write    a
    ${login}    Telnet.Login               ${server_details['username']}     ${server_details['password']}    login_prompt=login:    password_prompt=password:
    Log      \nSuccessfully logged into the server    console=True
    Sleep    60sec
    Telnet.Write    powershell
    Log      \n${team_cmd}    console=True
    Telnet.Write    ${team_cmd}
    Sleep    30sec
    Telnet.Write    y
    Sleep    30sec
    Telnet.Close Connection
    Telnet.Close All Connections
    Log        \nteaming completed    console=True

Create Teaming windows
    [Documentation]    Create Teaming windows
    [Arguments]         ${adapter_name_1}   ${adapter_name_2}    ${Powershell_get_mac1}    ${windows_server_details}    ${serverip_List1_global[1]}
    ${tmp}    Remove Whitespace   ${adapter_name_1}
    ${tmp1}    Remove Whitespace   ${adapter_name_2}
    ${replaced_cmd1} =    Replace String Using Regexp    ${Powershell_get_mac1}    pppp    ${tmp}
    Log      \nstrafter strip is${tmp}    console=True
    Log      \nreplaced_cmd1 is${replaced_cmd1}    console=True
    ${replaced_cmd2} =    Replace String Using Regexp    ${replaced_cmd1}    qqq    ${tmp1}
    Log      \nstr is${replaced_cmd2}    console=True
    Create Windows Teaming   ${serverip_List1_global[1]}    ${windows_server_details}    ${replaced_cmd2}

Delete Windows Teaming
    [Documentation]    Delete Windows Teaming
    [Arguments]         ${team_ip}    ${windows_server_details}    ${detlete_team_cmd}
    Telnet.Open Connection     ${team_ip}     prompt=>     timeout=20s
    Log      \nSuccessfully opened connection to the server    console=True
    Telnet.Write    a
    ${login}    Telnet.Login               ${windows_server_details['username']}     ${windows_server_details['password']}    login_prompt=login:    password_prompt=password:
    Log      \nSuccessfully logged into the server    console=True
    Sleep    60sec
    Telnet.Write    powershell
    Log      \n${detlete_team_cmd}    console=True
    Telnet.Write    ${detlete_team_cmd}
    Sleep    60sec
    Telnet.Write    y
    Sleep    60sec
    ${stdout} =  Telnet.Read
    Log       \nout is ${stdout}    console=True
    Telnet.Close Connection
    Telnet.Close All Connections
    Log        \nteaming deleted    console=True

Get Profile Details
    [Documentation]    Get Profile Details
    [Arguments]                  ${resp}    ${profile_name}
    ${profile_len} =    Get Length    ${resp['members']}
    :FOR    ${x}    IN RANGE   ${profile_len}
    \   ${y} =    Set Variable    ${resp['members'][${x}]['connectionSettings']}
    \   ${mac_address} =    Run Keyword If  '${resp['members'][${x}]['name']}' == '${profile_name}'
    \   ...    Get Mac address Of Server Profile    ${y['connections']}
    \   ...    ELSE
    \   ...    Continue For Loop
    [return]            ${mac_address}

Get Mac address Of Server Profile
    [Documentation]    Get Mac address Of Server Profile
    [Arguments]                  ${connections}
    ${mac_address} =    Create List
    ${connection_length} =    Get Length    ${connections}
    :FOR    ${x}    IN RANGE    ${connection_length}
    \   Append To List   ${mac_address}    ${connections[${x}]['mac']}
    [return]            ${mac_address}

Get Mac Address from server
    [Documentation]    Get Mac Address from server
    [Arguments]         ${server_details}    ${IP}    ${Powershell_get_mac}
    Telnet.Open Connection     ${IP}     prompt=>     timeout=30s
    Sleep    5sec
    Telnet.Write    a
    ${login}    Telnet.Login               ${server_details['username']}    ${server_details['password']}    login_prompt=login:    password_prompt=password:
    Log      \nLogged in to server    console=True
    Sleep    60sec
    ${out}    Telnet.Read
    Telnet.Write    Powershell
    Sleep    60sec
    Telnet.Write    ${Powershell_get_mac}
    Sleep    30sec
    ${stdout} =  Telnet.Read
    Sleep    30sec
    Telnet.Close Connection
    Telnet.Close All Connections
    [Return]    ${stdout}
