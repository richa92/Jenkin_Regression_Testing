***Settings***
Documentation        Feature Tests: OVF1757_Carbon_32_Monitored_Mode
Library                   FusionLibrary
Library                   RoboGalaxyLibrary
Library                   Collections
Library                   OperatingSystem
Library                   Process
Variables                 data_variables.py

Suite Setup               Suite Setup Tasks
Suite Teardown            Suite Teardown Tasks

Resource            ../../../../resource/fusion_api_all_resource_files.txt

*** Variables ***
${APPLIANCE_IP}                 15.186.9.136

***Testcases***
############# Verification for Carbon_32 module in MONITORED mode - Power ON/OFF in Monitored_Mode #############
1 Turn ON/OFF UID_Light in ICM's
    [Documentation]    Power_ON_OFF the UID_Light in ICM's
    ${ic_list} =     Get IC
    ${len_icm} =   Get Length   ${ic_list}
	Set Global Variable     ${len_ic}     ${len_icm}

	############### Verifying that UID_Light is Powered Off ###############
    :FOR    ${x}    IN RANGE    0  ${len_ic}
	\   Verifying UId_Light_Off in ICMs    uri=${IC_URI[${x}]}

	################## POWER On UID_Light in ICM's #######################
    :FOR    ${x}    IN RANGE    0  ${len_ic}
    \   ${body} =   Create Dictionary   op=replace
    \   ...                             path=/uidState
    \   ...                             value=On
    \   ${body} =   Create list     ${body}
    \   ${resp} =   fusion api patch interconnect   body=${body}    uri=${IC_URI[${x}]}
    \   ${task} =   Wait for Task   ${resp}   2min    10s
    \   Validate Response   ${task}  ${valDict}
    \   Log to console and logfile  \nVerifying UID_light for ICM : ${IC_URI[${x}]} is ON
    \   Wait Until Keyword Succeeds    10 min   15s      Power_on_off UID_Light in ICMs     ${IC_URI[${x}]}        On
    \   Log to console and logfile   \n Successfully Powered ON ${IC_URI[${x}]}

    ############### Verifying that UID_Light is Powered On ###############
    :FOR    ${x}    IN RANGE    0  ${len_ic}
	\   Verifying UId_Light_On in ICMs    uri=${IC_URI[${x}]}

	################## POWER OFF UID_Light in ICM's #######################
    :FOR    ${x}    IN RANGE    0  ${len_ic}
    \   ${body} =   Create Dictionary   op=replace
    \   ...                             path=/uidState
    \   ...                             value=Off
    \   ${body} =   Create list     ${body}
    \   ${resp} =   fusion api patch interconnect   body=${body}    uri=${IC_URI[${x}]}
    \   ${task} =   Wait for Task   ${resp}   2min    10s
    \   Validate Response   ${task}  ${valDict}
    \   Log to console and logfile  \nVerifying UID_light for ICM : ${IC_URI[${x}]} is Off
    \   Wait Until Keyword Succeeds    10 min   15s      Power_on_off UID_Light in ICMs     ${IC_URI[${x}]}        Off
    \   Log to console and logfile   \n Successfully Powered Off ${IC_URI[${x}]}

	############### Verifying that UID_Light is Powered Off ###############
    :FOR    ${x}    IN RANGE    0  ${len_ic}
	\   Verifying UId_Light_Off in ICMs    uri=${IC_URI[${x}]}


################## STEP 2 : RESETTING THE ICM'S AND VERIFYING ICM STATE ###########################

2 Resetting ICM's and verifying the ICM_status
    [Documentation]    Resetting ICM's and verifying the ICM_status
    :FOR    ${x}    IN RANGE    0  ${len_ic}
    \    Log to console and logfile  \n\nChecking ICM in Monitored state
    \    verify IC state    ${IC_URI[${x}]}    Monitored
    \    Log to console and logfile  \n\nThe IC module ${IC_URI[${x}]} is in Monitored state
    \    Log to console and logfile  \n\nRemoving and adding back Carbon_32 ${IC_URI[${x}]} module
    \    Get EM IP
    \    Get EM Token    ${ENC1}
    \    EFuse ICM    EFuseReset   ${ICBay[${x}]}
	\    Sleep    180s
    \    ${ic_resp} =    Fusion Api Get Interconnect     param=?filter="'name'=='${INTERCONNECTS[${x}]}'"
	\    Run keyword unless	  '${ic_resp['members'][0]['state']}' == 'Monitored'    Fail    ${IC_URI[${x}]} is ${ic_resp['members'][0]['state']}
	\    Log to console and logfile    Resetting ICM completed for ${IC_URI[${x}]}


################## STEP 3 : EFUSE OFF/ON THE ICM'S ###########################

3 Efuse ON/OFF for ICM's
    [Documentation]    Efuse ON/OFF for ICM's and verifying the state
    Log to console and logfile  \n\n${len_ic} Carbon_32 Interconnect modules are available\n
    :FOR    ${x}    IN RANGE    0  ${len_ic}
	\   ${ic_resp} =    Fusion Api Get Interconnect
	\   Run keyword unless	  '${ic_resp['count']}' == '2'   Fail    ${ic_resp['count']}
    \   Efuse ICM command   ${ENC1}   ${ICBay[${x}]}   ${Action[0]}
    \   Sleep   60s
	\   ${ic_resp} =    Fusion Api Get Interconnect
	\   Run keyword unless	  '${ic_resp['count']}' == '1'   Fail    ${ic_resp['count']}
    \   Log to console and logfile    Successfully removed ${ICBay[${x}]}
    \   Efuse ICM command   ${ENC1}   ${ICBay[${x}]}   ${Action[1]}
    \   Sleep   2min
	\   ${ic_resp} =    Fusion Api Get Interconnect
	\   Run keyword unless	  '${ic_resp['count']}' == '2'   Fail    ${ic_resp['count']}
	\   Log to console and logfile    Successfully inserted ${ICBay[${x}]}

	:FOR    ${x}    IN RANGE    0  ${len_ic}
	\   ${ic_resp} =    Fusion Api Get Interconnect     param=?filter="'name'=='${INTERCONNECTS[${x}]}'"
	\   Run keyword unless	  '${ic_resp['members'][0]['state']}' == 'Monitored'    Fail    ${ic_resp['members'][0]['state']}
	\   Log to console and logfile    ${INTERCONNECTS[${x}]} : ${ic_resp['members'][0]['state']} state

################## STEP 4 : POWER OFF/NO THE ICM'S ###########################

4 Powering OFF/ON the IC's
    [Documentation]    Power_ON_OFF ICM's and Verifying the State of ICM's
    ################## POWER OFF ICM's #######################
    :FOR     ${interconnect}   IN   @{INTERCONNECTS}
    \   ${ic_uri} =    Get IC URI    ${interconnect}
    \   ${body} =   Create Dictionary   op=replace
    \   ...                             path=/powerState
    \   ...                             value=Off
    \   ${body} =   Create list     ${body}
    \   ${resp} =   fusion api patch interconnect   body=${body}    uri=${ic_uri}
    \   ${task} =   Wait for Task   ${resp}   1min    10s
    \   Validate Response   ${task}  ${valDict}
    \   sleep   120s
    \   Log to console and logfile  \nVerify ${interconnect} is off
    \   Wait Until Keyword Succeeds    10 min   15s        Verify Interconnect Power State     ${interconnect}        Off
    \   Log to console and logfile   \n Powered off ${interconnect}
    Sleep   60s

    ################## POWER ON ICM's #######################

    Log to console and logfile   \n Power on interconnect
    :FOR     ${interconnect}   IN   @{INTERCONNECTS}
    \   ${ic_uri} =    Get IC URI    ${interconnect}
    \   ${body} =   Create Dictionary   op=replace
    \   ...                             path=/powerState
    \   ...                             value=On
    \   ${body} =   Create list     ${body}
    \   ${resp} =   fusion api patch interconnect   body=${body}    uri=${ic_uri}
    \   ${task} =   Wait for Task   ${resp}   1min    10s
    \   Validate Response   ${task}  ${valDict}
    \   sleep   120s
    \   Log to console and logfile  \nVerify ${interconnect} is On
    \   Wait Until Keyword Succeeds    10 min   15s        Verify Interconnect Power State     ${interconnect}        On
    \   Log to console and logfile   \n Powered on ${interconnect}
    Sleep  60s

	:FOR    ${x}    IN RANGE    0  ${len_ic}
	\   ${ic_resp} =    Fusion Api Get Interconnect     param=?filter="'name'=='${INTERCONNECTS[${x}]}'"
	\   Run keyword unless	  '${ic_resp['members'][0]['state']}' == 'Monitored'    Fail    ${ic_resp['members'][0]['state']}
	\   Log to console and logfile    ${INTERCONNECTS[${x}]} : ${ic_resp['members'][0]['state']} state


################## STEP 5 : CREATING EG_POOLS AND EDITING EG_DHCP ###########################

5 Creation of EG_IPV4_Address and Editing as EG_DHCP
    [Documentation]    creating EG_Pools and editing as EG_DHCP
    Log to console and logfile    Removing the Subnets and Associated Ranges
    Remove All Subnets and Associated Ranges
    Log to console and logfile     \nCreating an IpV4 address pool to use while creating EG
    ${resp} =     Fusion Api Create Ipv4 Subnet     body=${subnet}
    ${valdict} =  Create Dictionary   status_code=${200}
    Validate Response   ${resp}    ${valdict}
    ${range_name} =      Get From Dictionary   ${ipv4range}   name
    ${network_id}=       Get From Dictionary   ${subnet}     networkId
    ${ip_range_body}=     Build IPV4 Body   ${ipv4range}    ${network_id}    ${range_name}
    ${resp}=      Fusion Api Create Ipv4 Range     ${ip_range_body}
    Validate Response   ${resp}    ${valdict}
    Log to console and logfile     \n\n Created the IPV4 address range successfully

    Log to console and logfile     \n Creating EG after getting the iprange Uris from Subnet
    ${subnets}=     Get Subnet     ${network_id}
    ${uri}=     Get from Subnet    ${subnets}        uri
    ${resp} =    Fusion Api Get Ipv4 Subnet     uri=${uri}
    ${rangeuri} =     Get From Dictionary     ${resp}    rangeUris
    ${eg_body}=     Create EG Body with Associate Range    ${enc_group_static}      ${EG1}    ${rangeuri}
    ${resp}=        Fusion Api Create Enclosure Group     ${eg_body}
    ${etag}=     Get From Dictionary     ${resp}     eTag
    ${valDict}=     Create Dictionary   status_code=${201}
    Validate Response   ${resp}   ${valDict}
	Add Logical Enclosure from variable   ${LE['le1']}

	################  validating static_ip  #################
	${POOLS_IP} =   Create List
	:FOR    ${x}    IN RANGE    0  ${len_ic}
	\   ${ic_resp} =    Fusion Api Get Interconnect    param=?filter="'name'=='${INTERCONNECTS[${x}]}'"
	\   Log to console and logfile    \nChecking in ICM if its getting DHCP Ipv4 address
    \   ${IC_IP}=      Get From Dictionary      ${ic_resp['members'][0]['ipAddressList'][0]}    ipAddress
    \   ${ip_type}=    Get From Dictionary      ${ic_resp['members'][0]['ipAddressList'][0]}    ipAddressType
    \   Run keyword unless     '${ip_type}' == 'Ipv4Static'    Should Contain    ${ip_pool_static}        ${IC_IP}     msg="The ICM is not setting the IP address from the given pool"
	\   Append to List   ${POOLS_IP}   ${IC_IP}
	Log to console and logfile    ${POOLS_IP}

    ############## Editing EG_DHCP and update in LE #################

	Log to console and logfile    \nEditing EG to change the IPV4 address mgmt to "DHCP"
    ${resp1} =    Fusion Api Get Enclosure Groups    param=?filter="'name'=='${EG1}'"
    ${etag} =     Get From Dictionary     ${resp1['members'][0]}    eTag 
    ${egnew_body}=    Set To Dictionary   ${enc_groups['enc_group_dhcp']}   eTag=${etag}
    ${resp}=      Edit Enclosure Group     ${egnew_body}
    Run Keyword If  ${resp['status_code']} !=200    fail    EG edit Failed with Error code \n${resp['errorCode']}
    ...         ELSE    Log to console and logfile  \n\nEG edited Succesfully !!
    Log to console and logfile  \n\n Updating LE as per the edited EG
    ${le_uri} =    Get LE URI      ${LE1}
    Perform an Update From Group   ${le_uri}   15 min   15 s

    ################  validating DHCP_ip  #################
	${DHCP_IP} =   Create List
    :FOR    ${x}    IN RANGE    0  ${len_ic}
	\   ${ic_resp} =    Fusion Api Get Interconnect    param=?filter="'name'=='${INTERCONNECTS[${x}]}'"
	\   Log to console and logfile    \nChecking in ICM if its getting DHCP Ipv4 address
    \   ${ic_IP}=      Get From Dictionary      ${ic_resp['members'][0]['ipAddressList'][0]}    ipAddress
	\   ${IC_IP}    Convert To String    ${ic_IP}
    \   ${ip_type}=    Get From Dictionary      ${ic_resp['members'][0]['ipAddressList'][0]}    ipAddressType
	\   Run Keyword If     '${ip_type}' == 'Ipv4Dhcp'    Should Match Regexp    ${IC_IP}   (\\d+.\\d+.\\d+.\\d+)
	\   Append to List   ${DHCP_IP}   ${IC_IP}
	Log to console and logfile    DHCP IP's : ${DHCP_IP}

################## STEP 6 : VALIDATING  ###########################

6 Validating the FRU_datas,General and other H/W Paramerters in ICM's
    [Documentation]    Validating the FRU_datas,General and other H/W Paramerters in ICM's
    :FOR    ${x}    IN RANGE    0  ${len_ic}
	\   ${ic_resp} =    Fusion Api Get Interconnect     param=?filter="'name'=='${INTERCONNECTS[${x}]}'"
	\   Run keyword unless	  '${ic_resp['members'][0]['interconnectMAC']}' == '${interconnectMAC[${x}]}'    Fail    ${ic_resp['members'][0]['interconnectMAC']}
    \   Run keyword unless	  '${ic_resp['members'][0]['baseWWN']}' == '${baseWWN[${x}]}'    Fail    ${ic_resp['members'][0]['baseWWN']}
	\   ${dhcp_ip} =   Get From Dictionary     ${ic_resp['members'][0]['ipAddressList'][0]}   ipAddress
	\   ${string}    Convert To String    ${dhcp_ip}
    \   ${match}   ${ip}    Should Match Regexp    ${string}    (\\d+.\\d+.\\d+.\\d+)
	\   Log to console and logfile   dhcp_ip:${ip}
	\   ${firmwareVersion} =   Get From Dictionary     ${ic_resp['members'][0]}   firmwareVersion
	\   ${str}    Convert To String    firmwareVersion:${firmwareVersion}
    \   ${match}   ${Version}    Should Match Regexp    ${str}    (\\d+.\\d+.\\d+)
	\   Log to console and logfile   ${Version}
	\   Run keyword unless	  '${ic_resp['members'][0]['productName']}' == '${ICM_MODEL}'    Fail    ${ic_resp['members'][0]['productName']}
	\   Run keyword unless	  '${ic_resp['members'][0]['partNumber']}' == '${partNumber[0]}'    Fail    ${ic_resp['members'][0]['partNumber']}
	\   Run keyword unless	  '${ic_resp['members'][0]['serialNumber']}' == '${serialNumber[${x}]}'    Fail    ${ic_resp['members'][0]['serialNumber']}
	\   Run keyword unless	  '${ic_resp['members'][0]['hostName']}' == '${hostName[0]}'    Fail ${ic_resp['members'][0]['hostName']}
	\   Run keyword unless	  '${ic_resp['members'][0]['powerState']}' == 'On'    Fail ${ic_resp['members'][0]['powerState']}
	\   Run keyword unless	  '${ic_resp['members'][0]['sparePartNumber']}' == '${sparePartNumber[0]}'    Fail ${ic_resp['members'][0]['sparePartNumber']}
	\   Run keyword unless	  '${ic_resp['members'][0]['status']}' == 'OK'    Fail    ${ic_resp['members'][0]['status']}
	\   Run keyword unless	  '${ic_resp['members'][0]['state']}' == 'Monitored'    Fail    ${ic_resp['members'][0]['state']}
	\   Run keyword unless	  '${ic_resp['members'][0]['name']}' == '${INTERCONNECTS[${x}]}'    Fail    ${ic_resp['members'][0]['name']}
	\   Run keyword unless	  '${ic_resp['members'][0]['type']}' == '${type[0]}'    Fail    ${ic_resp['members'][0]['type']}
	\   Run keyword unless	  '${ic_resp['members'][0]['enclosureType']}' == '${enclosureType[0]}'    Fail    ${ic_resp['members'][0]['enclosureType']}
    \   Run keyword unless	  '${ic_resp['members'][0]['interconnectMAC']}' == '${interconnectMAC[${x}]}'    Fail    ${ic_resp['members'][0]['interconnectMAC']}
    \   Run keyword unless	  '${ic_resp['members'][0]['baseWWN']}' == '${baseWWN[${x}]}'    Fail    ${ic_resp['members'][0]['baseWWN']}

*** Keywords ***
Suite Setup Tasks
    [Documentation]    Suite Setup
    Set Log Level      TRACE
    ${TEST_NAME} =      Set Variable    TEST-SPECIFIC SETUP
    Run Keyword and Ignore Error    Write To ciDebug Log
    Log to console and logfile  [TEST-SPECIFIC SETUP]
    Fusion Api Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}
	Clean OV
	#########   Check interconnect state is Monitored  ##########
	${IC_URI} =   Create List
    :FOR     ${interconnect}   IN   @{INTERCONNECTS}
    \   ${icm_uri} =    Get IC URI    ${interconnect}
	\   verify IC state    ${icm_uri}    Monitored
	\   Append to list    ${IC_URI}    ${icm_uri}
    Log to console and logfile    ${IC_URI}
	Set Global Variable    ${IC_URI}    ${IC_URI}

Verifying UId_Light_Off in ICMs
    [Documentation]    Verifying UId_Light_Off in ICMs
    [Arguments]     ${uri}
	${ic_resp} =    Fusion Api Get Interconnect    ${uri}
	Run keyword unless	  '${ic_resp['uidState']}' == 'Off'    Fail    ${IC_URI[${x}]} is ${ic_resp['uidState']}
	Log to console and logfile     UID_Light for ${uri} is in Powered off State.

Verifying UId_Light_On in ICMs
    [Documentation]    Verifying UId_Light_Off in ICMs
    [Arguments]     ${uri}
	${ic_resp} =    Fusion Api Get Interconnect    ${uri}
	Run keyword unless	  '${ic_resp['uidState']}' == 'On'    Fail    ${IC_URI[${x}]} is ${ic_resp['uidState']}
	Log to console and logfile     UID_Light for ${uri} is in Powered on State.

Power_on_off UID_Light in ICMs
    [Documentation]    Power_on_off UID_Light in ICMs
    [Arguments]     ${uri}      ${UID_STATE}
    ${ic_resp}    Fusion Api Get Interconnect    ${uri}
	${uidState}   Get From Dictionary    ${ic_resp}    uidState
	Should Be Equal As Strings    ${uidState}    ${UID_STATE}
	Log to console and logfile    \n\nUID_State of the ICM ${uri}:${uidState}

Get from Subnet
    [Documentation]    Getting Subnet value from list
    [Arguments]     ${subnet_list}      ${element}
    ${return} =     Get From Dictionary     ${subnet_list}          ${element}
    [Return]    ${return}

Build IPV4 Body
      [Documentation]    Build the  Range Body by adding the Subnet Uri
      [Arguments]       ${ipv4range}   ${NETWORK_ID}    ${RANGE_NAME}
      ${subnets}=     Get Subnet        ${NETWORK_ID}
      ${uri}=         Get from Subnet         ${subnets}              uri
      Set to dictionary       ${ipv4range}         subnetUri=${uri}
      [Return]   ${ipv4range}

Perform an Update From Group
    [Documentation]	 Performing Update from group in LE
	[Arguments]		${LE_uri}	${timeout}=10 min 	${interval}=15s
	${resp_update} = 	    Fusion Api Update Logical Enclosure from Group   uri=${LE_uri}
	Run keyword unless	${resp_update['status_code']}== 202    Fail    ${resp_update['message']}
	${task} =	Wait For Task 	${resp_update} 	900s	30s
	Sleep   30s
	Log to console and logfile    \nLE updated from group successfully.

Remove All Subnets and Associated Ranges
     [Documentation]    Removes all subnets and IP range pools
     Log to console and logfile    \n Removing subnets and IP ranges
     ${resp}=     Fusion Api Get Ipv4 Subnet
     ${count}=    Get From Dictionary    ${resp}    count
     :FOR   ${x}  IN RANGE   0  ${count}
     \    ${uri}=     Get From Dictionary   ${resp['members'][${x}]}    uri
     \    ${del}=     Fusion Api Delete Ipv4 Subnet     uri=${uri}

Get Subnet
    [Documentation]    Getting Subnet details
    [Arguments]             ${NETWORK_ID}
    ${resp} =   fusion api get ipv4 subnet
    ${subnetcounts} =     Get From Dictionary     ${resp}    members
    ${l} =  Get Length  ${subnetcounts}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${subnet} =     Get From List   ${subnetcounts}    ${x}
    \   Exit For Loop If    '${subnet['networkId']}' == '${NETWORK_ID}'
    [Return]    ${subnet}

Edit Enclosure Group
    [Documentation]    Edit Enclosure Group from EG DTO
    ...              Example:
    ...                Edit Enclosure Group  ${enc_group}
    ...              Data Required:
    ...                EG DTO
    [Arguments]     ${enc_group}
    ${name} =  Get From Dictionary  ${enc_group}  name
    Log to console and logfile  ${\n}Editing Enclosure Group ${name}
    ${uri} =  Get Enclosure Group URI  ${name}
    ${l} =  Get Length  ${enc_group['interconnectBayMappings']}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${liguri} =     Get From Dictionary ${enc_group['interconnectBayMappings'][${x}]}   logicalInterconnectGroupUri
    \   Continue For Loop If    '${liguri}' == 'None'
    \   ${liguri} =     Common URI Lookup by name    ${liguri}
    \   Set to dictionary   ${enc_group['interconnectBayMappings'][${x}]}   logicalInterconnectGroupUri     ${liguri}
    Set to dictionary  ${enc_group}  uri  ${uri}
    ${resp} =  fusion api edit enclosure group  ${enc_group}  ${uri}
    [Return]    ${resp}

Efuse ICM command
     [Documentation]    Efuse ICM command
     [Arguments]     ${ENC1}    ${ICBay}    ${Action}
     SSHLibrary.Open Connection     ${Host}
     ${login}    SSHLibrary.Login               root     hpvse1
     ${EM1}    SSHLibrary.Execute Command   /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${ENC1}
     Log to console and logfile   \n em1 ${EM1}
     ${EM}    catenate   SEPARATOR=   ${EM1}%bond0
     Log to console and logfile   \n em ${EM}
     ${XAUTH}    SSHLibrary.Execute Command  /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${ENC1} -o t
     Log to console and logfile   \n XAUTH ${XAUTH}
     ${efuse_operation}    SSHLibrary.Execute Command   curl -i -X POST https://[${EM}]/rest/v1/InterconnectBays/${ICBay} -k -H "X-Auth-Token: ${XAUTH}" -d '{"Action":"${Action}"}'
     Log to console and logfile   efuseresponce\n-${efuse_operation}
     SSHLibrary.Close All Connections

Verify Interconnect Power State
    [Documentation]    Verifying power state of interconnect
    [Arguments]        ${ICM_NAME}        ${POWER_STATE}
    ${IC}=    Fusion Api Get Interconnect    param=?filter="'name'=='${ICM_NAME}'"
    ${powerState} =     Get From dictionary    ${IC['members'][0]}   powerState
    Should Be Equal As Strings    ${powerState}    ${POWER_STATE}
    Log to console and logfile    \n\nPower State of the ICM is ${ICM_NAME}:${powerState}

verify IC state
    [Documentation]    Verifying the reached state
    [Arguments]     ${uri}  ${state}
    Set Log Level   TRACE
    ${resp} =   fusion api get resource     ${uri}
    Log to console and logfile      \t ${resp['name']}: ${resp['state']}
    Should Match Regexp     ${resp['state']}    ${state}
    [Return]    ${resp}

Clean OV
    [Documentation]    Cleans the appliance
    Log to console and logfile  \nCleaning the OV
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets
    Remove ALL Users

Create EG Body with Associate Range
    [Documentation]    Adds Enclosure Group to an appliance from a variable which contains a list of dicts with the entire payload and also Associate a Range
    [Arguments]     ${enc_groups}       ${enc_group_name}   ${rangeuri}
    Log     ${enc_group_name}
    Log     ${enc_groups}
    Log     ${rangeuri}
    Log to console and logfile      Adding ENCLOSURE GROUP
    :FOR    ${enc_group1}   IN  @{enc_groups}
    \       Log     ${enc_group1}
    \       ${enc_group_name1} =        Get From Dictionary     ${enc_group1}       name
    \       Log     ${enc_group_name1}
    \       Run Keyword If  '${enc_group_name1}'!='${enc_group_name}'       Continue For Loop
    \       Set to dictionary           ${enc_group1}           ipRangeUris=${rangeuri}
    \       ${enc_group_body}=  Copy Dictionary     ${enc_group1}
    \       Log     ${enc_group_body}
    ${l} =  Get Length  ${enc_group_body['interconnectBayMappings']}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${liguri} =     Get From Dictionary ${enc_group_body['interconnectBayMappings'][${x}]}  logicalInterconnectGroupUri
    \   Continue For Loop If    '${liguri}' == 'None'
    \   ${liguri} =     Common URI Lookup by name    ${liguri}
    \   Set to dictionary   ${enc_group_body['interconnectBayMappings'][${x}]}  logicalInterconnectGroupUri     ${liguri}
    [Return]    ${enc_group_body}