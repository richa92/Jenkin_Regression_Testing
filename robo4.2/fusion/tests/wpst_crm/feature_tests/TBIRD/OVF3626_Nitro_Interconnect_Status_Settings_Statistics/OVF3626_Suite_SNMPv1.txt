*** Settings ***
Documentation    Test Nitro Overview Behaviour
...              SNMP Configurations

Variables       OVF3626_data_variables.py
Library         json
Library         FusionLibrary
Library         RoboGalaxyLibrary
Library         Collections
Library         SSHLibrary
Library         String
Resource            ../../../../../Resources/api/fusion_api_resource.txt
Suite Setup     Presetup for Nitro
Suite Teardown    Clean OV

*** Variables ***
#${ICM_Reboot_Trap}    Cold Start Trap
${ICM_Reboot_Trap}    Enterprise Specific Trap
${trap}    Enterprise Specific Trap
${ICM_Reboot_v1}    SNMP v1
${link_down}     Link Down Trap
${link_up}    Link Up Trap

*** Test Cases ***
API_TC1 SNMPv1 Setup SNMPv1 Configurations on LI and LIG
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG
    [Tags]    Configure_SNMPv1_on_LI_LIG
    Set Log Level    Trace
    ${resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${ADMIN_CREDS}


    #${i}    Get Master IC
    #Log to console and logfile  \n\n${i}


    Log    \n\n setup Up SNMPv1 on LIG !!\n\n    console=True
    ${len}    Get Length    ${LIG_names}
    :For    ${x}    In Range    0    ${len}
    \    Configure SNMPv1 on LIG    ${LIG_names[${x}]}

    ${state}    Check LI Status    ${LI}    NOT_CONSISTENT
    Update Logical Interconnect from Group    ${LI_update}
    Check IC's State

API_TC2 SNMPv1 Verify SNMPv1 Trap for ICM Reboot
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG with ICM Reboot Trap verification
    [Tags]   SNMPv1_Trap_Scenarios
    Set Log Level    Trace
    Log    \n\n Verify SNMPv1 on LIG & LI \n\n    console=True

    Verify SNMPv1 on LIG    ${LIG_names}
    Verify SNMPv1 on LI    ${LI_names}

    Clear Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}

    ${ic_list}    Get ICs
    ${len_ic} =   Get Length   ${ic_list}
    Run keyword If    ${len_ic} == '0'    FAIL    ELSE    \nLog to console and logfile  \n\n${len_ic} Nitro Interconnect modules are available\n
    #:FOR    ${x}    IN RANGE    0    ${len_ic}
    :FOR    ${x}    IN RANGE    0    1
    \    ${ic_name_list}    Create List
    \    ${ic_name}    Get From Dictionary     ${ic_list[${x}]}     name
    \    Append To List    ${ic_name_list}    ${ic_name}
    \    ${ic_uri}    Get From Dictionary     ${ic_list[${x}]}     uri
    \    ${ic_ip}    Get interconnect ip    ${ic_name}
    \    Patch Interconnect    ${INTERCONNECTS_dto[${x}]}  op=replace  path=/powerState  value=Off  timeout=60
    \    sleep    50s
    \    Patch Interconnect    ${INTERCONNECTS_dto[${x}]}  op=replace  path=/powerState  value=On  timeout=60
    \    Wait Until Keyword Succeeds    8 min    20s      IC reached state    ${ic_uri}    Configured
    \    #${ic_ip1}    Get Master IC
    \    ${test}    Verify Trap for reboot1    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${ICM_Reboot_Trap}
    \    Wait Until Keyword Succeeds    8 min    20s      IC reached state    ${ic_uri}    Configured
    Run Keyword Unless    ${test} == 'True'    Fail    msg=Traps donot match woith expected

API_TC3 SNMPv1 Verify SNMPv1 Trap for ICM Enable disable uplink and downlink ports
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG and verify Traps for port Enable Disable
    [Tags]    SNMPv1_Trap_Scenarios
    Log    \n\n Verify SNMPv1 on LIG & LI \n\n    console=True

    Verify SNMPv1 on LIG    ${LIG_names}
    Verify SNMPv1 on LI    ${LI_names}

    Clear Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}

    ${ic_list}    Get ICs
    ${len_ic} =   Get Length   ${ic_list}
    Run keyword If    ${len_ic} == '0'    FAIL    ELSE    \nLog to console and logfile  \n\n${len_ic} Nitro Interconnect modules are available\n
    #:FOR    ${x}    IN RANGE    0    ${len_ic}
    :FOR    ${x}    IN RANGE    1    2
    \    ${ic_name_list}    Create List
    \    ${ic_name}    Get From Dictionary     ${ic_list[${x}]}     name
    \    Append To List    ${ic_name_list}    ${ic_name}
    \    ${ic_uri}    Get From Dictionary     ${ic_list[${x}]}     uri
    \    ${ic_ip}    Get interconnect ip    ${ic_name}
    \    ${associatedUplinkset}    Set Variable if    '${ic_name}' == '${INTERCONNECTS[0]}'   ${Uplinksets_nitro[0]}    ${Uplinksets_nitro[1]}
    \    Set To Dictionary    ${Edit_port_body}     associatedUplinkSetUri=${associatedUplinkset}
    \    Set To Dictionary    ${Edit_port_body}     interconnectName=${ic_name}
    \    Set To Dictionary    ${Edit_port_body}     portName=${Linked_uplink_ports[0]}
    \    log    \n\n Edit Port Body ${Edit_port_body}    console=True
    \    ${resp}    Update IC Port     ${ic_name}   ${Linked_uplink_ports[0]}   ${Edit_port_body}
    \    Log    \n\nVerify trap during Enabling & Disabling Uplink Port \n    console=True
    \    ${test1}    Verify Trap for Port Status    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${link_down}
    \    Run Keyword Unless    ${test1} != 'True'    Fail    msg=Traps donot match with expected
    \    Set To Dictionary    ${Edit_port_body}     associatedUplinkSetUri=${associatedUplinkset}
    \    Set To Dictionary    ${Edit_port_body}     enabled=True
    \    log    \n\n Edit Port Body ${Edit_port_body}    console=True
    \    ${resp}    Update IC Port     ${ic_name}   ${Linked_uplink_ports[0]}   ${Edit_port_body}
    \    #${ic_ip1}    Get Master IC
    \    ${test2}    Verify Trap for Port Status1    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${link_up}
    \    Run Keyword Unless    ${test2} != 'True'    Fail    msg=Traps donot match with expected
    \    Log    \n\nVerify trap during Enabling & Disabling Downlink Port \n    console=True

    \    Set To Dictionary    ${Edit_port_body}     associatedUplinkSetUri=${associatedUplinkset}
    \    Set To Dictionary    ${Edit_port_body}        interconnectName=${ic_name}
    \    Set To Dictionary    ${Edit_port_body}     enabled=False
    \    Set To Dictionary    ${Edit_port_body}     portType=Downlink
    \    Set To Dictionary    ${Edit_port_body}     portName=${Linked_downlink_ports[0]}
    \    ${resp}    Update IC Port     ${ic_name}   ${Linked_downlink_ports[0]}   ${Edit_port_body}
    \    ${ic_ip1}    Get Master IC
    \    ${test3}    Verify Trap for Port Status1    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip1}    ${link_down}
    \    Run Keyword Unless    ${test3} != 'True'    Fail    msg=Traps donot match with expected
    \    Set To Dictionary    ${Edit_port_body}     associatedUplinkSetUri=${associatedUplinkset}
    \    Set To Dictionary    ${Edit_port_body}        interconnectName=${ic_name}
    \    Set To Dictionary    ${Edit_port_body}     enabled=True
    \    Set To Dictionary    ${Edit_port_body}     portType=Downlink
    \    Set To Dictionary    ${Edit_port_body}     portName=${Linked_downlink_ports[0]}
    \    ${resp}    Update IC Port     ${ic_name}   ${Linked_downlink_ports[0]}   ${Edit_port_body}
    \    ${ic_ip1}    Get Master IC
    \    ${test4}    Verify Trap for Port Status1    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip1}    ${link_up}
    \    Run Keyword Unless    ${test4} != 'True'    Fail    msg=Traps donot match with expected

API_TC4 SNMPv1 verify the snmpv1 attributes on LIG & LI
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG
    [Tags]    Configure_SNMPv1_on_LI_LIG
    Set Log Level    Trace

    Log    \n\n Verify readcommunity parameter on LIG\n    console=True
    ${lig_get1}    Get LIG member    ${LIG_names[0]}
    ${lig_uri}    Get Variable Value    ${lig_get1['uri']}

    Set To Dictionary    ${lig_get1}    eTag=
    Set To Dictionary    ${lig_get1}    snmpConfiguration=${snmpv1_invalid_body}
    ${resp}    fusion_api_edit_lig    body=${lig_get1}    uri=${lig_uri}
    #${task}    Wait For Task    ${resp}    60s
    Run Keyword If  '${resp['errorCode']}' == 'CRM_SNMP_CONFIGURATION_READ_COMMUNITY_MISSING'    Log to console  \nmessage: ${resp['message']}\n Expected failure\n
    ...    ELSE    FAIL

    Log to console and logfile    \n\n Verify edit LI for SNMPv1\n
    ${li_uri}    Get LI URI    ${LI_names[0]}
    ${LIURI}    LI Uri for SNMP    ${LI_names[0]}
    ${LI_edit}    Fusion Api Get Li    ${li_uri}

    Set To Dictionary    ${LI_edit}    snmpConfiguration=${snmpv1_body}
    ${resp}    fusion_api_update_li_telemetry_configuration    uri=${LIURI}    body=${LI_edit['snmpConfiguration']}
    Wait For Task2    ${resp}   timeout=2m    interval=10

    Log to console and logfile    \n\n Verify readcommunity parameter on LIG\n
    ${LI_edit}    Fusion Api Get Li    ${li_uri}
    Set To Dictionary    ${LI_edit}    snmpConfiguration=${snmpv1_invalid_body}
    ${resp}    fusion_api_update_li_telemetry_configuration    uri=${LIURI}    body=${LI_edit['snmpConfiguration']}
    Run Keyword If  '${resp['status_code']}' == '400' or '${resp['errorCode']}' == 'CRM_SNMP_CONFIGURATION_READ_COMMUNITY_MISSING'   Log to console  \n Error Message is : ${resp['message']} \n
    ...    ELSE    FAIL


API_TC5 SNMPv1 verify the snmpv1 walk on Nitro module
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG with SNMP walk
    [Tags]    SNMPv1_Trap_Scenarios

    ${resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${ADMIN_CREDS}
    Verify SNMPv1 on LIG    ${LIG_names}
    Verify SNMPv1 on LI    ${LI_names}

    Log    \n\n Verify edit LI for SNMPv1\n    console=True
    ${li_uri}    Get LI URI    ${LI_names[0]}
    ${snmp_uri}    LI Uri for SNMP    ${LI_names[0]}
    ${LI_edit}    Fusion Api Get Li    ${li_uri}

    Set To Dictionary    ${LI_edit}    snmpConfiguration=${snmpv1_body}
    ${resp}    fusion_api_update_li_telemetry_configuration    uri=${snmp_uri}    body=${LI_edit['snmpConfiguration']}
    Wait For Task2    ${resp}   timeout=2m    interval=10

    Clear Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}

    ### Code for nitro snmp walk

    ${ICM_walk_IP}    Get interconnect ip    ${INTERCONNECTS[0]}
    ${walk_command}    Replace String Using Regexp    ${snmp_walk_command}    (ICMIP)   ${ICM_walk_IP}
    Verify Nitro snmp walk    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${walk_command}    ${Nitro_walk_module}
    log to console and logfile    \n\n Code for nitro snmp walk\n

API_TC6 SNMPv1 Verify the snmpv1 on Nitro ICM for Multiple Trap receivers
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG with traps on multiple receivers
    [Tags]    SNMPv1_Trap_Scenarios

    ${resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${ADMIN_CREDS}

    Verify SNMPv1 on LIG    ${LIG_names}
    Verify SNMPv1 on LI    ${LI_names}

    Log to console and logfile    \n\n Verify edit LI for SNMPv1\n
    ${li_uri}    Get LI URI    ${LI_names[0]}
    ${snmp_uri}    LI Uri for SNMP    ${LI_names[0]}
    ${LI_edit}    Fusion Api Get Li    ${li_uri}

    Set To Dictionary    ${LI_edit}    snmpConfiguration=${trapDestination_2}
    ${resp}    fusion_api_update_li_telemetry_configuration    uri=${snmp_uri}    body=${LI_edit['snmpConfiguration']}
    Wait For Task2    ${resp}   timeout=2m    interval=10
    Log   \n\n successfully added 2 receievers for SNMPv1\n    console=True

## once IC reboot trap is finalised, add here.

    Clear Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}
    Clear Trap    ${snmp_host2}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}

    ${ic_list}    Get ICs
    ${len_ic} =   Get Length   ${ic_list}
    Run keyword If    ${len_ic} == '0'    FAIL    ELSE    \nLog to console and logfile  \n\n${len_ic} Nitro Interconnect modules are available\n
    #:FOR    ${x}    IN RANGE    0    ${len_ic}
    :FOR    ${x}    IN RANGE    1    2
    \    ${ic_name_list}    Create List
    \    ${ic_name}    Get From Dictionary     ${ic_list[${x}]}     name
    \    Append To List    ${ic_name_list}    ${ic_name}
    \    ${ic_uri}    Get From Dictionary     ${ic_list[${x}]}     uri
    \    ${ic_ip}    Get interconnect ip    ${ic_name}
    \    Log    \n\nVerify trap during Disabling Uplink Port in Receiver 1:${snmp_host} \n
    \    ${associatedUplinkset}    Set Variable if    '${ic_name}' == '${INTERCONNECTS[0]}'   ${Uplinksets_nitro[0]}    ${Uplinksets_nitro[1]}
    \    Set To Dictionary    ${Edit_port_body}     associatedUplinkSetUri=${associatedUplinkset}
    \    Set To Dictionary    ${Edit_port_body}     interconnectName=${ic_name}
    \    Set To Dictionary    ${Edit_port_body}     portName=${Linked_uplink_ports[0]}
    \    log    \n\n Edit Port Body ${Edit_port_body}    console=True
    \    ${resp}    Update IC Port     ${ic_name}   ${Linked_uplink_ports[0]}   ${Edit_port_body}
    \    ${ic_ip1}    Get Master IC
    \    ${test1}    Verify Trap for Port Status1    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip1}    ${link_down}
    \    Run Keyword Unless    ${test1} != 'True'    Fail    msg=Traps donot match with expected
    \    Log    \n\nVerify trap during Disabling Uplink Port in Receiver 2:${snmp_host2} \n
    \    ${ic_ip1}    Get Master IC
    \    ${test_1}    Verify Trap for Port Status1    ${snmp_host2}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip1}    ${link_down}
    \    Run Keyword Unless    ${test_1} != 'True'    Fail    msg=Traps donot match with expected
    \    Log to console and logfile    \n\nVerify trap during Enabling Uplink Port in Receiver 1:${snmp_host} \n
    \    Set To Dictionary    ${Edit_port_body}     associatedUplinkSetUri=${associatedUplinkset}
    \    Set To Dictionary    ${Edit_port_body}     enabled=True
    \    log    \n\n Edit Port Body ${Edit_port_body}    console=True
    \    ${resp}    Update IC Port     ${ic_name}   ${Linked_uplink_ports[0]}   ${Edit_port_body}
    \    ${ic_ip1}    Get Master IC
    \    ${test2}    Verify Trap for Port Status1   ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip1}    ${link_up}
    \    Run Keyword Unless    ${test2} != 'True'    Fail    msg=Traps donot match with expected
    \    Log    \n\nVerify trap during Enabling Uplink Port in Receiver 2:${snmp_host2} \n    console=True
    \    ${ic_ip1}    Get Master IC
    \    ${test_2}    Verify Trap for Port Status1    ${snmp_host2}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip1}    ${link_up}
    \    Run Keyword Unless    ${test_2} != 'True'    Fail    msg=Traps donot match with expected


API_TC7 SNMPv1 Verify the snmpv1 backup and restore scenario on Nitro module
    [Documentation]    Configure the SNMPv1 settings on LIG and verify UFG with Backup and Restore
    [Tags]    Configure_SNMPv1_on_LI_LIG

    ${resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${ADMIN_CREDS}

    Verify SNMPv1 on LIG    ${LIG_names}
    Verify SNMPv1 on LI    ${LI_names}

    Log    \n-Creating the backup in OV    console=True
    Create Backup           Backup failed

    Log    \n DISABLE SNMPv1 on OV for ${LI_names[0]} \n    console=True
    ${li_uri}    Get LI URI    ${LI_names[0]}
    ${snmpURI}    LI Uri for SNMP    ${LI_names[0]}
    ${LI_edit}    Fusion Api Get Li    ${li_uri}

    Set To Dictionary    ${LI_edit['snmpConfiguration']}    enabled=false
    ${resp}    fusion_api_update_li_telemetry_configuration    uri=${snmpURI}    body=${LI_edit['snmpConfiguration']}
    Wait For Task2    ${resp}   timeout=2m    interval=10

    Log     \n\nRestoring from the backup in the appliance    console=True
    Restore Appliance
    Sleep   5 min
    Fusion Api Login Appliance     ${APPLIANCE_IP}    ${ADMIN_CREDS}

    Log     \nVerifying whether snmpv1 is enabled after restore\n    console=True
    ${li_uri}    Get LI URI   ${LI_names[0]}
    ${LI_edit}    Fusion Api Get Li    ${li_uri}
    ${LI_edit_snmp}    Get Variable Value    ${LI_edit['snmpConfiguration']}
    Log    \nSNMPv1 configuration after restore is ${LI_edit_snmp['enabled']}\n    console=True

    Run Keyword Unless  '${LI_edit_snmp['enabled']}' != 'true'    Fail    msg=SNMPv1 configurations not restored properly\n
    Verify SNMPv1 on LIG    ${LIG_names}
    Verify SNMPv1 on LI    ${LI_names}
    Log    \nverified SNMPv1 configuration after restore Successfully!!\n    console=True


# If needed
# \    Efuse IC and Wait    ${ic_name}    ${efuse_action[0]}
# \    Efuse IC and Wait    ${ic_name}    ${efuse_action[1]}


*** Keywords ***
Presetup for Nitro
    [Documentation]    Presetup for Nitro OVF3626
    Log    \n Clean up the OV    console=True
    Set Log Level    Trace
    ${resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${ADMIN_CREDS}
    Clean OV
    Add Ethernet Networks from variable    ${Enet_nitro}
    ## Includes sampling
    Add LIG from variable    ${lig_Nitro}
    Add Enclosure Group and Verify    ${enc_group}
    Add Logical Enclosure from variable    ${LE_Nitro}

    :FOR     ${IC}   IN   @{INTERCONNECTS}
    \   ${ic_uri} =    Get IC URI    ${IC}
    \   Wait Until Keyword Succeeds   10 min    10s    IC reached state    ${ic_uri}    Configured
    \    Sleep    2min
    \   ${resp}=    Fusion Api Get Interconnect    param=?filter="'name'=='${IC}'"
    \  ${state}=     Get From Dictionary     ${resp['members'][0]}   state
    \  Run Keyword If    '${state}' != 'Configured'      fail      msg="The IC module ${IC} is not in configured state"
    \   ...     ELSE   Log to console and logfile    \n The IC module ${IC} is in configured state

Clean OV
    [Documentation]    Cleans the appliance
    Log    \nCleaning the OV    console=True
    Power off ALL Servers    PressAndHold
    Remove All Server Profiles
    Remove All LEs
    Remove All Enclosure Groups
    Remove ALL LIGs
    Remove ALL Ethernet Networks
    Remove ALL FC Networks
    Remove ALL FCoE Networks
    Remove ALL Network Sets

Get ICs
    [Documentation]  Get IC
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =  Get Length  ${ics}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \   Run Keyword If  '${ic['model']}' != '${ICM_MODEL}'      Continue For Loop
    \   Append to list      ${ic_list}  ${ic}
    [Return]    ${ic_list}


Verify Trap for reboot1
    [Documentation]  Verify trap for reboot new keyword
    [Arguments]    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${trap}
    Set Log Level    TRACE
    ${trap_output}   Get Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}
    #${trap_output}   Get Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}
    ${traps}=    Split String    ${trap_output}     public
    ${length}=  Get Length    ${traps}

    :FOR    ${x}    IN RANGE    0    ${length}
    \   ${status}=   Run Keyword And Return Status    Should Contain        ${traps[${x}]}     ${ic_ip}
    \   ${status1}=    Run Keyword And Return Status    Should Contain      ${traps[${x}]}     ${trap}
    \   Run keyword If    '${status}' == 'True' or '${status1}' == 'True'    Exit For Loop    ELSE      Continue For Loop

Verify Trap for Port Status1
    [Documentation]    Verify Trap for Port Status
    [Arguments]    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${trap}

    ${trap_output}   Get Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}
    ${traps}=    Split String    ${trap_output}     public
    ${length}=  Get Length    ${traps}

    :FOR    ${x}    IN RANGE    0    ${length}
    \   ${status}=   Run Keyword And Return Status    Should Contain        ${traps[${x}]}     ${ic_ip}
    \   ${status1}=    Run Keyword And Return Status    Should Contain      ${traps[${x}]}     ${trap}
    \   Run keyword If    '${status}' == 'True' or '${status1}' == 'True'    Exit For Loop    ELSE      Continue For Loop


Verify Trap for Port Status
    [Documentation]    Verify Trap for Port Status
    [Arguments]    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${trap}

    ${trap_output}   Get Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}
    ${IC_trap}    Get Lines Containing String    ${trap_output}    ${trap}
    Log to console    \nThe Trap Output ${trap_output} \n
    Log to console    \nThe IC_trap Output ${IC_trap} \n
    ${lines1}    Should contain   ${trap_output}    ${ic_ip}
    ${lines2}    Should contain   ${trap_output}    ${trap}
    ${match}    ${Trap_match}    Should Match Regexp  ${IC_trap}  \\s+(Link+\\s+Down+\\s+Trap)
    Log to console and log file    \n\n ${trap} & ${ic_ip} are present in the trap output\n
    [Return]    True

Verify Nitro snmp walk
    [Documentation]    Verify Nitro SNMPv1 Walk command
    [Arguments]    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${walk_command}    ${Nitro_walk_module}
    My Open Connection And Log In    ${snmp_host}    ${snmp_user}    ${snmp_pass}
    #Login               ${snmp_user}     ${snmp_pass}
    SSHLibrary.Write    ${walk_command}
    sleep    5s
    ${output}    SSHLibrary.Read
    ${match1}    ${match2}    Should Match Regexp    ${output}    sysDescr.0 = STRING: (VC.*Module)
    Run Keyword Unless    '${match2}' == '${Nitro_walk_module}'    Fail    msg=SNMPv1 walk command failed


Get interconnect ip
    [Documentation]    Fetch IC IPs
    [Arguments]     ${ic}
    ${resp} =   Fusion Api Get Interconnect         param=?filter="'name'=='${ic}'"
    ${interconnectIP} =     Get From Dictionary     ${resp['members'][0]}   ipAddressList
    ${len}    Get Length    ${interconnectIP}
    :For    ${x}    In Range    0    ${len}
    \    ${value}    Run Keyword If   '${interconnectIP[${x}]['ipAddressType']}' == 'Ipv4Dhcp'    Get Variable Value    ${interconnectIP[${x}]['ipAddress']}    ELSE    Continue For Loop
    #\    ${value}    Run Keyword If      '${interconnectIP[${x}]['ipAddressType']}' == 'Ipv4'    Get Variable Value    ${interconnectIP[${x}]['ipAddress']}    ELSE    Continue For Loop
    Log to console    \n the interconnect ip is :${value}\n
    [Return]    ${value}


Verify SNMPv1 on LIG
    [Documentation]    Verify SNMPv1 value on LIG
    [Arguments]    ${LIG_names}
    ${len}    Get Length    ${LIG_names}
    :For    ${x}    In Range    0    ${len}
    \    ${lig_get}    Get LIG member    ${LIG_names[${x}]}
    \    ${lig_snmp}    Get Variable Value    ${lig_get['snmpConfiguration']}
    \    Run Keyword Unless    ${lig_snmp['enabled']} != 'True'    Fail    msg=\nSNMPv1 configuration on LIG ${LIG_names[${x}]} is absent!!\n
    [Return]    ${lig_snmp}

Verify SNMPv1 on LI
    [Documentation]    Verify SNMPv1 value on LI
    [Arguments]    ${LI_names}
    ${len}    Get Length    ${LI_names}
    :For    ${x}    In Range    0    ${len}
    \    ${li_uri}    Get LI URI    ${LI_names[${x}]}
    \    ${li_get}    Fusion Api Get Li    ${li_uri}
    \    ${li_snmp}    Get Variable Value    ${li_get['snmpConfiguration']}
    \    Run Keyword Unless    ${li_snmp['enabled']} != 'true'    Fail    msg=\nSNMPv1 configuration on LIG ${LI_names[${x}]} is absent!!\n
    [Return]    ${li_snmp}

Configure SNMPv1 on LIG
    [Documentation]    Setup SNMPv1 on LIG
    [Arguments]    ${LIG}
    ${lig_get}    Get LIG member    ${LIG}
    ${lig_uri}    Get Variable Value    ${lig_get['uri']}

    Set To Dictionary    ${lig_get}    eTag=
    Set To Dictionary    ${lig_get}    snmpConfiguration=${snmpv1_body}

    ${resp}    fusion_api_edit_lig    body=${lig_get}    uri=${lig_uri}
    Wait For Task2    ${resp}   timeout=2m    interval=10

LI Uri for SNMP
    [Documentation]    Fetch LI Uri for SNMP
    [Arguments]    ${LI_name}    ${snmp_config}=snmp-configuration
    ${li_uri}    Get LI URI   ${LI_name}
    ${LI}    Fusion Api Get Li    ${li_uri}
    ${uri}    Get From Dictionary    ${LI}    uri
    ${LI_uri}    Catenate    SEPARATOR=/    ${uri}    ${snmp_config}
    [Return]    ${LI_uri}

Clear Trap
    [Documentation]    clear old traps
    [Arguments]    ${host}    ${user}   ${pass}    ${path}    ${file}
    My Open Connection And Log In    ${host}    ${user}    ${pass}
    Write     cd /${path}
    Write    > ${file}
    Close All Connections
    log to console    \n Cleared the trap messages

Get Trap
    [Documentation]    Opens the Trap receiver machine to verify the trap
    [Arguments]    ${host}    ${user}   ${pass}    ${path}    ${file}
    My Open Connection And Log In    ${host}    ${user}    ${pass}
    Login               ${snmp_user}     ${snmp_pass}
    Write     cd /${path}
    #Write    cat ${file}
    Write    tail -f -n 20 ${file}
    Sleep    10s
    ${output}    Read
    Close All Connections
    [Return]    ${output}

Check IC's State
    [Documentation]    Check IC's State
    ${ic_list}    Get ICs
    ${len}    Get Length    ${ic_list}
    :For    ${x}    In Range    0    ${len}
    \    ${state}    Get From Dictionary    ${ic_list[${x}]}    state
    \    log to console    \n The iC's state are : ${state}\n
    \    Should Be Equal As Strings    ${state}    ${IC_state}
    \    log to console    \n The IC: ${ic_list[${x}]['productName']} is in Configured State\n

My Open Connection And Log In
    [Documentation]    Opens an SSH session to an appliance and logs in
    [Arguments]        ${host}=localhost   ${user}=root   ${pass}=hpvse1

    # The ssh prompt may be set by other Fusion keywords through Set Default Configuration
    # set the expected ssh prompt for this connection
    Open Connection    ${host}    timeout=120s
    Login               ${user}    ${pass}

Get Master IC
    [Documentation]  Get IC
    ${resp} =   fusion api get interconnect
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =  Get Length  ${ics}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${icx} =     Get From List   ${ics}    ${x}
    \   ${ic_ip}    Run Keyword If  '${icx['stackingDomainRole']}' == 'Master'     Get interconnect ip    ${icx['name']}    ELSE    Continue For Loop
     [Return]    ${ic_ip}


Verify Trap for reboot
    [Documentation]    Verify Trap for IC reboot
    [Arguments]    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}    ${ic_ip}    ${trap}
    Set Log Level    TRACE
    ${trap_output}   Get Trap    ${snmp_host}    ${snmp_user}    ${snmp_pass}    ${snmp_path}    ${snmp_file}
    ${IC_trap}    Should contain    ${trap_output}    ${ic_ip}
    ${IC_trap}    Get Lines Containing String    ${trap_output}    ${trap}
    Log to console    \nThe Trap Output ${IC_trap} \n
    ${lines1}    Should contain   ${IC_trap}    ${ic_ip}
    Log to console    \nThe Trap Output contains the required IC IP for IC reboot\n
    #${lines2}    Should Match Regexp    ${trap_output}    MIB::rmon ${tr}
    Log to console    \nThe Trap Output contains Enterprise Specific Trap for the given IC Operation\n
    [Return]    True
