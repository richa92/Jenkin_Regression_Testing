***Settings***
Documentation    OVF5608_keywords
Library             RoboGalaxyLibrary
Library             FusionLibrary
Library             OperatingSystem
Library             BuiltIn
Library             Collections
Library             SSHLibrary
Library             String
Library             Telnet
Resource            ../../../../../Resources/api/fusion_api_resource.txt

***Keywords***
Get Server Ip Windows
    [Documentation]    Gets the valid ip of the server.
    [Arguments]         ${ilo_details}
    Log     \nstdout is ${ilo_details}    console=True
    ${serverip_List}=   Create List
    ${serverip_List1}=   Create List
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=20s
    ${login}    SSHLibrary.Login               ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Read Until    SAC>
    Sleep    5sec
    SSHLibrary.Write    i
    Sleep    5sec
    ${stdout}    SSHLibrary.Read
    Log    \nstdout is ${stdout}    console=True
    ${cmd_output}=    Get Regexp Matches    ${stdout}    Ip=172\\.\\d+\\.\\d+\\.\\d+
    Log    \nstdout is ${cmd_output}    console=True
    ${ip_list_new}    Create List
    ${len}    Get Length    ${cmd_output}
    :FOR    ${x}    IN RANGE    ${len}
    \    ${ip_lists}    Remove String    ${cmd_output[${x}]}    Ip=
    \    Log     ip is ${ip_lists}    console=True
    \    Append To List   ${ip_list_new}    ${ip_lists}
    Log     \n IP's are is ${ip_list_new}    console=True
    ${cmd_output1}=    Get Regexp Matches    ${stdout}    Gateway=172\\.\\d+\\.\\d+\\.\\d+
    Log    \nstdout is ${cmd_output1}     console=True
    ${gateway_ip}    Remove String    ${cmd_output1[0]}    Gateway=
    SSHLibrary.Close All Connections
    [Return]    ${ip_list_new}    ${gateway_ip}

checking existing and additional counters
    [Documentation]    checking existing and additional counters
    [Arguments]     ${IC}    ${stats}    ${uplinkport}    ${counters}
    Set Log Level    TRACE
    Log    \nFetch ic uri    console=True
    ${uri} =    Get IC URI    ${IC}
    ${uplink_uri}    Catenate    ${uri}/${stats}/${uplinkport}
    Log    \n\nUplinkuri${uplink_uri}    console=True
    ${resp}     Fusion Api Get Interconnect     ${uplink_uri}
    Log    \n\nresponse${resp}    console=True
    ${fc_keys}    Get From Dictionary    ${resp}    fcStatistics
    Log    \n\n fcport statistics${fc_keys}    console=True
    ${fc_extendedstat}    Get From Dictionary    ${fc_keys}     extendedStatistics
    Log    \n\n fcport extended statistics${fc_extendedstat}    console=True
    ${keys}    Get Dictionary Keys    ${fc_extendedstat}
    Log    \n\n fcport keys${keys}    console=True
    ${l}    Get Length    ${counters}
    :FOR    ${x}    IN RANGE    0    ${l}
    \    List Should Contain Value    ${keys}    ${counters[${x}]}
    [Return]    ${fc_extendedstat}

Validating FC Counter Values
    [Documentation]    Validating FC Counter Values
    [Arguments]     ${IC}    ${stats}    ${uplinkport}    ${counters}    ${FC_counters}
    Set Log Level    TRACE
    ${counter_values}    Create List
    ${len}    Get Length     ${FC_counters}
    ${fc_keys}    checking existing and additional counters     ${IC}    ${stats}    ${uplinkport}    ${counters}
    : FOR    ${x}    IN RANGE    0    ${len}
    \    Append To List    ${counter_values}    ${fc_keys['${FC_counters[${x}]}']}
    \    Log    Value of ${FC_counters[${x}]} is ${counter_values[${x}]}    console=True
    [Return]     ${counter_values}

Verify If Counters are Increased
    [Documentation]    checking existing and additional counters
    [Arguments]     ${counter_values_initial}    ${counter_values_final}
    Set Log Level    TRACE
    Log    \nVerify counters are increased    console=True
    ${len}    Get Length    ${counter_values_initial}
    : FOR    ${x}    IN RANGE    0    ${len}
    \    ${diff}    Evaluate    ${counter_values_final[${x}]} - ${counter_values_initial[${x}]}
    \    Run Keyword If    ${diff} > 10000        Log    \n\nThe counter values are increased after passing traffic    console=True    ELSE    Fail    Log    \n\nthe values are not increased after passing traffic   console=True

Validate If Counters are not increased
    [Documentation]    Validate If Counters are not increased
    [Arguments]     ${IC_ports}    ${Interconnect_name}    ${counters}    ${FC_counters}    ${stats}
    Set Log Level    TRACE
    ${counter_values_initial}    Validating FC Counter Values    ${Interconnect_name}    ${stats}    ${IC_ports}    ${counters}    ${FC_counters}
    Sleep    120sec
    ${counter_values_final}    Validating FC Counter Values    ${Interconnect_name}    ${stats}    ${IC_ports}    ${counters}    ${FC_counters}
    ${len}    Get Length    ${counter_values_initial}
    : FOR    ${x}    IN RANGE    0    ${len}
    \    Run Keyword If    ${counter_values_final[${x}]} <= ${counter_values_initial[${x}]}        Log    \n\nThe counter values are not increased    console=True    ELSE    Fail    Log    \n\nthe values are not increased after passing traffic   console=True

Validate If Counters are zero
    [Documentation]    Validate If Counters are Zero
    [Arguments]     ${IC_ports}    ${Interconnect_name}    ${counters}    ${FC_counters}    ${stats}
    ${counter_values}    Validating FC Counter Values    ${Interconnect_name}    ${stats}    ${IC_ports}    ${counters}    ${FC_counters}
    ${len}    Get Length    ${counter_values}
    : FOR    ${x}    IN RANGE    0    ${len}
    \    Run Keyword If    ${counter_values[${x}]} <= 0        Log    \n\nThe counter values are not increased    console=True    ELSE    Fail    Log    \n\nthe values are not increased after passing traffic   console=True

Verify Port Status
    [Documentation]    Verifying the port status
    [Arguments]     ${uri}    ${portName}    ${verify}    ${status}
    ${port_status}    Get IC Port    ${uri}    ${portName}
    Should be Equal As Strings    ${port_status['${verify}']}    ${status}

Get IC Port
    [Documentation]    Returns the port info of the named port of specified interconnect uri
    [Arguments]     ${uri}    ${portName}
    ${return} =    Create List
    ${resp} =    fusion api get interconnect ports    uri=${uri}
    ${ports} =    Get From Dictionary    ${resp}    members
    :FOR    ${port}    IN    @{ports}
    \    ${return} =    Run Keyword If    '${port['portName']}' == '${portName}'    set variable    ${port}
    \    Exit for loop if    '${port['portName']}' == '${portName}'
    [Return]    ${return}

Clear Port Counters
    [Documentation]    Clear Port Counters
    [Arguments]     ${IC}
    ${IC_uri}    Get IC URI    ${IC}
    Log to console    ${IC_uri}
    ${body}    Create Dictionary
    ${Resp}    Fusion Api clear Interconnect Ports    ${body}    ${IC_uri}
    Run Keyword If  '${Resp['status_code']}' != '202'  Fail    ELSE  log to console   \n-Port counters cleared Successfully
    Sleep    2min

Verify Port
    [Documentation]    Verify the named port of specified interconnect uri has the optional expected attribute values
    [Arguments]    ${uri}    ${portName}    ${status}=${None}    ${portStatus}=${None}
    ...            ${portStatusReason}=${None}    ${opSpeed}=${None}    ${enabled}=${None}
    ...            ${loginsCount}=${None}    ${connectedTo}=${None}

    ${resp} =    Get IC Port    ${uri}    ${portName}
    Should Not Be Empty    ${resp}

    # for optional kw arguments. If not specified, do not check
    Run Keyword IF    '${status}' != '${None}'
    ...               Should be Equal As Strings    ${resp['status']}    ${status}
    Run Keyword IF    '${portStatus}' != '${None}'
    ...               Should be Equal As Strings    ${resp['portStatus']}    ${portStatus}
    Run Keyword IF    '${portStatusReason}' != '${None}'
    ...               Should be Equal As Strings    ${resp['portStatusReason']}    ${portStatusReason}
    Run Keyword IF    '${opSpeed}' != '${None}'
    ...               Should be Equal As Strings    ${resp['operationalSpeed']}    ${opSpeed}
    Run Keyword IF    '${enabled}' != '${None}'
    ...               Should be Equal As Strings    ${resp['enabled']}    ${enabled}
    Run Keyword IF    '${loginsCount}' != '${None}'
    ...               should be equal as Integers    ${resp['fcPortProperties']['loginsCount']}    ${loginsCount}
    Run Keyword IF    '${connectedTo}' != '${None}'
    ...               Should be Equal As Strings    ${resp['fcPortProperties']['principleInterconnectName']}
    ...                                             ${connectedTo}

Get Interconnect StackingDomainRole
    [Documentation]    Fetches PLUGGABLE MODULE INFORMATION
    [Arguments]     ${ic_name}    ${expected_role}
    ${resp} =   Get Interconnect    ${ic_name}
    ${Role}    Get From Dictionary    ${resp}    stackingDomainRole
    Should Be Equal As Strings    ${Role}    ${expected_role}
    [Return]    ${Role}

Suite Setup Tasks
    [Documentation]    Suite Setup Tasks
    ${Login_response}    Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}
    Run keyword unless    ${Login_response[0]['status_code']}== 200    Fail    "Unable to Login Appliance"
    Log    \n\n Cleaning up the appliance     console=True
    Power off ALL servers    PressAndHold
    Remove All Server Profiles
    Remove All LEs
    Remove All Enclosure Groups
    Remove All LIGs
    Remove All FCoE Networks
    Remove All Ethernet Networks
    Remove All FC Networks

    Log    \n\n Creating Ethernet network    console=True
    Add Ethernet Networks from variable    ${ethernet_networks}

    Log    \n\n -Creating FC Networks    console=True
    Add FC Networks from variable    ${fc_netowrks}

    Log   \n\n Creating LIG    console=True
    Add LIG from variable    ${ligs['LIG']}

    Log     \n\nCreating EG    console=True
    ${resp} =    Add Enclosure Group from variable    ${enc_group['EG']}
    Run Keyword If  ${resp['status_code']} != 201    fail    msg=\nUnable to create EG
    ...         ELSE    log    \nsuccessfully created EG

    Log     \n\n Creating LE     console=True
    Add Logical Enclosure from variable    ${LE_Nitro['LE']}

    Log     \n\nVerifying the interconnects are in configured state     console=True
    :FOR    ${x}    IN    @{Interconnect_dto}
    \    Verify Interconnect    ${x}    state=Configured
    Sleep    2min

    Log    \n\nVerifying the ports are linked     console=True
    Verify Port    ${ICM3_uri}    ${FA_PORTS[0]}    status=OK    portStatus=Linked    opSpeed=Speed32G
    Verify Port    ${ICM6_uri}    ${FA_PORTS[1]}    status=OK    portStatus=Linked    opSpeed=Speed32G
    Verify Port    ${ICM3_uri}    ${DA_PORTS[0]}    status=OK    portStatus=Linked    opSpeed=Speed16G
    Verify Port    ${ICM6_uri}    ${DA_PORTS[1]}    status=OK    portStatus=Linked    opSpeed=Speed16G

Counter Value Validation
    [Documentation]    Validation
    [Arguments]     ${IC_ports}    ${Interconnect_name}    ${counters}    ${FC_counters}    ${sample_interval_time}
    ${len}    Get Length    ${IC_ports}
    :For    ${x}    IN RANGE    0    ${len}
    \    ${fcport_keys}    checking existing and additional counters    ${Interconnect_name}    ${stats}    ${IC_ports[${x}]}    ${counters}
    \    Log    \n\n successfully validated existing and additional counters    console=True

    ${len}    Get Length    ${IC_ports}
    :For    ${x}    IN RANGE    0    ${len}
    \    ${counter_values_initial}    Validating FC Counter Values    ${Interconnect_name}    ${stats}    ${IC_ports[${x}]}    ${counters}    ${FC_counters}
    \    Sleep     ${sample_interval_time}
    \    ${counter_values_final}    Validating FC Counter Values    ${Interconnect_name}    ${stats}    ${IC_ports[${x}]}    ${counters}    ${FC_counters}
    \    Verify If Counters are Increased    ${counter_values_initial}    ${counter_values_final}

Get Statistics
    [Documentation]    checking existing and additional counters
    [Arguments]     ${IC}    ${stats}
    [Tags]  add   POSITIVE
    Set Log Level    TRACE
    ${uri} =    Get IC URI    ${IC}
    ${uplink_uri}    Catenate    ${uri}/${stats}
    Log    \n\nUplinkuri${uplink_uri}    console=True
    ${resp}     Fusion Api Get Interconnect     ${uplink_uri}
    [Return]    ${resp}

Get IP In a List
    [Documentation]    checking existing and additional counters
    [Arguments]     ${ilo_details}
    ${ip_list1}    Create List
    ${ip_list2}    Create List
    ${l}     Get Length    ${ilo_details}
    :FOR    ${x}    IN RANGE    0    ${l}
    \    ${IP}    ${gate_ip}    Get Server Ip Windows    ${ilo_details[${x}]}
    \    Append to List    ${ip_list1}    ${IP[0]}
    \    Append to List    ${ip_list2}    ${IP[1]}
    [Return]    ${ip_list1}    ${ip_list2}

Execute Traffic In Servers
    [Documentation]    checking existing and additional counters
    [Arguments]     ${ilo_details}    ${ip_list}    ${server_details}    ${kill_diskspd}    ${diskspd_cmd}
    ${l}     Get Length    ${ilo_details}
    :FOR    ${x}    IN RANGE    0    ${l}
    \    ${out}    execute_traffic    ${ip_list[${x}]}    ${server_details['username']}    ${server_details['password']}    ${kill_diskspd}
    \    Sleep    60sec
    \    execute_traffic    ${ip_list[${x}]}    ${server_details['username']}    ${server_details['password']}    ${diskspd_cmd[${x}]}

Restore From Backup
    [Documentation]    Restore From Backup
    ${status}=    Set Variable    ${EMPTY}
    ${Response}=    Fusion Api Get Backup
    Run keyword If    ${Response['status_code']} != 200    Fail     msg="Failed to Get the latest backup"
    ${restore_body}=   Create Dictionary    type=RESTORE
    ...                                     uriOfBackupToRestore=${Response['members'][0]['uri']}
    ${output}=    Fusion Api Restore Backup    ${restore_body}
    Run keyword If    ${output['status_code']} != 202    Fail      msg="Failed to perform the restore from backup operation"
    Sleep    10min
    ${restore_resp}=     Fusion Api Get Restore Status
    Run keyword If    ${restore_resp['status_code']} != 200    fail    msg="Failed to get the restore details"
    :FOR   ${index}   IN RANGE   ${restore_resp['count']}
    \   Run Keyword If    '${restore_resp['members'][${index}]['backupIdToRestore']}' != '${Response['members'][0]['id']}'   Continue For Loop
    \   ${restore_id} =    Set Variable    ${restore_resp['members'][${index}]['id']}
    :FOR   ${index}   IN RANGE   100
    \   sleep   300sec
    \   log      "Restoring is in Progress..."
    \   ${resp}=    Fusion Api Get Restore Status    param=?filter="'id'=='${restore_id}'"
    \   Run keyword If     ${resp['status_code']}!= 200     Fail      msg="Unable to get the restore id details"
    \   Run Keyword If     '${resp['members'][0]['restorePhase']}' != 'COMPLETED'    Continue For Loop
    \   ${status} =    Set Variable    ${resp['members'][0]['status']}
    \   Run Keyword If   '${resp['members'][0]['restorePhase']}' == 'COMPLETED'    Exit For Loop
    Should Be Equal    ${status}    SUCCEEDED
    log     \nRestore process got succeeded

Get Profiles
    [Documentation]    Get Profiles
    ${resp} =             fusion api get server profiles
    ${profiles} =         Create List
    ${profile_list} =     Get From Dictionary     ${resp}    members
    ${l} =  Get Length  ${profile_list}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${profile} =     Get From List   ${profile_list}    ${x}
    \   ${profile_details} =    Create Dictionary     name=${profile['name']}
    \   ...                                           uri=${profile['uri']}
    \   ...                                           state=${profile['state']}
    \   ...                                           status=${profile['status']}
    \   ...                                           serverHardwareUri=${profile['serverHardwareUri']}
    \   append to list    ${profiles}   ${profile_details}
    [Return]    ${profiles}

Unassign profiles
    [Documentation]    Unassign profiles
    [Arguments]     ${profiles}
    Set Log Level   TRACE
    Log to console   \nUnassigning profiles....
    :FOR    ${p}    IN    @{profiles}
    \   ${profile} =    Fusion Api Get Resource    uri=${p['uri']}
    \   set to dictionary    ${profile}   serverHardwareUri=${None}
    \   set to dictionary    ${profile}   enclosureBay=${None}
    \   set to dictionary    ${profile}   enclosureUri=${None}
    \   remove from dictionary    ${profile}   status_code    headers
    \   ${resp} =   fusion api edit server profile    uri=${p['uri']}   body=${profile}
    \   ${task} =   Wait For Task   ${resp}     6m   15s
    ${valDict} =        Create Dictionary   status_code=${200}
    ...                                     taskState=Completed
    Validate Response   ${task}    ${valDict}

Re-assign profiles
    [Documentation]    Re-assign profiles
    [Arguments]     ${profiles}    ${param}=?force=ignoreServerHealth
    Set Log Level   TRACE
    Log to console   \nRe-assigning profiles....
    :FOR    ${p}    IN    @{profiles}
    \   ${profile} =    Fusion Api Get Resource    uri=${p['uri']}
    \   set to dictionary    ${profile}   serverHardwareUri=${p['serverHardwareUri']}
    \   remove from dictionary    ${profile}   status_code    headers
    \   ${resp} =   fusion api edit server profile    uri=${p['uri']}   body=${profile}    param=${param}
    \   ${task} =   Wait For Task   ${resp}     6m   15s
    ${valDict} =        Create Dictionary   status_code=${200}
    ...                                     taskState=Completed
    Validate Response   ${task}    ${valDict}