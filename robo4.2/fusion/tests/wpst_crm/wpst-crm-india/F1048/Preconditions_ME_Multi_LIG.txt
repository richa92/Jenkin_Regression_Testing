*** Settings ***
Documentation        Feature Test: F1048
...                  Updated test to include all network type: Ethernet Tunnel networks
...        
Variables              data_variables.py        
#Suite Setup           Run FTS and test-specific setup
#Suite Teardown        Suite Teardown
Resource               C:/LATEST_25_04_2016/fusion/tests/wpst_crm/resources/resource.txt
Library                Collections
Library                json
Library                OperatingSystem
Library                Selenium2Library
Library                apic.py
Test Setup             Load Test Data

*** Variables ***
${SSH_PASS}                     hpvse1
${DataFile}            ./OVAData.xml
${APPLIANCE_IP}                    15.212.137.16
#${X-API-VERSION}                201
${APIC_APPLIANCE_IP}            10.10.3.71
${li_1}                          LE-LIG
${li_2}                          LE-LIG1
${lig_1}                        LIG
${lig_2}                        LIG1    
${RTtrue}                    True
${TLtrue}                     True
${RTfalse}                     False
${TLfalse}                     False
${LLDPEnabledIP_li_1}                     15.212.137.21
${LLDPEnabledIP_li_2}                     15.212.137.20
${LLDPDisabledIP}                     
${RECALCIP_li_1}                    15.212.137.23
${RECALCIP_li_2}                    15.212.137.22
${LLDPEnabledIP_IPv6_li_1}    fe80::5eb9:1ff:fe28:c369
${LLDPEnabledIP_IPv6_li_2}    fe80::5eb9:1ff:fe47:ba59
${RECALCIP_IPv6_li_1}        fe80::5eb9:1ff:fe28:e16e
${RECALCIP_IPv6_li_2}        fe80::5eb9:1ff:fe47:b38d
${APIC_IPList_disabled_li_1}    15.212.137.23,15.212.137.21
${APIC_IPList_enabled_li_1}       15.212.137.21
${APIC_IPList_Bay1Off_li_1}       15.212.137.23
${APIC_IPList_disabled_li_2}    15.212.137.22,15.212.137.20
${APIC_IPList_enabled_li_2}        15.212.137.20
${APIC_IPList_Bay1Off_li_2}        15.212.137.22
${APIC_HOST}                     10.10.3.71
${APIC_USER}                    admin
${APIC_PASS}                    password
${ICM_NAME}           IRTQI6MH9D, interconnect 3
${POWER_STATE_OFF}    Off
${POWER_STATE_ON}        On
#${ICM_NAME}                    IRTQI6MH9D, interconnect 3
#${ICM_NAME}                    EM1FFFF600, interconnect 3
#${bay}                        3
${enc_serial}        IRTQI6MH9D
${bay_1}             2
${bay_2}                        3
${FUSION_NIC}                bond0
${FUSION_IP}                15.212.137.16
${FUSION_SSH_USERNAME}        root
${FUSION_SSH_PASSWORD}        hpvse1
${FUSION_PROMPT}            #
${FUSION_TIMEOUT}            10
${State_Power_Off}             Maintenance
${State_Power_On}             Configured
${ICM_1}                     IRTQI6MH9D, interconnect 3
${ICM_2}                     EM1FFFF600, interconnect 6
${ICM_3}                     IRTQI6MH9D, interconnect 2
${ICM_4}                     EM1FFFF600, interconnect 5
${Value}                    15.212.137.0



*** Test Cases ***
00 Appliance LogIn        
    Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}
    ${users} = Get Variable Value ${users}
    Run Keyword If  ${users} is not ${null}    Add Users from variable              ${users}
    ${ethernet_networks} =    Get Variable Value    ${ethernet_networks1}
    Run Keyword If    ${ethernet_networks1} is not ${null}    Add Ethernet Networks from variable    ${ethernet_networks1}
    
    
    #CREATE SUBNET-15.212.137.0
	${sub} =		Build SUBNET Body		${subnet}   	15.212.137.0
	log to console     \n\nSubnet: ${sub}
	${resp} = 			fusion_api_create_ipv4_subnet	 body=${sub}
	log to console     \n\nResponse is : ${resp}	
	${valDict} = 	Create Dictionary	status_code=${200}
	Validate Response	${resp}	${valDict}

	#CREATE RANGE-15.212.137.0
	${range}=   Build IPRange Body    	${ipv4ranges}      15.212.137.0		Test
	log to console     \n\nResponse is : ${range}
	:For  ${x}  in  @{range}
	\   ${resp}=  fusion_api_create_ipv4_range   	${x}
	\   ${valDict} = 	Create Dictionary		status_code=${200}
	\	log to console     \n\nDict is ${valDict}
	\   Validate Response	${resp}	${valDict}  

00 Create LIG         
    #Create LIG, create enclosure group and import enclosure
    #create Logical INterconnect group -LIG
    [Tags]  14    
    Log to console    Create LIG group
    ${body} =   Build LIG body      ${ligs_tbird_ME_Multi_LIG['lig1']}
    Log to console        ${body}        
    ${resp} =     Fusion Api Create LIG    ${body}
    Log to console        ${resp}
    ${task} =    Wait For Task    ${resp}     60s    2s
    Log to console        ${task}
    Log to console    Created LIG successfully
    
    #create Logical Interconnect group -LIG1
    [Tags]  14    
    Log to console    Create LIG group
    ${body} =   Build LIG body      ${ligs_tbird_ME_Multi_LIG['lig2']}
    Log to console        ${body}        
    ${resp} =     Fusion Api Create LIG    ${body}
    Log to console        ${resp}
    ${task} =    Wait For Task    ${resp}     60s    2s
    Log to console        ${task}
    Log to console    Created LIG successfully

00 Create Range and EnclosureGroup     
    #Create Enclosure GrouP    
    Log to console    Create Enclosure group
    ${subnets} =        Get Subnet        ${Value}    
    Log         \n\n subnet is ${subnets}
    ${uri} =            Get from Subnet                ${subnets}            uri
    ${resp} =   fusion api get ipv4 subnet        uri=${uri}
    ${rangeuri} =     Get From Dictionary     ${resp}    rangeUris
    Log        ${rangeuri}
    ${enc_body} =        Create EG Body with Associate Range     ${enc_group_tbird_Multi_LIG}        EGLldp            ${rangeuri}
    Log    ${enc_body}
    ${resp} =        Fusion Api Create Enclosure Group    ${enc_body}
    Log    ${resp}
    ${valDict} =     Create Dictionary    status_code=${201}
    Validate Response    ${resp}    ${valDict}
    Fusion Api Logout Appliance           

00 Create LE  
    Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}
    ${les} =    Get Variable Value    ${les_tbird_Multi_LIG}
    Log to console and logfile    \n\n${les}
    Run Keyword If    ${les} is not ${null}                    Run Keyword for List    ${les}      Add Logical Enclosure from variable
    
    
     Wait Until Keyword Succeeds    1200 s    10 s    Verify Interconnect State    ${ICM_1}    ${State_Power_On}
     Wait Until Keyword Succeeds    1200 s    10 s    Verify Interconnect State    ${ICM_2}    ${State_Power_On}          
     Wait Until Keyword Succeeds    1200 s    10 s    Verify Interconnect State    ${ICM_3}    ${State_Power_On}
     Wait Until Keyword Succeeds    1200 s    10 s    Verify Interconnect State    ${ICM_4}    ${State_Power_On}

00 Create ServerProfiles                   
    #Create server profile and ping blade        
    Power off ALL servers
    #Log to console    \n Hai-1
    ${profiles} =    Copy List    ${server_profiles_tbird_Multi_LIG}
    Add Server Profiles from variable    ${profiles}
    #Log to console    \n Hai-2
    Power on server      IRTQI6MH9D, bay 4
    Log to console and logfile      Waiting 10 minutes for server to boot...
    ${profiles} =    Copy List    ${server_profiles_tbird_Multi_LIG1}
    Add Server Profiles from variable    ${profiles}
    #Log to console    \n Hai-2
    Power on server      IRTQI6MH9D, bay 11 
    #Log to console and logfile      Waiting 10 minutes for server to boot...
    Sleep   10min
    ##Wait For Appliance To Become Pingable   10.10.2.31    
   
    Fusion Api Logout Appliance    
            


    
*** Keywords ***
Load Test Data
    Set Log Level    TRACE
    Load Test Data  ${DataFile}
    
    
Build SUBNET Body
      [Arguments]       ${subnet}       ${SUBNET_SELECT}    
      Log                 "Deba ":${subnet}
      ${subnet_ret}=     Create Dictionary
      :For  ${subnetdetails}  IN   @{subnet}
      \        Log         ${subnetdetails}
      \     ${networkId} =   Get From Dictionary   ${subnetdetails}  networkId
      \        Log            ${networkId}
      \        Log            ${SUBNET_SELECT}
      \        Run Keyword If    '${networkId}'!='${SUBNET_SELECT}'        Continue For Loop
      \        Log             "Deba Matching ":${subnetdetails}
      \        ${subnet_ret}=        Copy Dictionary        ${subnetdetails}     
      Log         "Deb Subnet_ret":${subnet_ret}
      [Return]    ${subnet_ret}

Build IPRange Body
      [Arguments]       ${ipv4ranges}       ${NETWORK_ID}        ${RANGE_NAME}    
      ${subnets}=    Get Subnet        ${NETWORK_ID}
      ${uri}=         Get from Subnet         ${subnets}              uri
      #Log            ${uri}
      ${ipv4_1}=  Create List 
      :For  ${ipv4}  IN   @{ipv4ranges}
      \           ${name} =   Get From Dictionary   ${ipv4}  name
      \           #Log            ${name}
      \              #Log             ${RANGE_NAME}    
      \           Run Keyword If    '${name}'!='${RANGE_NAME}'        Continue For Loop
      \              #Log            ${uri}
      \           Set to dictionary            ${ipv4}             subnetUri=${uri}
      \              #Log            ${ipv4}   
      \           Append to List    ${ipv4_1}        ${ipv4}
      [Return]   ${ipv4_1}      
      

Get Subnet
    [Arguments]             ${NETWORK_ID}
    #Log to Console    "Debarghya":${NETWORK_ID}
    ${resp} =   fusion api get ipv4 subnet    
    ${subnetcounts} =     Get From Dictionary     ${resp}    members
    ${l} =     Get Length    ${subnetcounts}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${subnet} =     Get From List   ${subnetcounts}    ${x}
    \    Exit For Loop If     '${subnet['networkId']}' == '${NETWORK_ID}'
    [Return]    ${subnet}
    #Log            ${subnet}

Get from Subnet
    [Arguments]     ${subnet_list}       ${element}
    #Log to Console    ${subnet_list}:"Debarghya    ":${element}
    ${return} =     Get From Dictionary     ${subnet_list}            ${element}  
    [Return]    ${return}
      

Create EG Body with Associate Range 
    [Documentation]    Adds Enclosure Group to an appliance from a variable which contains a list of dicts with the entire payload and also Associate a Range
    [Arguments]        ${enc_groups}        ${enc_group_name}    ${rangeuri}
    #[Arguments]        ${networks}        ${networkname}    ${NETWORK_ID}
    Log        ${enc_group_name}
    Log        ${enc_groups}
    Log        ${rangeuri}
    Log to console and logfile      Adding ENCLOSURE GROUP
    :FOR    ${enc_group1}    IN    @{enc_groups}
    \        ${enc_group_name1} =        Get From Dictionary        ${enc_group1}        name
    \        Log     ${enc_group_name1}
    \        Run Keyword If    '${enc_group_name1}'!='${enc_group_name}'        Continue For Loop
    \        Set to dictionary            ${enc_group1}             ipRangeUris=${rangeuri}
    \        ${enc_group_body}=    Copy Dictionary     ${enc_group1}
    \        Log        ${enc_group_body}
    Log to console and logfile      EDITING LIG GROUP
    ${l} =     Get Length    ${enc_group_body['interconnectBayMappings']}
    :FOR     ${x}    IN RANGE    0    ${l}
    \    ${liguri} =     Get From Dictionary    ${enc_group_body['interconnectBayMappings'][${x}]}    logicalInterconnectGroupUri
    \    Log to console and logfile      EDITING LIG GROUP:${liguri}    
    \   Continue For Loop If    '${liguri}' == 'None'
    \    ${liguri} =     Common URI Lookup by name    ${liguri}
    \    Log to console and logfile      EDITING LIG GROUP1:${liguri}
    \    Set to dictionary    ${enc_group_body['interconnectBayMappings'][${x}]}    logicalInterconnectGroupUri        ${liguri}
    \    Log to console and logfile      EDITING LIG GROUP Body:${enc_group_body}
    [Return]    ${enc_group_body}   



  
Build LI SPP body
    [Arguments]        ${li_spp}
    ${liedit} =     Copy Dictionary    ${li_spp}
    ${command} =                       Get Variable Value  ${li_spp['command']}
    ${sppUri} =           Get Variable Value  ${li_spp['sppUri']}
    ${force} =              Get Variable Value  ${li_spp['force']}
    

    ${body} =     Fusion Api Create LI spp Body    command=${command}
    ...                                         sppUri=${sppUri}                                
    ...                                         force=${force}
    ...                                         
    [Return]    ${body}    
APIC INVENTORY SYNC
    [Documentation]    issues a inventory synch at APIC 
    [Arguments]           ${APIC_HOST}    ${APIC_USER}        ${APIC_PASS}    
    Open Connection     ${APIC_HOST}     timeout=20s
    Login               ${APIC_USER}     ${APIC_PASS}
    Write    cd /aci/vm-networking/policies/vmware/vmm-domains/HPVC-WPST-DVS/controllers/10.10.3.74
    Read Until    admin@apic1:10.10.3.74>
    Write    moset inventory-trigger-state triggered
    Sleep         10secs
    Log to console and logfile            Triggering inventory re-synch at APIC nodes
    Write    moconfig commit
    Sleep         15secs
    Close All Connections
    Sleep         120secs
        
APIC LogIn and Validate FabricNodes
    [Arguments]        ${APIC_APPLIANCE_IP}        ${apic_admin_credentials}        ${IPList}
    APIC INVENTORY SYNC                ${APIC_HOST}    ${APIC_USER}        ${APIC_PASS}
    Log to console        Wait time for APIC to reflect CRM changes
    ${token} =         Fusion Apic Api Login Appliance         ${APIC_APPLIANCE_IP}        ${apic_admin_credentials}
    ${apic_ip} =    Get Variable Value    ${apic_ip}
    ${status} =         Fusion Apic Get fabricNodes         ${APIC_APPLIANCE_IP}        ${token}    ${IPList}
    run keyword if  '${status}'=='False'    Fail    'fabricNodes information did not match'

Edit LIG
    [Arguments]        ${lig}    ${li}    ${LLDPIP}    ${ltlv}    
    Fusion Api Login Appliance         ${APPLIANCE_IP}        ${admin_credentials}
    ${body} =   Build LIG body      ${lig}    
    ${lig} =         Get LIG Member      ${LIG1}
    ${lig_uri} =    Get LIG Uri         ${LIG1}
    ${resp} =     Fusion Api Edit LIG    body=${body}        uri=${lig_uri}
    Log to console and logfile    ${resp}
    ${task} =    Wait For Task     ${resp}     45s    
    ${valDict} =     Create Dictionary    status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}    
    Perform an Update From Group    ${li}    120 min        1 min
    ValidateLI LLDP Ip Address    ${li}    ${LLDPIP}
    ValidateLI TaggedLLDP        ${li}    ${ltlv}    
    

ValidateLI LLDP Ip Address
    [Arguments]        ${li}    ${LLDPIP}    
    ${li_uri} =     Get LI URI   ${li}
    ${resp} =     Fusion Api Get Li    ${li_uri}
    ${es} =     Get From Dictionary        ${resp}    ethernetSettings
    ${ip} =     Get From Dictionary        ${es}    lldpIpv4Address        
    ${status} =    Should Be Equal    ${ip}    ${LLDPIP}
    run keyword if    '${status}'=='False'    Fail    "LLDP Ip Address is not calculated in correct manner"
    
ValidateLI TaggedLLDP and RICH TLV
    [Arguments]        ${li}    ${ltlv}    
    ${li_uri} =     Get LI URI   ${li}
    ${getresp} =     Fusion Api Get Li    ${li_uri}
    Log        ${getresp}
    ${es} =     Get From Dictionary        ${getresp}    ethernetSettings
    ${LLDPTLV} =     Get From Dictionary        ${es}    enableTaggedLldp    
    
    Should Be Equal As Strings    ${ltlv}    ${LLDPTLV}
    
ValidateLI LLDP Ipv6 Address
    [Arguments]        ${li}    ${LLDPIP}    
    ${li_uri} =     Get LI URI   ${li}
    ${resp} =     Fusion Api Get Li    ${li_uri}
    ${es} =     Get From Dictionary        ${resp}    ethernetSettings
    ${ip} =     Get From Dictionary        ${es}    lldpIpv6Address        
    ${status} =    Should Be Equal    ${ip}    ${LLDPIP}
    run keyword if    '${status}'=='False'    Fail    "LLDP Ip Address is not calculated in correct manner"    
    Log to console and logfile    Tagged LLDP <${LLDPIP}> compared with TaggedLldp <${ip}>
        
    

Get IC
    [Arguments]        ${ICM_NAME}
    ${resp} =   fusion api get interconnect
    Log        ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =     Get Length    ${ics}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \     Exit For Loop If     '${ic['name']}' == '${ICM_NAME}'
    [Return]    ${ic}
    Log        ${ic}
    
Validate Interconnects 
    [Arguments]        ${ICM_NAME}        ${LLDPIP}
    Log to console and logfile    Validating Interconnects for LLDP and taggedTLV and RichTLV flags
    ${ic} =     Get IC        ${ICM_NAME}
    ${enableTaggedLldp} =         Get From IC    ${ic}   enableTaggedLldp
    ${lldpip} =                Get from IC     ${ic}        lldpIpv4Address
    Should be Equal as Strings    ${enableTaggedLldp}    
    Should be Equal as Strings    ${lldpip}        ${LLDPIP}
    
Validate Interconnects Ipv6
    [Arguments]        ${ICM_NAME}        ${ltlv}        ${LLDPIP_IPv6}
    Log to console and logfile    Validating Interconnects for TaggedLLDP of ${ICM_NAME}    
    ${ic} =     Get IC        ${ICM_NAME}
    ${enableTaggedLldp} =         Get From IC    ${ic}   enableTaggedLldp
    ${lldpip} =                Get from IC     ${ic}        lldpIpv6Address
    Should be Equal as Strings    ${enableTaggedLldp}        ${ltlv}
    Should be Equal as Strings    ${lldpip}        ${LLDPIP_IPv6}    
    Log to console and logfile    Tagged LLDP <${ltlv}> compared with TaggedLldp <${enableTaggedLldp}> for ${ICM_NAME}    
    
Perform an Update From Group
    [Arguments]        ${li}=${LE}-${LIG1}    ${timeout}=5 min     ${interval}=15s
    ${li_uri} =     Get LI URI   ${li}
    ${resp} =         Fusion Api Update from group    ${li_uri}
    ${task} =        Wait For Task     ${resp}     ${timeout}        ${interval}
    ${valDict} =     Create Dictionary    status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}


POWER OFF ICM
    [Arguments]        ${ICM_NAME}
    Log to console and logfile  -Issue powerControl Off
    Run Keyword and Ignore Error    Write To ciDebug Log
    ${ic} =     Get IC                  ${ICM_NAME} 
    ${uri} =    Get From IC     ${ic}   uri
    Log to console    \n${uri}    
    ${body} =   Create Dictionary   op=replace
    ...                             path=/powerState
    ...                             value=Off
    ${body} =   Create list     ${body}
    ${resp}        fusion api patch interconnect    body=${body}    uri=${uri}
    Log to console    \n${resp}
    sleep   180s    
          
          
POWER ON ICM
    [Arguments]        ${ICM_NAME}
    Log to console and logfile  -Issue powerControl Off
    Run Keyword and Ignore Error    Write To ciDebug Log
    ${ic} =     Get IC                  ${ICM_NAME} 
    ${uri} =    Get From IC     ${ic}   uri
    Log to console    \n${uri}    
    ${body} =   Create Dictionary   op=replace
    ...                             path=/powerState
    ...                             value=On
    ${body} =   Create list     ${body}
    ${resp}        fusion api patch interconnect    body=${body}    uri=${uri}
    Log to console    \n${resp}
    sleep   180s    
          
          
Verify Interconnect Power State
     [Arguments]        ${ICM_NAME}        ${POWER_STATE}    

    Log to console and logfile  -Verify Power status
    ${ic} =     Get IC                  ${ICM_NAME} 
    ${powerState} =     Get From IC    ${ic}   powerState
    Should Be Equal As Strings    ${powerState}    ${POWER_STATE}
    Log to console    \n\nPower State is:${powerState}
        
Verify Interconnect State
    #Log to console and logfile-Verify Power status of ${ICM_1}
    [Arguments]        ${ICM_1}        ${POWER_STATE}
    ${ic} =        Get IC        ${ICM_1} 
    ${State} =    Get From IC        ${ic}    state
    Should Be Equal As Strings    ${State}    ${POWER_STATE}    
        
     
EFUSE OFF ICM1    
        [Arguments]            ${bay}        ${enc_serial}    
        ${EM_IP} =        Get EM IP
        Log to console    ${EM_IP}        
        ${EM_TOKEN} =        Get EM Token    ${enc_serial}
        Log to console    ${EM_TOKEN}
        Efuse ICM   EFuseOff     ${bay}    
        Log to console and logfile            \t Waiting for ICM in Bay:${bay} to reach state:Configured|Monitored
        Wait Until Keyword Succeeds     3 min   5s      IC reached state    ${ic['uri']}    Configured|Monitored
        

EFUSE OFF ICM    
        [Arguments]            ${bay}        ${enc_serial}    
        ${EM_IP} =        Get EM IP
        Log to console    ${EM_IP}        
        ${EM_TOKEN} =        Get EM Token    ${enc_serial}
        Log to console    ${EM_TOKEN}
        ${ic} =     Get IC                  ${ICM_NAME} 
        Log to console    ${ic}
        ${uri} =    Get From IC     ${ic}   uri
        Log to console    ${uri}
        EFuse ICM   EFuseOn    ${bay}    
        Log to console and logfile            \t Waiting for ICM in Bay:${bay} to reach state:Configured|Monitored
        Wait Until Keyword Succeeds     3 min   5s      IC reached state    ${ic['uri']}    Configured|Monitored
        

EFUSE ON ICM    
        [Arguments]            ${bay}        ${enc_serial}    
        ${EM_IP} =        Get EM IP
        Log to console    ${EM_IP}        
        ${EM_TOKEN} =        Get EM Token    ${enc_serial}
        Log to console    ${EM_TOKEN}
        ${ic} =     Get IC                  ${ICM_NAME} 
        Log to console    ${ic}
        ${uri} =    Get From IC     ${ic}   uri
        Log to console    ${uri}
        EFuse ICM   EFuseOff    ${bay}    
        Log to console and logfile            \t Waiting for ICM in Bay:${bay} to reach state:Absent
        Wait Until Keyword Succeeds     3 min   5s      IC reached state    ${ic['uri']}    Absent
        #EFuse ICM   EFuseOff    ${bay}    ${EM_IP}    ${EM_TOKEN}        ${FUSION_NIC}                

Get EM IP
    Set Log Level    TRACE
    # Get EM IP
    # TODO:  going to need to see how this works with multiple EM's
    log to console    \n\nHELLO
    ${EM_IP} =        Execute SSH Command        lldpcli show neighbor
    ${m}    ${EM_IP} =  Should Match Regexp     ${EM_IP}    (?im)MgmtIP:\\s*(\\S*:\\S*:\\S*:\\S*:\\S*:\\S*)
    #${m}    ${EM_IP} =  Should Match    ${EM_IP}    "fe80::377d:ba56:25b8:44d4"
    Set Suite Variable    ${EM_IP}
    log to console     EM IP: ${EM_IP}
    [Return]    ${EM_IP}
        
Login to Fusion via SSH
    [Documentation]             Connect to Fusion VM Bash via SSH
    ...                         Example:\n| Login to Fusion Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}=${FUSION_IP}      ${USERNAME}=${FUSION_SSH_USERNAME}
    ...                         ${PASSWORD}=${FUSION_SSH_PASSWORD}    ${PROMPT}=${FUSION_PROMPT}
    ...                         ${TIMEOUT}=${FUSION_TIMEOUT}    ${ALIAS}=Fusion_SSH
    Log Many                    ${IP}                   ${USERNAME}     ${PASSWORD}     ${PROMPT}   ${TIMEOUT}
    Set Default Configuration   prompt=${PROMPT}        timeout=${TIMEOUT}
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    #log to console  \n\nssh loop1 
    #log to console    ${Output}
    #log to console  \n\nssh loop2
    #log to console    ${Id}
    [Return]                    ${Id}

Logout of Fusion Via SSH
    [Documentation]     Exits the current Bash SSH session
    ...                 Example:\n| Logout Of Fusion Via SSH |
    Close Connection

Execute SSH Command
    [Documentation]     Executes given command on the Fusion SSH shell
    ...                 Example:\n| Execute CLI Command | show enclosure list |
    [Arguments]         ${Command}      ${PROMPT}=#
    log to console    ${Command}    
    Login to Fusion via SSH
    SSHLibrary.Write            ${Command}
    SSHLibrary.Write            ${Command}
    ${Output}=          Read until      ${PROMPT}
    log to console        ${Output}
    Logout of Fusion Via SSH
    [Return]            ${Output}    

EFuse ICM
    [Documentation]    Perform an efuse action on a ICM bay. Action = EFuseOff | EFuseOn
    [Arguments]    ${Action}    ${BayNumber}
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Data}      Set Variable    {"Action":"${Action}"}
    Log to console and logfile      \t Issuing ${Action} for ICM:${BayNumber}
    ${Output}    Execute SSH Command
    ...    curl -ikX POST -H ${Header} --data-ascii '${data}' https://${EM_IP}%${FUSION_NIC}/rest/v1/InterconnectBays/${BayNumber}
    Should Contain    ${Output}    { "Action": "${Action}" }
    ...    msg=EFuse action failed \n${Output}    

Edit LI
    [Arguments]        ${li}    ${li_set1}    ${LLDPIP}    ${ltlv}            
    Fusion Api Login Appliance         ${APPLIANCE_IP}        ${admin_credentials}
    ${body} =    Build LI body    ${li_set1}
    ${li_uri} =     Get LI URI   ${li}    
    ${resp} =     Fusion Api Get Li    ${li_uri}    
    Log   ${resp}
    ${es} =     Get From Dictionary        ${resp}    ethernetSettings 
    ${uri} =     Get From Dictionary        ${es}        uri
    ${id} =     Get From Dictionary        ${es}        id
    Log        ${id}    
    Set to Dictionary    ${body}    id    ${id}    
    Log   ${body}
    ${resp1} =     Fusion Api Update LI Ethernet Settings    body=${body}        uri=${li_uri}
    Log   ${resp1}
    ${task} =    Wait For Task     ${resp1}     120s    
    ${valDict} =     Create Dictionary    status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}
    ValidateLI LLDP Ip Address    ${li}    ${LLDPIP}
    ValidateLI TaggedLLDP and RICH TLV    ${li}    ${ltlv}    
    
Build LI body
    [Arguments]        ${liedit}
    ${liedit} =     Copy Dictionary    ${liedit}
    ${type} =                       Get Variable Value  ${liedit['type']}
    ${enableRichTLV} =           Get Variable Value  ${liedit['enableRichTLV']}
    ${enableTaggedLldp} =              Get Variable Value  ${liedit['enableTaggedLldp']}
    ${body} =     Create Dictionary                type=${type}
    ...                                         enableRichTLV=${enableRichTLV}                                
    ...                                         enableTaggedLldp=${enableTaggedLldp}
    ...                                         
    [Return]    ${body}        
    
SSH to host and ping x
    [Documentation]    SSH's to a given host, then pings an IP from that host
    [Arguments]           ${HOST}    ${HOST2}
    Open Connection And Log In      ${HOST}
    ${Output}=    Execute Command    ping -c 4 ${HOST2}    return_stdout=True    return_rc=False
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
    Close All Connections

Add LIG from variable
    [Documentation]    Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
    [Arguments]        ${ligx}
    Log       Adding LIG ${ligx}
    ${ligx} =     Copy Dictionary    ${ligs['${ligx}']}

    ${name} =                       Get Variable Value  ${ligx['name']}
    ${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
    ${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
    ${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
    ${fcoeSettings} =               Get Variable Value  ${ligx['fcoeSettings']}
    ${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
    ${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
    ${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
    ${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
    ${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
    ${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
    ${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
    ${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
    #${uplinkSets} =     Copy List    ${ligx['uplinkSets']}
    ${l} =     Get Length    ${uplinkSets}
    

    :FOR    ${x}    IN RANGE    0    ${l}
    \    ${networkType} =     Get From Dictionary     ${uplinkSets[${x}]}    networkType
    \    ${networks} =         Get From Dictionary        ${uplinkSets[${x}]}    networkUris
    \   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
    \     Run Keyword If     '${networkType}' == 'FibreChannel'    Continue For Loop
    #\    ${networkUris} =     Get FCoE Uris    ${networks}
    #\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    #\   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
    \    ${networkUris} =     Get Ethernet URIs    ${networks}
    \    Set to dictionary    ${uplinkSets[${x}]}    networkUris        ${networkUris}
    \   ${nativeNetworkUri} =     Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri    ${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}    nativeNetworkUri     ${nativeNetworkUri}

    
    Log   ${uplinkSets}
    ${body} =     Fusion Api Create LIG Payload    name=${name}                                    
    ...                                         enclosureType=${enclosureType}
    ...                                         ethernetSettings=${ethernetSettings}    
    ...                                            interconnectMapTemplate=${interconnectMapTemplate}                   
    ...                                         stackingMode=${stackingMode}
    ...                                         telemetryConfiguration=${telemetryConfiguration}
    ...                                         snmpConfiguration=${snmpConfiguration}
    ...                                            uplinkSets=${uplinkSets}
    
    ${resp} =     Fusion Api Create LIG    ${body}
    ${task} =    Wait For Task    ${resp}     60s       2s
    ${liguri} =     Get From Dictionary    ${task['associatedResource']}    resourceUri        
    [Return]    ${resp}    

#FTS
    #Set Log Level    DEBUG
    #Get VM IP   ${VM}
    #First Time Setup                    password=hpvse123

Test Specific Setup
    Set Log Level    TRACE    
    Run Keyword and Ignore Error    Write To ciDebug Log
    Log to console and logfile    [TEST-SPECIFIC SETUP]
    Fusion Api Login Appliance         ${APPLIANCE_IP}        ${admin_credentials}
    ${users} =    Get Variable Value    ${users}
    Run Keyword If    ${users} is not ${null}    Add Users from variable                ${users}
    ${ethernet_networks} =    Get Variable Value    ${ethernet_networks}
    Run Keyword If    ${ethernet_networks} is not ${null}    Add Ethernet Networks from variable    ${ethernet_networks}
    #${ethernet_ranges} =    Get Variable Value    ${ethernet_ranges}
    #Run Keyword If    ${ethernet_ranges} is not ${null}        Run Keyword for List    ${ethernet_ranges}    Create Ethernet Range
    #${fc_networks} =    Get Variable Value    ${fc_networks}
    #Run Keyword If    ${fc_networks} is not ${null}    Add FC Networks from variable        ${fc_networks}
    #${fcoe_networks} =    Get Variable Value    ${fcoe_networks}
    #Run Keyword If    ${fcoe_networks} is not ${null}    Add FCoE Networks from variable        ${fcoe_networks}
    #${licenses} =    Get Variable Value    ${licenses}
    #Run Keyword If    ${licenses} is not ${null}        Add Licenses from variable        ${licenses}
    #Login all users     ${users}

Run FTS and test-specific setup
    Set Log Level    TRACE
    #FTS
    Test Specific Setup          
                    