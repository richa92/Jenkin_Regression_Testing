*** Settings ***
Library				RoboGalaxyLibrary
Library				FusionLibrary
Library				OperatingSystem
Library				BuiltIn
Library				Collections
Library		        SSHLibrary
Library				String

*** Variables ***
${DATA}				data_variables.py
${VM}				${None}
${VMSETUP}			no
${FTS}				no
${CONFIGURE}		no
							
*** Keywords ***
#######################################
# SETUP WORFLOWS - Variables
#######################################
Get Logical Downlink from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${downlinkuri}	
	${resp} = 	Fusion Api Get Logical Downlink		uri=${downlinkuri['enclosureTypeUri']}	
	
	${l} = 	Get Length	${resp['members']}	
	
	:FOR	${x}	IN RANGE	0	${l}		
	\	@{words} = 	Split String	${resp['members'][${x}]['name']}	(
	\	${type} = 	Get From List	${words}	1
	\	${Data} =	Set Variable    ${resp['members'][${x}]}
	\	Run keyword if	'${type}' == '${downlinkuri['module1']}'	Exit For Loop
	Log to console and logfile	${type}
	Log to console and logfile	${downlinkuri['module1']}
	Dictionaries Should Be Equal	${Data['downlinkPortCapability']['downlinkSubPorts']}	${downlinkuri['Ports']}	msg=Response does not match validation dictionary	values=True
	Log to console and logfile		completed
	[Return]	${resp}
	
Get Logical Downlink from variable_1
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${downlinkuri}	
	${resp} = 	Fusion Api Get Logical Downlink		uri=${downlinkuri['enclosureTypeUri']}	
	Log to console and logfile	${resp}	
	${l} = 	Get Length	${resp['members']}	
	
	:FOR	${x}	IN RANGE	0	${l}		
	\	@{words} = 	Split String	${resp['members'][${x}]['name']}	(
	\	${type} = 	Get From List	${words}	1
	\	${Data} =	Set Variable    ${resp['members'][${x}]}
	\	Run keyword if	'${type}' == '${downlinkuri['module1']}'	Continue For Loop
	Log to console and logfile	${type}
	Log to console and logfile	${downlinkuri['module1']}
	Log to console and logfile	${Data['downlinkPortCapability']['downlinkSubPorts']}
	Dictionaries Should Be Equal	${Data['downlinkPortCapability']['downlinkSubPorts']}	${downlinkuri['Ports']}	msg=Response does not match validation dictionary	values=True
	Log to console and logfile		completed
	[Return]	${resp}
	
Build LI SPP body1
	[Arguments]		${li_spp}
	${liedit} = 	Copy Dictionary	${li_spp}
	${command} =                       Get Variable Value  ${li_spp['command']}
	${sppUri} =           Get Variable Value  ${li_spp['sppUri']}
	${force} =              Get Variable Value  ${li_spp['force']}
	

	${body} = 	Fusion Api Create LI spp Body	command=${command}
	...                                         sppUri=${sppUri}                                
	...                                         force=${force}
	...                                         
    [Return]    ${body}	
    
Build LI SPP body
      [Arguments]       ${li_spp}
      ${liedit} =    Copy Dictionary   ${li_spp}
      ${command} =                       Get Variable Value  ${li_spp['command']}
      ${sppUri} =           Get Variable Value  ${li_spp['sppUri']}
      ${force} =              Get Variable Value  ${li_spp['force']}
     
 
      ${body} =    Create Dictionary    command=${command}
      ...                                         sppUri=${sppUri}
      ...                                         force=${force}  
      ...                                                                                                              
    [Return]    ${body}
    
Edit LIG
	[Arguments]		${lig}
	Log to console and logfile	${APPLIANCE_IP}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}
	${body} =   Build LIG body      ${lig}
	
    ${lig} = 	    Get LIG Member      ${LIG1}
	${lig_uri} =    Get LIG Uri         ${LIG1}
	Log to console and logfile		LIG URI  	
	Log to console and logfile		${lig_uri}  	
	${resp} = 	Fusion Api Edit LIG	body=${body}		uri=${lig_uri}
	Log to console and logfile		${resp}
	${task} =	Wait For Task 	${resp} 	120s
	
	${valDict} = 	Create Dictionary	status_code=${200}
	...                                 taskState=Completed
	Log to console and logfile	valdict
	Log to console and logfile	${valDict}
	${p} =	Validate Response	${task}	${valDict}
	Log to console and logfile	validate rep
	Log to console and logfile	${p}	

    	
Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	Log to console and logfile  	Adding LICENSES	
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}
	\		Run keyword if 		${resp['status_code']} != ${201}	    Log     Error adding License Key:${license['key']}   WARN

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	Log to console and logfile  	Adding USERS	
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding ETHERNET NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FC NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FCOE NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding NETWORK SETS	
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}		
	\		${nativeNetworkUri} = 	Run Keyword If 	'${net['nativeNetworkUri']}' != 'None'		Get Ethernet URI	${net['nativeNetworkUri']}
	\		Set To Dictionary 	${net}	nativeNetworkUri	${nativeNetworkUri}		
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}
	Log to console and logfile  	Adding RANGES	
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
	\ 	${resp} =	Run Keyword If 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range		body=${range}		
	[Return]	${resp}

Process InterconnectMapTemplate
	[Arguments]		${icmap}
	${l} = 	Get Length	${icmap['interconnectMapEntryTemplates']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	${permittedInterconnectTypeUri} = 	Get Interconnect Type URI	${permittedInterconnectTypeUri}
	\	Set to dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri		${permittedInterconnectTypeUri}
	[Return]	${icmap}

Add LIG from variable
	[Documentation]	Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ligx}
	Log to console and logfile  	Adding LIG ${ligx['name']}
	
	${ligx} = 	Copy Dictionary	${ligx}
	Log to console and logfile	${ligx}	
    ${name} =                       Get Variable Value  ${ligx['name']}
    Log to console and logfile	${name}
	${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
	${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
	${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
	${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
	${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
	${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
	#${uplinkSets} = 	Copy List	${ligx['uplinkSets']}
	Log to console and logfile	${uplinkSets}	
	${l} = 	Get Length	${uplinkSets}
	Log to console and logfile	${l}	
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}
	
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	    ${networkUris}
	\   ${nativeNetworkUri} = 	Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri	${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}	nativeNetworkUri     ${nativeNetworkUri}
	Log to console and logfile	${ethernetUris}
    # Process Internal URIs
	${internalNetworkUris} = 	Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris	${internalNetworkUris}
	Log to console and logfile	${internalNetworkUris}
	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
	Log to console and logfile	${body}
	${resp} = 	Fusion Api Create LIG	${body}
	Log to console and logfile	${resp}
	${task} =	Wait For Task	${resp} 	60s	2s
	Log to console and logfile	${task}
	${liguri} = 	Get From Dictionary	${task['associatedResource']}	resourceUri		
	[Return]	${resp}

Add Enclosure Group from variable
	[Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${enc_group}
	#Log to console and logfile		${enc_group['name']}
	Log to console and logfile		${enc_group}
	Log to console and logfile  	Adding ENCLOSURE GROUP ${enc_group['name']}
	${l} = 	Get Length	${enc_group['interconnectBayMappings']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${liguri} = 	Get From Dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
	\   Continue For Loop If    '${liguri}' == 'None'
	\	${liguri} = 	Common URI Lookup by name    ${liguri}
	\	Set to dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}	
	${resp} =	Fusion Api Create Enclosure Group	${enc_group}

Common URI lookup by name
	[Documentation]	Takes a string containing URI type + : + resource name, performs a lookup and returns URI
	...				Ex:    ${uri} = 	Common Lookup by name	LIG:LIG1
	[Arguments]		${uri}
	Log to console and logfile  	getting uri
	@{words} = 	Split String	${uri}	:
	${type} = 	Get From List	${words}	0
	${name} = 	Get From List	${words}	1
	${uri} = 	Run Keyword If 	'${type}' == 'EG'		Get Enclosure Group URI		${name}
	...         ELSE IF         '${type}' == 'ENC'		Get Enclosure URI		    ${name}
	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URI			${name}
	...			ELSE IF			'${type}' == 'FC'		Get FC URI					${name}
	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URI				${name}
	...			ELSE IF			'${type}' == 'LI'		Get LI URI					${name}
	...			ELSE IF			'${type}' == 'LIG'		Get LIG URI					${name}
	...			ELSE IF			'${type}' == 'NS'		Get Network Set URI			${name}
	...			ELSE IF			'${type}' == 'SH'		Get Server Hardware URI		${name}
	...			ELSE IF			'${type}' == 'US'		Get Uplink Set URI			${name}
	...			ELSE			Set variable			ResourceTypeNotFound:${type}

	[Return]	${uri}

Add Enclosures from variable
	[Documentation]	Adds Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${encs}
	Log to console and logfile  	Adding ENCLOSURES 		
	:FOR	${enc}	IN	@{encs}
	\	${encuri} =		Get From Dictionary	${enc}	enclosureGroupUri
	\	${encuri} = 	Common URI Lookup by name    ${encuri}
	\	Log to console and logfile	encuri
	\	Log to console and logfile	${encuri}
	\	Set to dictionary	${enc}	enclosureGroupUri		${encuri}
	\	Log to console and logfile	enc
	\	Log to console and logfile	${enc}
	\	${resp} =	Fusion Api Add Enclosure	${enc}
	\	Log to console and logfile	response
	\	Log to console and logfile	${resp}	
	\	${task} =	Wait For Task	${resp}		6min	10s
	\	Log to console and logfile	${task}	

Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}
	Log to console and logfile  	Adding LOGICAL ENCLOSURE
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	${eguri} = 	Common URI Lookup by name    ${eguri}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
	Set to dictionary	${enc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\       ${encuri} = 	Common URI Lookup by name    ${encuri}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${enc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Create Logical Enclosure 	${enc}
	${task} =		${resp} 	120min	1min
	

Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILES	
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	Log to console and logfile	${profile}
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	Log to console and logfile	${shuri}
	\	${uri} =	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	Log to console and logfile	${uri}	
	\	Log to console and logfile	${profile}
	\	${eg} =		Get from Dictionary	${profile}	enclosureGroupUri
	\	Log to console and logfile	${eg}	
	\	${uri} = 	Common URI Lookup by name    ${eg}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}	
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri
	\	Log to console and logfile	${enc} 
	\	${uri} = 	Common URI Lookup by name    ${enc}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	Log to console and logfile	${connections}
	\	${connections} = 	Lookup Connection Uris	${connections}
	\	Log to console and logfile	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}	
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	Log to console and logfile	${resp}	
	\	${task} =   Wait For Task	${resp}		timeout=1 mins		interval=10s	
	\	Log to console and logfile	${task}
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   @{message} = 	Get From dictionary 	${task}     taskErrors
		:FOR	${mess}	IN	@{message}				
		\	${dict} =	Get from Dictionary	${mess}	message
		\	Log to console and logfile	${dict}		
		\	Log to console and logfile	${errormessage}
		\	Run Keyword If	'${dict}' == '${errormessage}'	Exit For Loop		
	\	Log to console and logfile	${task}
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)
	

Edit Server Profiles from variable
	[Documentation]	Edits Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Editing SERVER PROFILES	
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	Log to console and logfile	${profile}
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	Log to console and logfile	${shuri}	
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	Log to console and logfile	${uri}	
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	Log to console and logfile	${eg}	
	\	${uri} =	Common URI Lookup by name	${eg}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${enc} =	Get from Dictionary		${profile}	enclosureUri
	\	Log to console and logfile	${enc} 
	\	${uri} =	Common URI Lookup by name	${enc}
	\	Log to console and logfile	${uri}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}	
	\	${connections} =	Get From Dictionary		${profile}	connections
	\	Log to console and logfile	${connections}
	\	${connections} =	Lookup Connection Uris	${connections}
	\	Log to console and logfile	${connections}
	\   Set to Dictionary	${profile}	connections		${connections}
	\	${resturi} =	Get Profile Uri
	\	${eTag} =	Get Profile ETag
	\	Log to console and logfile	${resturi}
	\	Log to console and logfile	${eTag}
	\	Set to Dictionary   ${profile}  eTag     ${eTag}
	\	${resp} =	Fusion Api Edit Server Profile	body=${profile}	uri=${resturi}
	\	Log to console and logfile	${resp}	
	\	${task} =	Wait For Task	${resp}		timeout=1 mins		interval=10s
	\	Log to console and logfile	${task}
	\   ${task_state} =		Get From dictionary		${task}     taskState
	\   @{message} =	Get From dictionary		${task}     taskErrors
		:FOR	${mess}	IN	@{message}		
		\	Log to console and logfile	Errorfromoneview
		\	${dict} =	Get from Dictionary	${mess}	recommendedActions
		\	Log to console and logfile	${dict[0]}
		\	Log to console and logfile	Errorfromdata
		\	Log to console and logfile    errormessage     	
		\	Run Keyword If	'${dict[0]}' == 'errormessage'	Exit For Loop	
	\	Log to console and logfile	${task}	
	\	Log to console and logfile	${message}
	\	Log to console and logfile    ${task_state}   
	\   Should Match Regexp	${task_state}	((?i)Warning|Error)
	

Get Profile Lists
	[Documentation]	Getting Server Profile ports lists to an appliance from a variable which contains a list of dicts with the entire payload
	Log to console and logfile  	Getting SERVER PROFILEportlist
	${resp} = 	Fusion Api Get Server Profiles  param=?sort=name:ascending
	Log to console and logfile  	${resp}
	${l} = 	Get Length	$${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}	
	\	${connections} = 	Get From Dictionary		${resp['members'][${x}]}	connections
	\	Log to console and logfile	${connections}
	\	${type0} = 	Get From List	${connections}	0
	\	${type1} = 	Get From List	${connections}	1
	\	${type2} = 	Get From List	${connections}	2
	\	${type3} = 	Get From List	${connections}	3
	\	${portid0} = 	Get From Dictionary		${type0}		portId
	\	${portid1} = 	Get From Dictionary		${type1}		portId
	\	${portid2} = 	Get From Dictionary		${type2}		portId
	\	${portid3} = 	Get From Dictionary		${type3}		portId
	\	Log to console and logfile	${portid0}
	\	Log to console and logfile	${portid1}
	\	Log to console and logfile	${portid2}
	\	Log to console and logfile	${portid3}
	\	${portid} =	Create List		${portid0}	${portid1}	${portid2}	${portid3}
	\	Log to console and logfile	${portid}
	\	Exit For Loop
	Log to console and logfile		completed	
	[Return]	${portid}
	
	
Get Profile Uri
	[Documentation]	Getting Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	Log to console and logfile  	Getting SERVER PROFILE
	${profiles} = 	Fusion Api Get Server Profiles  param=?sort=name:ascending
	Log to console and logfile  	${profiles}
	${l} = 	Get Length	${profiles['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\	Log to console and logfile  	${profiles['members'][${x}]['name']}
	\ 	Run Keyword If 	'${profiles['members'][${x}]['name']}' != 'Profile5'		Continue For Loop
	\	${uri} =	Get From Dictionary		${profiles['members'][${x}]}	uri
	Log to console and logfile		${uri}	
	[Return]	${uri}
	
Get Profile ETag
	[Documentation]	Getting Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	Log to console and logfile  	Getting SERVER PROFILE
	${profiles} = 	Fusion Api Get Server Profiles  param=?sort=name:ascending
	Log to console and logfile  	${profiles}
	${l} = 	Get Length	${profiles['members']}	
	:FOR	${x}	IN RANGE	0	${l}	
	\	Log to console and logfile  	${profiles['members'][${x}]['name']}
	\ 	Run Keyword If 	'${profiles['members'][${x}]['name']}' != 'Profile5'		Continue For Loop	
	\	${eTag} = 	Get From Dictionary		${profiles['members'][${x}]}	eTag		
	Log to console and logfile	${eTag}	
	[Return]	${eTag}

Add Server Profile Templates from variable
	[Documentation]	Adds Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILE TEMPLATES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	${sht} = 	Get from Dictionary	${profile}	serverHardwareTypeUri
	\	${uri} = 	Common URI lookup by name		${sht}
	\	Set to Dictionary	${profile}	serverHardwareTypeUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	${uri} = 	Common URI Lookup by name	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile template		body=${profile}
	\   # TODO: Change timeout!
	\	${task} =   	${resp}		timeout=1 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)
	
	

Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	${conns} =  Create List
	:FOR	${connection}	IN	@{connections}
	\   ${connection} =     Copy dictionary     ${connection}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1	
	\	${net} = 	Create List	${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Set to Dictionary	${connection}	networkUri	${uri}
	\   append to list  ${conns}    ${connection}
	[Return]	${conns}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable ALL Generated ID Ranges
	[Documentation]	Enables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Enable Generated VSN Range	${rangeUri}

Enable Generated VMAC Range
	[Documentation]	Enables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VWWN Range
	[Documentation]	Enables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VSN Range
	[Documentation]	Enables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword as user
	[Documentation]		Runs a Fusion_API keyword as a particular user.
	...					Ex:		Run Keyword As User		nat		Fusion Api Get Ethernet Networks	${empty}	param=?filter="'name'=='net_101'"
    [Arguments]     ${user}     ${keyword}      @{varargs}
    ${original_user} =   Fusion Api Get Active user
	${active_sessions} = 	Fusion Api Get Active Sessions
	Dictionary Should Contain Key	${active_sessions}	${user}
    Fusion Api Switch Active User   ${user}
    ${resp} =   Run Keyword and continue on failure     ${keyword}  @{varargs}
    Fusion Api Switch Active User   ${original_user}
    [Return]    ${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument
	[Arguments]	${list}	${keyword}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}	${x}
		
#######################################
# COMMON KEYWORDS
#######################################
Build LIG body
	[Arguments]		${xlig}
	${xlig} = 	Copy Dictionary	${xlig}
	${uplinkSets} = 	Copy List	${xlig['uplinkSets']}
	${l} = 	Get Length	${uplinkSets}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	${name} =                       Get Variable Value  ${xlig['name']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
	${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
	${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
	${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	#${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
    [Return]    ${body}

Build US body
	[Arguments]		${us}	${li_uri}
	Set to dictionary	${us}	logicalInterconnectUri	${li_uri}
	${l} = 	Get Length	${us['portConfigInfos']}
	:FOR	${x}	IN RANGE	0	${l}
	\   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}	enclosure
	\   ${enc_uri} =        Get Enclosure Uri   ${enc_uri}
	\	Set To Dictionary		${us['portConfigInfos'][${x}]}	enclosure	${enc_uri}

	# process eth
	${networks} = 		Get From Dictionary		${us}	networkUris
	${networkUris} = 	Get Ethernet Uris	${networks}
	Set to dictionary	${us}	networkUris	${networkUris}
	# process fc
	${networks} = 		Get From Dictionary		${us}	fcNetworkUris
	${networkUris} = 	Get FC Uris	${networks}
	Set to dictionary	${us}	fcNetworkUris	${networkUris}
	# process fcoe
	${networks} = 		Get From Dictionary		${us}	fcoeNetworkUris
	${networkUris} = 	Get FCoE Uris	${networks}
	Set to dictionary	${us}	fcoeNetworkUris	${networkUris}

	${body} = 		Fusion Api Create Uplink Set Payload	${us}
	[Return]	${body}

Create Network Set range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding NETWORK SET RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end
	${netlist} = 	Create List
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Append To List	${netlist}	${range['prefix']}${x}${range['suffix']}
	${networkUris} = 	Get Ethernet URIs	${netlist}
	Set To Dictionary 	${body}	networkUris	${networkUris}
	${nativeNetworkUri} = 	Run Keyword If 	'${range['nativeNetworkUri']}' != 'None'  Get Ethernet URI	${range['nativeNetworkUri']}
	Set To Dictionary 	${body}	nativeNetworkUri	${nativeNetworkUri}
	${resp} = 	Fusion Api Create Network Set		body=${body}
	[Return]	${resp}

Create Ethernet range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding ETHERNET NETWORK RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end

	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Set To Dictionary 	${body}	name	${range['prefix']}${x}${range['suffix']}
	\	Set To Dictionary 	${body}	vlanId	${x}
	\	${resp} = 	Fusion Api Create Ethernet Network	body=${body}

Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding FCOE NETWORK RANGES
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-network
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\		${resp}

Get connectionTemplateUri
	[Documentation]	Retrieves the connectionTemplateUri from a given network {name} of a given {type} where:
	...             {name} is the name of the network
	...             {type} is the type of network: [ethernet, fc, fcoe], default=ethernet
	...             Returns: connectionTemplateUri string
	[Arguments]		${name}   ${type}=ethernet
    Set Log Level	DEBUG
    ${param} =      Set Variable    ?filter="'name'=='${name}'"
	${net} =		Run Keyword If          '${type}' == 'ethernet'      Fusion Api Get Ethernet Networks    param=${param}
	...             ELSE IF                 '${type}' == 'fc'            Fusion Api Get fc Networks          param=${param}
    ...             ELSE IF                 '${type}' == 'fcoe'          Fusion Api Get fcoe Networks        param=${param}
    ...             ELSE                    Log     Invalid network type specified for 'Get connectionTemplateUri'     WARN
	${ct_uri} =     Get From Dictionary      ${net['members'][0]}    connectionTemplateUri

    [Return]    ${ct_uri}

Get Enclosure URI
	[Arguments]		${enc}
	${resp} =	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} =	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Enclosure Group URI
	[Arguments]		${eg}
	Log to console and logfile	Get Enclosure Group Uri
	${resp} =	Fusion Api Get Enclosure Groups
	Log to console and logfile	${resp}
	Log to console and logfile	encl members
	${l} =	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}		
	\ 	Run Keyword If	'${resp['members'][${x}]['name']}' != '${eg}'	Continue For Loop
	\	Log to console and logfile	${resp['members'][${x}]}
	\	${uri} =	Get From Dictionary		${resp['members'][${x}]}	uri	
	[Return]	${uri}

Get Ethernet URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}
	
Get Ethernet URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}	

Get FC URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FC URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get FCoE URI
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FCoE Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FCoE URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Fcoe Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get IC URI
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Get Interconnect Type URI
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect Types 		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LI member
	[Arguments]		${li}
	${resp} = 	    Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${member} = 	Get From List		${resp['members']}  ${x}
	[Return]	${member}

Get LI URI
	[Arguments]		${li}
	${resp} = 	Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LIG member
	[Arguments]		${lig}
	${resp} = 	    Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${member} = 	Get From List		${resp['members']}  0
	[Return]	${member}

Get LIG URI
	[Arguments]		${lig}
	Log to console and logfile  	Getting LIG URI
	${resp} = 	Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Network Set URI
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Network Set URIs
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Resource by URI
	[Documentation]    Returns any type of resource using its URI
	[Arguments]	${uri}   @{varargs}
    ${resp} =     Fusion Api Get Resource    ${uri}    @{varargs}
	[Return]    ${resp}

Get Server Hardware URI
	[Arguments]		${enc_server}
	${resp} =	Fusion Api Get Server Hardware
	${shlist} =		Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} =	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} =	Get From dictionary		${sh}	uri
	[Return]	${uri}

Get Server Hardware Type URI
	[Arguments]		${sht}
	Set Log Level	TRACE
	${resp} = 	Fusion Api Get Server Hardware Types    param=?filter="'name'=='${sht}'"
	${uri} = 	Get From dictionary 	${resp['members'][0]}	uri
	[Return]	${uri}


Get Uplinkset URI
	[Arguments]		${us}
	${resp} = 	Fusion Api Get Uplink Set 		param=?filter="'name'=='${us}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Log to console and logfile
	[Arguments]	${data}     ${level}=INFO
	Log	${data}     ${level}
	Log to console	${data}
	

Wait For Task
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=180 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate	${resp}
	[Return]	${task}

Wait For Task1
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate1	${resp}
	[Return]	${task}
	
Task Reached Endstate
	[Arguments]	${resp}
	Set Log Level	TRACE
	${location} =    Get Variable Value    ${resp['headers']['location']} 
	Log to console and logfile 	${location}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary	${resp}		uri
	...                 ELSE                    Get Variable Value          ${location}
	Log to console and logfile	${task_uri}
	Log to console and logfile	taskuri is
	Log to console and logfile	${task_uri}	
	${task} =		Fusion Api Get Task		uri=${task_uri}	
	${task_state} = 	Get From Dictionary		${task}		taskState
	Log to console and logfile	${task_state}
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)	
	[Return]	${task}

Task Reached Endstate1
	[Arguments]	${resp}
	
	Set Log Level	TRACE
	${location} =       Get Variable Value      ${resp['location']}
	${task_uri} =		Get Variable Value          ${location}	
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	Log to console    ${task}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
	[Return]	${task}
	
Wait For Appliance To Be Ready
	[Documentation]	Waits for an appliance reach a the ready state
	[Arguments]		${appliance}	${timeout}=20 min	${interval}=30 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance Reached Ready State	${appliance}	

Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	Log to console and logfile 		Pinging: ${appliance} ...
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance is pingable 	${appliance}	

Appliance is pingable 
	[Arguments]		${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	Windows ping	${appliance}
	...	ELSE	Unix ping	${appliance}

Unix ping
	[Arguments]		${host}
    ${Output}=    Run    ping -c 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
	[Return]	${Output}
	
Windows ping
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    TTL=
	[Return]	${Output}
		
Appliance Reached Ready State
	[Arguments]		${appliance}
	${state} = 	Fusion Api Get Resource		${appliance}/controller-state.json
	Log to console and logfile	-Appliance state: ${state['state']}
	Should Match Regexp	${state['state']}	((?i)OK)
	
First Time Setup
	[Documentation]	Changes intial administrator password, answers EULA, enables service access, adds licenses, configures appliance interfaces.
	...	If args are null, uses XML ${DATAFILE}
	[Arguments]	${DATAFILE}=${null}	${password}=${null}	${interfaces}=${null}
	#${password} =	Set Variable	${password}
	Log to console and logfile	[FIRST TIME SETUP]
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}		
	Wait For Appliance To Be Ready			${APPLIANCE_IP}
	Log to console and logfile	-Agree to EULA	
	Fusion Api Save EULA	${APPLIANCE_IP}
	Log to console and logfile	-Enable service access
	Fusion Api Set service access	${APPLIANCE_IP}

	${req} = 		Create Dictionary		newPassword=${password}
	...										oldPassword=admin
	...										userName=Administrator
	#Run Keyword If	${password} is not ${null}	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	#Add licenses from variable		${licenses}
	Configure Appliance Interfaces	
	
Configure Appliance Interfaces
	Log to console and logfile	-Configuring Appliance Interfaces, Time, Locale
	${resp} =	Fusion Api Get Appliance Interface Mac	eth0
	Set to dictionary	${appliance['applianceNetworks'][0]}	macAddress	${resp}	
	${ipv4Type} = 		Get Variable Value 	${appliance['applianceNetworks'][0]['ipv4Type']}
	${app1Ipv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['app1Ipv4Addr']}
    ${virtIpv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['virtIpv4Addr']}
	Sleep 	10s			
	${resp} = 	Fusion Api Configure Appliance Interfaces			${appliance}
	# if STATIC, get new IP and login. for 2.00, use virtIpv4Addr (Tbird), otherwise use app1Ipv4Addr
    Run Keyword If	'${virtIpv4Addr}' is not 'None'     			Set New IP and Login	${virtIpv4Addr}
	...             ELSE IF     '${app1Ipv4Addr}' is not 'None'     Set New IP and Login	${app1Ipv4Addr}
	...             ELSE    Log     Either app1Ipv4Addr or virtIpv4Addr must be provided in the 'appliance' variable in your data file     WARN

		${resp}		timeout=200s		interval=5s
	${resp} = 	Fusion Api Configure Appliance Time and Locale			${timeandlocale}
		${resp}		timeout=200s		interval=5s
	
Set New IP and Login
	[Arguments]	${IP}
	Set Suite Variable		${APPLIANCE_IP}	${IP}
	Sleep 	60s	
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	
Login all users
	[Arguments]     ${users}
	Set Log Level	TRACE
	${original_user} =    Fusion Api Get Active User
	:FOR	${user}	IN	@{users}
	\	${user_and_pass} = 	Create Dictionary	userName=${user['userName']}	password=${user['password']}
	\	Fusion Api Login Appliance 		${APPLIANCE_IP}		${user_and_pass}
	Fusion api switch active user    user=${original_user}


# -----------------------------------------------------------------------------
#   EM KEYWORDS
# -----------------------------------------------------------------------------
Get EM IP
	Set Log Level	TRACE
    # Get EM IP
    # TODO:  going to need to see how this works with multiple EM's
    ${EM_IP} =  Execute SSH Command     lldpcli show neighbors
    ${m}    ${EM_IP} =  Should Match Regexp     ${EM_IP}    (?im)MgmtIP:\\s*(\\S*:\\S*:\\S*:\\S*:\\S*:\\S*)
    Set Suite Variable    ${EM_IP}
    log to console     EM IP: ${EM_IP}
    [Return]    ${EM_IP}

Get EM Enclosures
    # Get EM enclosures
    ${EM_ENCS} =   Execute SSH Command     /ci/bin/tbird/appliance-hal.sh list-enclosures
    @{ignore last} =     Split to lines  ${EM_ENCS}  ${null}   -1
    ${EM_ENCS} =        Create List     @{ignore last}
    Set Suite Variable    ${EM_ENCS}
    log to console     Enclosures: ${EM_ENCS}
    [Return]    ${EM_ENCS}

Get EM Token
    [Arguments]     ${enc_serial}
    # Get EM token
    ${EM_TOKEN} =  Execute SSH Command     /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${enc_serial} -o token
    ${EM_TOKEN}    Should Match Regexp    ${EM_TOKEN}    (?i)\\S*
    Set Suite Variable    ${EM_TOKEN}   ${EM_TOKEN}
    log to console     EM TOKEN: ${EM_TOKEN}
    [Return]    ${EM_TOKEN}

Get EM Sessions
    # Get Sessions using session Id to test that everything is working
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Output}    Execute SSH Command
    ...    curl -ikX GET https://${EM_IP}%${FUSION_NIC}/rest/v1/Sessions -H ${Header}
    Should Contain    ${Output}    "Name": "Sessions Collection"
    ...    msg=Get Sessions action failed \n${Output}

EFuse ICM
    [Documentation]    Perform an efuse action on a ICM bay. Action = EFuseOff | EFuseOn
    [Arguments]    ${Action}    ${BayNumber}
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Data}      Set Variable    {"Action":"${Action}"}
	Log to console and logfile  	\t Issuing ${Action} for ICM:${BayNumber}
    ${Output}    Execute SSH Command
    ...    curl -ikX POST -H ${Header} --data-ascii '${data}' https://${EM_IP}%${FUSION_NIC}/rest/v1/InterconnectBays/${BayNumber}
    Should Contain    ${Output}    { "Action": "${Action}" }
    ...    msg=EFuse action failed \n${Output}

IC reached state
	[Arguments]	    ${uri}  ${state}
	Set Log Level	TRACE
    ${resp} =   fusion api get resource     ${uri}
	Log to console and logfile  	\t ${uri}: ${resp['state']}
	Should Match Regexp 	${resp['state']}    ${state}
	[Return]	${resp}

Get IC
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	${l} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${ICM_MODEL}'		Continue For Loop
	\   Append to list      ${ic_list}  ${ic}
	[Return]    ${ic_list}

Get from IC
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}

# -----------------------------------------------------------------------------
#   FUSION BASH SHELL INTERFACE KEYWORDS
# -----------------------------------------------------------------------------
Login to Fusion via SSH
    [Documentation]             Connect to Fusion VM Bash via SSH
    ...                         Example:\n| Login to Fusion Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}=${FUSION_IP}      ${USERNAME}=${FUSION_SSH_USERNAME}
    ...                         ${PASSWORD}=${FUSION_SSH_PASSWORD}    ${PROMPT}=${FUSION_PROMPT}
    ...                         ${TIMEOUT}=${FUSION_TIMEOUT}    ${ALIAS}=Fusion_SSH
    Log Many                    ${IP}                   ${USERNAME}     ${PASSWORD}     ${PROMPT}   ${TIMEOUT}
    Set Default Configuration   prompt=${PROMPT}        timeout=${TIMEOUT}
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    [Return]                    ${Id}

Logout of Fusion Via SSH
    [Documentation]     Exits the current Bash SSH session
    ...                 Example:\n| Logout Of Fusion Via SSH |
    Close Connection

Execute SSH Command
    [Documentation]     Executes given command on the Fusion SSH shell
    ...                 Example:\n| Execute CLI Command | show enclosure list |
    [Arguments]         ${Command}      ${PROMPT}=${FUSION PROMPT}
    Login to Fusion via SSH
    SSHLibrary.Write    ${Command}
    ${Output}=          Read until      ${PROMPT}
    Logout of Fusion Via SSH
    [Return]            ${Output}



#######################################
# TEARDOWN WORFLOWS
#######################################
Suite Teardown
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[TEARDOWN]
	#
	Run Keyword If All Tests Passed    Power off ALL Servers
	Run Keyword If All Tests Passed    Remove All Server Profiles
	Run Keyword If All Tests Passed    tlosures
	Run Keyword If All Tests Passed    Remove ALL Enclosure Groups
	Run Keyword If All Tests Passed    Remove ALL LIGs
	Run Keyword If All Tests Passed    Remove ALL Ethernet Networks
	Run Keyword If All Tests Passed    Remove ALL FC Networks
	Run Keyword If All Tests Passed    Remove ALL FCoE Networks
	Run Keyword If All Tests Passed    Remove ALL Network Sets
	Run Keyword If All Tests Passed    Remove ALL Users

Remove All Enclosures
	[Documentation]	Querys the appliance for all Enclosures and then removes them
	Log to console	Removing ENCLOSURES	
	${encls} = 	Fusion Api Get Enclosures	
	Log to console	XXXXXXXXXXXXXXXXX
	Log to console	${encls}
	:FOR	${encl}	IN	@{encls['members']}
	\		${resp} =   Fusion Api Remove Enclosure		uri=${encl['uri']}
	\		Log to console	@@@@@@@@@
	\		Log to console	${encl['uri']}	
	\		${task} =   Wait For Task  ${resp}     2 minutes 40 seconds
	\		Log to console	Task is
	\		Log to console	${task}
	\       ${val} =       Create Dictionary   taskState=Completed
	\       ${result} =    Validate Response    ${task}	${val}
		
Remove Enclosures
	[Documentation]	Querys the appliance for all Enclosures and then removes them
	Log to console and logfile  	Removing ENCLOSURES	
	${encs} =	Get Enclosure11 URI		SGH420HHY8
	Log to console and logfile	enc uri available are
	Log to console and logfile		${encs}
	
	${resp} =	Fusion Api Remove Enclosure		uri=${encs}		param=?force=true 
	Log to console and logfile		${resp}
	Sleep	6 min
	
Remove Server Profile
	[Documentation]	Querys the appliance for all Profiles and then removes them
	Log to console and logfile  	Removing Profiles	
	${resturi} =	Get Profile Uri		SGH420HHY8
	Log to console and logfile	enc uri available are
	Log to console and logfile		${encs}
	
	${resp} =	Fusion Api Remove Enclosure		uri=${encs}		param=?force=true 
	Log to console and logfile		${resp}
	Sleep	6 min
		
Get Enclosure11 URI
	[Arguments]		${eg}
	Log to console and logfile	Get Enclosure Group Uri
	${resp} = 	Fusion Api Get Enclosures
	Log to console and logfile	${resp}
	Log to console and logfile	encl members
	${l} =	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\	Log to console and logfile	wwwwwwwww
	\	Log to console and logfile	${resp['members'][${x}]['name']}		
	\ 	Run Keyword If	'${resp['members'][${x}]['name']}' != '${eg}'	Continue For Loop
	\	Log to console and logfile	encl membersqqqqq
	\	Log to console and logfile	${resp['members'][${x}]['uri']}
	\	${uri} =	Get From Dictionary		${resp['members'][${x}]}	uri	
	[Return]	${uri}
	
Remove All Enclosure Groups
	[Documentation]	Querys the appliance for all Enclosure Groups and then removes them
	Log to console and logfile  	Removing ENCLOSURE GROUPS	
	${encs} = 	Fusion Api Get Enclosure Groups
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} = 	Fusion Api Delete Enclosure Group		uri=${enc['uri']}

Remove All Ethernet Networks
	[Documentation]	Querys the appliance for all Ethernet networks and then removes them
	Log to console and logfile  	Removing ETHERNET NETWORKS	
	${networks} = 	Fusion Api Get Ethernet Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Ethernet Network		uri=${net['uri']}
	\		${task} =	 	${resp} 	240s	2s

Remove All FC Networks
	[Documentation]	Querys the appliance for all FC networks and then removes them
	Log to console and logfile  	Removing FC NETWORKS	
	${networks} = 	Fusion Api Get FC Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FC Network		uri=${net['uri']}
	\		${task} =	 	${resp} 	240s	2s

Remove All FCoE Networks
	[Documentation]	Querys the appliance for all FCoE networks and then removes them
	Log to console and logfile  	Removing FCoE NETWORKS	
	${networks} = 	Fusion Api Get FCoE Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FCoE Network		uri=${net['uri']}
	\		${task} =	 	${resp} 	240s	2s

Remove All LIGs
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console and logfile  	Removing LIGS	
	${ligs} = 	Fusion Api Get LIG
	:FOR	${lig}	IN	@{ligs['members']}
	\		${resp} = 	Fusion Api Delete LIG		uri=${lig['uri']}
	\		${task} =	 	${resp} 	240s	2s

Remove All Network Sets
	[Documentation]	Querys the appliance for all Network Sets and then removes them
	Log to console and logfile  	Removing NETWORK SETS	
	${networks} = 	Fusion Api Get Network Set
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Network Set		uri=${net['uri']}
	\		${task} =	 	${resp} 	240s	2s

Power off ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them off
	Log to console and logfile  	Powering off SERVERS	
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	 	${resp} 	240s	5s

Power on server
	[Arguments]     ${server}
	[Documentation]	Querys the appliance for a server by name and then Powers it on
	Log to console and logfile  	Powering on ${server}
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${s}	IN	@{servers['members']}
	\       Continue For Loop If	  '${s['name']}' != '${server}'
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${s['uri']}
	\		${task} =	 	${resp} 	240s	10s

Power on ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them on
	Log to console and logfile  	Powering On SERVERS	
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='Off' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	 	${resp} 	240s	5s
	

powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	 	${resp} 	240s	5s
	
Remove All Server Profiles
	[Documentation]	Querys the appliance for all Server Profiles and then removes them
	Log to console and logfile  	Removing SERVER PROFILES	
	${profiles} =	Fusion Api Get Server Profiles	param=?sort=name:ascending
	:FOR	${profile}	IN	@{profiles['members']}
	\		Log to console and logfile	tytyty
	\		${resp} =	Fusion Api Delete Server Profile	uri=${profile['uri']}
	\		${task} =	Wait For Task	${resp} 	220s

Remove Custom Range
	[Documentation]	Querys the appliance for all CUSTOM vmac, vwwn, vsn ranges and then removes them
	[Arguments]		${uri}
	Log to console and logfile  	Removing CUSTOM RANGES
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'     Remove VWWN Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	    Remove VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	    Remove VMAC Range	${rangeUri}

Remove VMAC Range
	[Documentation]	Removes a CUSTOM VMAC range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VMAC Range	uri=${uri}

Remove VWWN Range
	[Documentation]	Removes a CUSTOM VWWN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VWWN Range	uri=${uri}

Remove VSN Range
	[Documentation]	Removes a CUSTOM VSN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VSN Range	uri=${uri}

Remove All Users
	[Documentation]	Querys the appliance for all Users and then removes them
	Log to console and logfile  	Removing USERS	
	${users} = 	Fusion Api Get User
	:FOR	${user}	IN	@{users['members']}
	\		Continue For Loop If	'${user['userName']}'=='Administrator' 	
	\		Continue For Loop If	'${user['userName']}'=='administrator' 	
	\		${resp} = 	Fusion Api Remove User		uri=${user['uri']}
		
#######################################
# VALIDATION
#######################################
New Validate Response
    [Documentation]	Validates data in a response body against expected values using REGEX
    ...	looks up ${validation_code} in codes dicitonary
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation_code}
	Set Log Level	TRACE
	${validation} = 	Get From Dictionary	${codes}	${validation_code}
	${validation_results} = 	Fusion Api Validate Response	${resp}	${validation}
	# Log results	
	# Fail if results['passed'] is False
	[Return]	${validation_results}
	
Validate Response
    [Documentation]	Validates data in a response body against expected values
    ...	Example:
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE	
	${response} = 	Copy Dictionary	${resp}
	Log to console and logfile	*****1
	Log to console and logfile	${validation}
	Log to console and logfile	****2
	Log to console and logfile	${response}	
	@{vkeys} =	Get Dictionary Keys	${validation}
	Log to console and logfile	****3
	
	${rkeys} =	Get Dictionary Keys	${response}
	Log to console and logfile	***4
	Log to console and logfile	${rkeys}
	@{keys} =	Remove all the keys in response that are not in validation	${vkeys}	${rkeys}
	Log to console and logfile	***5
	Log to console and logfile	${keys[0]}
	Log to console and logfile	${keys[1]}
	:FOR	${x}	IN	@{keys}
	\	Remove From Dictionary	${response}	${x}
	Dictionaries Should Be Equal	${validation}	${response}	msg=Response does not match validation dictionary	values=True

Validate Response Regex
    [Documentation]	Validates data in a response body against expected values using regex
    ...    Make sure to escape your pattern strings properly!
    ...    Example:
	...    ${valDict} = 	Create Dictionary	status_code=${200}
	...                                     taskState=Error
	...									    taskStatus=Invalid uplink-set: Port: \\d+ for interconnect-type: .* is not an uplink port.
	...    Validate Response Regex		${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE
	${response} =   Copy Dictionary    ${resp}
	@{vkeys} =      Get Dictionary Keys    ${validation}
	:FOR	${x}	IN	@{vkeys}
	\   ${r} =    Convert to string    ${resp['${x}']}
	\   ${v} =    Convert to string    ${valDict['${x}']}
	\   Should Match Regexp		       ${r}   ${v}

Remove all the keys in response that are not in validation
	[Arguments]	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{vkeys}
	\	Remove Values From List	${rkeys}	${x}
	[Return]	${rkeys}

#######################################
# VM
#######################################

VM setup and FTS
	[Arguments]		${VM}
	Log to console and logfile	[VM SETUP]
	Run Keyword If 	'${VMSETUP}' == 'yes'	VM setup		${VM}
	Get VM IP	${VM}
	Run Keyword If 	'${FTS}' == 'yes'		First Time Setup	password=hpvse123

Get VM IP
	[Arguments]		${VM}
    # Skip looking up IP from vCenter if IP provided via command line\suite variable
	Return from Keyword If	'${APPLIANCE_IP}' is not 'None'

	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Retrieving IPv4 Address for ${VM}
	${IPS} = 	Get VM IPv4 Addresses	${VM}
	${APPLIANCE_IP} = 	Get From List	${IPS}	0
	Log to console and logfile	- Found ${APPLIANCE_IP}
    Set Suite Variable		${APPLIANCE_IP}	${APPLIANCE_IP}

VM setup
	[Arguments]		${VM}
	Set Log Level	TRACE
	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Creating snapshot for ${VM}
	Create VM Snapshot	${VM}	oob-snapshot	True	True
	Log to console and logfile	- Powering on ${VM}
	Power On VM 	${VM}
	Log to console and logfile	- Sleeping 2 min while ${VM} boots ...
	Sleep	2 min

#######################################
# LOGGING
#######################################
Open Connection And Log In
    [Arguments]         ${SSH_HOST}=localhost   ${SSH_USER}=root
    Open Connection     ${SSH_HOST}     timeout=180s
    Run Keyword If	    '${SSH_PASS}' is ${null}      Set Suite variable  ${SSH_PASS}     hpvse1
    Login               ${SSH_USER}     ${SSH_PASS}

Get Latest Log
   [Arguments]      ${LOG}=/ci/logs/ciDebug.*
   ${LATEST_LOG_FILE}=  Execute Command  ls \-r ${LOG} | head \-1
   [return]  ${LATEST_LOG_FILE}

Write To ciDebug Log
    [Documentation]    This example uses ssh to write out to the latest
    ...                ciDebug on on the OV appliance.
    [Arguments]	       ${TEXT_TO_LOG}=[${SUITE_NAME}:${TEST_NAME}]      ${SSH_HOST}=${APPLIANCE_IP}
    Open Connection And Log In      ${SSH_HOST}
    ${LOG}=  Get Latest Log
    ${rc}=    Execute Command    echo "\n#### ${TEXT_TO_LOG}\n" >> ${LOG}     return_stdout=False    return_rc=True
    Should Be Equal    ${rc}    ${0}
    Close All Connections

#######################################
# OA CLI Commands
#######################################
OA CLI EFUSE
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}    ${ACTION}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    ++diag--
    Read Until    diag>
    Write    efuse ${DEVICE} ${BAY} ${ACTION}
    Write    q
    Close All Connections

OA CLI POWERON
    [Documentation]    issues an POWERON command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWERON ${DEVICE} ${BAY}
    Close All Connections

OA CLI POWEROFF
    [Documentation]    issues an POWEROFF command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWEROFF ${DEVICE} ${BAY}
    Close All Connections

