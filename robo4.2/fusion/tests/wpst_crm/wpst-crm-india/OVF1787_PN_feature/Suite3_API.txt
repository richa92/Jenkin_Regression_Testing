*** Settings ***
Documentation     OVF1787-TBird/Hafnium: Private Network Support on Nitro.
Library         Sdumpfunctions
Library         json
Library         OperatingSystem
Library         FusionLibrary
Library         RoboGalaxyLibrary
Library         Collections
#Library           SSHLibrary
Library            Telnet
Library             Dialogs
Library             back_ping.py
Library             multhre.py
Variables       data_variables.py
Resource        ../../../resource/fusion_api_all_resource_files.txt
#Resource    OVAConfig.txt
#Force Tags    Buildup
#Suite Setup    Load Test Data and Open Browser
#Suite Teardown    Cleanup For Suite

*** Variables ***
${APPLIANCE_IP}                    192.168.144.171

${LEuri}     /rest/logical-enclosures/
${FWB_uri}   /rest/firmware-drivers/
${dump_file_path}       ${CURDIR}/support_dump
${decryptor_path}       ${CURDIR}/Decryptor
${LE_DUMP_FILE}            ${CURDIR}/support_dump/fusion_le_supportdump.sdmp
${status_trap_name}    Lost
${SPP_downgrade}    ${CURDIR}/SPP/Fw_Downgrade/${Fw_old}
#${SPP_upgrade}    ${CURDIR}/SPP/Cust_K120_37_EM2_G10/${Fw_new}
#${SPP_warm_upgrade}    ${CURDIR}/SPP/Cust_K120_38_EM2_G10/${Fw_latest}
#${SPP_downgrade}    ${CURDIR}/SPP/Cust_K130_28_EM202_Prod_G10/${Fw_old}
#${SPP_upgrade}    ${CURDIR}/SPP/Cust_K130_29_EM202_Prod_G10/${Fw_new}
${SPP_upgrade}    ${CURDIR}/SPP/FW_Upgrade/${Fw_new}
${SPP_warm_upgrade}    ${CURDIR}/SPP/Cust_K130_30_EM202_Prod_G10/${Fw_latest}
${SPP_unsupported}    ${CURDIR}/SPP/unsupported/${Fw_unsupported}
${ApplianceUrl}      192.168.144.171

*** Test Cases ***

Initial Cleanup
    [Documentation]    Returns appliance to a 'clean' state by removing all resources\enclosures
    Log to console and logfile    [Cleanup]
    Login to OneView via REST
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove All Network Sets
    Remove ALL Ethernet Networks
    Remove ALL FC Networks

Initial Setup
    [Documentation]    Initial Setup
    Set Log Level    TRACE
    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"

    :For    ${Enet}    IN    @{Enet_default}
    \    ${Enet1_resp}    Fusion Api Create Ethernet Network    ${Enet}
    \    ${task} =   Wait For Task   ${Enet1_resp}     240s    2s
    \    Run keyword unless    ${Enet1_resp['status_code']}== 202    Fail    "Unable to Create network"

    ${body} =   Build LIG body      ${LIGS_TB['ligsup'][0]}
    ${lig_resp}    Fusion Api Create LIG    ${body}
    ${task} =   Wait For Task    ${lig_resp}    400s    2s
    Run Keyword If  '${lig_resp['status_code']}' != '202'   fail    ELSE    Log to Console  \n-LIG  created successfully
    

    ${eg_resp}    Add Enclosure Group from variable    ${Enc_group}
    Run Keyword If  '${eg_resp['status_code']}' != '201'  Fail    ELSE  log to console   \n-EG created successfully

    ${le_resp}    Add Logical Enclosure from variable    ${Logical_Enclosure[0]}
    Run Keyword If  '${le_resp['status_code']}' != '200'  Fail    ELSE  log to console   \n-LE created successfully

    
    ${uplink_resp}    Fusion Api Get Uplink Set
    ${upset_members}    Get Variable Value    ${uplink_resp['members'][0]}
    ${upset_uri}    Get Variable Value    ${upset_members['logicalInterconnectUri']}
    ${body_li}=    Get Variable Value    ${libody_Dlspeed10gb}
    ${li_edit_dlspeed}=     fusion_api_patch_li    body=${libody_Dlspeed10gb}    uri=${upset_uri}

    Run Keyword If    '${li_edit_dlspeed['status_code']}' != '202'    Fail    ELSE    Log to Console  \n-Networks added successfully..
    Sleep    50

    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_1}
    Log to console    \n-${server_profile_1[0]['name']} is created successfully.
    ${Server_resp2}    Add Server Profiles from variable    ${server_profile_2}
    Log to console    \n-${server_profile_2[0]['name']} is created successfully.

    Power on server    ${server_profile_1[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_1[0]['serverHardwareUri']} is powered on Successfully

    Power on server    ${server_profile_2[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_2[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot....
    Sleep    10min


#

TC01_OVF1787_API_TC_18:60:71:110:45:Verify the traffic flow between the servers-Networks in disabled mode(2-net,2-serv)\Unicast Traffics_Verify the Private Network configuration HA setup_Verify the traffic flow between different Nitro and should be success when private network is disabled_Verify OneView allows to create network on VLAN Id:1 and allow the servers to communicate with each other
    [Documentation]    verification of the traffic flow between the servers-Networks in disabled mode(2-net,2-serv)\Unicast Traffics_Verification of the Private Network configuration HA setup_Verification of the traffic flow between different Nitro and should be success when private network is disabled_Verification of OneView allows to create network on VLAN Id:1 and allow the servers to communicate with each other


    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    Login_to_linuxserver_bringupbayone     ${iLo1_details}    ${server1_details}    ${ips_b1}

    Login_to_linuxserver_bringupbaysix     ${iLo2_details}    ${server2_details}    ${ips_b6}

    Log to Console   getting the interfaces ips from server
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    Set Global Variable    ${server_ip_address}    ${ip}

    # verification of the traffic flow between the servers-Networks in disabled mode
    Log to Console  Checking the traffics between the servers should be pass when PN is disable
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${routenbserver_ip_address}
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rout192enbpingserver_ip_address}


TC02_OVF1787_API_TC_19:59:111:45:71:101:Verify the traffic flow between the servers-Networks in enabled mode(2-net,2-serv)\Unicast traffics_Verify the traffic flow between different Nitro and should be success when private network is enabled_Verify OneView allows to create network on VLAN Id:1 and verify the server are not communicating with each other_Verify the Private Network configuration HA setup_Verify the traffic pass between S-channel and MLAG when Private network is enabled
    [Documentation]    Verification of the traffic flow between the servers-Networks in enabled mode(2-net,2-serv)\Unicast traffics_Verification of the traffic flow between different Nitro and should be success when private network is enabled_Verify OneView allows to create network on VLAN Id:1 and verify the server are not communicating with each other_Verify the Private Network configuration HA setup_Verification of the traffic pass between S-channel and MLAG when Private network is enabled
    Log to console and logfile    \n***Enable the Private network mode***
    
    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"
    
    Log to Console   \nEnabling the private network  for traffic validation between the setup servers\n
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     250s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    99
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    Log to Console   Verifying all the uplinks are in active state after toggling the Private networks
    # validate the port status reason for the ports
    validate port status reason    ${interconnectname_1}    ${uplink_port_number[0]}    Active
    validate port status reason    ${interconnectname_1}    ${uplink_port_number[1]}    Active
    validate port status reason    ${interconnectname_2}    ${uplink_port_number[0]}    Active
    validate port status reason    ${interconnectname_2}    ${uplink_port_number[1]}    Active


    Log to Console   \nChecking the traffics should be not established whne private network is enabled\n
    # Verify the traffic pass between S-channel and MLAG when Private network is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    
    Log to Console   Performing route enable on TOR 
    # enbale the router
    Route Enable    ${switch_details}
    Log to Console   \nChecking and verifying that traffic should pass between the server when route enabled in TOR and Private network enabled in networks\n
    # verify the traffic pass is success after the router enable
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    Log to Console   Verifying the traffics should fail when disable the route on TOR when private network is enabled
    # disbale the route
    Route Disable    ${switch_details}
    Sleep    300
    # Verify the traffic pass between S-channel and MLAG when Private network is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   \nValidation of ICM state of Interconnects\n
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    

TC03_OVF1787_API_TC_28:Verify that OneView should allow to take support dump
    [Documentation]    verification that OneView should allow to take support dump
    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"
    
    Validate Private Network support    ${Enet_default}

    Create Directory     ${dump_file_path}
    Log to console and logfile     \n-Getting the LE id
    ${LI_name}=     Get Variable Value    ${LI}
    ${le_uri} =    Get LE URI      ${LE}
    ${logicalEnclosureId}=    Fetch From Right        ${le_uri}      /

    Log to console and logfile     \n-Creating support dump for the LE
    ${Response}=    Fusion Api Get Logical Enclosure Support Dump   body=${LE_SupportDump_Payload}   id=${logicalEnclosureId}
    Should Be Equal as Strings      ${Response['status_code']}       202       msg=Failed to initiate Create Enclosure Support Dump.
    Log to console and logfile     \n-Waiting for dump creation task to complete
    ${task} =    Wait For Task    ${Response}    75min    1min
    Should Be Equal as Strings      ${task['status_code']}      200       msg=Failed to Create Enclosure Support Dump.
    Log to console and logfile     \n-Support dump created successfully

    Empty Directory     ${dump_file_path}
    ${supportDumpUri}=          Get From Dictionary     ${task['associatedResource']}   resourceUri
    ${Response1}=        Fusion Api Download Support Dump            uri=${supportDumpUri}   localfile=${LE_DUMP_FILE}
    Should Be Equal as Strings      ${Response1['status_code']}      200           msg=Failed to Download Enclosure Support Dump.
    Log to console and logfile      \n-Support Dump downloaded successfully
    ${presence_exists} =    file_exists    ${LE_DUMP_FILE}
    ${sizeof} =    getSize    ${LE_DUMP_FILE}
    Log to console and logfile    \n${sizeof}
    Run Keyword If    '${sizeof}' == '0'    Fail    Else    Log to console and logfile    \n-Oneview allow support dump creation in private network feature

    # Verify that OneView should allow to take support dump and validate the private network feature
    Validate Private Network support    ${Enet_default}



TC04_OVF1787_API_TC_37:Restart the Nitro and verify the private network is same
    [Documentation]    verification of the Private network configuration is same-even after Restarting the Nitro

     
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_false}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     250s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    90
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # verification of the traffic flow between the servers-Networks in disabled mode
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_192server_ip_address}


    ${private_config}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${mode}    Get Variable Value    ${Enet_resp['members'][0]['privateNetwork']}
    \    Append to list    ${private_config}    ${mode}
    Log to console and logfile    \n-${private_config}

    # restart the Nitro interconnects
    Restart Nitro    ${interconnectname_1}
    Restart Nitro    ${interconnectname_2}

    # Restart the Nitro and verify the private network is same
    ${get_lig}    Fusion Api Get Lig    param=?filter="'name'=='${LIGS_TB['ligsup'][0]['name']}'"
    ${net_uri}    Get From Dictionary    ${get_lig['members'][0]['uplinkSets'][0]}    networkUris

    ${network_config}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${net_resp}    Fusion Api Get Ethernet Networks    uri=${net_uri[${x}]}
    \    ${net_value}    Get Variable Value    ${net_resp['privateNetwork']}
    \    Append to list    ${network_config}    ${mode}

    # verification of the traffic flow between the servers-Networks in disabled mode
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_192server_ip_address}


    Lists Should Be Equal    ${private_config}    ${network_config}


TC05_OVF1787_API_TC_47:Verify that private network feature when Modified name of network(networks added in uplink set)
    [Documentation]    verification of the private network feature when modifying the network names in the uplink set

    
#    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
#    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"
    
    
     Log to console and logfile    \n***Change the name of the network***
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${pnet_name}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${pnet_name}    name    ${Net_name[${x}]}
    \    Set To Dictionary    ${pnet_name}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${pnet_name}    connectionTemplateUri    ${Enet_CT}
    \    ${change_name}    Fusion Api Edit Ethernet Network    body=${pnet_name}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${change_name}     240s    2s
    \    Run Keyword If    '${change_name['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # verify the traffic flow when modifying the network names in the uplink set
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Net_name[${x}]}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    Set To Dictionary    ${Enet_default[${x}]}    connectionTemplateUri    ${Enet_CT}
    \    ${pnet_edit}    Fusion Api Edit Ethernet Network    body=${Enet_default[${x}]}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${pnet_edit}     240s    2s
    \    Run Keyword If    '${pnet_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify the traffic flow after modifying the uplinkset names
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}



TC06_OVF1787_API_TC_49:Verify that OneView should retains the private network configuration on VLANs when Disable and Enable the Downlink ports
    [Documentation]    Verification that OneView should retains the private network configuration on VLANs when Disable and Enable the Downlink ports


 
    Log to console and logfile    \n***Enable private networks ***
    :For    ${x}    INRANGE    0    2
    \    validate port status    ${interconnectname_${x+1}}    ${downlink_port_number_${x+1}[${x}]}    Linked
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully

    Sleep    90
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Before disbale the ports check for traffic flow
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    log to console and logfile    \n*** Disabling the downlink port in IC and Verify private network configuration is same ***
    :For    ${x}    INRANGE    0    2
    \    Disable port    ${interconnectname_${x+1}}    ${downlink_port_number_${x+1}[${x}]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_${x+1}}    ${downlink_port_number_${x+1}[${x}]}    Unlinked
    \    ${resp_li}    Fusion Api Get Li    param=?filter="'name'=='${LE}-${LIG_1}'
    \    ${lig_uri}    Get Variable Value    ${lig_uri['members'][0]['logicalInterconnectGroupUri']}
    \    ${resp_lig}    Fusion Api Get Lig    uri=${lig_uri}
    \    ${net_uri}    Get Variable Value    ${resp_lig['members'][0]['uplinkSets'][0]['networkUris']}
    \    Validate the Network Configuration    ${net_uri}

    # After disable the ports check for traffic flow between the servers
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    log to console and logfile    \n*** Enabling the downlink port in IC and Verify private network configuration is same ***
    :For    ${x}    INRANGE    0    2
    \    Enable port    ${interconnectname_${x+1}}    ${downlink_port_number_${x+1}[${x}]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_${x+1}}    ${downlink_port_number_${x+1}[${x}]}    Linked
    \    ${resp_li}    Fusion Api Get Li    param=?filter="'name'=='${LE}-${LIG_1}'
    \    ${lig_uri}    Get Variable Value    ${lig_uri['members'][0]['logicalInterconnectGroupUri']}
    \    ${resp_lig}    Fusion Api Get Lig    uri=${lig_uri}
    \    ${net_uri}    Get Variable Value    ${resp_lig['members'][0]['uplinkSets'][0]['networkUris']}
    \    Validate the Network Configuration    ${net_uri}

    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # after enable the ports check for traffic flow
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}



TC07_OVF1787_API_TC_58:Verify private network configuration is as it is when Power OFF\ON Nitro modules(failover case)
    [Documentation]    Verification of the private network configuration is as it is when Power OFF\ON Nitro modules(failover case)


    Set Log Level    TRACE
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${bnet_name[${x}]}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    Set To Dictionary    ${Enet_default[${x}]}    connectionTemplateUri    ${Enet_CT}
    \    ${pnet_edit}    Fusion Api Edit Ethernet Network    body=${Enet_default[${x}]}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${pnet_edit}     240s    2s
    \    Run Keyword If    '${pnet_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify the traffic flow after modifying the uplinkset names
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_192server_ip_address}


    Log to console and logfile    \n***Enable the Private network mode***
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    ${private_config}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${mode}    Get Variable Value    ${Enet_resp['members'][0]['privateNetwork']}
    \    Append to list    ${private_config}    ${mode}
    Log to console and logfile    \n-${private_config}

    Log to console and logfile    \n***Powering off the Nitro modules
    :For    ${x}    INRANGE    0    2
    \    PowerControl    ${interconnectname_${x+1}}    ${power_off}
    \    Wait Until Keyword Succeeds    650 s   35 s    Verify Interconnect State    ${interconnectname_${x+1}}    ${IC_Maintenance}

    # after power off the Nitro validate the private network configuration
    Validate Private Network support    ${Enet_default}

    # power on the Nitro
    Log to console and logfile    \n***Powering on the Nitro modules
    :For    ${x}    INRANGE    0    2
    \    PowerControl    ${interconnectname_${x+1}}    ${power_on}
    \    Wait Until Keyword Succeeds    650 s   35 s    Verify Interconnect State    ${interconnectname_${x+1}}    ${IC_Configured}

    # after power on the Nitro validate the private network configuration
    ${get_lig}    Fusion Api Get Lig    param=?filter="'name'=='${LIGS_TB['ligsup'][0]['name']}'"
    ${net_uri}    Get From Dictionary    ${get_lig['members'][0]['uplinkSets'][0]}    networkUris
    ${network_config}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${net_resp}    Fusion Api Get Ethernet Networks    uri=${net_uri[${x}]}
    \    ${net_value}    Get Variable Value    ${net_resp['privateNetwork']}
    \    Append to list    ${network_config}    ${mode}


    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${bnet_name[${x}]}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    Set To Dictionary    ${Enet_default[${x}]}    connectionTemplateUri    ${Enet_CT}
    \    ${pnet_edit}    Fusion Api Edit Ethernet Network    body=${Enet_default[${x}]}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${pnet_edit}     240s    2s
    \    Run Keyword If    '${pnet_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    Lists Should Be Equal    ${private_config}    ${network_config}
    

    # Verify the traffic flow after modifying the uplinkset names
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_192server_ip_address}
    


TC08_OVF1787_API_TC_20:Verify the traffic flow between the servers-1 network in enabled mode and other in disabled mode(2-net,2-serv)
    [Documentation]    Verify the traffic flow between the servers-1 network in enabled mode and other in disabled mode(2-net,2-serv)


    
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    
    
    Log to console and logfile    \n***Edit Networks**
    ${resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[0]['name']}'"
    ${uri}    Get Variable Value    ${resp['members'][0]['uri']}
    ${Enet_CT}    Get Variable value    ${resp['members'][0]['connectionTemplateUri']}
    Set To Dictionary    ${Enet_default[0]}    connectionTemplateUri    ${Enet_CT}
    ${pnet_edit}    Fusion Api Edit Ethernet Network    body=${Enet_default[0]}    uri=${uri}
    ${task} =   Wait For Task   ${pnet_edit}     240s    2s
    Run Keyword If    '${pnet_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..

    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[0]['name']}'"
    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    ${Enet}    Copy Dictionary    ${Enet_default[0]}
    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_false}
    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..


    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify the traffic flow between the servers-1 network in enabled mode and other in disabled mode
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${disenbserver_ip_address}
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${new_no_ping_server_ip_address}





TC09_OVF1787_API_TC_16:54:Verify the traffic flow between the servers-Networks in disabled mode & added in Internal Networks_Verify the Downlink traffics between stack link(While networks are in disabled mode)
    [Documentation]    Verification of the traffic flow between the servers-Networks in disabled mode & added in Internal Networks_Verification of the the Downlink traffics between stack link(While networks are in disabled mode).


    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${bnet_name[${x}]}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    Set To Dictionary    ${Enet_default[${x}]}    connectionTemplateUri    ${Enet_CT}
    \    ${pnet_edit}    Fusion Api Edit Ethernet Network    body=${Enet_default[${x}]}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${pnet_edit}     240s    2s
    \    Run Keyword If    '${pnet_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # Edit the uplink set and remove the networks in LI
    ${uplink_resp}    Fusion Api Get Uplink Set
    ${upset_members}    Get Variable Value    ${uplink_resp['members'][0]}
    ${upset_uri}    Get Variable Value    ${upset_members['uri']}
    Set To Dictionary    ${Edit_uplink}    uri    ${upset_uri}
    ${li_uri}    Get Variable Value    ${upset_members['logicalInterconnectUri']}
    Set To Dictionary    ${Edit_uplink}    logicalInterconnectUri    ${li_uri}
    ${portConfigInfos}    Get Variable Value    ${upset_members['portConfigInfos']}
    Set To Dictionary    ${Edit_uplink}    portConfigInfos    ${portConfigInfos}
    Log to Console and log file    ${Edit_uplink}
    ${li_edit_net} =   Fusion Api Edit Uplink Set    body=${Edit_uplink}    uri=${upset_uri}
    Run Keyword If    '${li_edit_net['status_code']}' != '202'    Fail    ELSE    Log to Console  \n-Networks removed successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify the traffic flow between the servers-Networks in disabled mode & added in Internal Networks
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_192server_ip_address}




TC10_OVF1787_API_TC_17:53:Verify the traffic flow between the servers-Networks in enabled mode & added in Internal Networks(2-net,2-serv)_Verify the Downlink traffics between stack link(While networks are in enabled mode)
    [Documentation]    Verification of the traffic flow between the servers-Networks in enabled mode & added in Internal Networks(2-net,2-serv)_Verification of the Downlink traffics between stack link(While networks are in enabled mode)


    
    # enbale the Private network
    ${network_uris}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    Append to list    ${network_uris}    ${Enet_uri}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify the traffic flow between the servers-Networks in enabled mode & added in Internal Networks
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    # enable the router to pass the traffic
    Log to Console    \nEnabling Routing on SwitchHP5900
    Route Enable    ${switch_details}

    
    # Edit the uplink set and Add the networks in LI
    ${uplink_resp}    Fusion Api Get Uplink Set
    ${upset_members}    Get Variable Value    ${uplink_resp['members'][0]}
    ${upset_uri}    Get Variable Value    ${upset_members['uri']}
    Set To Dictionary    ${Edit_uplink}    uri    ${upset_uri}
    ${li_uri}    Get Variable Value    ${upset_members['logicalInterconnectUri']}
    Set To Dictionary    ${Edit_uplink}    logicalInterconnectUri    ${li_uri}
    ${portConfigInfos}    Get Variable Value    ${upset_members['portConfigInfos']}
    Set To Dictionary    ${Edit_uplink}    portConfigInfos    ${portConfigInfos}
    ${Network_add}    Get Variable Value    ${Add_net_Edit_uplink['nativeNetworkUri']}
    ${NW_Net1}    Get Variable Value    ${network_uris[1]}
    Set To Dictionary    ${Edit_uplink}    networkUris    ${network_uris}
    Set To Dictionary    ${Edit_uplink}    nativeNetworkUri    ${NW_Net1}
    Log to Console and log file    ${Edit_uplink}
    ${li_edit_net} =   Fusion Api Edit Uplink Set    body=${Edit_uplink}    uri=${upset_uri}
    Run Keyword If    '${li_edit_net['status_code']}' != '202'    Fail    ELSE    Log to Console  \n-Networks added successfully..
    Sleep    50

    # after router enable-ping should be success
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
#    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_192server_ip_address}

    # disable the route
    Route Disable    ${switch_details}

    # Verify the traffic flow between the servers-Networks in enabled mode & added in Internal Networks
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}
    


TC11_OVF1787_API_TC_48:Verify that private network feature when change name\change network mode of network(networks added in internal networks)
    [Documentation]    verification of the private network feature when changing the name\network mode for the internal networks


    Log to console and logfile    \n***Change the name of the network***
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${pnet_name}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${pnet_name}    name    ${Net_name[${x}]}
    \    Set To Dictionary    ${pnet_name}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${pnet_name}    connectionTemplateUri    ${Enet_CT}
    \    ${change_name}    Fusion Api Edit Ethernet Network    body=${pnet_name}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${change_name}     240s    2s
    \    Run Keyword If    '${change_name['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    99
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify that private network feature when change name\change network mode of network(networks added in internal networks)
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    # change back to Previous network name and check for traffic flow
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Net_name[${x}]}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    Set To Dictionary    ${Enet_default[${x}]}    connectionTemplateUri    ${Enet_CT}
    \    ${pnet_edit}    Fusion Api Edit Ethernet Network    body=${Enet_default[${x}]}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${pnet_edit}     240s    2s
    \    Run Keyword If    '${pnet_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    90
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # ping should be success for traffic flow verification when the networks names are same in LI-LIG
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}



TC12_OVF1787_API_TC_100_36 Verfiy the traffic pass between the S-channel and Uplinkset when the Private network is in enabled mode_Verify that OneView should able to configure the private network via Update from group from LE level
    [Documentation]    verification of the traffic pass between the S-channel and Uplinkset when the Private network is in enabled mode_Verification that OneView should able to configure the private network via Update from group from LE level
    # enable the Private network
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_default_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_default_edit}     240s    2s
    \    Run Keyword If    '${Enet_default_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # get the uplink set details for uplinkset body
    ${uplink_resp}    Fusion Api Get Uplink Set
    ${upset_members}    Get Variable Value    ${uplink_resp['members'][0]}
    ${upset_uri}    Get Variable Value    ${upset_members['uri']}
    Set To Dictionary    ${Edit_uplink}    uri    ${upset_uri}
    ${li_uri}    Get Variable Value    ${upset_members['logicalInterconnectUri']}
    Set To Dictionary    ${Edit_uplink}    logicalInterconnectUri    ${li_uri}
    ${networkUris}    Get Variable Value    ${upset_members['networkUris']}
    Set To Dictionary    ${Edit_uplink}    networkUris    ${networkUris}
    ${nativeNetworkUri}    Get Variable Value    ${upset_members['nativeNetworkUri']}
    Set To Dictionary    ${Edit_uplink}    nativeNetworkUri    ${nativeNetworkUri}
    ${portConfigInfos}    Get Variable Value    ${upset_members['portConfigInfos']}
    ${portconf}    Create List
    Append to list    ${portconf}    ${portConfigInfos[0]}
    Append to list    ${portconf}    ${portConfigInfos[2]}
    Log to console    ${portconf}
    Set To Dictionary    ${Edit_uplink}    portConfigInfos    ${portconf}

    # Edit the uplink sets
    ${li_edit_net} =   Fusion Api Edit Uplink Set    body=${Edit_uplink}    uri=${upset_uri}
    ${task} =   Wait For Task   ${li_edit_net}     240s    2s
    Run Keyword If  '${li_edit_net['status_code']}' != '202'    fail    ELSE    Log to Console  \n-LI  edited successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verfiy the traffic pass between the S-channel and Uplinkset when the Private network is in enabled mode
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    ${le_uri}    Get LE URI    ${LE}
    ${Le_update_resp}    Perform an LE Update    ${le_uri}
    Log to console and logfile    ${Le_update_resp}

TC13_OVF1787_API_TC_34:Verify the private network configuration is the same after the parallel firmware downgrade
    [Documentation]    Verify the traffic pass between the servers after doing the parallel firmware downgrade

    Log to console and logfile    \n***Enable the Private network mode***
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    Firmware Update    ${interconnectname_1}    ${interconnectname_2}    ${SPP_downgrade}    ${Fw_old}    ${firmware_li_downgrade}    ${IC_Configured}    ${Module_name}    ${Enet_default}

    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    

    # Verify the private network configuration is the same after the parallel firmware downgrade
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}


TC14_OVF1787_API_TC_33:Verify the private network configuration is the same after the parallel firmware upgrade
    [Documentation]    Verification of the private network configuration is the same after the parallel firmware upgrade


    Log to console and logfile    \n***Enable the Private network mode***
    Log to Console    \nEnable the private network on NW inLI
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50

    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK


    Firmware Update    ${interconnectname_1}    ${interconnectname_2}    ${SPP_upgrade}    ${Fw_new}    ${firmware_li_upgrade}    ${IC_Configured}    ${Module_name}    ${Enet_default}
    
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK

    # Verify the private network configuration is the same after the parallel firmware upgrade
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}


TC15_OVF1787_API_TC_30:Verify the private network is supported while warmboot firmware upgrade(Case-A)
    [Documentation]    Verify the traffic pass between the servers after doing the warmboot firmaware upgrade

    # enbale the router
     Route Enable    ${switch_details}

    # verify the traffic pass is success after the router enable
     Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    Firmware Update    ${interconnectname_1}    ${interconnectname_2}    ${SPP_warm_upgrade}    ${Fw_latest}    ${warmboot_firmware}    ${IC_Configured}    ${Module_name}    ${Enet_default}

    # Verify the private network is supported while warmboot firmware upgrade(Case-A)
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    # enbale the router
    Route Enable    ${switch_details}

    # verify the traffic pass is success after the firmware upgrade
     Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${rr_enb_server_ip_address}

    # disbale the route
     Route Disable    ${switch_details}

*** Keywords ***
Login to OneView via REST
    [Documentation]     Login to the appliance with the credentials
    [Tags]  add   POSITIVE
    Set Log Level    TRACE
    ${resp}     Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}

Ping should be success
    [Documentation]    Verify the traffic pass between two linux servers are allowed
    ...             Example:
    ...             Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    [Arguments]        ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    Log to console and logfile    \n*** Verifying the connectivity between the servers ***
    ${out} =    Login to linux server via iLo    ${iLo1_details}    ${server1_details}    ${ips[1]}
    Should Contain    ${out}    ttl=
    Should Contain    ${out}    0% packet loss

    ${out} =    Login to linux server via iLo    ${iLo2_details}    ${server2_details}    ${ips[0]}
    Should Contain    ${out}    ttl=
    Should Contain    ${out}    0% packet loss

Ping should fail
    [Documentation]    Verify the traffic pass between two windows servers are blocked
    ...             Example:
    ...             Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    [Arguments]    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    Log to console and logfile    \n*** Verifying the connectivity between the servers ***
    ${out} =    Login to linux server via iLo    ${iLo1_details}    ${server1_details}    ${ips[1]}
    Should Not Contain    ${out}    ttl=


    ${out} =    Login to linux server via iLo    ${iLo2_details}    ${server2_details}    ${ips[0]}
    Should Not Contain    ${out}    ttl=

Firmware Update
    [Documentation]    Do Firmware update in LI-validate IC state-validate Private Network support
    [Arguments]    ${Nitro_1}    ${Nitro_2}    ${Spp_path}    ${Spp_bundle}    ${Update_body}    ${IC_state}    ${Module_name}    ${Enet}
#    Power OFF ALL Servers
    ${Nitro_ic_1} =     Get IC Version        ${Nitro_1}
    Log to console and logfile    \n-${Nitro_ic_1}
    ${Nitro_ic_2} =     Get IC Version        ${Nitro_2}
    Log to console and logfile    \n-${Nitro_ic_2}
    Firmware bundle upload    ${Spp_path}
    ${resp}=   Fusion Api Get Firmware Driver    param=?filter="name='${SPP_bundle}'"    api=500
    # Run Keyword If   ${resp['count']} == 0   Fail    msg=\n No SPP bundle found!!.Please upload the correct SPP bundle
    ${fw_uri}=   Get From Dictionary  ${resp['members'][0]}    uri
    LI Firmware Update    ${Update_body}   ${fw_uri}
    Validate IC State    ${IC_state}    ${Module_name}
    ${Nitro_ic_3} =     Get IC Version        ${Nitro_1}
    Log to console and logfile    \n-${Nitro_ic_3}
    ${Nitro_ic_4} =     Get IC Version        ${Nitro_2}
    Log to console and logfile    \n-${Nitro_ic_4}
    Run Keyword If    '${Nitro_ic_1}' == '${Nitro_ic_3}'    Fail    ELSE    Log to console and logfile    \n-Firmware updated successfully.
    Run Keyword If    '${Nitro_ic_2}' == '${Nitro_ic_4}'    Fail    ELSE    Log to console and logfile    \n-Firmware updated successfully.
#    Power ON ALL Servers
    Sleep    8min
    Validate Private Network support    ${Enet}
    Sleep    150
    ${Remove_FW}   Fusion Api Remove Firmware Driver    uri=${fw_uri}
    ${task} =   Wait For Task    ${Remove_FW}    400s    2s

Firmware Update for Unsupported Hafnium
    [Documentation]    keyword to do firmware update for unsupported hafinum
    [Arguments]    ${Nitro_1}    ${Nitro_2}    ${Spp_path}    ${Spp_bundle}    ${Update_body}    ${IC_state}    ${Module_name}    ${Enet}
    Power OFF ALL Servers
    ${Nitro_ic_1} =     Get IC Version        ${Nitro_1}
    Log to console and logfile    \n-${Nitro_ic_1}
    ${Nitro_ic_2} =     Get IC Version        ${Nitro_2}
    Log to console and logfile    \n-${Nitro_ic_2}
    Firmware bundle upload    ${Spp_path}
    ${resp}=   Fusion Api Get Firmware Driver    param=?filter="name='${SPP_bundle}'"    api=500
    Run Keyword If   ${resp['count']} == 0   Fail    msg=\n No SPP bundle found!!.Please upload the correct SPP bundle
    ${fw_uri}=   Get From Dictionary  ${resp['members'][0]}    uri
    LI Firmware Update for Unsupported    ${Update_body}   ${fw_uri}
    # Validate IC State    ${IC_state}    ${Module_name}
    ${Nitro_ic_3} =     Get IC Version        ${Nitro_1}
    Log to console and logfile    \n-${Nitro_ic_3}
    ${Nitro_ic_4} =     Get IC Version        ${Nitro_2}
    Log to console and logfile    \n-${Nitro_ic_4}
    Run Keyword If    '${Nitro_ic_1}' != '${Nitro_ic_3}'    Fail    ELSE    Log to console and logfile    \n-Firmware cannot be updated successfully.
    Run Keyword If    '${Nitro_ic_2}' != '${Nitro_ic_4}'    Fail    ELSE    Log to console and logfile    \n-Firmware cannot be updated successfully.
    Power ON ALL Servers
    Sleep    8min
    Validate Private Network support    ${Enet}
    Sleep    150
    ${Remove_FW}   Fusion Api Remove Firmware Driver    uri=${fw_uri}
    ${task} =   Wait For Task    ${Remove_FW}    400s    2s


Firmware bundle upload
    [Documentation]    keyword to upload the firmware bundle
    [Arguments]         ${SPP_Path}
    ${Spp_resp} =     Fusion Api Upload Firmware Bundle      localfile=${SPP_Path}
    Log to Console    Upload_spp_details ${Spp_resp}
    ${task} =   Wait For Task    ${Spp_resp}    400s    2s

Validate Private Network support
    [Documentation]    Validation of the Private network support in the Oneview
    [Arguments]    ${Enets}
    :For    ${x}    INRANGE    0    2
    \    ${pri_net_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enets[${x}]['name']}'"
    \    ${Validate_net}    Copy Dictionary    ${pri_net_resp['members'][0]}
    \    Dictionary Should Contain Key    ${Validate_net}    privateNetwork
    \    ${value}    Get Variable Value    ${Validate_net['privateNetwork']}
    \    Run Keyword If  '${value}' == 'True'    Log to console and logfile    \n-private network is enabled..    ELSE    Fail

Get IC Version
    [Documentation]    Get the version of the ICM
    [Arguments]    ${Nitro_Name}
    ${Nitro_ic} =   Get IC        ${Nitro_Name}
    ${Nitro_vesrion} =    Get From IC    ${Nitro_ic}   firmwareVersion
    [Return]    ${Nitro_vesrion}

LI Firmware Update
    [Documentation]    Update firmware in LI
    [Arguments]    ${fw_update}    ${fw_uri}
    ${li_uri}    Get LI URI    ${LE}-${LIG_1}
    Set to dictionary     ${fw_update}     sppUri    ${fw_uri}
    ${Li_firmware} =    Fusion Api Li Upgrade Firmware    body=${fw_update}    uri=${li_uri}
    ${task} =    Wait For Task    ${Li_firmware}    45 min    15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}

LI Firmware Update for Unsupported
    [Documentation]    Update firmware in LI for unsupported mode and validate the taskstate as Warning
    [Arguments]    ${fw_update}    ${fw_uri}
    ${li_uri}    Get LI URI    ${LE}-${LIG_1}
    Set to dictionary     ${fw_update}     sppUri    ${fw_uri}
    ${Li_firmware} =    Fusion Api Li Upgrade Firmware    body=${fw_update}    uri=${li_uri}
    ${task} =       Wait For Task    ${Li_firmware}    45 min       15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Warning
    Validate Response    ${task}    ${valDict}

Restart Nitro
    [Documentation]    Refresh/Restart of the ICM Nitro
    [Arguments]    ${IC}
    Log to console and logfile  -Restart Nitro
    ${ic} =     Get IC    ${IC}
    ${uri} =    Get From IC     ${ic}   uri
    Log to console and logfile      ${uri}
    ${body} =   Create Dictionary   op=replace
    ...                             path=/deviceResetState
    ...                             value=Reset
    ${body} =   Create list     ${body}
    ${resp} =   fusion api patch interconnect   body=${body}    uri=${uri}
    Log to console and logfile    ${resp}
    ${task} =   Wait for Task   ${resp}
    Log to console and logfile    ${task}
    Log to console and logfile      Sleeping for 2 mins
    Sleep   9min

PowerControl
    [Documentation]    Power off and Power on the interconnect and verify its power state by ic name
    [Arguments]    ${IC}    ${power_control}
    ${ic} =     Get IC    ${IC}
    ${uri} =    Get From IC     ${ic}   uri
    Log to console and logfile      ${uri}
    ${body} =   Create Dictionary   op=replace
    ...                             path=/powerState
    ...                             value=${power_control}
    ${body} =   Create list     ${body}
    Log to console and logfile    ${body}
    ${resp} =   fusion api patch interconnect   body=${body}    uri=${uri}
    Log to console and logfile    ${resp}
    ${task} =   Wait for Task   ${resp}
    Log to console and logfile      task is ${task}
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Log to console and logfile      valdict is ${valDict}
    Validate Response    ${task}    ${valDict}
    Log to console and logfile      Sleeping for 4 mins
    Sleep   13min
    Log to console and logfile  -Verify it's ${power_control}

Validate IC State
    [Documentation]    Get and validate the ICM state by IC-Name
    ...             Example:
    ...             Validate IC State    ${IC_State}    ${Module_name}
    [Arguments]    ${IC_State}    ${Module_name}
    ${resp} =   Get IC State    ${Module_name}
    #Log to console and logfile    \n\n${resp}
    ${len} =    Get Length  ${resp}
    :FOR    ${x}    IN RANGE    0   ${len}
    \   Run Keyword If    '${resp[${x}]}' == '${IC_State}'    Log to console    \nThe state of IC is ${resp[${x}]}    Fail    "The state of IC is not ${resp[${x}]}"

Get IC State
    [Documentation]    Get the Interconnect state by name
    ...             Example:
    ...             Get IC State    ${Module_name}
    [Arguments]    ${Module_name}
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
    #Log to console and logfile ${ics}
    ${l} =  Get Length  ${ics}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \   Run Keyword If  '${ic['model']}' != '${Module_name}'        Continue For Loop
    \   ${uri} =     Get From Dictionary   ${ic}    uri
    \   ${name} =     Get From Dictionary   ${ic}    name
    \   ${state} =    Get From Dictionary   ${ic}    state
    \   Log to console and logfile      \n\n${ic['model']} : ${uri} : ${name} : ${state}
    \   Append to list      ${ic_list}  ${state}
    \   Log To Console      \nGet IC:${ic_list}
    [Return]    ${ic_list}

Verify Interconnect State
    [Documentation]    Verify the interconnect state of the ICM
    ...             Example:
    ...             Verify Interconnect State    ${interconnectname_1}    ${IC_Configured}
    [Arguments]        ${interconnectname_1}        ${POWER_STATE}
    ${ic} =        Get IC    ${interconnectname_1}
    ${State} =    Get From IC        ${ic}    state
    Log to console and logfile    Interconnect state is ${interconnectname_1}:${State}
    Should Be Equal As Strings    ${State}    ${POWER_STATE}

Get IC and Verify state
    [Documentation]    Get the IC details and verify the interconnect state for each ICM
    [Arguments]    ${IC_Configured}
    ${IC_output}    Fusion Api Get Interconnect
    ${Num_IC}    Get Variable Value    ${IC_output['count']}
    :For    ${x}    INRANGE    0    ${Num_IC}
    \    Wait Until Keyword Succeeds    650s   35 s    Verify Interconnect State    ${IC_output['members'][${x}]['name']}    ${IC_Configured}
    Sleep    50

Get IC
    [Documentation]    Get Interconnect details by IC name
    ...             Example:
    ...             Get IC      ${ICM_NAME}
    [Arguments]        ${ICM_NAME}
    ${resp} =   fusion api get interconnect
    Log        ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =     Get Length    ${ics}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \     Exit For Loop If     '${ic['name']}' == '${ICM_NAME}'
    [Return]    ${ic}

Get from IC
    [Documentation]    Get the required element from the interconnect
    ...             Example:
    ...             Get from IC    ${ic}    ${element}
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}

Route Enable
    [Documentation]    Enable Route arp by passing switch credentials
    ...             Example:
    ...             Route Enable    ${Switch_credentials}
    [Arguments]    ${Credentials}
    Log to console    \n-Route Enable
    SSHLibrary.Open Connection    ${Credentials['switch_ip']}
    SSHLibrary.Login    ${Credentials['username']}    ${Credentials['password']}
    Sleep    5s
    SSHLibrary.Read Until    <HP>
    Sleep    5s
    SSHLibrary.Write    sys
    Sleep    5s
    SSHLibrary.Read Until    [HP]
    Sleep    5s
    SSHLibrary.Write    interface Vlan-interface 1601
    Sleep    5s
    SSHLibrary.Write    local-proxy-arp enable
    Sleep    1000s
    SSHLibrary.Close All connections

Route Disable
    [Documentation]    Disable Route arp by passing switch credentials
    ...             Example:
    ...             Route Disable    ${Switch_credentials}
    [Arguments]    ${Credentials}
    Log to console    \n-Route Disable
    SSHLibrary.Open Connection    ${Credentials['switch_ip']}
    SSHLibrary.Login    ${Credentials['username']}    ${Credentials['password']}
    Sleep    5s
    SSHLibrary.Read Until    <HP>
    Sleep    5s
    SSHLibrary.Write    sys
    Sleep    5s
    SSHLibrary.Read Until    [HP]
    Sleep    5s
    SSHLibrary.Write    interface Vlan-interface 1601
    Sleep    5s
    SSHLibrary.Write    undo local-proxy-arp enable
    Sleep    1200s
    SSHLibrary.Close All connections

Disable port
    [Documentation]   Disabling the uplink port of interconnect by passing portnumber and icname
    ...             Example:
    ...             Disable port    ${icm}    ${port_number}
    [Arguments]    ${icm}    ${port_number}
    ${ic_uri} =   Get IC URI    ${icm}
    Log to console    ${ic_uri}
    ${resp} =     Get IC Port    uri=${ic_uri}   port=${port_number}
    Log to console and logfile    \n${resp}
    Set to Dictionary   ${resp}   enabled    ${false}
    ${body} =    Create List
    Append to list    ${body}    ${resp}

    ${resp} =     fusion api edit interconnect ports   uri=${ic_uri}   body=${body}
    ${task} =       Wait For Task   ${resp}     7 min   15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}
    Sleep    60

Enable port
    [Documentation]   Enabling the uplink port of interconnect by passing portnumber and icname
    ...             Example:
    ...             Enable port    ${icm}    ${port_number}
    [Arguments]    ${icm}    ${port_number}
    ${ic_uri} =   Get IC URI    ${icm}
    Log to console    ${ic_uri}
    ${resp} =     Get IC Port    uri=${ic_uri}   port=${port_number}
    Log to console and logfile    \n${resp}
    Set to Dictionary   ${resp}   enabled    ${true}
    ${body} =    Create List
    Append to list    ${body}    ${resp}

    ${resp} =     fusion api edit interconnect ports   uri=${ic_uri}   body=${body}
    ${task} =       Wait For Task   ${resp}     7 min   15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}
    Sleep    60

Get IC Port
    [Documentation]    Get IC Port name
    [Arguments]     ${uri}  ${port}
    ${resp} =   fusion api get interconnect ports    uri=${uri}
    ${ics} =     Get From Dictionary     ${resp}    members
    :FOR    ${ic}   IN      @{ics}
    \   ${return} =    Run Keyword If   '${ic['portName']}' == '${port}'        set variable     ${ic}
    \   Exit for loop if    '${ic['portName']}' == '${port}'
    [Return]    ${return}

validate port status
    [Documentation]    validate the port status of the ICM
    [Arguments]   ${icm}   ${portname}   ${state}
    ${ic}=   Get IC URI   ${icm}
    ${resp}=   fusion_api_get_interconnect_ports   uri=${ic}
    :FOR   ${port}  IN   @{resp['members']}
    \    run keyword if  '${port['portName']}' != '${portname}'   Continue For Loop
    \    should match  ${port['portStatus']}   ${state}
    \    Log to console and logfile    Port Status ${port['portStatus']} matches expected ${state}

Get IC URI
    [Documentation]    Get the uri of the interconnect
    [Arguments]     ${ic}
    ${resp} =   Fusion Api Get Interconnect         param=?filter="'name'=='${ic}'"
    ${uri} =    Get From Dictionary     ${resp['members'][0]}   uri
    [Return]    ${uri}

Get Valid Server IP list
    [Documentation]    Get the only the valid ip of the one or more servers
    ...             Example:
    ...             Get Valid Server IP list    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}    ${get_interface}
    [Arguments]    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}    ${get_interface}
    ${Adapter_list}    Get Valid Interface List    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    ${ifconfig_output_list}    Create List
    ${Len_of_adapter}    Get Length    ${Adapter_list}
    :For    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${ifconfig_name}    Replace String Using Regexp    ${get_interface}    interface-name    ${Adapter_list[${x}]}
    \    ${Ip_output}    Get Valid Server IP    ${ilo_details}    ${server_details}    ${ifconfig_name}
    \    Log to console and logfile    ${Ip_output}
    \    Append to list    ${ifconfig_output_list}    ${Ip_output}
    ${temp_list}    Convert To String    ${ifconfig_output_list}

    ${ret}    Get Regexp Matches    ${temp_list}    inet (\\d+.\\d+.\\d+.\\d+)\\s+netmask
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\s+netmask
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    Log to console and logfile    ${Ip_List}
    [Return]    ${Ip_List}

Get Valid Interface List
    [Documentation]    Get the all the interface of the server and return only the required server
    ...             Example:
    ...             Get Valid Interface List    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    [Arguments]    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    ${ip_adapter}    Get Server IP Linux    ${ilo_details}    ${server_details}
    ${ret}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<BROADCAST
    ${ret_1}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<NO-CARRIER
    ${Interface_list} =    Create List
    ${length} =     Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${Interface_list}    ${ret[${x}]}
    ${length} =     Get Length    ${Interface_list}
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${Interface_list[${x}]}    \\d+:\\s+(.*):\\s+<BROADCAST
    \    Log to console   values ${match}
    \    Append To List   ${Adapter_name}    ${match}
    Remove Values From List    ${Adapter_name}    virbr0-nic

    ${Len_of_adapter}    Get Length    ${Adapter_name}
    ${Adapter_list}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${Adapter_name[${x}]}
    \    Append to list    ${Adapter_list}    ${temp}
    Log to console and logfile    ${Adapter_list}

    ${Len_of_adapter_list}    Get Length    ${Adapter_list}
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter_list}
    \    ${ifup_adapter}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapter_list[${x}]}
    \    Up the Interface    ${ilo_details}    ${server_details}    ${ifup_adapter}

    ${Non_Interface_list} =    Create List
    ${length} =     Get Length  ${ret_1}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${Non_Interface_list}    ${ret_1[${x}]}

    ${length} =     Get Length    ${Non_Interface_list}
    ${Non_Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${Non_Interface_list[${x}]}    \\d+:\\s+(.*):\\s+<NO-CARRIER
    \    Log to console   values ${match}
    \    Append To List   ${Non_Adapter_name}    ${match}
    Remove Values From List    ${Non_Adapter_name}    virbr0

    ${Len_of_non_adapter}    Get Length    ${Non_Adapter_name}
    ${Non_Adapter_list}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_non_adapter}
    \    ${temp}    Convert To String    ${Non_Adapter_name[${x}]}
    \    Append to list    ${Non_Adapter_list}    ${temp}
    Log to console and logfile    ${Non_Adapter_list}

    ${Len_of_non_adapter_list}    Get Length    ${Non_Adapter_list}
    :FOR    ${x}    INRANGE    0    ${Len_of_non_adapter_list}
    \    ${ifdown_adapter}    Replace String Using Regexp   ${down_interface}    interface-name    ${Non_Adapter_list[${x}]}
    \    Down the Interface    ${ilo_details}    ${server_details}    ${ifdown_adapter}

    [Return]    ${Adapter_list}

Get Valid Server IP
    [Documentation]    Get the only the valid ip of the server
    ...             Example:
    ...             Get Valid Server IP    ${ilo_details}    ${server_details}    ${ifconfig_adapter_name}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifconfig_adapter_name}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifconfig_adapter_name}
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    Sleep    15sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Down the Interface
    [Documentation]    Disconnect the interface/off the interface inside server
    ...             Example:
    ...             Down the Interface    ${ilo_details}    ${server_details}    ${ifdown_adapter}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifdown_adapter}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifdown_adapter}
    Sleep    10sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections

Up the Interface
    [Documentation]    Up the interface/connect the interface inside server
    ...             Example:
    ...             Up the Interface    ${ilo_details}    ${server_details}    ${ifup_adapter}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifup_adapter}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifup_adapter}
    Sleep    10sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections

Get Server IP Linux
    [Documentation]    Gets the valid ip of the server
    [Arguments]         ${linux_ilo_details}    ${linux_server_details}
    SSHLibrary.Open Connection     ${linux_ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login               ${linux_ilo_details['username']}     ${linux_ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    20sec
    SSHLibrary.Read
    Sleep    5sec
    SSHLibrary.Write     ${linux_server_details['username']}
    Sleep    10sec
    SSHLibrary.Write     ${linux_server_details['password']}
    Sleep    10sec
    SSHLibrary.Read
    SSHLibrary.Write     ip addr
    Sleep    10sec
    ${stdout}    SSHLibrary.Read
    Sleep    15sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Login to linux server via iLo
    [Documentation]    Ping server via iLo
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ping -c 10 ${ip}
    Sleep    10sec
    SSHLibrary.write    ping -c 120 ${ip}
    Sleep    240sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    Sleep    50sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Login_to_linuxserver_bringupbayone
    [Documentation]    Ping server via iLo
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ifdown ens2f1
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f0 ${ip[1]} netmask 255.255.255.0 up
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f4 ${ip[0]} netmask 255.255.248.0 up
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    Sleep    50sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Login_to_linuxserver_bringupbaysix
    [Documentation]    Ping server via iLo
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ifdown ens2f1
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f4 ${ip[1]} netmask 255.255.255.0 up
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f0 ${ip[0]} netmask 255.255.248.0 up
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    Sleep    50sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}
    
Get IP and Adapter
    [Documentation]    Get IP and adapter from the server
    [Arguments]         ${ip_adapter}
    ${ret}    Get Regexp Matches    ${ip_adapter}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    ${match2}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    \    ${Adapter_list}    Fetch From Right        ${Ret}      global
    \    ${temp}    Remove Whitespace    ${Adapter_list}
    \    Append To List   ${Adapter_name}    ${temp}

    Log to console  final list ${Ip_List}
    Log to console   final list2 ${Adapter_name}
    [Return]    ${Ip_List}    ${Adapter_name}

Get Server IP
    [Documentation]    Get the server ip list from the ifconfig output
    [Arguments]         ${server_ip}
    ${ret}    Get Regexp Matches    ${server_ip}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    Log to console  final list ${Ip_List}
    [Return]    ${Ip_List}

Build LIG body
    [Documentation]    Building LIG
    [Arguments]     ${xlig}
    ${xlig} =   fusion_api_appliance_setup.Copy Dictionary  ${xlig}
    ${uplinkSets} =     Copy List   ${xlig['uplinkSets']}
    ${l} =    Get Length    ${uplinkSets}

    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${networkType} =    Get From Dictionary     ${uplinkSets[${x}]}    networkType
    \   ${networks} =       Get From Dictionary     ${uplinkSets[${x}]}    networkUris
    \   ${networks_native} =        Get From Dictionary     ${uplinkSets[${x}]}    nativeNetworkUri
    \   Run Keyword If    '${networkType}' == 'Ethernet'      Continue For Loop
    \   ${networkUris} =    Get FC Uris    ${networks}
    \   Set to dictionary   ${uplinkSets[${x}]}    networkUris    ${networkUris}

    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${networkType} =    Get From Dictionary     ${uplinkSets[${x}]}    networkType
    \   ${networks} =       Get From Dictionary     ${uplinkSets[${x}]}    networkUris
    \   #fusion_api_appliance_setup.Log to console and logfile    \n networks    ${networks}
    \   ${networks_native} =    Get From Dictionary     ${uplinkSets[${x}]}    nativeNetworkUri
    \   #fusion_api_appliance_setup.Log to console and logfile    \n networks native    ${networks_native}
    \   Run Keyword If    '${networkType}' == 'FibreChannel'    Continue For Loop
    \   ${networkUris} =    Get FCoE Uris    ${networks}
    \   ${ethernetUris} =   Get Ethernet URIs    ${networks}
    \   ${ethernetUris_native} =   Get Ethernet URI    ${networks_native}
    \   #fusion_api_appliance_setup.Log to console and logfile    \n native uri${ethernetUris_native}
    \   ${networkUris} =    combine lists   ${networkUris}    ${ethernetUris}
    \   #fusion_api_appliance_setup.Log to console and logfile    \n net ${networkUris}
    \   Set to dictionary    ${uplinkSets[${x}]}    networkUris     ${networkUris}
    \   Set to dictionary   ${uplinkSets[${x}]}    nativeNetworkUri    ${ethernetUris_native}
    \   #fusion_api_appliance_setup.Log to console and logfile    ${uplinkSets[${x}]}

    ${name} =                       Get Variable Value  ${xlig['name']}
    ${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
    ${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
    ${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
    ${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
    ${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
    ${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
    ${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
    ${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
    ${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
    ${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
    ${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
    #${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}

    ${body} =   Fusion Api Create LIG Payload   name=${name}
    ...                                         enclosureIndexes=${enclosureIndexes}
    ...                                         enclosureType=${enclosureType}
    ...                                         ethernetSettings=${ethernetSettings}
    ...                                         fcoeSettings=${fcoeSettings}
    ...                                         interconnectBaySet=${interconnectBaySet}
    ...                                         interconnectMapTemplate=${interconnectMapTemplate}
    ...                                         redundancyType=${redundancyType}
    ...                                         stackingMode=${stackingMode}
    ...                                         telemetryConfiguration=${telemetryConfiguration}
    ...                                         snmpConfiguration=${snmpConfiguration}
    ...                                         uplinkSets=${uplinkSets}
    [Return]    ${body}

Validate the Network Configuration

    [Documentation]    Validate the private network configuration by checking private network attribute
    [Arguments]    ${Network_Uri}
    :For    ${x}    INRANGE    0    2
    \    ${resp_ethernet}    Fusion Api Get Ethernet Networks    uri=${Network_Uri[${x}]}
    \    ${Validate_net}    Get Variable Value    ${resp_ethernet['privateNetwork']}
    \    Run Keyword If    '${Validate_net}' == 'True'    Log to console and logfile    \n-The private network feature remains the same..    ELSE    Fail

validate port status reason
    [Documentation]   validate port status
    [Arguments]   ${icm}   ${portname}   ${state}
    ${ic}=   Get IC URI   ${icm}
    ${resp}=   fusion_api_get_interconnect_ports   uri=${ic}
    :FOR   ${port}  IN   @{resp['members']}
    \    run keyword if  '${port['portName']}' != '${portname}'   Continue For Loop
    \    should match  ${port['portStatusReason']}   ${state}
    \    Log to console and logfile    Port Status ${port['portStatusReason']} matches expected ${state}

Port Affinity MLAG
    [Documentation]    Get the ICM list of the MLAG port affinity status from the server profile
    [Arguments]    ${server_profile_1}    ${server_profile_2}
    ${Profile1_ICM}    Create List
    ${Profile2_ICM}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${server_resp}    Fusion Api Get Server Profiles    param=?filter="'name'=='${server_profile_${x+1}[0]['name']}'"
    \    ${Connections}    Get From Dictionary      ${server_resp['members'][0]['connectionSettings']}      connections
    \    ${Len_of_connections}    Get Length    ${Connections}
    \    ${IC_List}    Port Affinity Status    ${Len_of_connections}    ${Connections}
    \    Append to List    ${Profile${x+1}_ICM}    ${IC_List}
    Log to console and logfile    ${Profile1_ICM}
    Log to console and logfile    ${Profile2_ICM}

    ${Len_of_ICM1_list}    Get Length    ${Profile1_ICM[0]}
    ${Len_of_ICM2_list}    Get Length    ${Profile2_ICM[0]}
    ${ICM}    Create List
    :For    ${x}    INRANGE    0    ${Len_of_ICM1_list}
    \    ${Pro1_ICM_Value}    Get From List    ${Profile1_ICM[0]}    ${x}
    \    Append to list    ${ICM}    ${Pro1_ICM_Value}

    :For    ${x}    INRANGE    0    ${Len_of_ICM2_list}
    \    ${Pro2_ICM_Value}    Get From List    ${Profile2_ICM[0]}    ${x}
    \    Append to list    ${ICM}    ${Pro2_ICM_Value}

    Log to console and logfile    ${ICM}
    ${Final_list_ICM}    Remove Duplicates    ${ICM}
    Log to console and logfile    ${Final_list_ICM}

    [Return]    ${Final_list_ICM}

Port Affinity Status
    [Documentation]    verify the port affinity status of the interconnect and return the ICM list
    [Arguments]    ${count}    ${Connections}
    ${ICM}    Create List
    :For    ${x}    INRANGE    0    ${count}
    \    ${connection}    Copy Dictionary   ${Connections[${x}]}
    \    Dictionary Should Contain Key    ${connection}    interconnectUri
    \    ${IC_Uri}    Get Variable Value    ${connection['interconnectUri']}
    \    ${IC_resp}    Fusion Api Get Interconnect    uri=${IC_Uri}
    \    ${Fetch_IC_name}    Get Variable Value    ${IC_resp['name']}
    \    Append to List    ${ICM}    ${Fetch_IC_name}

    ${ICM_list}    Remove Duplicates    ${ICM}

    [Return]    ${ICM_list}

Get Inpackets and Outpackets
    [Documentation]    Get statistics of Inpackets and Outpackets of the ICM by portname
    [Arguments]    ${ICM_1}    ${stat}    ${uplink_port_name}
    ${icUri}        Get IC URI    ${ICM_1}
    ${ic_uri_statistics} =        catenate    ${icUri}/${stat}/${uplink_port_name}

    ${statistics_data}    Fusion Api Get Interconnect    ${ic_uri_statistics}
    Log to console    \n${statistics_data['commonStatistics']}
    ${In_packets}    Get from Dictionary    ${statistics_data['commonStatistics']}    rfc1213IfInUcastPkts
    ${Out_packets}    Get from Dictionary    ${statistics_data['commonStatistics']}    rfc1213IfOutUcastPkts
    Log to console    ${ICM_1}:${uplink_port_name}
    Log to console    In-packets:${In_packets}
    Log to console    Out-packets:${Out_packets}
    [Return]    ${In_packets}    ${Out_packets}

Perform an LE Update
    [Documentation]    Performing an LE update from group
    [Arguments]       ${le}     ${timeout}=35 min    ${interval}=25s
    ${resp} =       Fusion Api Update Logical Enclosure from Group    ${le}
    ${task} =       Wait For Task       ${resp}     ${timeout}        ${interval}
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}

IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    [Documentation]    Get the IC state and verifyit is in configured state
#    [Arguments]     ${LI_ALL_VC_INTERCONNECTS}

	${resp} =   fusion api get interconnect
#    Log To Console          ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =      Get Length    ${ics}
    ${icm_list} =    Create List
    :FOR  ${x}  IN RANGE    0     ${l}
    \    ${ic} =     Get From List   ${ics}    ${x}
     \    ${ic_name} =     Get from IC    ${ic}    name

	\    ${ic} =     Get IC        ${ic_name}
	\    ${icstate} =     Get From IC    ${ic}   state
	\    Should Be Equal As Strings    ${icstate}     Configured
	\    Log to Console    Validated the Interconnect state of ${ic_name}
	\    Log to Console    and its state is ${icstate}


Cleanup For Suite
    [Documentation]    Returns appliance to a 'clean' state by removing all resources\enclosures
    Log to console and logfile  [Cleanup]
    Login to OneView via REST
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove All Network Sets
    Remove ALL Ethernet Networks
    Remove ALL FC Networks