*** Settings ***
Documentation     ovf1787-TBird/Hafnium:Add Private Network Support.
Library         Sdumpfunctions
Library         OperatingSystem
Library         FusionLibrary
Library         Telnet
Library         SSHLibrary
Library    Dialogs
Library         RoboGalaxyLibrary
Library         data_variables
Library             back_ping.py
Variables       data_variables.py
Resource        ../../../resource/fusion_api_all_resource_files.txt
Resource    OVAConfig.txt
Force Tags    Buildup
#Suite Setup    Cleanup For Suite
#Suite Teardown      Cleanup For Suite

*** Test Cases ***



Initial Cleanup
    [Documentation]    Returns applianceto a 'clean' state by removing all resources\enclosures
    Log to console and logfile    [Cleanup]
    Login to OneView via REST

    # delete the created bond
    :For    ${x}    INRANGE    0    2
    \    ${Del_bond}    Build Commands For Delete Bonding    ${Delete_Network_bond}    ${Delete_bond_slave_1}    ${Delete_bond_slave_2}    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${Bond_${x+1}}


    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove All Network Sets
    Remove ALL Ethernet Networks
    Remove ALL FC Networks

1 Initial Setup
    [Documentation]    Creating setup
    Set Log Level    TRACE
    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Run keyword unless    ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"

    :For    ${Enet}    IN    @{Enet_default}
    \    ${Enet1_resp}    Fusion Api Create Ethernet Network    ${Enet}
    \    ${task} =   Wait For Task   ${Enet1_resp}     240s    2s
    \    Run keyword unless    ${Enet1_resp['status_code']}== 202  Fail    "Unable to Create network"
    # create LIG
    ${body} =    Build LIG body    ${LIGS_TB['ligsup_HA'][0]}
    ${lig_resp}    Fusion Api Create LIG    ${body}
    ${task} =   Wait For Task    ${lig_resp}    400s    2s
    Log to Console  \n-LIG  created successfully

    ${eg_resp}    Add Enclosure Group from variable    ${Enc_group}
    Run Keyword If  '${eg_resp['status_code']}' != '201'  Fail    ELSE  log to console   \n-EG created successfully
    ${le_resp}    Add Logical Enclosure from variable    ${Logical_Enclosure[0]}
    Run Keyword If  '${le_resp['status_code']}' != '200'  Fail    ELSE  log to console   \n-LE created successfully
   
    ${uplink_resp}    Fusion Api Get Uplink Set
    ${upset_members}    Get Variable Value    ${uplink_resp['members'][0]}
    ${upset_uri}    Get Variable Value    ${upset_members['logicalInterconnectUri']}
    ${body_li}=    Get Variable Value    ${libody_Dlspeed10gb}
    ${li_edit_dlspeed}=     fusion_api_patch_li    body=${libody_Dlspeed10gb}    uri=${upset_uri}

    Run Keyword If    '${li_edit_dlspeed['status_code']}' != '202'    Fail    ELSE    Log to Console  \n-Networks added successfully..
    Sleep    50
    
TC01_OVF1787_API_TC_81 Verify the traffic flow should be success between the servers via Downlinks of different PHYs when the private network is disabled
    [Documentation]    verification of the traffic flow should be success between the servers via Downlinks of different PHYs when the private network is disabled
    Set Log Level    TRACE
    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Run keyword unless    ${Login_resp[0]['status_code']}== 200    Fail    "Unable to Login"

    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_HA1_OP}
    Log to console    \n-${server_profile_HA1_OP[0]['name']} is created successfully.
    ${Server_resp2}    Add Server Profiles from variable    ${server_profile_HA2_OP}
    Log to console    \n-${server_profile_HA2_OP[0]['name']} is created successfully.

    Power on server    ${server_profile_HA1_OP[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA1_OP[0]['serverHardwareUri']} is powered on Successfully

    Power on server    ${server_profile_HA2_OP[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA2_OP[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot...

    Sleep    10min

    # Get the valid server ip list ofr traffic flow verifictaion
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # Verify the traffic flow should be success between the servers via Downlinks of different PHYs when the private network is disabled
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

#####OVF1787_API_TC_76 Verify the traffic flow should not be success between the servers via Downlinks of different PHYs when the private network is enabled####

    # Enbale the Private network and check for traffic flow
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_default_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_default_edit}     240s    2s
    \    Run Keyword If    '${Enet_default_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # Verify the traffic flow between the servers via Downlinks of different PHYs when the private network is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

TC02_OVF1787_API_TC_92:Verify the traffic flow between VPLAG and different S-channel when the private network feature is enabled
    [Documentation]    Verification of the traffic flow between VPLAG and different S-channel when the private network feature is enabled

    Power off server    ${server_profile_HA1_OP[0]['serverHardwareUri']}

    ${del_pro1}    Fusion Api Delete Server Profile    param=?filter="'name'=='${server_profile_HA1_OP[0]['name']}'"
    ${task} =   Wait For Task    ${del_pro1}    400s    2s

    # create the VPLAG Profile
    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_HA3_lag}
    Log to console    \n-${server_profile_HA3_lag[0]['name']} is created successfully..

    Power on server    ${server_profile_HA3_lag[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA3_lag[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot...

    Sleep    10min


    # Get the valid interface list for network bonding
    ${adapter}    Get Valid Interface List    ${ilo1_details}    ${server1_details}    ${up_interface}    ${down_interface}
    Log to console and logfile    ${adapter}
    ${Len_of_adapter}    Get Length    ${adapter}
    ${Adapterlist}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${adapter[${x}]}
    \    Append to list    ${Adapterlist}    ${temp}
    Log to console and logfile    ${Adapterlist}

    # create Bond
    ${cmd_out}    Build Commands For Create Bonding    ${Adapter_1}    ${Adapter_2}    ${Create_bond}    ${Master_slave_1}    ${Master_slave_2}    ${Bond_slave_1}    ${Bond_slave_2}    ${Network_bond}    ${Master}    ${Modify_bond}    ${Modify_ip}    ${Modify_manual}    ${Adapterlist}    ${Bond_1}    ${space}    ${Ip_bond_1}    ${iLo1_details}    ${server1_details}


    # Get the valid server ip list for traffic flow verifictaion
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # Verify the traffic flow between VPLAG and different S-channel when the private network feature is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

#####OVF1787_API_TC_87:Verify the traffic flow between VPLAG and different S-channel when the private network feature is disabled#####

    # disbale the Private network
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_false}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_default_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_default_edit}     240s    2s
    \    Run Keyword If    '${Enet_default_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # Verify the traffic flow between VPLAG and different S-channel when the private network feature is disabled
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}


TC03_OVF1787_API_TC_88:Verify the traffic flow between VPLAG1 and VPLAG2 when the private network feature is disabled
    [Documentation]    verification of the traffic flow between VPLAG1 and VPLAG2 when the private network feature is disabled

    Power off server    ${server_profile_HA2_OP[0]['serverHardwareUri']}

    ${del_pro1}    Fusion Api Delete Server Profile    param=?filter="'name'=='${server_profile_HA2_OP[0]['name']}'"
    ${task} =   Wait For Task    ${del_pro1}    400s    2s

    # create another LAG profile
    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_HA4_lag}
    Log to console    \n-${server_profile_HA4_lag[0]['name']} is created successfully..

    Power on server    ${server_profile_HA4_lag[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA1_lag[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot..
    Sleep    10min

    # Get the valid interface list for bond creation
    ${adapter}    Get Valid Interface List    ${ilo2_details}    ${server2_details}    ${up_interface}    ${down_interface}
    Log to console and logfile    ${adapter}
    ${Len_of_adapter}    Get Length    ${adapter}
    ${Adapterlist}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${adapter[${x}]}
    \    Append to list    ${Adapterlist}    ${temp}
    Log to console and logfile    ${Adapterlist}

    # create bond
    ${cmd_out}    Build Commands For Create Bonding    ${Adapter_1}    ${Adapter_2}    ${Create_bond}    ${Master_slave_1}    ${Master_slave_2}    ${Bond_slave_1}    ${Bond_slave_2}    ${Network_bond}    ${Master}    ${Modify_bond}    ${Modify_ip}    ${Modify_manual}    ${Adapterlist}    ${Bond_2}    ${space}    ${Ip_bond_2}    ${ilo2_details}    ${server2_details}
    Log to console and logfile    ${cmd_out}

    # get the valid serverip list for traffic flow verification
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # Verify the traffic flow between VPLAG1 and VPLAG2 when the private network feature is disabled
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

######OVF1787_API_TC_93:102 Verify the traffic flow between VPLAG1 and VPLAG2 when the private network feature is enabled_Verify the traffic flow between VPLAG and Uplinkset when the private network feature is enabled#####

    # Enable the Private network
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_default_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_default_edit}     240s    2s
    \    Run Keyword If    '${Enet_default_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # Verify the traffic flow between VPLAG1 and VPLAG2 when the private network feature is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    ${uplink_resp}    Fusion Api Get Uplink Set
    ${upset_members}    Get Variable Value    ${uplink_resp['members'][0]}
    ${upset_uri}    Get Variable Value    ${upset_members['uri']}
    Set To Dictionary    ${Edit_uplink}    uri    ${upset_uri}
    ${li_uri}    Get Variable Value    ${upset_members['logicalInterconnectUri']}
    Set To Dictionary    ${Edit_uplink}    logicalInterconnectUri    ${li_uri}
    ${networkUris}    Get Variable Value    ${upset_members['networkUris']}
    Set To Dictionary    ${Edit_uplink}    networkUris    ${networkUris}
    ${nativeNetworkUri}    Get Variable Value    ${upset_members['nativeNetworkUri']}
    Set To Dictionary    ${Edit_uplink}    nativeNetworkUri    ${nativeNetworkUri}
    ${portConfigInfos}    Get Variable Value    ${upset_members['portConfigInfos']}
    ${portconf}    Create List
    Append to list    ${portconf}    ${portConfigInfos[0]}
    Append to list    ${portconf}    ${portConfigInfos[2]}
    Log to console    ${portconf}
    Set To Dictionary    ${Edit_uplink}    portConfigInfos    ${portconf}


    ${li_edit_net} =   Fusion Api Edit Uplink Set    body=${Edit_uplink}    uri=${upset_uri}
    ${task} =   Wait For Task   ${li_edit_net}     240s    2s
    Run Keyword If  '${li_edit_net['status_code']}' != '202'    fail    ELSE    Log to Console  \n-LI  edited successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # Verify the traffic flow between VPLAG and Uplinkset when the private network feature is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    # disbale the Private network
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_default[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_default[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_false}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_default_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_default_edit}     240s    2s
    \    Run Keyword If    '${Enet_default_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..

    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}
    Log to Console   Validation of IC state of Interconnects
    IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    
    # Verify the traffic flow between VPLAG and Uplinkset when the private network feature is disabled
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    # Delete the network bond
    :For    ${x}    INRANGE    0    2
    \    ${Del_bond}    Build Commands For Delete Bonding    ${Delete_Network_bond}    ${Delete_bond_slave_1}    ${Delete_bond_slave_2}    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${Bond_${x+1}}

*** keywords ***
Login to OneView via REST
    [Documentation]     Login to the appliance with the credentials
    [Tags]  add   POSITIVE
    Set Log Level    TRACE
    ${resp}     Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}

Get IC and Verify state
    [Documentation]    Get the IC details and verify the interconnect state for each ICM
    [Arguments]    ${IC_Configured}
    ${IC_output}    Fusion Api Get Interconnect
    ${Num_IC}    Get Variable Value    ${IC_output['count']}
    :For    ${x}    INRANGE    0    ${Num_IC}
    \    Wait Until Keyword Succeeds    650s   35 s    Verify Interconnect State    ${IC_output['members'][${x}]['name']}    ${IC_Configured}
    Sleep    50


Verify Interconnect State
    [Documentation]    Verify the interconnect state of the ICM
    ...             Example:
    ...             Verify Interconnect State    ${interconnectname_1}    ${IC_Configured}
    [Arguments]        ${interconnectname_1}        ${IC_Configured}
    Log to Console    Verify interconnect
    ${ic} =    Get IC    ${interconnectname_1}
    ${State} =    Get From IC        ${ic}    state
    Log to Console and logfile    ${State}
    Log to console and logfile    Interconnect state is ${interconnectname_1}:${State}
    Should Be Equal As Strings    ${State}    ${IC_Configured}

Get IC
    [Documentation]    Get IC by name
    ...             Example:
    ...             Get IC    ${ICM_NAME}
    [Arguments]        ${ICM_NAME}
    ${resp} =   fusion api get interconnect
    Log        ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =     Get Length    ${ics}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \     Exit For Loop If     '${ic['name']}' == '${ICM_NAME}'
    [Return]    ${ic}

Get from IC
    [Documentation]    Get the required element from the interconnect
    ...             Example:
    ...             Get from IC    ${ic}    ${element}
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}


Get Server Ip Windows
    [Documentation]    Gets the valid ip of the server
    [Arguments]         ${ilo_details}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=20s
    ${login}    SSHLibrary.Login               ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Read Until    SAC>
    Sleep    5sec
    SSHLibrary.Write    i
    Sleep    5sec
    ${stdout}    SSHLibrary.Read
    Log to Console    \nstdout is ${stdout}
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Ping should be success
    [Documentation]    Verify the traffic pass between two linux servers are allowed
    ...             Example:
    ...             Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    [Arguments]        ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    Log to console and logfile    \n*** Verifying the connectivity between the servers ***
    ${out} =    Login to linux server via iLo    ${iLo1_details}    ${server1_details}    ${ips[1]}
    Should Contain    ${out}    ttl=
    Should Contain    ${out}    0% packet loss

    ${out} =    Login to linux server via iLo    ${iLo2_details}    ${server2_details}    ${ips[0]}
    Should Contain    ${out}    ttl=
    Should Contain    ${out}    0% packet loss

Ping should fail
    [Documentation]    Verify the traffic pass between two windows servers are blocked
    ...             Example:
    ...             Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    [Arguments]    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    Log to console and logfile    \n*** Verifying the connectivity between the servers ***
    ${out} =    Login to linux server via iLo    ${iLo1_details}    ${server1_details}    ${ips[1]}
    Should Not Contain    ${out}    ttl=


    ${out} =    Login to linux server via iLo    ${iLo2_details}    ${server2_details}    ${ips[0]}
    Should Not Contain    ${out}    ttl=

validate port status
    [Documentation]    validate the port status of the ICM
    [Arguments]   ${icm}   ${portname}   ${state}
    ${ic}=   Get IC URI   ${icm}
    ${resp}=   fusion_api_get_interconnect_ports   uri=${ic}
    :FOR   ${port}  IN   @{resp['members']}
    \    run keyword if  '${port['portName']}' != '${portname}'   Continue For Loop
    \    should match  ${port['portStatus']}   ${state}
    \    Log to console and logfile    Port Status ${port['portStatus']} matches expected ${state}

Disable port
    [Documentation]   Disabling the uplink port of ICM
    [Arguments]    ${icm}    ${port_number}
    ${ic_uri} =   Get IC URI    ${icm}
    Log to console    ${ic_uri}
    ${resp} =     Get IC Port    uri=${ic_uri}   port=${port_number}
    Log to console and logfile    \n${resp}
    Set to Dictionary   ${resp}   enabled    ${false}
    ${body} =    Create List
    Append to list    ${body}    ${resp}

    ${resp} =     fusion api edit interconnect ports   uri=${ic_uri}   body=${body}
    ${task} =       Wait For Task   ${resp}     7 min   15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}     ${valDict}
    Sleep    60

Enable port
    [Documentation]   Enabling the uplink port of ICM
    [Arguments]    ${icm}    ${port_number}
    ${ic_uri} =   Get IC URI    ${icm}
    Log to console    ${ic_uri}
    ${resp} =     Get IC Port    uri=${ic_uri}   port=${port_number}
    Log to console and logfile    \n${resp}
    Set to Dictionary   ${resp}   enabled    ${true}
    ${body} =    Create List
    Append to list    ${body}    ${resp}

    ${resp} =     fusion api edit interconnect ports   uri=${ic_uri}   body=${body}
    ${task} =       Wait For Task   ${resp}     7 min   15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}
    Sleep    60

Get IC Port
    [Documentation]    Get IC Port name
    [Arguments]     ${uri}  ${port}
    ${resp} =   fusion api get interconnect ports    uri=${uri}
    ${ics} =     Get From Dictionary     ${resp}    members
    :FOR    ${ic}   IN      @{ics}
    \   ${return} =    Run Keyword If   '${ic['portName']}' == '${port}'        set variable     ${ic}
    \   Exit for loop if    '${ic['portName']}' == '${port}'
    [Return]    ${return}


Build Commands For Create Bonding
    [Documentation]    Building commands for bond creation or teaming the adapters
    [Arguments]    ${Adapter_1}    ${Adapter_2}    ${Create_bond}    ${Master_slave_1}    ${Master_slave_2}    ${Bond_slave_1}    ${Bond_slave_2}    ${Network_bond}    ${Master}    ${Modify_bond}    ${Modify_ip}    ${Modify_manual}    ${Adapterlist}    ${Bond}    ${space}    ${Ip_bond}    ${ilo_details}    ${server_details}

    ${Network_adapter_1}    Replace String Using Regexp   ${Adapter_1}    adapter1    ${Adapterlist[0]}
    ${Network_adapter_2}    Replace String Using Regexp   ${Adapter_2}    adapter2    ${Adapterlist[1]}
    ${Network_bond_1}    Replace String Using Regexp   ${Create_bond}    bond-name    ${Bond}
    ${Add_connection_1}    Replace String Using Regexp   ${Master_slave_1}    connection-name-1    ${Adapterlist[0]}
    ${Add_connection_2}    Replace String Using Regexp   ${Master_slave_2}    connection-name-2    ${Adapterlist[1]}
    ${Up_connection_1}    Replace String Using Regexp   ${Bond_slave_1}    connection-name-1    ${Adapterlist[0]}
    ${Up_connection_2}    Replace String Using Regexp   ${Bond_slave_2}    connection-name-2    ${Adapterlist[1]}
    ${Up_bond}    Replace String Using Regexp   ${Network_bond}    bond-name    ${Bond}
    ${Bond_name}    Replace String Using Regexp    ${Master}    bond-name    ${Bond}
    ${connection_1}    catenate    ${Add_connection_1}/${Bond_name}
    ${bond_connection_1}    Replace String Using Regexp    ${connection_1}    /    ${space}
    ${connection_2}    catenate    ${Add_connection_2}/${Bond_name}
    ${bond_connection_2}    Replace String Using Regexp    ${connection_2}    /    ${space}
    ${Assign_adapter}    Replace String Using Regexp    ${Modify_bond}    bond-name    ${Bond}
    ${Assign_ip}    Replace String Using Regexp    ${Modify_ip}    ip-address    ${Ip_bond}
    ${Combine_ip_adapter}    catenate    ${Assign_adapter}/${Assign_ip}
    ${Assign_ip_adapter}    Replace String Using Regexp    ${Combine_ip_adapter}    /    ${space}
    ${Assign_ip_netmask}    Replace String Using Regexp    ${Modify_manual}    netmask    ${Netmask}
    ${Assign_ip_address}    catenate    ${Assign_ip_adapter}/${Assign_ip_netmask}
    #${Up_interface}    Replace String Using Regexp    ${interface_up}    interface-name    ${Bond}
    #${Down_interface}    Replace String Using Regexp    ${down_interface}    interface-name    ${Bond}
    Log to console and logfile    ${Network_adapter_1}
    Log to console and logfile    ${Network_adapter_2}
    Log to console and logfile    ${Network_bond_1}
    Log to console and logfile    ${bond_connection_1}
    Log to console and logfile    ${bond_connection_2}
    Log to console and logfile    ${Up_connection_1}
    Log to console and logfile    ${Up_connection_2}
    Log to console and logfile    ${Up_bond}
    Log to console and logfile    ${Assign_ip_address}
    #Log to console and logfile    ${Down_interface}
    #Log to console and logfile    ${Up_interface}

    Log to console and logfile    *********Network bonding is about start*********
    ${cmd_out}    Create Network Bonding    ${ilo_details}    ${server_details}    ${Network_adapter_1}    ${Network_adapter_2}    ${Network_bond_1}    ${bond_connection_1}    ${bond_connection_2}    ${Up_connection_1}    ${Up_connection_2}    ${Up_bond}    ${Assign_ip_address}
    [Return]    ${cmd_out}

Build Commands For Delete Bonding
    [Documentation]    Build commands to delete the created Bond
    [Arguments]    ${Delete_Network_bond}    ${Delete_bond_slave_1}    ${Delete_bond_slave_2}    ${ilo_details}    ${server_details}    ${up_interface}    ${Bond}
    ${Delete_bond}    Replace String Using Regexp   ${Delete_Network_bond}    bond-name    ${Bond}
    Log to console and logfile    ${Delete_bond}
    ${cmd_out}    Delete Network Bonding    ${ilo_details}    ${server_details}    ${Delete_bond}
    ${ip_adapter}    Get Server IP Linux    ${ilo_details}    ${server_details}
    ${ret}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<BROADCAST
    ${flag_list} =    Create List
    ${length} =     Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${flag_list}    ${ret[${x}]}
    ${length} =     Get Length    ${flag_list}
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${flag_list[${x}]}    \\d+:\\s+(.*):\\s+<BROADCAST
    \    Log to console   values ${match}
    \    Append To List   ${Adapter_name}    ${match}
    Remove Values From List    ${Adapter_name}    virbr0-nic
    ${Len_of_adapter}    Get Length    ${Adapter_name}
    ${Adapterlist}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${Adapter_name[${x}]}
    \    Append to list    ${Adapterlist}    ${temp}
    Log to console and logfile    ${Adapterlist}
    ${Delete_connection_1}    Replace String Using Regexp   ${Delete_bond_slave_1}    connection-name-1    ${Adapterlist[0]}
    ${Delete_connection_2}    Replace String Using Regexp   ${Delete_bond_slave_2}    connection-name-2    ${Adapterlist[1]}
    ${Network_adapter_1}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapterlist[0]}
    ${Network_adapter_2}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapterlist[1]}
    Log to console and logfile    ${Delete_connection_1}
    Log to console and logfile    ${Delete_connection_2}
    ${cmd}    Delete Network Slave    ${ilo_details}    ${server_details}    ${Delete_connection_1}    ${Delete_connection_2}    ${Network_adapter_1}    ${Network_adapter_2}

    [Return]    ${cmd}

Login to linux server via iLo
    [Documentation]    Ping server via iLo.
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ping -c 10 ${ip}
    Sleep    10sec
    SSHLibrary.write    ping -c 120 ${ip}
    Sleep    240sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Get Server IP Linux
    [Documentation]    Gets the adapter list of the server.
    [Arguments]         ${linux_ilo_details}    ${linux_server_details}
    SSHLibrary.Open Connection     ${linux_ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login               ${linux_ilo_details['username']}     ${linux_ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    20sec
    SSHLibrary.Read
    Sleep    5sec
    SSHLibrary.Write     ${linux_server_details['username']}
    Sleep    10sec
    SSHLibrary.Write     ${linux_server_details['password']}
    Sleep    10sec
    SSHLibrary.Read
    SSHLibrary.Write     ip addr
    Sleep    20sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}


Get IP and Adapter
    [Documentation]    Get IP and adapter from the server
    [Arguments]         ${ip_adapter}
    ${ret}    Get Regexp Matches    ${ip_adapter}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    ${match2}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    \    ${Adapter_list}    Fetch From Right        ${Ret}      global
    \    ${temp}    Remove Whitespace    ${Adapter_list}
    \    Append To List   ${Adapter_name}    ${temp}

    Log to console  final list ${Ip_List}
    Log to console   final list2 ${Adapter_name}
    [Return]    ${Ip_List}    ${Adapter_name}

Get Server IP
    [Documentation]    Get the server ip list from the ifconfig output
    [Arguments]         ${ip_adapter}
    ${ret}    Get Regexp Matches    ${ip_adapter}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    Log to console  final list ${Ip_List}
    [Return]    ${Ip_List}

Create Network Bonding
    [Documentation]    Team the adapters in the server.
    [Arguments]         ${ilo_details}    ${server_details}    ${Network_adapter_1}    ${Network_adapter_2}    ${Network_bond_1}    ${bond_connection_1}    ${bond_connection_2}    ${Up_connection_1}    ${Up_connection_2}    ${Up_bond}    ${Assign_ip_address}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.Write    ${Network_adapter_1}
    Sleep    10sec
    SSHLibrary.Write    ${Network_adapter_2}
    Sleep    10sec
    SSHLibrary.Write    ${Network_bond_1}
    Sleep    10sec
    SSHLibrary.Write    ${bond_connection_1}
    Sleep    10sec
    SSHLibrary.Write    ${bond_connection_2}
    Sleep    10sec
    SSHLibrary.Write    ${Up_connection_1}
    Sleep    10sec
    SSHLibrary.Write    ${Up_connection_2}
    Sleep    10sec
    SSHLibrary.Write    ${Assign_ip_address}
    Sleep    10sec
    SSHLibrary.Write    ${Up_bond}
    Sleep    10sec
    SSHLibrary.Write    ${Up_interface}
    Sleep    10sec
    SSHLibrary.Write    ip addr
    Sleep    15sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Delete Network Bonding
    [Documentation]    Delete the network bond created in the server.
    [Arguments]         ${ilo_details}    ${server_details}    ${Delete_bond}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.Write    ${Delete_bond}
    Sleep    10sec
    SSHLibrary.Write    ip addr
    Sleep    10sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Delete Network Slave
    [Documentation]    Delete the network bond slave in the server.
    [Arguments]         ${ilo_details}    ${server_details}    ${Delete_connection_1}    ${Delete_connection_2}    ${Network_adapter_1}    ${Network_adapter_2}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.Write    ${Delete_connection_1}
    Sleep    10sec
    SSHLibrary.Write    ${Delete_connection_2}
    Sleep    10sec
    SSHLibrary.Write    ${Network_adapter_1}
    Sleep    10sec
    SSHLibrary.Write    ${Network_adapter_2}
    Sleep    10sec
    SSHLibrary.Write    ip addr
    Sleep    20sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Get Valid Server IP list
    [Documentation]    Get the only the valid ip of the one or more servers
    ...             Example:
    ...             Get Valid Server IP list    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}    ${get_interface}
    [Arguments]    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}    ${get_interface}
    ${Adapter_list}    Get Valid Interface List    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    ${ifconfig_output_list}    Create List
    ${Len_of_adapter}    Get Length    ${Adapter_list}
    :For    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${ifconfig_name}    Replace String Using Regexp    ${get_interface}    interface-name    ${Adapter_list[${x}]}
    \    ${Ip_output}    Get Valid Server IP    ${ilo_details}    ${server_details}    ${ifconfig_name}
    \    Log to console and logfile    ${Ip_output}
    \    Append to list    ${ifconfig_output_list}    ${Ip_output}
    ${temp_list}    Convert To String    ${ifconfig_output_list}

    ${ret}    Get Regexp Matches    ${temp_list}    inet (\\d+.\\d+.\\d+.\\d+)\\s+netmask
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\s+netmask
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    Log to console and logfile    ${Ip_List}
    [Return]    ${Ip_List}

Get Valid Interface List
    [Documentation]    Get the all the interface of the server and return only the required server
    ...             Example:
    ...             Get Valid Interface List    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    [Arguments]    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    ${ip_adapter}    Get Server IP Linux    ${ilo_details}    ${server_details}
    ${ret}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<BROADCAST
    ${ret_1}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<NO-CARRIER
    ${Interface_list} =    Create List
    ${length} =     Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${Interface_list}    ${ret[${x}]}
    ${length} =     Get Length    ${Interface_list}
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${Interface_list[${x}]}    \\d+:\\s+(.*):\\s+<BROADCAST
    \    Log to console   values ${match}
    \    Append To List   ${Adapter_name}    ${match}
    Remove Values From List    ${Adapter_name}    virbr0-nic

    ${Len_of_adapter}    Get Length    ${Adapter_name}
    ${Adapter_list}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${Adapter_name[${x}]}
    \    Append to list    ${Adapter_list}    ${temp}
    Log to console and logfile    ${Adapter_list}

    ${Len_of_adapter_list}    Get Length    ${Adapter_list}
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter_list}
    \    ${ifup_adapter}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapter_list[${x}]}
    \    Up the Interface    ${ilo_details}    ${server_details}    ${ifup_adapter}

    ${Non_Interface_list} =    Create List
    ${length} =     Get Length  ${ret_1}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${Non_Interface_list}    ${ret_1[${x}]}

    ${length} =     Get Length    ${Non_Interface_list}
    ${Non_Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${Non_Interface_list[${x}]}    \\d+:\\s+(.*):\\s+<NO-CARRIER
    \    Log to console   values ${match}
    \    Append To List   ${Non_Adapter_name}    ${match}
    Remove Values From List    ${Non_Adapter_name}    virbr0

    ${Len_of_non_adapter}    Get Length    ${Non_Adapter_name}
    ${Non_Adapter_list}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_non_adapter}
    \    ${temp}    Convert To String    ${Non_Adapter_name[${x}]}
    \    Append to list    ${Non_Adapter_list}    ${temp}
    Log to console and logfile    ${Non_Adapter_list}

    ${Len_of_non_adapter_list}    Get Length    ${Non_Adapter_list}
    :FOR    ${x}    INRANGE    0    ${Len_of_non_adapter_list}
    \    ${ifdown_adapter}    Replace String Using Regexp   ${down_interface}    interface-name    ${Non_Adapter_list[${x}]}
    \    Down the Interface    ${ilo_details}    ${server_details}    ${ifdown_adapter}

    [Return]    ${Adapter_list}

Get Valid Server IP
    [Documentation]    Get the only the valid ip of the server
    ...             Example:
    ...             Get Valid Server IP    ${ilo_details}    ${server_details}    ${ifconfig_adapter_name}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifconfig_adapter_name}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifconfig_adapter_name}
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Down the Interface
    [Documentation]    Disconnect the interface/off the interface inside server
    ...             Example:
    ...             Down the Interface    ${ilo_details}    ${server_details}    ${ifdown_adapter}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifdown_adapter}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifdown_adapter}
    Sleep    15sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections

Up the Interface
    [Documentation]    Up the interface/connect the interface inside server
    ...             Example:
    ...             Up the Interface    ${ilo_details}    ${server_details}    ${ifup_adapter}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifup_adapter}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifup_adapter}
    Sleep    10sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections

Get Inpackets and Outpackets
    [Documentation]    Get statistics of Inpackets and Outpackets of the ICM by portname
    [Arguments]    ${ICM_1}    ${stat}    ${uplink_port_name}
    ${icUri}        Get IC URI    ${ICM_1}
    ${ic_uri_statistics} =        catenate    ${icUri}/${stat}/${uplink_port_name}

    ${statistics_data}    Fusion Api Get Interconnect    ${ic_uri_statistics}
    Log to console    \n${statistics_data['commonStatistics']}
    ${In_packets}    Get from Dictionary    ${statistics_data['commonStatistics']}    rfc1213IfInUcastPkts
    ${Out_packets}    Get from Dictionary    ${statistics_data['commonStatistics']}    rfc1213IfOutUcastPkts
    Log to console    ${ICM_1}:${uplink_port_name}
    Log to console    In-packets:${In_packets}
    Log to console    Out-packets:${Out_packets}
    [Return]    ${In_packets}    ${Out_packets}

Validate Lag
    [Documentation]    Validate LAG configuration is present in the server Profile
    [Arguments]    ${count}    ${Connections}
    :For    ${x}    INRANGE    0    ${count}
    \    ${connection}    Copy Dictionary   ${Connections[${x}]}
    \    Dictionary Should Contain Key    ${connection}    lagName
    \    ${value}    Get Variable Value    ${Validate_net['lagName']}
    [Return]    ${value}

Port Affinity Status
    [Documentation]    verify the port affinity status of the interconnect and return the ICM list
    [Arguments]    ${count}    ${Connections}
    ${ICM}    Create List
    :For    ${x}    INRANGE    0    ${count}
    \    ${connection}    Copy Dictionary   ${Connections[${x}]}
    \    Dictionary Should Contain Key    ${connection}    interconnectUri
    \    ${IC_Uri}    Get Variable Value    ${connection['interconnectUri']}
    \    ${IC_resp}    Fusion Api Get Interconnect    uri=${IC_Uri}
    \    ${Fetch_IC_name}    Get Variable Value    ${IC_resp['name']}
    \    Append to List    ${ICM}    ${Fetch_IC_name}

    ${ICM_list}    Remove Duplicates    ${ICM}

    [Return]    ${ICM_list}

Port Affinity MLAG
    [Documentation]    Get the ICM list of the MLAG port affinity status from the server profile
    [Arguments]    ${server_profile_1}    ${server_profile_2}
    ${Profile1_ICM}    Create List
    ${Profile2_ICM}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${server_resp}    Fusion Api Get Server Profiles    param=?filter="'name'=='${server_profile_${x+1}[0]['name']}'"
    \    ${Connections}    Get From Dictionary      ${server_resp['members'][0]['connectionSettings']}      connections
    \    ${Len_of_connections}    Get Length    ${Connections}
    \    ${IC_List}    Port Affinity Status    ${Len_of_connections}    ${Connections}
    \    Append to List    ${Profile${x+1}_ICM}    ${IC_List}
    Log to console and logfile    ${Profile1_ICM}
    Log to console and logfile    ${Profile2_ICM}

    ${Len_of_ICM1_list}    Get Length    ${Profile1_ICM[0]}
    ${Len_of_ICM2_list}    Get Length    ${Profile2_ICM[0]}
    ${ICM}    Create List
    :For    ${x}    INRANGE    0    ${Len_of_ICM1_list}
    \    ${Pro1_ICM_Value}    Get From List    ${Profile1_ICM[0]}    ${x}
    \    Append to list    ${ICM}    ${Pro1_ICM_Value}

    :For    ${x}    INRANGE    0    ${Len_of_ICM2_list}
    \    ${Pro2_ICM_Value}    Get From List    ${Profile2_ICM[0]}    ${x}
    \    Append to list    ${ICM}    ${Pro2_ICM_Value}

    Log to console and logfile    ${ICM}
    ${Final_list_ICM}    Remove Duplicates    ${ICM}
    Log to console and logfile    ${Final_list_ICM}

    [Return]    ${Final_list_ICM}


validate port status reason
    [Documentation]   validate port status
    [Arguments]   ${icm}   ${portname}   ${state}
    ${ic}=   Get IC URI   ${icm}
    ${resp}=   fusion_api_get_interconnect_ports   uri=${ic}
    :FOR   ${port}  IN   @{resp['members']}
    \    run keyword if  '${port['portName']}' != '${portname}'   Continue For Loop
    \    should match  ${port['portStatusReason']}   ${state}
    \    Log to console and logfile    Port Status ${port['portStatusReason']} matches expected ${state}

IC_STATE_VALIDATION_AFTER_EDIT_PRIVATE_NETWORK
    [Documentation]    Get the IC state and verifyit is in configured state
#    [Arguments]     ${LI_ALL_VC_INTERCONNECTS}

	${resp} =   fusion api get interconnect
#    Log To Console          ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =      Get Length    ${ics}
    ${icm_list} =    Create List
    :FOR  ${x}  IN RANGE    0     ${l}
    \    ${ic} =     Get From List   ${ics}    ${x}
     \    ${ic_name} =     Get from IC    ${ic}    name

	\    ${ic} =     Get IC        ${ic_name}
	\    ${icstate} =     Get From IC    ${ic}   state
	\    Should Be Equal As Strings    ${icstate}     Configured
	\    Log to Console    Validated the Interconnect state of ${ic_name}
	\    Log to Console    and its state is ${icstate}
Login_to_linuxserver_bringupbayone
    [Documentation]    Ping server via iLo
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ifdown ens2f1
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f0 ${ip[1]} netmask 255.255.255.0 up
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f4 ${ip[0]} netmask 255.255.248.0 up
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    Sleep    50sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Login_to_linuxserver_bringupbaysix
    [Documentation]    Ping server via iLo
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ifdown ens2f1
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f4 ${ip[1]} netmask 255.255.255.0 up
    Sleep    10sec
    SSHLibrary.write    ifconfig ens2f0 ${ip[0]} netmask 255.255.248.0 up
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    Sleep    50sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}
    


Cleanup For Suite
    [Documentation]    Returns appliance to a 'clean' state by removing all resources\enclosures
    Log to console and logfile  [Cleanup]
    Login to OneView via REST
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove All Network Sets
    Remove ALL Ethernet Networks
    Remove ALL FC Networks