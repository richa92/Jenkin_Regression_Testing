*** Settings ***
Documentation       Feature Test: F1211
...                 Carbon firmware update
...     
Variables           data_variables.py
Resource            ./OVAConfig.txt
Resource             ../../../resource/fusion_api_all_resource_files.txt

Library             Collections
Library             json
Library             OperatingSystem

*** Variables ***
${DataFile}                 ./lig-eg-le_data.xml
${SSH_PASS}                 hpvse1
${APPLIANCE_IP}             10.10.3.99
#${APPLIANCE_IP}             15.212.161.153
${POTASSIUM}                Synergy 40Gb F8 Switch Module
${POTASH}                   Virtual Connect SE 40Gb F8 Module for Synergy - 794502-B23
${CHLORIDE20}               Synergy 20Gb Interconnect Link Module
${CARBON}                   Virtual Connect SE 16Gb FC Module for Synergy
${USERNAME}                 Administrator
${PASSWORD}                 hpvse123
${FUSION_SSH_USERNAME}      root
${FUSION_SSH_PASSWORD}      hpvse1
${FUSION_TIMEOUT}           30
#${ENCLOSURE}               CN7515048X
${ENCLOSURE}                0000000010
${TEST_DELAY}               180

${ICM_a_1}                      ${ENCLOSURE}, interconnect 1
${ICM_a_2}                      ${ENCLOSURE}, interconnect 2
${ICM_b_4}                      ${ENCLOSURE}, interconnect 4
${ICM_b_5}                      ${ENCLOSURE}, interconnect 5

${UPGRADE_FIRMWARE}             1.01.04
${DOWNGRADE_FIRMWARE}           1.00.26
${INCOMP_FIRMWARE}              1.00.26

${MESSAGE_ACTIVATE}           Activation started for the interconnect ${ICM_a_1} with firmware version 1.00.21 from baseline
${MESSAGE_STAGE_SUCCESSS}     Staging success for the interconnect ${ICM_a_1} with firmware version 1.00.21 from baseline
${MESSAGE_STAGE_STARTED_}     Staging started for the interconnect ${ICM_a_1} with firmware version 1.00.21 from baseline

${ICM_Alert1_stg_star}           Staging started for the interconnect
${ICM_Alert1_stg_str_end}        \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert1_stg_star}           Staging started for the interconnect
${ICM_Alert1_stg_str_end}        \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert1_stg_succ}           Staging success for the interconnect
${ICM_Alert1_stg_succ_end}       \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert1_act_star}          Activation started for the interconnect  
${ICM_Alert1_act_star_end}      \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert1_act_succ}          Activation success for the interconnect
${ICM_Alert1_act_succ_end}      \  with firmware version ${UPGRADE_FIRMWARE} from baseline 

#1 4.40 2014-10-12T08:56:22Z    4.40 2014-10-12T08:56:22Z
${ICM_Alert1_stg_star_1_end}    \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert1_stg_star_2_end}    \  with firmware version ${UPGRADE_FIRMWARE} from baseline


${ICM_Alert2_stg_star}           Staging started for the interconnect
${ICM_Alert2_stg_str_end}        \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert2_stg_succ}           Staging success for the interconnect
${ICM_Alert2_stg_succ_end}       \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert2_act_star}          Activation started for the interconnect  
${ICM_Alert2_act_star_end}      \  with firmware version 1.00 from baseline

${ICM_Alert2_act_succ}          Activation success for the interconnect
${ICM_Alert2_act_succ_end}      \  with firmware version ${UPGRADE_FIRMWARE} from baseline 

#1 4.40 2014-10-12T08:56:22Z    4.40 2014-10-12T08:56:22Z
${ICM_Alert2_stg_star_1_end}    \  with firmware version ${UPGRADE_FIRMWARE} from baseline

${ICM_Alert2_stg_star_2_end}    \  with firmware version ${UPGRADE_FIRMWARE} from baseline

*** Keywords ***

Get IC Name
    [Arguments]     ${ICM_NAME}
    ${resp} =   fusion api get interconnect
    #Log to Console ${resp}
    ${ic_list} =    Create List
    #Log to Console ${ic_list}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =  Get Length  ${ics}
    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \   Run Keyword If  '${ic['name']}' != '${ICM_NAME}'        Continue For Loop
    \   Append to list      ${ic_list}  ${ic}
    [Return]    ${ic_list}

Build LI SPP body
      [Arguments]       ${li-fw-update}
      ${liedit} =       Copy Dictionary   ${li-fw-update}
      
      ${command} =                       Get From Dictionary     ${li-fw-update}  command
      ${ethernetActivationDelay} =              Get From Dictionary     ${li-fw-update}  ethernetActivationDelay
      ${ethernetActivationType} =              Get From Dictionary     ${li-fw-update}  ethernetActivationType
      ${fcActivationDelay} =              Get From Dictionary     ${li-fw-update}  fcActivationDelay
      ${fcActivationType} =              Get From Dictionary     ${li-fw-update}  fcActivationType
      ${force} =              Get From Dictionary     ${li-fw-update}  force
      ${sppUri} =           Get From Dictionary     ${li-fw-update}  sppUri
      
      ${body} =   Fusion Api Create LI spp Body      command=${command}
      ...                                            ethernetActivationDelay=${ethernetActivationDelay}
      ...                                            ethernetActivationType=${ethernetActivationType}
      ...                                            fcActivationDelay=${fcActivationDelay}
      ...                                            fcActivationType=${fcActivationType}
      ...                                            force=${force}
      ...                                            sppUri=${sppUri}
      
      [Return]    ${body}

#Get LI URI
#       [Arguments]          ${li}
#       ${resp} =     Fusion Api Get LI
#       ${l} =        Get Length    ${resp['members']}
#       :FOR   ${x}   IN RANGE      0      ${l}
#       \      Run Keyword If       '${resp['members'][${x}]['name']}' != '${li}'          Continue For Loop
#       \      ${uri} =      Get From Dictionary        ${resp['members'][${x}]}   uri
#       [Return]      ${uri}



Get LE URI
       [Arguments]          ${le}
       ${resp} =     Fusion Api Get Logical Enclosure 
       ${l} =        Get Length    ${resp['members']}
       :FOR   ${x}   IN RANGE      0      ${l}
       \      Run Keyword If       '${resp['members'][${x}]['name']}' != '${le}'          Continue For Loop
       \      ${uri} =      Get From Dictionary        ${resp['members'][${x}]}   uri
       [Return]      ${uri}
       
SSH to host and ping x
    [Arguments]        ${HOST}    ${HOST2}
    Open Connection And Log In      ${HOST}
    ${Output}=    Execute Command    ping -c 4 ${HOST2}    return_stdout=True    return_rc=False
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
    Close All Connections
    [return]    ${Output}
Create fcUplink-set Body
    [Arguments]     ${uplink_sets}
    Set Log Level    Trace
    ${logicalInterconnectUri}=   Get From Dictionary   ${uplink_sets}   logicalInterconnectUri
    ${fcNetworkUris}=   Get From Dictionary   ${uplink_sets}   fcNetworkUris
    ${fcNetworkUris}=   Get FC Uris   ${fcNetworkUris}
    
    
    set to Dictionary   ${uplink_sets}      fcNetworkUris=${fcNetworkUris}
    ${logicalInterconnectUri}=    Get LI URI   ${logicalInterconnectUri}
    set to Dictionary   ${uplink_sets}    logicalInterconnectUri=${logicalInterconnectUri}
    [return]   ${uplink_sets}


FTS
    Set Log Level   DEBUG
    Get VM IP   ${VM}
    First Time Setup                    password=hpvse123

Test Specific Setup
    Set Log Level   TRACE
    ${TEST_NAME} =      Set Variable    TEST-SPECIFIC SETUP
    Run Keyword and Ignore Error    Write To ciDebug Log
    Log to console and logfile  [TEST-SPECIFIC SETUP]
    Fusion Api Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}
    ${users} =  Get Variable Value  ${users}
    Run Keyword If  ${users} is not ${null}    Add Users from variable              ${users}
    ${ethernet_networks} =  Get Variable Value    ${ethernet_networks}
    Run Keyword If  ${ethernet_networks} is not ${null}    Add Ethernet Networks from variable  ${ethernet_networks}
    ${ethernet_ranges} =    Get Variable Value  ${ethernet_ranges}
    Run Keyword If  ${ethernet_ranges} is not ${null}       Run Keyword for List    ${ethernet_ranges}  Create Ethernet Range
    ${fc_networks} =    Get Variable Value  ${fc_networks}
    Run Keyword If  ${fc_networks} is not ${null}    Add FC Networks from variable      ${fc_networks}
    ${fcoe_networks} =  Get Variable Value  ${fcoe_networks}
    Run Keyword If  ${fcoe_networks} is not ${null}    Add FCoE Networks from variable      ${fcoe_networks}
    ${licenses} =   Get Variable Value  ${licenses}
    Run Keyword If  ${licenses} is not ${null}      Add Licenses from variable      ${licenses}

    Login all users     ${users}

Create FC Networks
    #[Arguments]     ${fc_networks}
    ${fc_networks} =    Get Variable Value  ${fc_networks}
    Run Keyword If  ${fc_networks} is not ${null}    Add FC Networks from variable  ${fc_networks}
    sleep    5

Run FTS and test-specific setup
    Set Log Level   TRACE
    FTS
    Test Specific Setup
    
Get available Licenses Count
 
    Fusion Api Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}
    ${resp}=  fusion api get licenses
    ${total_count}=  Get From Dictionary   ${resp}   count   
    ${avlic1}=    set variable    ${0}
    ${avlic}=  Get From Dictionary   ${resp}   members
    ${nodes_list}=   Create List
    :FOR    ${av}   IN  @{avlic}
    \   ${avlic2}=  Get From Dictionary   ${av}   availableCapacity
    \   ${avlic1}=   Evaluate   ${avlic1}+${avlic2}
    \   ${nodes}=   Get From Dictionary  ${av}   nodes
    \   Append to List   ${nodes_list}    ${nodes}
    \   Run keyword if      ${resp['status_code']} != ${200}    Log to console   Error getting license count   WARN
    ${license_info}=   Create Dictionary
    Set to Dictionary   ${license_info}   availablelicense=${avlic1}
    Set to Dictionary   ${license_info}   totallicense=${total_count}
    Set to Dictionary   ${license_info}   nodes=${nodes_list}
    [return]   ${license_info}
    

Create Logical Enclosure
    [Arguments]     ${LE NAME}   ${EG Name}
    Set Log Level   TRACE
    # Get enclosureGroupUri
    ${Response}=            Fusion Api Get Enclosure Groups     param=?filter="name=${EG NAME}"
    ${members}=             Get From Dictionary                 ${Response}     members
    ${member}=              Get From List                       ${members}      0
    ${enclosureGroupUri}=   Get From Dictionary                 ${member}       uri

    # Get enclosureUri
    ${Response}=        Fusion Api Get Enclosures
    ${members}=         Get From Dictionary     ${Response}     members
    ${member}=          Get From List           ${members}      0
    ${enclosureUri}=    Get From Dictionary     ${member}       uri
    ${enclosureUris}=   Create List             ${enclosureUri}

    # Build Payload
    ${LE Payload}=      Fusion API Create Logical Enclosure Payload     name=${LE Name}
    ...                 enclosureGroupUri=${enclosureGroupUri}
    ...                 enclosureUris=${enclosureUris}

    # Create Logical Enclosure
    ${Response}=        Fusion Api Create Logical Enclosure         body=${LE Payload}
    ${status_code}=     Get From Dictionary     ${Response}         status_code
    Should Be Equal as Strings                  ${status_code}      202
    ...                 msg=Failed to initiate create Enclosure.

    # Wait for task to complete
    ${task} =                       Wait For Task           ${Response}     300s    30s
    ${status_code}=                 Get From Dictionary     ${task}         status_code
    Should Be Equal as Strings      ${status_code}          200             msg=Failed to Create Enclosure.

    [Return]    ${Response}
    
    
Create LIG TBird Payload
    [Arguments]     ${ligs}
    Set Log Level    Trace
    #log to console and logfile    'Creating Payload'
    #${Potash}=   Get Interconnect Type URI     ${POTASH}
    #${Chloride}=     Get Interconnect Type URI    ${CHLORIDE20}
    ${Carbon}=     Get Interconnect Type URI    ${CARBON}
    ${Response}=   Get From Dictionary     ${ligs}    interconnectMapTemplate
    ${interconnectMapEntryTemplates}=    Create List
    ${interconnectMapEntryTemplates1}=    Get From Dictionary     ${Response}     interconnectMapEntryTemplates
    #log to console    'select fc module'
    :For   ${item}   IN   @{interconnectMapEntryTemplates1}
    \   ${ICM}=    Get From Dictionary    ${item}   permittedInterconnectTypeUri
    \   Run keyword If   '${ICM}' == 'Virtual Connect SE 40Gb F8 Module for Synergy - 794502-B23'     Set to Dictionary     ${item}   permittedInterconnectTypeUri=${Potash}
    \   Run keyword If   '${ICM}' == '${CHLORIDE20}'     Set to Dictionary     ${item}   permittedInterconnectTypeUri=${Chloride}
    \   Run keyword If   '${ICM}' == 'Virtual Connect SE 16Gb FC Module for Synergy'     Set to Dictionary     ${item}   permittedInterconnectTypeUri=${Carbon}
    #\   Run keyword If   '${ICM}' == 'Virtual Connect SE 16Gb FC Module'     Set to Dictionary     ${item}   permittedInterconnectTypeUri=${Carbon}
    #Virtual Connect SE 16Gb FC Module
    \   Append To List    ${interconnectMapEntryTemplates}     ${item}
    # Create LIG Body
    #log to console    'selected FC module'
    #log to console and logfile    item details
    #log to console and logfile    ${item}
    ${ls}=    Set to Dictionary     ${Response}   interconnectMapEntryTemplates=${interconnectMapEntryTemplates}
    Set to Dictionary      ${ligs}    interconnectMapTemplate=${Response}
    
    
    ${uplinkSets1} =    Get From Dictionary  ${ligs}   uplinkSets
    ${uplinkSets2} =    Create List 
    ${fcnetworkuri}=    Create List
    ${ethnetworkuri}=   Create List
    
    :FOR    ${x}    IN    @{uplinkSets1}
    \    ${networkType} =    Get From Dictionary    ${x}    networkType
    \    ${networks} =    Get From Dictionary       ${x}    networkUris
    \    Run Keyword If    '${networkType}' == 'Ethernet'    Continue For Loop
    \    ${networkUris} =    Get FC Uris    ${networks}
    #\    Append to List    ${fcnetworkuri}   ${networkUris}
    \    log to console and logfile   ${networkUris}
    \    Set to dictionary    ${x}    networkUris=${networkUris}
    \    Append to List    ${uplinkSets2}    ${x}
    #log to console and logfile   ${uplinkSets2}

    :FOR    ${x}    IN    @{uplinkSets1}
    \   ${networkType} =    Get From Dictionary    ${x}    networkType
    \   ${networks} =    Get From Dictionary    ${x}    networkUris
    \   Run Keyword If    '${networkType}' == 'FibreChannel'    Continue For Loop
    \   ${networkUris} =    Get FCoE Uris    ${networks}
    \   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
    #\  Append to List    ${ethnetworkuri}  ${networkUris}
    \   Set to dictionary    ${x}    networkUris=${networkUris}
    \   Append to List    ${uplinkSets2}    ${x}
    #log to console and logfile   ${uplinkSets2}
    
    Set to Dictionary    ${ligs}     uplinkSets=${uplinkSets2}
    #log to console and logfile  ${ligs}
    [Return]   ${ligs}
    
    
Get FCLicense status for interconnect 
    [Arguments]    ${ICM_type}
    ${resp}=   fusion api get interconnect
    ${IC}=  Get IC NEW   ${ICM_type}
    ${l} =  Get Length  ${IC}
    ${fclic_nodes}=  Create Dictionary
    :FOR    ${x}    IN   @{IC}
    \  ${icmuri}=   Get From Dictionary     ${x}   uri
    \   ${lic_status}=   fusion_api_index_resource   ${icmuri}
    \   ${node}=  Get from Dictionary   ${lic_status}  name
    \   ${attributes}=    Get from Dictionary    ${lic_status}   attributes
    \   ${fclicenseapplied}=    Get from Dictionary    ${attributes}   fcLicenseApplied
    \   Set to Dictionary   ${fclic_nodes}   ${node}=${fclicenseapplied}
    [Return]    ${fclic_nodes}
    
Get Alerts
    [Arguments]    ${description}    ${correction}    ${alertState}    
    ${alert1}=   fusion_api_get_alerts
    ${resp}=   Get From Dictionary   ${alert1}  members
    ${lis1}=   create list 
    :FOR   ${x}  IN  @{resp}
    \   run keyword if   '${x['alertState']}' != '${alertState}'  Continue For Loop
    \   ${ex}=   Get Lines Containing String  "${x['description']}"  ${description}
    \   ${resol}=   Get Lines Containing String  "${x['correctiveAction']}"     ${correction}
    \   ${ela}=   Get Length   ${ex}
    \   ${resolen}=   Get Length   ${resol}  
    \   run keyword if    ${ela} > 1    Append to List    ${lis1}   ${ex}
    \   run keyword if    ${resolen} >1   Append to List   ${lis1}   ${resol}
    [return]   ${lis1}
    
    
Get IC NEW
    [Arguments]   ${ICM_MODEL}
    ${resp} =    fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary    ${resp}    members
    ${l} =  Get Length  ${ics}
    :FOR    ${x}    IN RANGE    0   ${l}
    \    ${ic} =     Get From List   ${ics}    ${x}
    \    Run Keyword If    '${ic['model']}' != '${ICM_MODEL}'    Continue For Loop
    \    Append to list    ${ic_list}    ${ic}
    [Return]    ${ic_list}

Create LIG
    [Arguments]   ${LIG_DATA}
    #[Documentation]   "Creating LIG"
    #${ethnet}=  Get Variable Value   ${ethernet_networks_TBird}
    #Run Keyword If  ${ethnet} is not ${null}       Add Ethernet Networks from variable    ${ethnet}
    #${fcnet}=  Get Variable Value   ${fc_networks}
    #Run Keyword If  ${fcnet} is not ${null}        Add FC Networks from variable     ${fcnet}  

    ${ligs}=  Create LIG TBird Payload   ${LIG_DATA}
    #Log to Console and logfile    CreateLIG2 ${ligs['name']} with FC-Uplink and Ethernet in Bayset3
    ${resp}=  fusion api create lig     ${ligs}
    ${task}=  Wait For Task     ${resp}     300s    30s

#Add Enclosure Group from variable
#    [Arguments]    ${enc_group}
#    Log to console and logfile    Adding ENCLOSURE GROUP ${enc_group['name']}
#    ${l} =     Get Length    ${enc_group['interconnectBayMappings']}
#    :FOR    ${x}    IN RANGE    0    ${l}
#    \    ${liguri} =    Get From Dictionary    ${enc_group['interconnectBayMappings'][${x}]}    logicalInterconnectGroupUri
#    \    Continue For Loop If    '${liguri}' == 'None'
#    \    log to console    ${liguri}
#    \    ${liguri} =    Common URI Lookup by name    ${liguri}
#    \    Set to dictionary    ${enc_group['interconnectBayMappings'][${x}]}    logicalInterconnectGroupUri    ${liguri}
#    log to console    ${enc_group}
#    ${resp} =    Fusion Api Create Enclosure Group    ${enc_group}
#    log to console    ${resp}
#    #${task} =                       Wait For Task           ${resp}     600s    30s
#    #${status_code}=                 Get From Dictionary     ${task}         status_code
#    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Create EG
#    #${valDict} =    Create Dictionary    status_code=${200}
#    #...                                  taskState=Completed
#    #Validate Response   ${task}     ${valDict}


Create EG-1
    [Arguments]   ${EG_DATA}
    Log to console    Create Enclosure group
    ${enc_groups} =    Get Variable Value    ${EG_DATA}
    Run Keyword If    ${enc_groups} is not ${null}    Run Keyword for List    ${enc_groups}    Add Enclosure Group from variable

Create EG
    [Arguments]   ${EG_DATA}
    Log to console    Create Enclosure group
    ${enc_groups} =    Get Variable Value    ${EG_DATA}
    Run Keyword If    ${enc_groups} is not ${null}    Run Keyword for List    ${enc_groups}    Add Enclosure Group from variable
    sleep   15


Create LE
    [Arguments]     ${LE_NAME}   ${EG_Name}
    Set Log Level   TRACE
    Log to console    reading eguri
    # Get enclosureGroupUri
    ${Response}=            Fusion Api Get Enclosure Groups     param=?filter="name=${EG_NAME}"
    ${members}=             Get From Dictionary                 ${Response}     members
    ${member}=              Get From List                       ${members}      0
    ${enclosureGroupUri}=   Get From Dictionary                 ${member}       uri
    Log to console    reading enclosureuri
    # Get enclosureUri
    ${Response}=        Fusion Api Get Enclosures
    ${members}=         Get From Dictionary     ${Response}     members
    ${member}=          Get From List           ${members}      0
    ${enclosureUri}=    Get From Dictionary     ${member}       uri
    ${enclosureUris}=   Create List             ${enclosureUri}

    # Build Payload
    ${LE Payload}=      Fusion API Create Logical Enclosure Payload     name=${LE_Name}
    ...                 enclosureGroupUri=${enclosureGroupUri}
    ...                 enclosureUris=${enclosureUris}
    Log to console and log file    ${LE Payload}
    #
    # Create Logical Enclosure
    ${Response}=        Fusion Api Create Logical Enclosure         body=${LE Payload}
    ${status_code}=     Get From Dictionary     ${Response}         status_code
    Should Be Equal as Strings                  ${status_code}      202
    ...                 msg=Failed to initiate create Enclosure.

    # Wait for task to complete
    ${task} =                       Wait For Task           ${Response}     2800s    30s
    #${status_code}=                 Get From Dictionary     ${task}         status_code
    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Create LE.
    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}

    [Return]    ${Response}

Create LE and update firmware
    [Arguments]     ${LE_NAME}   ${EG_Name}    ${fw_data}
    Set Log Level   TRACE
    #Log to console    reading eguri
    # Get enclosureGroupUri
    ${Response}=            Fusion Api Get Enclosure Groups     param=?filter="name=${EG_NAME}"
    ${members}=             Get From Dictionary                 ${Response}     members
    ${member}=              Get From List                       ${members}      0
    ${enclosureGroupUri}=   Get From Dictionary                 ${member}       uri
    Log to console    reading enclosureuri
    # Get enclosureUri
    ${Response}=        Fusion Api Get Enclosures
    ${members}=         Get From Dictionary     ${Response}     members
    ${member}=          Get From List           ${members}      0
    ${enclosureUri}=    Get From Dictionary     ${member}       uri
    ${enclosureUris}=   Create List             ${enclosureUri}

    # Get Firmware data
    ${firmwareBaselineUri}=         Get From Dictionary     ${fw_data}      firmwareBaselineUri
    ${forceInstallFirmware}=        Get From Dictionary     ${fw_data}      forceInstallFirmware
    
    # Build Payload
    ${LE Payload}=      Fusion API Create Logical Enclosure Payload     name=${LE_Name}
    ...                 enclosureGroupUri=${enclosureGroupUri}
    ...                 enclosureUris=${enclosureUris}
    ...                 firmwareBaselineUri=${firmwareBaselineUri}
    ...                 forceInstallFirmware=${forceInstallFirmware}
    
    # Create Logical Enclosure
    ${Response}=        Fusion Api Create Logical Enclosure         body=${LE Payload}
    ${status_code}=     Get From Dictionary     ${Response}         status_code
    Should Be Equal as Strings                  ${status_code}      202
    ...                 msg=Failed to initiate create Enclosure.

    # Wait for task to complete
    ${task} =                       Wait For Task           ${Response}     5000s    30s
    #${status_code}=                 Get From Dictionary     ${task}         status_code
    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Create LE.

    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}  

    [Return]    ${Response}
    
Build LE FwUpdate body
      [Arguments]       ${le-fw-update}
      ${ledict} =       Copy Dictionary   ${le-fw-update}
      #${op} =                       Get Variable Value  ${le-fw-update['op']}
      #${path} =                       Get Variable Value  ${le-fw-update['path']}
      #${firmwareBaselineUri} =                       Get Variable Value  ${le-fw-update['firmwareBaselineUri']}
      #${forceInstallFirmware} =                       Get Variable Value  ${le-fw-update['forceInstallFirmware']}
      #${firmwareUpdateOn} =                       Get Variable Value  ${le-fw-update['firmwareUpdateOn']}
      #${validateIfLIFirmwareUpdateIsNonDisruptive} =     Get Variable Value  ${le-fw-update['validateIfLIFirmwareUpdateIsNonDisruptive']}
      #${logicalInterconnectUpdateMode} =          Get Variable Value  ${le-fw-update['logicalInterconnectUpdateMode']}
      #${updateFirmwareOnUnmanagedInterconnect} =         Get Variable Value  ${le-fw-update['updateFirmwareOnUnmanagedInterconnect']}
      
      #${Response}=   Get From Dictionary     ${ligs}    interconnectMapTemplate
      ${op} =                       Get From Dictionary     ${le-fw-update}    op
      ${path} =                     Get From Dictionary     ${le-fw-update}    path
      ${firmwareBaselineUri} =                        Get From Dictionary     ${le-fw-update}  firmwareBaselineUri
      ${forceInstallFirmware} =                       Get From Dictionary     ${le-fw-update}  forceInstallFirmware
      ${firmwareUpdateOn} =                           Get From Dictionary     ${le-fw-update}  firmwareUpdateOn
      ${validateIfLIFirmwareUpdateIsNonDisruptive} =  Get From Dictionary     ${le-fw-update}  validateIfLIFirmwareUpdateIsNonDisruptive
      ${logicalInterconnectUpdateMode} =              Get From Dictionary     ${le-fw-update}  logicalInterconnectUpdateMode
      ${updateFirmwareOnUnmanagedInterconnect} =      Get From Dictionary     ${le-fw-update}  updateFirmwareOnUnmanagedInterconnect
      
      
      ${value} =    Create Dictionary    firmwareBaselineUri=${firmwareBaselineUri}
      ...                                forceInstallFirmware=${forceInstallFirmware}
      ...                                firmwareUpdateOn=${firmwareUpdateOn}

      ${body} =   Create Dictionary         op=${op}
      ...                                   path=${path}
      ...                                   value=${value}

      ${body1} =   Create list     ${body}
      Log to console    ${body1}
      [Return]    ${body1}

Build LI FwUpdate API body
      [Arguments]       ${li-fw-update}
      ${command} =                  Get From Dictionary     ${li-fw-update}  command
      ${path} =                     Get From Dictionary     ${li-fw-update}  path
      ${ethernetActivationDelay} =  Get From Dictionary     ${li-fw-update}  ethernetActivationDelay
      ${ethernetActivationType} =   Get From Dictionary     ${li-fw-update}  ethernetActivationType
      ${fcActivationDelay} =        Get From Dictionary     ${li-fw-update}  fcActivationDelay
      ${fcActivationType} =         Get From Dictionary     ${li-fw-update}  fcActivationType
      ${force} =                    Get From Dictionary     ${li-fw-update}  force
      ${sppUri} =                   Get From Dictionary     ${li-fw-update}  sppUri
      
      
      ${body} =    Create Dictionary                command=${command}
      ...                                            ethernetActivationDelay=${ethernetActivationDelay}
      ...                                            ethernetActivationType=${ethernetActivationType}
      ...                                            fcActivationDelay=${fcActivationDelay}
      ...                                            fcActivationType=${fcActivationType}
      ...                                            force=${force}
      ...                                            sppUri=${sppUri}
    

      Log to console    ${body}
      [Return]    ${body}

Update LE Firmware
    [Arguments]       ${LE_FIRMWARE_DATA}    ${LE_NAME}
    ${uri} =    Get LE URI    ${LE_NAME}
    ${body} =    Build LE FwUpdate body    ${LE_FIRMWARE_DATA}
    ${resp} =   fusion_api_le_firmware_update   body=${body}    uri=${uri}
    log to console  ${resp}
    ${task}=  Wait For Task     ${resp}     3600s    30s
    #${status_code}=                 Get From Dictionary     ${task}         status_code
    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Update/Downgrade Module Firmware
    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}  

Update LE Firmware and return msg
    [Arguments]       ${LE_FIRMWARE_DATA}    ${LE_NAME}
    ${uri} =    Get LE URI    ${LE_NAME}
    ${body} =    Build LE FwUpdate body    ${LE_FIRMWARE_DATA}
    ${resp} =   fusion_api_le_firmware_update   body=${body}    uri=${uri}
    log to console  ${resp}
    ${task}=  Wait For Task     ${resp}     3600s    30s
    log to console    ${task}
    ${taskStatus}=                 Get From Dictionary     ${task}         taskStatus
    [Return]    ${taskStatus}

Update LE Firmware check Authorization_old
    [Arguments]       ${LE_FIRMWARE_DATA}    ${LE_NAME}
    ${uri} =    Get LE URI    ${LE_NAME}
    ${body} =    Build LE FwUpdate body    ${LE_FIRMWARE_DATA}
    ${resp} =   fusion_api_le_firmware_update   body=${body}    uri=${uri}
    Run keyword if    "${resp['status_code']}" == "401"    log to console    ${resp['message']}
    [Return]    ${resp['status_code']}

Update LE Firmware check Authorization
    [Arguments]       ${LE_FIRMWARE_DATA}    ${LE_NAME}
    log to console     collecting le uri
    ${resp} =     Fusion Api Get Logical Enclosure
    Run keyword if    "${resp['status_code']}" == "401"    log to console    ${resp['message']}
    [Return]    ${resp['status_code']}

Update LI Firmware
    [Arguments]       ${LI_FIRMWARE_DATA}    ${LI_NAME}
    ${uri} =    Get LI URI    ${LI_NAME}
    ${body} =    Build LI FwUpdate API body    ${LI_FIRMWARE_DATA}
    #${bondy} =    Build LI SPP body    ${LI_FIRMWARE_DATA}
    ${resp} =   fusion_api_li_upgrade_firmware   body=${body}    uri=${uri}
    log to console  ${resp}
    #Verify resp for result    ${resp}
    ${task}=  Wait For Task     ${resp}     3600s    30s
    #Log to console and logfile    Response is    ${task}
    #${status_code}=                 Get From Dictionary     ${task}         status_code
    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Update/Downgrade Module Firmware
    
    ${valDict} =    Create Dictionary    status_code=${200}
      ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}

Update LI Firmware and return msg_old
    [Arguments]       ${LI_FIRMWARE_DATA}    ${LI_NAME}
    ${uri} =    Get LI URI    ${LI_NAME}
    ${body} =    Build LI FwUpdate API body    ${LI_FIRMWARE_DATA}
    #${bondy} =    Build LI SPP body    ${LI_FIRMWARE_DATA}
    ${resp} =   fusion_api_li_upgrade_firmware   body=${body}    uri=${uri}
    log to console  ${resp}
    ${task}=  Wait For Task     ${resp}     3600s    30s
    ${taskStatus}=                 Get From Dictionary     ${task}         taskStatus
    [Return]    ${taskStatus}
    
Update LI Firmware and return msg
    [Arguments]       ${LI_FIRMWARE_DATA}    ${LI_NAME}
    ${uri} =    Get LI URI    ${LI_NAME}
    ${body} =    Build LI FwUpdate API body    ${LI_FIRMWARE_DATA}
    #${bondy} =    Build LI SPP body    ${LI_FIRMWARE_DATA}
    ${resp} =   fusion_api_li_upgrade_firmware   body=${body}    uri=${uri}
    log to console  ${resp}
    #Verify resp for result    ${resp}
    ${task}=  Wait For Task     ${resp}     3600s    30s
    log to console    ${task}
    ${taskStatus}=                 Get From Dictionary     ${task}         taskStatus
    [Return]    ${taskStatus}
    # Example
    #${msg} =    Update LI Firmware and return msg    ${LI_fw_update_Carbon_orchestrated_stage_activate_incomp}    TB_CAR_LE_1_4-lig_1_4
    #
    #log to console    ${msg}
    #${msg1}=              Convert To Lowercase    ${msg}
    #log to console    ${msg}
    #${sameversionmsg1}=   Convert To Lowercase    ${sameversionmsg}
    #Run Keyword and Continue on Failure    Should Contain       '${msg1}'     ${sameversionmsg1}

Verify resp for result
    [Arguments]  ${resp}
    ${status_code} =    Get From dictionary    ${resp}    status_code
    ${errorCode} =    Get From dictionary    ${resp}    errorCode
    ${recommendedActions} =    Get From dictionary    ${resp}    recommendedActions
    run keyword if  '${status_code}'=='400'    fail    ${recommendedActions}
    ${task}=  Wait For Task     ${resp}     1800s    30s
    ${status_code}=                 Get From Dictionary     ${task}         status_code
    Should Be Equal as Strings      ${status_code}          200             msg=Failed to Update/Downgrade Module Firmware  
    


Remove All LEs
    #...              Example:
    #...                 Remove All LEs
    #...                 Remove All LEs  timeout=2400  interval=10
    #...                 Remove All LEs  force=${True}  timeout=2400  interval=10
    [Arguments]  ${force}=${False}  ${timeout}=1200  ${interval}=30
    Log to console and logfile      ${\n}Removing All Logical Enclosures
    # Set the force flag
    ${param} =  set variable if  ${force}==${False}  ${Empty}  ?force=${True}
    ${list} =   fusion api get logical enclosure
    :FOR    ${element}  IN  @{list['members']}
    \       Log to console and logfile  ${\n}Removing Logical Enclosure ${element['name']}
    \       ${resp} =   fusion api delete logical enclosure  uri=${element['uri']}  param=${param}
    \       ${status}  ${task_uri} =  Run Keyword and Ignore Error  Get From Dictionary  ${resp['headers']}  location
    \       Continue For Loop If  '${status}'=='FAIL'
    \       Log to console and logfile  The task URI is ${task_uri}
    \       ${task} =  Fusion Api Get Task  uri=${task_uri}
    #\       Wait For Task2  ${task}  timeout=${timeout}  interval=${interval}
    \       ${task}=  Wait For Task     ${resp}     300s    30s
    

Dump Tests
    #Create LIG    ${lig_tbird_a_1}
    #Create LIG    ${lig_tbird_a_2}
    #Create LIG    ${lig_tbird_b_4}
    #Create LIG    ${lig_tbird_b_5}
    #Create LIG    ${lig_tbird_1_4}
    #Create LIG    ${lig_tbird_2_5}
    #
    #Create EG    ${enc_groups_carbon_a1}
    #Create EG    ${enc_groups_carbon_a2}
    #Create EG    ${enc_groups_carbon_1_4}
    #Create EG    ${enc_groups_carbon_b4}
    #Create EG    ${enc_groups_carbon_b5}
    #Create EG    ${enc_groups_carbon_2_5}
    #
    #Create LE     le_car    enc_groups_carbon_a_1
    #Remove All LEs
    #Create LE     le_car    enc_groups_carbon_a_1
    
    
    #${ic} =    Get IC Name    0000A66101, interconnect 2
    #${d1} =    Get From Dictionary    ${ic[0]}    powerState
    #Should Be Equal As Strings    ${d1}  On
    #Log to console and logfile  ${d1}
    #${d1} =    Get From Dictionary    ${ic[0]}    firmwareVersion
    #Should Be Equal As Strings    ${d1}  On
    #Log to console and logfile  ${d1}
    #
    #${ic} =    Get IC Name    0000A66101, interconnect 1
    #${d1} =    Get From Dictionary    ${ic[0]}    state
    #Log to console and logfile  ${d1}
    #
    #Update LE Firmware  ${LE_fw_update_Carbon}    TB_CAR_LE_A1


Verify Alerts
      ${alerts} =    fusion_api_get_alerts    /rest/alerts
      # Log to Console    ${alerts}
      Log     ${alerts}     
      : FOR    ${ICM_NAME}    IN    @{ICM_names}

      \    ${Al_stg_str}    Catenate    SEPARATOR= ${ICM_NAME}    ${ICM_Alert2_stg_star}    ${ICM_Alert2_stg_str_end}
      \    Log to Console    ${Al_stg_str}
      \    Run Keyword and Continue on Failure     Should Contain       '${alerts}'       ${Al_stg_str}     Expected Error Message Not seen     
     
      \    ${Al_stg_suc}    Catenate    SEPARATOR= ${ICM_NAME}    ${ICM_Alert2_stg_succ}    ${ICM_Alert2_stg_succ_end}
      \    Log to Console    ${Al_stg_suc}
      \    Run Keyword and Continue on Failure     Should Contain       '${alerts}'       ${Al_stg_suc}     Expected Error Message Not seen
           
      \    ${Al_act_str}    Catenate    SEPARATOR= ${ICM_NAME}    ${ICM_Alert2_act_star}    ${ICM_Alert2_act_star_end}
      \    Log to Console    ${Al_act_str}
      \    Run Keyword and Continue on Failure     Should Contain       '${alerts}'       ${Al_act_str}     Expected Error Message Not seen
      
      \    ${Al_act_succ}    Catenate    SEPARATOR= ${ICM_NAME}    ${ICM_Alert2_act_succ}    ${ICM_Alert2_act_succ_end}
      \    Log to Console    ${Al_act_succ}
      \    Run Keyword and Continue on Failure     Should Contain       '${alerts}'       ${Al_act_succ}    Expected Error Message Not seen
      

Get Alert Example
     ${lis1}=   Get Alerts   Staging success for the interconnect 0000A66101, interconnect 8 with firmware version 1.00.21 from baseline     0000A66101, interconnect 4    Cleared
     Log to Console and Logfile    ${lis1}
     ${len}=   Get Length   ${lis1}  
     run keyword if  ${len} < 1    fail    Alert not found
     Log to Console and Logfile    ${lis1[0]}
     #${alerts} =    fusion_api_get_alerts    /rest/alerts
     #Verify Alerts

Add FC Uplink to LIG and update LI
    [Arguments]       ${UPLINK_DATA}    ${LIG_NAME}    ${LI_NAME}
    ${ligs}=  Create LIG TBird Payload   ${UPLINK_DATA}
    ${Uri}=  Get LIG URI   ${LIG_NAME}
    ${Response}=    fusion_api_edit_lig    ${ligs}    ${Uri}
    ${task} =                       Wait For Task           ${Response}     300s    30s
    ${status_code}=                 Get From Dictionary     ${task}         status_code
    Should Be Equal as Strings      ${status_code}          200             msg=Failed to Create FC Uplink
    sleep    15
    ${lI_Uri}=  Get LI URI    ${LI_NAME}
    ${upd}=   fusion_api_update_from_group    ${lI_Uri}
    ${task} =                       Wait For Task           ${upd}     1000s    30s
    ${status_code}=                 Get From Dictionary     ${task}         status_code
    Should Be Equal as Strings      ${status_code}          200             msg=Failed to Update LI from group

Get ICM Data
    [Arguments]       ${icm_name}
    ${ic} =    Get IC Name    ${icm_name}
    ${state} =    Get From Dictionary    ${ic[0]}    state
    Log To Console  ${state}
    ${firmwareVersion} =    Get From Dictionary    ${ic[0]}    firmwareVersion
    Log To Console  ${firmwareVersion}
    ${state} =    Get From Dictionary    ${ic[0]}    powerState
    Log To Console  ${powerState}
    ${state} =    Get From Dictionary    ${ic[0]}    state
    Log To Console  ${state}
    #
    ${icm_data}=  Create Dictionary
    set to Dictionary   ${icm_data}    frmversion=${frmversion}
    set to Dictionary   ${icm_data}    state=${state}
    #set to Dictionary   ${icm_data}    baseversion=${baseversion}
    set to Dictionary   ${icm_data}    powerstate=${powerstate}
    [Return]    ${icm_data}


Create LIG and EG
    Create LIG    ${lig_tbird_a_1}
    #Create LIG    ${lig_tbird_a_2}
    Create LIG    ${lig_tbird_b_4}
    #Create LIG    ${lig_tbird_b_5}
    Create LIG    ${lig_tbird_1_4}
    #Create LIG    ${lig_tbird_2_5}

    Create EG    ${enc_groups_carbon_a1}
    #Create EG    ${enc_groups_carbon_a2}
    Create EG    ${enc_groups_carbon_1_4}
    Create EG    ${enc_groups_carbon_b4}
    #Create EG    ${enc_groups_carbon_b5}
    #Create EG    ${enc_groups_carbon_2_5}

Remove EG and LIG
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_a_1
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_a_2
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_b_4
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_b_5
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_1_4
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_2_5
    Run Keyword and Ignore Error    Remove EG    enc_groups_carbon_1_4_2_5
    Run Keyword and Ignore Error    Remove LIG    lig_a_1
    Run Keyword and Ignore Error    Remove LIG    lig_a_2
    Run Keyword and Ignore Error    Remove LIG    lig_b_4
    Run Keyword and Ignore Error    Remove LIG    lig_b_5
    Run Keyword and Ignore Error    Remove LIG    lig_1_4
    Run Keyword and Ignore Error    Remove LIG    lig_2_5
    Run Keyword and Ignore Error    Remove LIG    lig_1_4_2_5

#*** comment ***
Create Server Profile Payload
    #[Documentation] Create Server Profile Payload1
    #...                 profile = {"type":"ServerProfileV6","serverHardwareUri":'SH:'+ ${ENC1SHBAY1},
    #...                            "serverHardwareTypeUri":'SHT:SY 480 Gen9 1',
    #...                            "enclosureGroupUri":"EG:EG1",
    #...                           ...}
    [Arguments]     ${profile}
    Log to console and logfile      \nCreating Server Profile Payload
    ${payload} =    copy dictionary    ${profile}
    ${status}  ${return} =  Run Keyword and Ignore Error  Get From Dictionary    ${payload}  serverHardwareUri
    ${sh} =  set variable if  '${status}'=='PASS'  ${return}  error
    ${sh} =  replace string using regexp  ${sh}  SH:  ${EMPTY}
    ${sh_uri} =  run keyword if  '${status}'=='PASS' and '${sh}'!=''  Get Server Hardware URI  ${sh}
    run keyword if  '${status}'=='PASS' and '${sh}'!=''  Set to Dictionary  ${payload}  serverHardwareUri   ${sh_uri}
    # SHT
    ${status}  ${return} =  Run Keyword and Ignore Error  Get From Dictionary    ${payload}  serverHardwareTypeUri
    ${sht} =  set variable if  '${status}'=='PASS'  ${return}  error
    ${sht} =    Add Category    ${sht}  SHT
    ${sht_uri} =  run keyword if  '${status}'=='PASS' and '${sht}'!=''   Common URI Lookup by name  ${sht}
    run keyword if  '${status}'=='PASS' and '${sht}'!=''  Set to Dictionary ${payload}  serverHardwareTypeUri   ${sht_uri}
    # SPT
    ${status}  ${return} =  Run Keyword and Ignore Error  Get From Dictionary    ${payload}  serverProfileTemplateUri
    ${spt} =  set variable if  '${status}'=='PASS'  ${return}  error
    ${spt_uri} =  run keyword if  '${status}'=='PASS' and '${spt}'!=''   Common URI Lookup by name  ${spt}
    run keyword if  '${status}'=='PASS' and '${spt}'!=''  Set to Dictionary ${payload}  serverProfileTemplateUri    ${spt_uri}
    # EG
    ${status}  ${return} =  Run Keyword and Ignore Error  Get From Dictionary    ${payload}  enclosureGroupUri
    ${eg} =  set variable if  '${status}'=='PASS'  ${return}  error
    ${eg} =     Add Category    ${eg}   EG
    ${eg_uri} =  run keyword if  '${status}'=='PASS' and '${eg}'!=''    Common URI Lookup by name    ${eg}
    run keyword if  '${status}'=='PASS' and '${eg}'!=''  Set to Dictionary  ${payload}  enclosureGroupUri   ${eg_uri}
    # Enclosure
    ${status}  ${return} =  Run Keyword and Ignore Error  Get From Dictionary    ${payload}  enclosureUri
    ${enc} =  set variable if  '${status}'=='PASS'  ${return}  error
    ${enc} =    Add Category    ${enc}  ENC
    ${enc_uri} =  run keyword if  '${status}'=='PASS' and '${enc}'!=''  Common URI Lookup by name    ${enc}
    run keyword if  '${status}'=='PASS' and '${enc}'!=''  Set to Dictionary ${payload}  enclosureUri    ${enc_uri}
    # Connections
    ${connections} =    Get From Dictionary    ${payload}  connections
    ${connections} =    Lookup Connection Uris  ${connections}
    Set to Dictionary   ${payload}  connections     ${connections}
    # sanStorage
    ${status}  ${return} =  Run Keyword and Ignore Error    Get From Dictionary    ${payload}  sanStorage
    ${sanStorage} =  set variable if  '${status}'=='PASS'  ${return}  error
    ${sanStorage} =   run keyword if  '${status}'=='PASS' and ${sanStorage}!=${None}     Verify Storage Volume      ${sanStorage}
    Set to Dictionary   ${payload}  sanStorage     ${sanStorage}
    [return]  ${payload}



Lookup connection uris
    #[Documentation]    Processes a list of connections, getting the uris for networks
    [Arguments]     ${connections}
    ${conns} =    Create List
    :FOR    ${connection}   IN  @{connections}
    \   ${connection} =     Copy dictionary     ${connection}
    \   ${functionType} =   Get from Dictionary    ${connection}   functionType
    \   ${net} =            Get From Dictionary    ${connection}   networkUri
    \   @{words} =  Split String    ${net}  :
    \   ${type} =   Get From List   ${words}    0
    \   ${net} =    Get From List   ${words}    1
    \   ${net} =    Create List    ${net}
    \   ${uri} =    Run Keyword If  '${type}' == 'FC'       Get FC URIs         ${net}
    \   ...         ELSE IF         '${type}' == 'ETH'      Get Ethernet URIs   ${net}
    \   ...         ELSE IF         '${type}' == 'NS'       Get Network Set URIs    ${net}
    \   ...         ELSE IF         '${type}' == 'FCOE'     Get FCoE URIs   ${net}
    \   ${uri} =    Get From List   ${uri}  0
    \   Set to Dictionary   ${connection}   networkUri  ${uri}
    \   append to list  ${conns}    ${connection}
    [Return]    ${conns}
#*** Keywords ***
#*** comment ***

Add Server Profile
    #[Documentation] Add Server Profile
    #...                 profile = [{'name':'Serverbay2', 'type':'ServerProfileV6', 'serverHardwareUri':'SH:CN750163KV, bay 9', 'serialNumberType':'Virtual', 'iscsiInitiatorNameType':'AutoGenerated', 'macType':'Virtual', 'wwnType':'Virtual', 'description':'Updated Profile', 'affinity':'Bay',
    #...                    'connections':[{'id':1, 'name':'Ethernet1', 'functionType':'Ethernet', 'portId':'Mezz 3:1-a', 'requestedMbps':'2500', 'networkUri':'ETH:net1038-a', 'boot':{'priority':'Primary'}, 'mac':None, 'wwpn':'', 'wwnn':''},
    #...                                   {'id':2, 'name':'FCOE1', 'functionType':'FibreChannel', 'portId':'Mezz 3:1-b', 'requestedMbps':'2500', 'networkUri':'FCOE:FCOE-1084', 'boot':{'priority':'NotBootable'}},
    #...                                   {'id':3, 'name':'FCOE2', 'functionType':'FibreChannel', 'portId':'Mezz 3:2-b', 'requestedMbps':'2500', 'networkUri':'FCOE:FCOE-1085', 'boot':{'priority':'NotBootable'}}],
    #...                    'boot':{'manageBoot':True, 'order':['HardDisk']},
    #...                    'bootMode':{'manageMode':True, 'mode':'UEFI', 'pxeBootPolicy':'Auto'},
    #...                    'firmware':{'manageFirmware':False, 'firmwareBaselineUri':'', 'forceInstallFirmware':False, 'firmwareInstallType':None},
    #...                    'bios':{'manageBios':False, 'overriddenSettings':[]},
    #...                    'hideUnusedFlexNics':True, 'iscsiInitiatorName':'', 'osDeploymentSettings':None,
    #...                    'localStorage':{'sasLogicalJBODs':[], 'controllers':[{'deviceSlot':'Embedded', 'mode':'RAID', 'initialize':True, 'importConfiguration': False, 'logicalDrives': [{'name':'OSDisk', 'raidLevel': 'RAID0', 'bootable': True, 'numPhysicalDrives': 1, 'driveTechnology': 'SasHdd', 'sasLogicalJBODId': None, 'driveNumber': None}]}]},
    #...                    'sanStorage':{'manageSanStorage':True, 'hostOSType':'Windows 2012 / WS2012 R2', 
    #...                                  'volumeAttachments':[{'id':1, 'volumeUri':None, 'volumeName':'Server18Volume1', 'volumeProvisionType':'Thin', 'lunType':'Manual', 'lun':1, 'volumeProvisionedCapacityBytes':'53687091200', 'permanent':False, 'volumeStoragePoolUri':'SPOOL:TB4-Raid5-FC', 'volumeStorageSystemUri':'SSYS:tbr13par', 'volumeShareable':False, 'storagePaths':[{'connectionId':2, 'isEnabled':True}]},
    #...                                                       {'id':2, 'volumeUri':'SVOL:TestVol', 'lunType':'Manual', 'lun':2, 'storagePaths':[{'connectionId':3, 'isEnabled':True}]}]
    #...                                  }}
    #...             ]
    [Arguments]     ${profile}
    ${name} =    Get from Dictionary    ${profile}    name
    Log to console and logfile      \nCreating Server Profile ${name}
    ${payload} =  Create Server Profile Payload  ${profile}
    ${resp} =   Fusion Api Create Server Profile        body=${payload}
    Log to console and logfile    ${resp}
    [return]  ${resp}

Execute firmware update in a loop
    [Arguments]       ${RANGE}
    log to console    'running LE firmware update'
    #
    :FOR    ${INDEX}    IN RANGE    1    ${RANGE}
    \    Log to console    'Performing LE firmware update - '
    \    Log to console    ${INDEX}
    \    log to console    'Start on this firmware update'
    #\    F1211_TC_API_03
    \    Stage and Activate firmware
    #\    F1211_TC_API_35
    \    sleep    120
    \    log to console    'End on this firmware update'
    
#Create Server Profile
    #[Arguments]       ${SERVER_DATA}
    #log to console     ${server_profile[0]}
    #${d1}=    Get From Dictionary    ${server_profile_fc[0]}    name
    #log to console    ${d1}
    #Add Server Profile    ${server_profile_eth_3[0]}
    #${payload}=    Create Server Profile Payload    ${server_profile_fc[0]}
    #log to console    ${payload}
    #${resp} =  Fusion Api Create Server Profile        body=${payload}
    #log to console    ${resp}

# Working Server profile create keyword
Create Server
    [Arguments]       ${SERVER_DATA}
    #log to console     ${server_profile[0]}
    #${d1}=    Get From Dictionary    ${server_profile_fc[0]}    name
    #log to console    ${d1}
    #Add Server Profile    ${server_profile_eth_3[0]}
    log to console    'creating payload'
    ${payload}=    Create Server Profile Payload    ${SERVER_DATA}
    log to console    ${payload}
    ${resp} =  Fusion Api Create Server Profile        body=${payload}
    log to console    ${resp}
    ${task} =                       Wait For Task           ${resp}     2800s    30s
    log to console    ${task}
    #${status_code}=                 Get From Dictionary     ${task}         status_code
    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Server Profile
    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}

Create Server1
    [Arguments]       ${SERVER_DATA}
    #log to console     ${server_profile[0]}
    #${d1}=    Get From Dictionary    ${server_profile_fc[0]}    name
    #log to console    ${d1}
    #Add Server Profile    ${server_profile_eth_3[0]}
    log to console    'creating payload'
    ${payload}=    Create Server Profile Payload    ${SERVER_DATA}
    log to console    ${payload}
    ${resp} =  Fusion Api Create Server Profile        body=${payload}
    log to console    ${resp}
    ${task} =                       Wait For Task           ${resp}     2800s    30s
    log to console    ${task}
    #${status_code}=                 Get From Dictionary     ${task}         status_code
    #Should Be Equal as Strings      ${status_code}          200             msg=Failed to Server Profile
    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}
    
Remove Server Profile
    [Arguments]       ${SERVER_DATA}
    Log to console and logfile    'Removing Server Profile'
    ${resp}=    fusion_api_delete_server_profile    name=${SERVER_DATA}
    ${task} =                       Wait For Task           ${resp}     2800s    30s
    log to console    ${task}
    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}

Validate Interconnect firmware version
    [Arguments]    ${ICM}               @{TestData.TB_interconnect_FVT}
    ${ic} =     Get IC          ${ICM}  
    ${firmwareVersion} =     Get From IC    ${ic}   firmwareVersion
    Log to console and logfile          \nFirmwareVersion from ICM '${ICM}' is '${firmwareVersion}'
    # ${serialNumber} =     Get From IC    ${ic}   serialNumber 
    ${EMreturn}=        get_ICM_info_EM_FRU         @{TestData.TB_interconnect_FVT}
    # Log           ${EMreturn}  
    ${FirmwareVersion} =    Get From Dictionary         ${EMreturn}         FirmwareVersion
    Run Keyword and Continue on Failure    Should Be Equal  '${FirmwareVersion}'        '${firmwareVersion}'    Part Number as desired
    Log to console and logfile          \n'${FirmwareVersion}' from EM matches '${firmwareVersion}' from Interconnect GET call

Login to EM And Create Session 
    # Get EM IP and create session
    Get EM IP
    ${encl_list}=    Get EM Enclosures
    Get EM Token    ${encl_list[0]}
    Get EM Sessions
    ${d}=   Get EM Diags RedundancySummary
    log to console    ${d}

Get ICM Data From EM
    [Arguments]     ${Bay}
    sleep    15
    Open Connection And Log In      ${APPLIANCE_IP}
    ${EM_SN}=   Execute Command   /ci/bin/tbird/appliance-hal.sh list-enclosures
    ${EM1}=  Execute Command   /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${EM_SN}
    ${EM1}=  catenate   SEPARATOR=   ${EM1}  %bond0
    ${XAUTH}=  Execute Command  /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${EM_SN} -o t
    #
    ${cmd}=    catenate    curl -g -x "" -k -i -H "x-auth-token:${XAUTH}"    https://${EM1}/rest/v1/InterconnectManager/${Bay}
    ${format}=    set variable   | grep } | python -m json.tool
    ${cmd}=    catenate    ${cmd}    ${format}
    ${canmic1}=   Execute Command   ${cmd}
    ${IndicatorLED}=    Get Lines Containing String    ${canmic1}    IndicatorLED
    ${dump}    ${IndicatorLED}=    split string    ${IndicatorLED}    :
    ${IndicatorLED}=    Remove String Using Regexp    ${IndicatorLED}    [ ",']
    ${PowerState}=    Get Lines Containing String    ${canmic1}    PowerState
    ${dump}    ${PowerState}=    split string    ${PowerState}    :
    ${PowerState}=    Remove String Using Regexp    ${PowerState}    [ ",']
    ${FirmwareVersion}=    Get Lines Containing String    ${canmic1}    FirmwareVersion
    ${dump}    ${FirmwareVersion}=    split string    ${FirmwareVersion}    :
    ${FirmwareVersion}=    Remove String Using Regexp    ${FirmwareVersion}    [ ",']
    #
    ${body} =    Create Dictionary                IndicatorLED=${IndicatorLED.strip('"')}
    ...                                            PowerState=${PowerState}
    ...                                            FirmwareVersion=${FirmwareVersion}
    Close All Connections
    [return]   ${body}
    #
    # How to use this keyword
    #${emdata}=    Get ICM Data From EM    1
    #log to console    ${emdata}
    #${d1} =    Get From Dictionary    ${emdata}    FirmwareVersion
    #Log To Console  ${d1}
    #Should Be Equal As Strings    ${d1}  ${DOWNGRADE_FIRMWARE}
    #
Check Alert
     [Arguments]     ${msg1}   ${msg2}   ${state}
     ${lis1}=   Get Alerts    ${msg1}    ${msg2}    ${state}
     #Log to Console and Logfile    ${lis1}
     ${len}=   Get Length   ${lis1}  
     run keyword if  ${len} < 1    fail    Alert not found
     Log to Console and Logfile    ${lis1[0]}
     #${alerts} =    fusion_api_get_alerts    /rest/alerts
     #Verify Alerts

Remove All Alerts
    [Arguments]  ${timeout}=600  ${interval}=10
    Log to console and logfile      ${\n}Removing All Alerts
    ${resp} =   fusion api delete alert
    ${status}  ${task_uri} =  Run Keyword and Ignore Error  Get From Dictionary  ${resp['headers']}  location
    Return From Keyword If    '${status}'=='FAIL'  Fail: Location header not found in response ${resp['header']}
    Log to console and logfile  The task URI is ${task_uri}
    ${task} =  Fusion Api Get Task  uri=${task_uri}
    Wait For Task  ${task}  timeout=${timeout}  interval=${interval}

Check All Alert
     [Arguments]     ${icm_name}   ${FIRMWARE_DATA}
     ${msg1}=    Set Variable    Staging success for the interconnect ${icm_name} with firmware version ${FIRMWARE_DATA} from baseline
     ${msg2}=    Set Variable    Staging started for the interconnect ${icm_name} with firmware version ${FIRMWARE_DATA} from baseline
     ${msg3}=    Set Variable    Activation success for the interconnect ${icm_name} with firmware version ${FIRMWARE_DATA} from baseline
     ${msg4}=    Set Variable    Activation started for the interconnect ${icm_name} with firmware version ${FIRMWARE_DATA} from baseline
     ${msg}=     Create List
     Append to List    ${msg}    ${msg1}    ${msg2}    ${msg3}   ${msg4}
     ${alerts} =    fusion_api_get_alerts    /rest/alerts
     : FOR    ${message}    IN    @{msg}
     \          Run Keyword and Continue on Failure     Should Contain       '${alerts}'       ${message}     Expected Alert Message Not seen     
     # How to use this keyword
     # Check All Alert    ${ICM_a_1}    ${DOWNGRADE_FIRMWARE}
     #
Remove LIG
    [Arguments]    ${LIG_NAME}
    ${Response}=    Fusion Api Delete LIG    name=${LIG_NAME}
    log to console    ${Response}
    # Wait for task to complete
    ${task} =                       Wait For Task           ${Response}     60s    30s
    ${valDict} =    Create Dictionary    status_code=${200}
    ...                                  taskState=Completed
    Validate Response   ${task}     ${valDict}

Remove EG
    [Arguments]    ${EG_NAME}
    ${Response}=    fusion_api_delete_enclosure_group    name=${EG_NAME}
    log to console    ${Response}


Power off ALL servers
    Log to console and logfile      Powering off SERVERS    
    ${body} =   Create Dictionary   powerState=Off
    ...                             powerControl=MomentaryPress
    ${servers} =    Fusion Api Get Server Hardware
    :FOR    ${server}   IN  @{servers['members']}
    \       Continue For Loop If    '${server['powerState']}'!='On'     
    \       ${resp} =   Fusion Api Edit Server Hardware Power State     body=${body}    uri=${server['uri']}
    \       ${task} =       ${resp}     240s    5s

Power on server
    [Arguments]     ${server}
    Log to console and logfile      Powering on ${server}
    ${body} =   Create Dictionary   powerState=On
    ...                             powerControl=MomentaryPress
    ${servers} =    Fusion Api Get Server Hardware
    :FOR    ${s}    IN  @{servers['members']}
    \       Continue For Loop If      '${s['name']}' != '${server}'
    \       ${resp} =   Fusion Api Edit Server Hardware Power State     body=${body}    uri=${s['uri']}
    \       ${task} =       ${resp}     240s    10s

Power on ALL servers
    Log to console and logfile      Powering On SERVERS 
    ${body} =   Create Dictionary   powerState=On
    ...                             powerControl=MomentaryPress
    ${servers} =    Fusion Api Get Server Hardware
    :FOR    ${server}   IN  @{servers['members']}
    \       Continue For Loop If    '${server['powerState']}'!='Off'    
    \       ${resp} =   Fusion Api Edit Server Hardware Power State     body=${body}    uri=${server['uri']}
    \       ${task} =       ${resp}     240s    5s

Fussion API logout
    fusion_api_logout_appliance

Add F1211 Users from variable
    [Arguments]     ${users}
    Log to console and logfile      Adding USERS    
    :FOR    ${user}    IN    @{users}
    \       ${resp} =   Fusion Api Add User     body=${user}

*** comment ***
Open Connection And Log In
    [Documentation]     Opens an SSH session to an appliance and logs in
    [Arguments]         ${SSH_HOST}=localhost   ${SSH_USER}=root
    Open Connection     ${SSH_HOST}     timeout=180s
    Run Keyword If      '${SSH_PASS}' is ${null}      Set Suite variable  ${SSH_PASS}     hpvse1
    Login               ${SSH_USER}     ${SSH_PASS}
