*** Settings ***
Documentation
...     Regression test work flow after changing cryptographic mode.
Resource                        ../../../../Resources/api/fusion_api_resource.txt
Variables                       ./data_variables_FIPS_regression.py

*** Variables ***
${APPLIANCE_IP}                 192.168.144.176
${SSH_PASS}                     hpvse1
${Bayset}                      3
${POTASH_IC_TYPE}     Virtual Connect SE 40Gb F8 Module for Synergy

*** Keywords ***
Write Canmic
    [Documentation]    Writing CANMIC block
    [Arguments]     ${ic}   ${blk}   ${data}
    ${temp1}=  Split String    ${ic}    ,
    ${enc_name}=  Get From List    ${temp1}     0
    ${temp2}=  Get From List    ${temp1}     1
    ${temp3}=  Split String    ${temp2}
    ${bayno}=  Get From List    ${temp3}  -1
    Open Connection And Log In      ${APPLIANCE_IP}
    ${em_ip}=  Execute Command    /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s "${enc_name}"
    ${xauth}=  Execute Command    /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s "${enc_name}" -o t
    ${out}=  Execute Command    curl -g -x "" -k -i -H "x-auth-token:${xauth}" -X POST https://[${em_ip}%bond0]/rest/v1/InterconnectManager/${bayno} -d '{ "Action": "WriteCanmicBlocks","List": [ { "Block": ${blk}, "Data" : "${data}", "Format" : "Base64" }]}'
    ${regex_match}=  Should Match Regexp   ${out}    "Result": "Success"

Read Canmic
    [Documentation]    Reading CANMIC block
    [Arguments]     ${ic}   ${blk}
    ${temp1}=  Split String    ${ic}    ,
    ${enc_name}=  Get From List    ${temp1}     0
    ${temp2}=  Get From List    ${temp1}     1
    ${temp3}=  Split String    ${temp2}
    ${bayno}=  Get From List    ${temp3}  -1
    Open Connection And Log In      ${APPLIANCE_IP}
    ${em_ip}=  Execute Command    /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s "${enc_name}"
    ${xauth}=  Execute Command    /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s "${enc_name}" -o t
    ${out}=  Execute Command    curl -g -x "" -k -i -H "x-auth-token:${xauth}" https://[${em_ip}%bond0]/rest/v1/InterconnectManager/${bayno} -d '{"Action":"ReadCanmicBlocks","List":[${blk}]}'
    ${regex_match}=  Should Match Regexp   ${out}    "Data": ".+"
    ${regex_match}=  Replace String Using Regexp   ${regex_match}   : "    :"
    ${regex_match}=  Remove String  ${regex_match}   "
    ${temp}=   Split String   ${regex_match}   :
    ${value}=   Get From List   ${temp}   1
    [Return]      ${value}

Efuse ICM
    [Documentation]    Efuse ICM
    [Arguments]     ${ic}   ${action}
    ${temp1}=  Split String    ${ic}    ,
    ${enc_name}=  Get From List    ${temp1}     0
    ${temp2}=  Get From List    ${temp1}     1
    ${temp3}=  Split String    ${temp2}
    ${bayno}=  Get From List    ${temp3}  -1
    Open Connection And Log In      ${APPLIANCE_IP}
    ${em_ip}=  Execute Command    /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s "${enc_name}"
    ${xauth}=  Execute Command    /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s "${enc_name}" -o t
    ${ret}=  Execute Command    curl -g -x "" -k -i -H "x-auth-token:${xauth}" -X POST https://[${em_ip}%bond0]/rest/v1/InterconnectBays/${bayno} -d '{"Action":"${action}"}'
    Should Contain    ${ret}    { "Action": "${action}" }
    ...    msg=EFuse action failed \n${ret}

Get LI URI
    [Documentation]    Get LI URI
    [Arguments]          ${li}
    ${resp} =     Fusion Api Get LI
    ${l} =        Get Length    ${resp['members']}
    :FOR   ${x}   IN RANGE      0      ${l}
    \      Run Keyword If       '${resp['members'][${x}]['name']}' != '${li}'          Continue For Loop
    \      ${uri} =      Get From Dictionary        ${resp['members'][${x}]}   uri
    [Return]      ${uri}

Get Li Name
    [Documentation]    Get Li Name
    [Arguments]     ${Bayset}
    ${LIs} =   Get Li Names
    ${desired_li}=    set variable   test
    :FOR  ${x}  IN    @{LIs}
    \    ${desired_li} =    Get ICM BayNo in LI    ${x}  ${Bayset}
    \    Exit For Loop If    '${desired_li}'!='test'
    Log    \n\nDesired LI: ${desired_li}\n
    [return]    ${desired_li}


Get ICM BayNo in LI
    [Documentation]    Get ICM BayNo in LI
    [Arguments]     ${LI}  ${Bayset}
    @{ICMS} =    ICMs in LI    ${LI}
    ${BayNo_list} =    Create List
    :FOR  ${ICM_name}  IN  @{ICMS}
    \    ${icm_split} =     Split String  ${ICM_name}  ,
    \    ${bay_no} =       Get from List    ${icm_split}    1
    \    ${bay_no1} =    Remove String Using Regexp   ${bay_no}   [interconnect ]
    \    run keyword if   '${bay_no1}'=='${Bayset}'    Return From Keyword   ${LI}
        ...         ELSE   Return From Keyword   test
    [return]    ${BayNo_list}

Get IC
    [Documentation]    Get IC
    [Arguments]                   ${ICM_NAME}
    ${resp} =   fusion api get interconnect
    Log           ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =      Get Length  ${ics}
    :FOR  ${x}  IN RANGE    0     ${l}
    \    ${ic} =     Get From List   ${ics}    ${x}
    \    Exit For Loop If     '${ic['name']}' == '${ICM_NAME}'
    [Return]    ${ic}
    Log         ${ic}

Get IC From URI
    [Documentation]    Get IC From URI
    [Arguments]                   ${ic_uri}
    ${resp} =   fusion api get interconnect
    Log           ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =      Get Length  ${ics}
    :FOR  ${x}  IN RANGE    0     ${l}
    \    ${ic} =     Get From List   ${ics}    ${x}
    \    Exit For Loop If     '${ic['uri']}' == '${ic_uri}'
    [Return]    ${ic}
    Log         ${ic}

Get from IC
    [Documentation]    Get from IC
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}

Validate LI Stacking Domain ID
    [Documentation]    Validate LI Stacking Domain ID
    [Arguments]     @{ICMS}
    ${STACKING_DOMAIN_ID} =    Create List
    :for    ${ICM}    in     @{ICMS}
    \    ${hfPotash_ic_role} =  Get IC        ${ICM}
    \    ${hfPotash_ic_role_from_ov} =    Get From IC    ${hfPotash_ic_role}   stackingDomainId
    \    Append to List    ${STACKING_DOMAIN_ID}    ${hfPotash_ic_role_from_ov}
    \    Log      \n\nICM ${ICM} Stacking Domain ID from OneView API : ${hfPotash_ic_role_from_ov}
    ${Member1} =    Get From List    ${STACKING_DOMAIN_ID}    0
    ${Member2} =    Get From List    ${STACKING_DOMAIN_ID}    1
    run keyword if   '${Member1}'=='${Member2}'    Log    \nstackingDomainId is same for both HFPotash ICMs\n    ELSE    Fatal error    \n\nstackingDomainId is DIFFERENT for both HFPotash ICMs

Validate LI Stacking Member ID
    [Documentation]    Validate LI Stacking Member ID
    [Arguments]     @{ICMS}
    ${STACKING_Member_ID} =    Create List    0  1
    Log    \n\nExpected ICM Stacking Member ID should be in ${STACKING_Member_ID}
    :for    ${ICM}    in     @{ICMS}
    \    ${hfPotash_ic_role} =  Get IC        ${ICM}
    \    ${hfPotash_ic_role_from_ov} =    Get From IC    ${hfPotash_ic_role}   stackingMemberId
    \    Log      \n\nICM ${ICM} Stacking Member ID from OneView API : ${hfPotash_ic_role_from_ov}
    \    ${abc} =    Convert To String  ${hfPotash_ic_role_from_ov}
    \    Log   ${abc}
    \    Should Contain    ${STACKING_Member_ID}     ${abc}

Get Le Name
    [Documentation]    Get Le Name
    ${resp} =   Fusion Api Get Logical Enclosure
    Log           ${resp}
    ${Le_name} =    Get From Dictionary  ${resp['members'][0]}  name
    Log   \n\nLE Name: ${Le_name}\n
    Log           ${Le_name}
    [return]    ${Le_name}

Get Li Names
    [Documentation]    Get Li Names
    ${resp} =    Fusion Api Get Li
    Log           ${resp}
    ${lis} =     Get From Dictionary     ${resp}    members
    ${l} =      Get Length  ${lis}
    ${li_list} =    Create List
    :FOR  ${x}  IN RANGE    0     ${l}
    \    ${li} =     Get From List   ${lis}    ${x}
    \    ${li_name} =     Get from IC    ${li}    name
    \    Append To List   ${li_list}   ${li_name}
    Log    \n\nLI Names : ${li_list}\n
    [return]    ${li_list}

List HFPotashICM Names In LI
    [Documentation]    List HFPotashICM Names In LI
    [Arguments]     ${LI}
    ${li_uri}=    Get LI URI    ${LI}
    Log   \nli_uri:${li_uri}\n
    ${resp} =     fusion_api_get_li     uri=${li_uri}
    ${x}=    Get Variable Value  ${resp['interconnects']}
    ${l} =      Get Length  ${x}
    ${icm_list} =    Create List
   :FOR  ${y}  IN RANGE    0     ${l}
    \    ${ic_uri} =     Get From List   ${x}    ${y}
    \    ${ic} =  Get IC From URI   ${ic_uri}
    \    ${ic_name} =     Get from IC    ${ic}    name
    \    ${ic_type} =     Get from IC    ${ic}    productName
    \    run keyword if   '${ic_type}'=='${POTASH_IC_TYPE}'    Append To List   ${icm_list}   ${ic_name}
    Log    \n\nHFPotash ICM Names in LI: ${icm_list}\n
    [return]    ${icm_list}

ICMs in LI
    [Documentation]    ICMs in LI
    [Arguments]     ${LI}
    ${li_uri}=    Get LI URI    ${LI}
    Log   \nli_uri:${li_uri}\n
    ${resp} =     fusion_api_get_li     uri=${li_uri}
    ${x}=    Get Variable Value  ${resp['interconnects']}
    ${l} =      Get Length  ${x}
    ${icm_list} =    Create List
   :FOR  ${y}  IN RANGE    0     ${l}
    \    ${ic_uri} =     Get From List   ${x}    ${y}
    \    ${ic} =  Get IC From URI   ${ic_uri}
    \    ${ic_name} =     Get from IC    ${ic}    name
    \    Append To List   ${icm_list}   ${ic_name}
    Log    \n\nICM Names in ${LI}: ${icm_list}\n
    [return]    ${icm_list}

Validate ICM Power
    [Documentation]    Validate ICM Power
    [Arguments]     ${POWER}    @{ICMS}
    ${ICM_POWERS} =    Create List
    :for    ${ICM}    in     @{ICMS}
    \    ${hfPotash_ic_powerState} =    Get IC        ${ICM}
    \    ${hfPotash_ic_powerState_from_ov} =      Get From IC    ${hfPotash_ic_powerState}   powerState
    \    Append to List    ${ICM_POWERS}    ${hfPotash_ic_powerState_from_ov}
    \    Log      \nICM ${ICM} Power from OneView API : ${hfPotash_ic_powerState_from_ov}
    :for    ${ICM_POWER}    in     @{ICM_POWERS}
    \    run keyword if   '${ICM_POWER}'!='${POWER}'      Fatal error    \n\nOne or more ICM Power is Off

Validate LI StackingHealth
    [Documentation]    Validate LI StackingHealth
    [Arguments]       ${LI}
    ${LI_URI} =    Get LI        ${LI}
    ${li_stackingHealth} =       Get From LI    ${LI_URI}   stackingHealth
    Log   \nLogicalInterconnect ${LI} consistency state is: ${li_stackingHealth}
    run keyword if   '${li_stackingHealth}'=='BiConnected'    Log    \nlogical interconnect Stacking Health: Redundantly connected   ELSE    Fatal error    \n\nlogical interconnect Stacking Health: ${li_stackingHealth}

Get LE URI
    [Documentation]    Get LE URI
    [Arguments]          ${le}
    ${resp} =     Fusion Api Get Logical Enclosure
    ${l} =        Get Length    ${resp['members']}
    :FOR   ${x}   IN RANGE      0      ${l}
    \      Run Keyword If       '${resp['members'][${x}]['name']}' != '${le}'          Continue For Loop
    \      ${uri} =      Get From Dictionary        ${resp['members'][${x}]}   uri
    [Return]      ${uri}

Build LE SPP Body
    [Documentation]    Build LE SPP Body
    [Arguments]       ${le_spp}

    ${firmwareBaselineUri} =           Get Variable Value  ${le_spp['firmwareBaselineUri']}
    ${forceInstallFirmware} =              Get Variable Value  ${le_spp['forceInstallFirmware']}
    ${firmwareUpdateOn} =              Get Variable Value  ${le_spp['firmwareUpdateOn']}
    ${logicalInterconnectUpdateMode} =              Get Variable Value  ${le_spp['logicalInterconnectUpdateMode']}

    ${validateIfLIFirmwareUpdateIsNonDisruptive} =              Get Variable Value  ${le_spp['validateIfLIFirmwareUpdateIsNonDisruptive']}
    ${value_dict} =   Create Dictionary       firmwareBaselineUri=${firmwareBaselineUri}
    ...                                             forceInstallFirmware=${forceInstallFirmware}
    ...                                             firmwareUpdateOn=${firmwareUpdateOn}
    ...                                             logicalInterconnectUpdateMode=${logicalInterconnectUpdateMode}
    ...                                          validateIfLIFirmwareUpdateIsNonDisruptive=${validateIfLIFirmwareUpdateIsNonDisruptive}
    ${value} =     Create list     ${value_dict}
    Log                ${value_dict}
    ${body} =   Create Dictionary   op=replace
    ...                             path=/firmware
    ...                             value=${value_dict}
    ${body} =     Create list     ${body}
    [Return]    ${body}

Validate ICM State
    [Documentation]    Validate ICM State
    [Arguments]     ${STATE}    @{ICMS}
    ${ICM_STATES} =    Create List
    :for    ${ICM}    in     @{ICMS}
    \    ${hfPotash_ic_state} =    Get IC        ${ICM}
    \    ${hfPotash_ic_state_from_ov} =      Get From IC    ${hfPotash_ic_state}   state
    \    Append to List    ${ICM_STATES}    ${hfPotash_ic_state_from_ov}
    \    Log     \n${ICM} State from OneView API : ${hfPotash_ic_state_from_ov}
    :for    ${ICM_STATE}    in     @{ICM_STATES}
    \    run keyword if   '${ICM_STATE}'!='${STATE}'    Fatal error    \nOne or more ICM state is not Configured

Validate LI Stacking Domain Role
    [Documentation]    Validate LI Stacking Domain Role
    [Arguments]     @{ICMS}
    ${STACKING_DOMAIN_ROLES} =    Create List
    :for    ${ICM}    in     @{ICMS}
    \    ${hfPotash_ic_role} =  Get IC        ${ICM}
    \    ${hfPotash_ic_role_from_ov} =    Get From IC    ${hfPotash_ic_role}   stackingDomainRole
    \    Append to List    ${STACKING_DOMAIN_ROLES}    ${hfPotash_ic_role_from_ov}
    \    Log      \n\nICM ${ICM} Stacking Domain Role from OneView API : ${hfPotash_ic_role_from_ov}
    ${Member1} =    Get From List    ${STACKING_DOMAIN_ROLES}    0
    ${Member2} =    Get From List    ${STACKING_DOMAIN_ROLES}    1
    run keyword if   '${Member1}'=='${Member2}'    Fatal error    \n\nBoth HFPotash ICMs have same Stacking Domain Role    ELSE    Log    \nOne ICM is Master and another ICM is Subordinate\n

Finding Master Potash
    [Documentation]    Finding Master Potash
    [Arguments]     @{ICMS}
    ${STACKING_DOMAIN_ROLES} =    Create List
    :for    ${ICM}    in     @{ICMS}
    \    ${hfPotash_ic_role} =  Get IC        ${ICM}
    \    ${hfPotash_ic_role_from_ov} =    Get From IC    ${hfPotash_ic_role}   stackingDomainRole
    \    Exit For Loop If   '${hfPotash_ic_role_from_ov}' == 'Master'
    [return]  ${ICM}

Validate LI Consistency State
    [Documentation]    Validate LI Consistency State
    [Arguments]       ${LI}
    ${LI_URI} =    Get LI        ${LI}
    ${li_consistency_state} =    Get From LI    ${LI_URI}   consistencyStatus
    Log   \nLogicalInterconnect ${LI} consistency state is: ${li_consistency_state}
    run keyword if   '${li_consistency_state}'=='CONSISTENT'    Log    \nlogical interconnect consistency state: Consistent   ELSE    Fatal error    \n\nlogical interconnect is Not Consistent

Get LI
    [Documentation]    Get LI
    [Arguments]                   ${LI_NAME}
    ${resp} =   Fusion Api Get Li
    Log           ${resp}
    ${lis} =     Get From Dictionary     ${resp}    members
    ${l} =      Get Length  ${lis}
    :FOR  ${x}  IN RANGE    0     ${l}
    \    ${li} =     Get From List   ${lis}    ${x}
    \    Exit For Loop If     '${li['name']}' == '${LI_NAME}'
    [Return]    ${li}
    Log         ${li}

Get from LI
    [Documentation]    Get from LI
    [Arguments]     ${li}   ${element}
    ${return} =     Get From Dictionary     ${li}   ${element}
    [Return]    ${return}

Reboot appliance via API
    [Documentation]    Reboot appliance via API
    [Arguments]  ${APPLIANCE_IP}    ${admin_credentials}
    Fusion API Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}
    ${resp} =  Fusion Api Appliance Shutdown        REBOOT
    ${task} =  wait for task2   ${resp}     20min   5   None Expected   Completed
    sleep  10m
    Log      -- Waiting for OneView state to change to "STARTING"
    Wait For Appliance State To Be STARTING
    Log      -- Waiting for OneView state to change to "OK"
    Wait For Appliance State To Be OK

Populate the role and reboot
    [Documentation]    Populate the role and reboot
    [Arguments]  ${APPLIANCE_IP}    ${admin_credentials}    ${ssh_credentials}      ${populateCMDs}
    Run Multi Cmd  ${APPLIANCE_IP}      ${ssh_credentials["userName"]}     ${ssh_credentials["password"]}   ${populateCMDs}
    Reboot appliance via API    ${APPLIANCE_IP}     ${admin_credentials}

Wait For Appliance State To Be STARTING
    [Documentation]    Wait For Appliance State To Be STARTING
    [Arguments]                     ${timeout}=20 min   ${interval}=30 s
    Wait Until Keyword Succeeds     ${timeout}  ${interval}     Appliance State Should Be STARTING

Wait For Appliance State To Be OK
    [Documentation]    Wait For Appliance State To Be OK
    [Arguments]                     ${timeout}=20 min   ${interval}=30 s
    Wait Until Keyword Succeeds     ${timeout}  ${interval}     Appliance State Should Be OK

Appliance State Should Be STARTING
    [Documentation]    Appliance State Should Be STARTING
    ${state} =  Fusion Api Get Resource     /controller-state.json
    Log  -Appliance state: ${state['state']}
    Should Match Regexp     ${state['state']}   ((?i)STARTING)

Appliance State Should Be OK
    [Documentation]    Appliance State Should Be OK
    ${state} =  Fusion Api Get Resource     /controller-state.json
    Log  -Appliance state: ${state['state']}
    Should Match Regexp     ${state['state']}   ((?i)OK)

Write CANMIC test
    [Documentation]    Write CANMIC test
    ${out}=  Write Canmic   ${Potash_IC_FIPS['name']}   33    AAAAAQ==
    Log      \n Canmic Data is ${out}
    ${regex_match}=  Should Match Regexp   ${out}    "Result": "Success"
    Log      \n Result is ${regex_match}

Reading CANMIC 60
    [Documentation]    Reading CANMIC 60
    [Arguments]  ${LI}
    @{ICMS} =    ICMs in LI    ${LI}
    Validate ICM State     Configured    @{ICMS}
    @{ICMS} =    List HFPotashICM Names In LI     ${LI}
    :for    ${ICM}    in     @{ICMS}
    \   Log      \n Reading block 60
    \   ${out1}=  Read Canmic   ${ICM}   60
    \   Should Be Equal  ${out1}    AAAAAA==
    \   Log   ${out1}


*** Test Cases ***
Login
    [Documentation]    Setup
    Fusion Api Login Appliance      ${APPLIANCE_IP}     ${admin_credentials}

#Enable feature toggles to test FIPS mode
    ${resp} =  Fusion Cli Enable Feature Toggles    ${APPLIANCE_IP}    ${features}     ${featureTogglesMapping}    ${ssh_credentials}
    Run Keyword If  ${resp}      Reboot appliance via API    ${APPLIANCE_IP}    ${admin_credentials}

#Creating Ethernet networks
    Add Ethernet Networks from variable    ${ethernet_networks}

#Creating FC networks
    Add FC Networks from variable     ${fc_networks}

#Creating FCoE networks
    Add FCoE Networks from variable    ${fcoe_networks}

#Changing bandwidth for Ethernet networks
    Set Suite Variable      ${net1_name}                eth_100
    Set Suite Variable      ${net2_name}                eth_200
    Set Suite Variable      ${type}                 ethernet
    Set Suite Variable      ${max_bw}               ${10000}
    Set Suite Variable      ${typ_bw}               ${10000}
    Set Suite Variable      ${TRUE}                 True
    ${bw}       Create Dictionary       maximumBandwidth=${max_bw}
    ...                                 typicalBandwidth=${typ_bw}
    ${conn1}    Create Dictionary       name=${net1_name}
    ...                                 type=${type}
    ...                                 bandwidth=${bw}
    ${conn2}    Create Dictionary       name=${net2_name}
    ...                                 type=${type}
    ...                                 bandwidth=${bw}
    ${bandwidth_dict}       Create List         ${conn1}
    ...                                         ${conn2}
    Modify ConnectionTemplateURI        ${bandwidth_dict}       ${TRUE}

#Changing bandwidth for FC networks
    Set Suite Variable      ${net1_name}                FC_A
    Set Suite Variable      ${net2_name}                FC_B
    Set Suite Variable      ${type}                 fc
    Set Suite Variable      ${max_bw}               ${8000}
    Set Suite Variable      ${typ_bw}               ${8000}
    Set Suite Variable      ${TRUE}                 True
    ${bw}       Create Dictionary       maximumBandwidth=${max_bw}
    ...                                 typicalBandwidth=${typ_bw}
    ${conn1}    Create Dictionary       name=${net1_name}
    ...                                 type=${type}
    ...                                 bandwidth=${bw}
    ${conn2}    Create Dictionary       name=${net2_name}
    ...                                 type=${type}
    ...                                 bandwidth=${bw}
    ${bandwidth_dict}       Create List         ${conn1}
    ...                                         ${conn2}
    Modify ConnectionTemplateURI        ${bandwidth_dict}       ${TRUE}

#Changing bandwidth for FCoE networks
    Set Suite Variable      ${net1_name}                FCoE_A201
    Set Suite Variable      ${net2_name}                FCoE_B200
    Set Suite Variable      ${type}                 fcoe
    Set Suite Variable      ${max_bw}               ${10000}
    Set Suite Variable      ${typ_bw}               ${10000}
    Set Suite Variable      ${TRUE}                 True
    ${bw}       Create Dictionary       maximumBandwidth=${max_bw}
    ...                                 typicalBandwidth=${typ_bw}
    ${conn1}    Create Dictionary       name=${net1_name}
    ...                                 type=${type}
    ...                                 bandwidth=${bw}
    ${conn2}    Create Dictionary       name=${net2_name}
    ...                                 type=${type}
    ...                                 bandwidth=${bw}
    ${bandwidth_dict}       Create List         ${conn1}
    ...                                         ${conn2}
    Modify ConnectionTemplateURI        ${bandwidth_dict}       ${TRUE}

#Creating LIG
    Set Suite Variable      ${TRUE}                 True
    Add LIG from variable       ${lig_potash_HA}

#Creating EG
    ${responses}=  Add Enclosure Group from variable      ${enc_groups_me}
    Wait For Task2    ${responses}    timeout=300    interval=15

#Add valid Licenses
   Add Licenses from variable   ${licenses_1}

#Creating LE
    Add Logical Enclosure from variable     ${logical_enclosure_multi}
    #Verify Resource      ${expected_logical_enclosure}
    Sleep  20m

#Validating ICM state
    @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
    Validate ICM State     Configured    @{ICMS}

#Validating Stacking Domain Role
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain Role      @{ICMS}

#Validating Stacking Domain ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain ID    @{ICMS}

#Validating Stacking Member ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Member ID    @{ICMS}

#Validating LI consistency state
    ${LIs} =    Get Li Names
    :FOR  ${LI}  IN  @{LIs}
    \   Validate LI Consistency State    ${LI}

#Validating Stacking Health
    Validate LI StackingHealth    ${Potash_LI['name']}


#Adding Storage Systems,Pool & Volume
    Add Storage System     ${storage_systems_fc}
    Sleep    30s
    Edit Storage System    ${storage_systems_fc}
    Sleep    30s
    Edit Storage System    ${storage_systems_desc_fc}
    Sleep    30s
    Verify Resources for List          ${expected_storage_systems_fc}
    Edit Storage Pool       ${storage_pool_fc}
    sleep  2m
    Add Existing Storage Volumes Async     ${storage_volumes_fc}

#Adding server profile for BFS
    Log    \nPowering off the server ${\n}${server_profile['serverHardwareUri']}
    Power off Server    ${server_profile['serverHardwareUri']}
    ${responses}=  Add Server Profile    ${server_profile}
    Wait For Task2    ${responses}    timeout=3000    interval=15
    Power on server     ${server_profile['serverHardwareUri']}
    Sleep    120s
    Log   \nVerifying ping & active path

FIPS mode change
    [Documentation]    FIPS mode change
    ${mode_name} =  Set Variable   FIPS
    Change Cryptography Mode    ${mode_name}    ${APPLIANCE_IP}
    sleep  30m

LE support Dump
    [Documentation]    LE support Dump
    ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
    ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
    ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
    ${task} =       Wait For Task       ${resp}    40m       10s
    ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
    ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump1.sdmp

#Self Test Result Check
    Open Connection And Log In    ${APPLIANCE_IP}
    Execute Command   rm -rf decryption
    Put Directory    ./decryption   /root/    mode=0777
    Execute Command   rm -rf  /root/LE_SD
    Execute Command   mkdir /root/LE_SD
    Put File  ./le_supportdump1.sdmp   /root/LE_SD/
    Execute Command   cd /root/LE_SD/; mv le_supportdump1.sdmp le_supportdump.sdmp
    ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
    Log   ${out}
    Execute Command  gunzip /root/LE_SD/*gz
    Sleep  10s
    Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
    Sleep  30s
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay3 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay3 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay6 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay6 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL

    Close Connection


#Getting all LI names & reading canmic block 60
    ${LIs} =    Get Li Names
    SortList    ${LIs}
    :for    ${LI}    in     @{LIs}
    \    Reading CANMIC 60   ${LI}


Potash Power Cycle
    [Documentation]    Potash Power Cycle
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    ${master_potash} =  Finding Master Potash      @{ICMS}
    Log   \nMaster Potash is ${master_potash}
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured
    Log      \n Powering Off ${master_potash}
    ${Potash_IC} =    Create Dictionary    name=${master_potash}
    Patch Interconnect  ${Potash_IC}  op=replace  path=/powerState  value=Off  timeout=60  interval=5
    Sleep   5m
    Log      \n Checking ICM Power State after Power Off
    ${ic_resp} =     Get IC    ${master_potash}
    ${ic_powerState} =     Get From IC    ${ic_resp}   powerState
    Should Be Equal  ${ic_powerState}    Off
    Log      \n Powering On ${master_potash}
    Patch Interconnect  ${Potash_IC}  op=replace  path=/powerState  value=On  timeout=60  interval=5
    Sleep  20m
    Log      \n Checking ICM State after Power On
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured

#Validating ICM state
    @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
    Validate ICM State     Configured    @{ICMS}

#Validating Stacking Domain Role
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain Role      @{ICMS}

#Validating Stacking Domain ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain ID    @{ICMS}

#Validating Stacking Member ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Member ID    @{ICMS}

#Validating LI consistency state
    ${LIs} =    Get Li Names
    :FOR  ${LI}  IN  @{LIs}
    \   Validate LI Consistency State    ${LI}

#Validating Stacking Health
    Validate LI StackingHealth    ${Potash_LI['name']}

#LE support Dump
    ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
    ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
    ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
    ${task} =       Wait For Task       ${resp}    40m       10s
    ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
    ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump2.sdmp

#Self Test Result Check
    Open Connection And Log In    ${APPLIANCE_IP}
    Execute Command   rm -rf decryption
    Put Directory    ./decryption   /root/    mode=0777
    Execute Command   rm -rf  /root/LE_SD
    Execute Command   mkdir /root/LE_SD
    Put File  ./le_supportdump2.sdmp   /root/LE_SD/
    Execute Command   cd /root/LE_SD/; mv le_supportdump2.sdmp le_supportdump.sdmp
    ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
    Log   ${out}
    Execute Command  gunzip /root/LE_SD/*gz
    Sleep  10s
    Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
    Sleep  30s
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay3 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay3 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay6 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay6 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    Close Connection

#Getting all LI names & reading canmic block 60
    ${LIs} =    Get Li Names
    SortList    ${LIs}
    :for    ${LI}    in     @{LIs}
    \    Reading CANMIC 60   ${LI}

Potash Reset
    [Documentation]    Potash Reset
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    ${master_potash} =  Finding Master Potash      @{ICMS}
    Log   \nMaster Potash is ${master_potash}
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured
    Log      \nResetting Interconnect ${master_potash}
    ${Potash_IC} =    Create Dictionary    name=${master_potash}
    Patch Interconnect  ${Potash_IC}  op=replace  path=/deviceResetState  value=Reset  timeout=60  interval=5
    Sleep  10m
    Log      \n Checking ICM State after Reset
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured

#Validating ICM state
    @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
    Validate ICM State     Configured    @{ICMS}

#Validating Stacking Domain Role
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain Role      @{ICMS}

#Validating Stacking Domain ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain ID    @{ICMS}

#Validating Stacking Member ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Member ID    @{ICMS}

#Validating LI consistency state
    ${LIs} =    Get Li Names
    :FOR  ${LI}  IN  @{LIs}
    \   Validate LI Consistency State    ${LI}

#Validating Stacking Health
    Validate LI StackingHealth    ${Potash_LI['name']}

#LE support Dump
    ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
    ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
    ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
    ${task} =       Wait For Task       ${resp}    40m       10s
    ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
    ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump3.sdmp

#Self Test Result Check
    Open Connection And Log In    ${APPLIANCE_IP}
    Execute Command   rm -rf decryption
    Put Directory    ./decryption   /root/    mode=0777
    Execute Command   rm -rf  /root/LE_SD
    Execute Command   mkdir /root/LE_SD
    Put File  ./le_supportdump3.sdmp   /root/LE_SD/
    Execute Command   cd /root/LE_SD/; mv le_supportdump3.sdmp le_supportdump.sdmp
    ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
    Log   ${out}
    Execute Command  gunzip /root/LE_SD/*gz
    Sleep  10s
    Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
    Sleep  30s
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay3 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay3 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay6 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay6 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    Close Connection

#Getting all LI names & reading canmic block 60
    ${LIs} =    Get Li Names
    SortList    ${LIs}
    :for    ${LI}    in     @{LIs}
    \    Reading CANMIC 60   ${LI}

Potash Efuse
    [Documentation]    Potash Efuse
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    ${master_potash} =  Finding Master Potash      @{ICMS}
    Log   \nMaster Potash is ${master_potash}
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured
    Log      \n Removing Interconnect ${master_potash}
    Efuse ICM  ${master_potash}  EFuseOn
    Sleep   5m
    Log      \n Checking ICM state
    ${ic_resp} =     Get IC    ${master_potash}
    ${ic_State} =      Get From IC    ${ic_resp}   state
    Should Be Equal  ${ic_State}    Absent
    Log      \n Inserting Interconnect ${master_potash}
    Efuse ICM  ${master_potash}  EFuseOff
    Sleep  10m
    Log      \n Checking ICM State after inserting
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured

#Validating ICM state
    @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
    Validate ICM State     Configured    @{ICMS}

#Validating Stacking Domain Role
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain Role      @{ICMS}

#Validating Stacking Domain ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain ID    @{ICMS}

#Validating Stacking Member ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Member ID    @{ICMS}

#Validating LI consistency state
    ${LIs} =    Get Li Names
    :FOR  ${LI}  IN  @{LIs}
    \   Validate LI Consistency State    ${LI}

#Validating Stacking Health
    Validate LI StackingHealth    ${Potash_LI['name']}

#LE support Dump
    ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
    ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
    ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
    ${task} =       Wait For Task       ${resp}    40m       10s
    ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
    ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump4.sdmp

#Self Test Result Check
    Open Connection And Log In    ${APPLIANCE_IP}
    Execute Command   rm -rf decryption
    Put Directory    ./decryption   /root/    mode=0777
    Execute Command   rm -rf  /root/LE_SD
    Execute Command   mkdir /root/LE_SD
    Put File  ./le_supportdump4.sdmp   /root/LE_SD/
    Execute Command   cd /root/LE_SD/; mv le_supportdump4.sdmp le_supportdump.sdmp
    ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
    Log   ${out}
    Execute Command  gunzip /root/LE_SD/*gz
    Sleep  10s
    Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
    Sleep  30s
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay3 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay3 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay6 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay6 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    Close Connection


#Getting all LI names & reading canmic block 60
    ${LIs} =    Get Li Names
    SortList    ${LIs}
    :for    ${LI}    in     @{LIs}
    \    Reading CANMIC 60   ${LI}


OneView Reboot
    [Documentation]    OneView Reboot
    Reboot appliance via API    ${APPLIANCE_IP}    ${admin_credentials}    35 min   30 s
    ${LIs} =    Get Li Names
    :FOR    ${LI}    IN     @{LIs}
    \    @{ICMS} =    ICMs in LI    ${LI}
    \    Validate ICM State     Configured    @{ICMS}

#Validating Stacking Domain Role
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain Role      @{ICMS}

#Validating Stacking Domain ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Domain ID    @{ICMS}

#Validating Stacking Member ID
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    Validate LI Stacking Member ID    @{ICMS}

#Validating LI consistency state
    ${LIs} =    Get Li Names
    :FOR  ${LI}  IN  @{LIs}
    \   Validate LI Consistency State    ${LI}

#Validating Stacking Health
    Validate LI StackingHealth    ${Potash_LI['name']}

#LE support Dump
    ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
    ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
    ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
    ${task} =       Wait For Task       ${resp}    40m       10s
    ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
    ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump5.sdmp

#LE Support Decryption
    Open Connection And Log In    ${APPLIANCE_IP}
    Execute Command   rm -rf decryption
    Put Directory    ./decryption   /root/    mode=0777
    Execute Command   rm -rf  /root/LE_SD
    Execute Command   mkdir /root/LE_SD
    Put File  ./le_supportdump5.sdmp   /root/LE_SD/
    Execute Command   cd /root/LE_SD/; mv le_supportdump5.sdmp le_supportdump.sdmp
    ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
    Log   ${out}
    Execute Command  gunzip /root/LE_SD/*gz
    Sleep  10s
    Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
    Sleep  30s
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
    Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
    Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay3 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay3 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
    Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
    Should Contain   ${out1}   POST Success
    ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
    Log   \n\ncontent of bay6 fss.log file is ${out2}
    Should Contain   ${out2}   Power On Self Test Passed
    ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
    Log   \n\ncontent of bay6 audit.txt file is ${out3}
    Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
    Close Connection

#Getting all LI names & reading canmic block 60
    ${LIs} =    Get Li Names
    SortList    ${LIs}
    :for    ${LI}    in     @{LIs}
    \    Reading CANMIC 60   ${LI}

*** Comments ***
###########################################################################################################################

CNSA mode change
    ${mode_name} =  Set Variable   CNSA
    Change Cryptography Mode    ${mode_name}    ${APPLIANCE_IP}
    sleep  30m

 LE support Dump
     ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
     ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
     ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
     ${task} =       Wait For Task       ${resp}    30m       10s
     ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
     ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump1.sdmp

Self Test Result Check
     Open Connection And Log In    ${APPLIANCE_IP}
     Execute Command   rm -rf decryption
     Put Directory    ./decryption   /root/    mode=0777
     Execute Command   rm -rf  /root/LE_SD
     Execute Command   mkdir /root/LE_SD
     Put File  ./le_supportdump1.sdmp   /root/LE_SD/
     Execute Command   cd /root/LE_SD/; mv le_supportdump1.sdmp le_supportdump.sdmp
     ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
     Log   ${out}
     Execute Command  gunzip /root/LE_SD/*gz
     Sleep  10s
     Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
     Sleep  30s
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay3 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay3 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay6 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay6 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL

     Close Connection


Getting all LI names & reading canmic block 60
     ${LIs} =    Get Li Names
     SortList    ${LIs}
     :for    ${LI}    in     @{LIs}
     \    Reading CANMIC 60   ${LI}


Potash Power Cycle
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    ${master_potash} =  Finding Master Potash      @{ICMS}
    Log   \nMaster Potash is ${master_potash}
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured
    Log      \n Powering Off ${master_potash}
    ${Potash_IC} =    Create Dictionary    name=${master_potash}
    Patch Interconnect  ${Potash_IC}  op=replace  path=/powerState  value=Off  timeout=60  interval=5
    Sleep   5m
    Log      \n Checking ICM Power State after Power Off
    ${ic_resp} =     Get IC    ${master_potash}
    ${ic_powerState} =     Get From IC    ${ic_resp}   powerState
    Should Be Equal  ${ic_powerState}    Off
    Log      \n Powering On ${master_potash}
    Patch Interconnect  ${Potash_IC}  op=replace  path=/powerState  value=On  timeout=60  interval=5
    Sleep  20m
    Log      \n Checking ICM State after Power On
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured

Validating ICM state
      @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
      Validate ICM State     Configured    @{ICMS}

Validating Stacking Domain Role
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain Role      @{ICMS}

Validating Stacking Domain ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain ID    @{ICMS}

Validating Stacking Member ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Member ID    @{ICMS}

Validating LI consistency state
      ${LIs} =    Get Li Names
      :FOR  ${LI}  IN  @{LIs}
      \   Validate LI Consistency State    ${LI}

Validating Stacking Health
      Validate LI StackingHealth    ${Potash_LI['name']}

 LE support Dump
     ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
     ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
     ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
     ${task} =       Wait For Task       ${resp}    30m       10s
     ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
     ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump2.sdmp

 Self Test Result Check
     Open Connection And Log In    ${APPLIANCE_IP}
     Execute Command   rm -rf decryption
     Put Directory    ./decryption   /root/    mode=0777
     Execute Command   rm -rf  /root/LE_SD
     Execute Command   mkdir /root/LE_SD
     Put File  ./le_supportdump2.sdmp   /root/LE_SD/
     Execute Command   cd /root/LE_SD/; mv le_supportdump2.sdmp le_supportdump.sdmp
     ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
     Log   ${out}
     Execute Command  gunzip /root/LE_SD/*gz
     Sleep  10s
     Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
     Sleep  30s
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay3 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay3 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay6 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay6 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     Close Connection


Getting all LI names & reading canmic block 60
     ${LIs} =    Get Li Names
     SortList    ${LIs}
     :for    ${LI}    in     @{LIs}
     \    Reading CANMIC 60   ${LI}

Potash Reset
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    ${master_potash} =  Finding Master Potash      @{ICMS}
    Log   \nMaster Potash is ${master_potash}
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured
    Log      \nResetting Interconnect ${master_potash}
    ${Potash_IC} =    Create Dictionary    name=${master_potash}
    Patch Interconnect  ${Potash_IC}  op=replace  path=/deviceResetState  value=Reset  timeout=60  interval=5
    Sleep  10m
    Log      \n Checking ICM State after Reset
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured

Validating ICM state
      @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
      Validate ICM State     Configured    @{ICMS}

Validating Stacking Domain Role
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain Role      @{ICMS}

Validating Stacking Domain ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain ID    @{ICMS}

Validating Stacking Member ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Member ID    @{ICMS}

Validating LI consistency state
      ${LIs} =    Get Li Names
      :FOR  ${LI}  IN  @{LIs}
      \   Validate LI Consistency State    ${LI}

Validating Stacking Health
      Validate LI StackingHealth    ${Potash_LI['name']}

 LE support Dump
     ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
     ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
     ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
     ${task} =       Wait For Task       ${resp}    30m       10s
     ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
     ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump3.sdmp

 Self Test Result Check
     Open Connection And Log In    ${APPLIANCE_IP}
     Execute Command   rm -rf decryption
     Put Directory    ./decryption   /root/    mode=0777
     Execute Command   rm -rf  /root/LE_SD
     Execute Command   mkdir /root/LE_SD
     Put File  ./le_supportdump3.sdmp   /root/LE_SD/
     Execute Command   cd /root/LE_SD/; mv le_supportdump3.sdmp le_supportdump.sdmp
     ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
     Log   ${out}
     Execute Command  gunzip /root/LE_SD/*gz
     Sleep  10s
     Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
     Sleep  30s
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay3 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay3 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay6 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay6 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     Close Connection


Getting all LI names & reading canmic block 60
     ${LIs} =    Get Li Names
     SortList    ${LIs}
     :for    ${LI}    in     @{LIs}
     \    Reading CANMIC 60   ${LI}

Potash Efuse
    @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
    ${master_potash} =  Finding Master Potash      @{ICMS}
    Log   \nMaster Potash is ${master_potash}
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured
    Log      \n Removing Interconnect ${master_potash}
    Efuse ICM  ${master_potash}  EFuseOn
    Sleep   5m
    Log      \n Checking ICM state
    ${ic_resp} =     Get IC    ${master_potash}
    ${ic_State} =      Get From IC    ${ic_resp}   state
    Should Be Equal  ${ic_State}    Absent
    Log      \n Inserting Interconnect ${master_potash}
    Efuse ICM  ${master_potash}  EFuseOff
    Sleep  20m
    Log      \n Checking ICM State after inserting
    ${Potash_URI}=  Get IC URI  ${master_potash}
    IC reached state  ${Potash_URI}  Configured

Validating ICM state
      @{ICMS} =    ICMs in LI    ${Potash_LI['name']}
      Validate ICM State     Configured    @{ICMS}

Validating Stacking Domain Role
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain Role      @{ICMS}

Validating Stacking Domain ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain ID    @{ICMS}

Validating Stacking Member ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Member ID    @{ICMS}

Validating LI consistency state
      ${LIs} =    Get Li Names
      :FOR  ${LI}  IN  @{LIs}
      \   Validate LI Consistency State    ${LI}

Validating Stacking Health
      Validate LI StackingHealth    ${Potash_LI['name']}

 LE support Dump
     ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
     ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
     ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
     ${task} =       Wait For Task       ${resp}    30m       10s
     ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
     ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump4.sdmp

 Self Test Result Check
     Open Connection And Log In    ${APPLIANCE_IP}
     Execute Command   rm -rf decryption
     Put Directory    ./decryption   /root/    mode=0777
     Execute Command   rm -rf  /root/LE_SD
     Execute Command   mkdir /root/LE_SD
     Put File  ./le_supportdump4.sdmp   /root/LE_SD/
     Execute Command   cd /root/LE_SD/; mv le_supportdump4.sdmp le_supportdump.sdmp
     ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
     Log   ${out}
     Execute Command  gunzip /root/LE_SD/*gz
     Sleep  10s
     Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
     Sleep  30s
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay3 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay3 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay6 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay6 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     Close Connection


Getting all LI names & reading canmic block 60
     ${LIs} =    Get Li Names
     SortList    ${LIs}
     :for    ${LI}    in     @{LIs}
     \    Reading CANMIC 60   ${LI}


OneView Reboot
    Reboot appliance via API    ${APPLIANCE_IP}    ${admin_credentials}    35 min   30 s
    ${LIs} =    Get Li Names
    :FOR    ${LI}    IN     @{LIs}
    \    @{ICMS} =    ICMs in LI    ${LI}
    \    Validate ICM State     Configured    @{ICMS}

Validating Stacking Domain Role
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain Role      @{ICMS}

Validating Stacking Domain ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Domain ID    @{ICMS}

Validating Stacking Member ID
      @{ICMS} =    List HFPotashICM Names In LI     ${Potash_LI['name']}
      Validate LI Stacking Member ID    @{ICMS}

Validating LI consistency state
      ${LIs} =    Get Li Names
      :FOR  ${LI}  IN  @{LIs}
      \   Validate LI Consistency State    ${LI}

Validating Stacking Health
      Validate LI StackingHealth    ${Potash_LI['name']}

 LE support Dump
     ${le_uri}=  Get LE URI  ${logical_enclosure_multi['name']}
     ${le_uri}=  Replace String   ${le_uri}    /rest/logical-enclosures/    ${EMPTY}
     ${resp}=  fusion_api_get_logical_enclosure_support_dump   ${le_sd_body_enc}  ${le_uri}
     ${task} =       Wait For Task       ${resp}    30m       10s
     ${uri}=     Get From Dictionary        ${task['associatedResource']}       resourceUri
     ${resp}=    Fusion Api Download Support Dump    ${uri}     ./le_supportdump5.sdmp

 LE Support Decryption
     Open Connection And Log In    ${APPLIANCE_IP}
     Execute Command   rm -rf decryption
     Put Directory    ./decryption   /root/    mode=0777
     Execute Command   rm -rf  /root/LE_SD
     Execute Command   mkdir /root/LE_SD
     Put File  ./le_supportdump5.sdmp   /root/LE_SD/
     Execute Command   cd /root/LE_SD/; mv le_supportdump5.sdmp le_supportdump.sdmp
     ${out}=  Execute Command    cd /root/decryption/;./decrypt-support-dump.sh /root/LE_SD/le_supportdump.sdmp
     Log   ${out}
     Execute Command  gunzip /root/LE_SD/*gz
     Sleep  10s
     Execute Command  cd /root/LE_SD;tar -xvf /root/LE_SD/*tar
     Sleep  30s
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/;mkdir bay3;mkdir bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_6.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6
     Execute Command   mv /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/*bay_3.tgz /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/; tar -xvf *bay_3.tgz
     Execute Command   cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/; tar -xvf *bay_6.tgz
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay3 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay3 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay3/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay3 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     ${out1}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat hf_ssh_post_log.txt
     Log   \n\ncontent of bay6 hf_ssh_post_log.txt file is ${out1}
     Should Contain   ${out1}   POST Success
     ${out2}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat fss.log | grep POST | tail -1
     Log   \n\ncontent of bay6 fss.log file is ${out2}
     Should Contain   ${out2}   Power On Self Test Passed
     ${out3}=  Execute Command  cd /root/LE_SD/logical-enclosure/var/tmp/le-support-dumps/*/${support_dump['LI_name']}/comware-irf/bay6/;cat audit.txt | grep POST | tail -1
     Log   \n\ncontent of bay6 audit.txt file is ${out3}
     Should Contain   ${out3}    FILE-POST-TEST: SUCCESS ALGO-FAILED:NULL
     Close Connection


Getting all LI names & reading canmic block 60
     ${LIs} =    Get Li Names
     SortList    ${LIs}
     :for    ${LI}    in     @{LIs}
     \    Reading CANMIC 60   ${LI}




