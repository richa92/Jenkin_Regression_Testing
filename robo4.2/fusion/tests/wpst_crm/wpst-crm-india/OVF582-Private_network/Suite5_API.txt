*** Settings ***
Documentation     OVF582-TBird/Hafnium:Add Private Network Support.
Library         Sdumpfunctions
Library         OperatingSystem
Library         FusionLibrary
Library         Telnet
Library         SSHLibrary
Library    Dialogs
Library         RoboGalaxyLibrary
Library         data_variables
Library             back_ping.py
Variables       data_variables.py
Resource        ../../../resource/fusion_api_all_resource_files.txt
Resource    OVAConfig.txt
Force Tags    Buildup
Suite Setup    Load Test Data and Open Browser
# Suite Teardown      Cleanup For Suite

*** Test Cases ***
Initial Cleanup
    [Documentation]    Returns appliance to a 'clean' state by removing all resources\enclosures
    Log to console and logfile    [Cleanup]
    Login to OneView via REST
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove All Network Sets
    Remove ALL Ethernet Networks
    Remove ALL FC Networks

1 Initial Setup
    [Documentation]    Creating setup
    Set Log Level    TRACE
    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    Run keyword unless    ${Login_resp[0]['status_code']}== 200    Fail    "Unable to Login"

    :For    ${Enet}    IN    @{Enet_1}
    \    ${Enet1_resp}    Fusion Api Create Ethernet Network    ${Enet}
    \    ${task} =   Wait For Task   ${Enet1_resp}     240s    2s
    \    Run keyword unless    ${Enet1_resp['status_code']}== 202   Fail    "Unable to Create network"

    ${body} =    Build LIG body    ${LIGS_TB['ligsup_HA'][0]}
    ${lig_resp}    Fusion Api Create LIG    ${body}
    ${task} =   Wait For Task    ${lig_resp}    400s    2s
    Log to Console  \n-LIG  created successfully

    ${eg_resp}    Add Enclosure Group from variable    ${Enc_group}
    Run Keyword If    '${eg_resp['status_code']}' != '201'    Fail    ELSE  log to console   \n-EG created successfully
    ${le_resp}    Add Logical Enclosure from variable    ${Logical_Enclosure[0]}
    Run Keyword If    '${le_resp['status_code']}' != '200'    Fail    ELSE  log to console   \n-LE created successfully

OVF582_API_TC_75:Verify the traffic flow should be dropped between the servers via Downlinks of different PHYs when the private network is enabled
    [Documentation]    verification of the the traffic flow should be dropped between the servers via Downlinks of different PHYs when the private network is enabled
    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_HA1_Dphy}
    Log to console    \n-${server_profile_HA1_Dphy[0]['name']} is created successfully
    ${Server_resp2}    Add Server Profiles from variable    ${server_profile_HA2_Dphy}
    Log to console    \n-${server_profile_HA2_Dphy[0]['name']} is created successfully

    Power on server    ${server_profile_HA1_Dphy[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA1_Dphy[0]['serverHardwareUri']} is powered on Successfully

    Power on server    ${server_profile_HA2_Dphy[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA2_Dphy[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot...

    Sleep    10min

    # Get the server ip list from the servers to verify the traffic flow
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # verify the traffic flow between the servers via Downlinks of different PHYs when the private network is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

#####OVF582_API_TC_80:Verify the traffic flow should be success between the servers via Downlinks of different PHYs when the private network is disabled#####

    # Disable the Private network and verify the traffic flow between the servers
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_1[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_1[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_false}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}

    # Verify the traffic flow should be success between the servers via Downlinks of different PHYs when the private network is disabled
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

OVF582_API_TC_84:Verify the traffic flow between VPLAG and different S-channel when the private network feature is disabled
    [Documentation]    Verification of the traffic flow between VPLAG and different S-channel when the private network feature is disabled
    Power off server    ${server_profile_HA1_Dphy[0]['serverHardwareUri']}

    # Delete the server Profile
    ${del_pro1}    Fusion Api Delete Server Profile    param=?filter="'name'=='${server_profile_HA1_Dphy[0]['name']}'"
    ${task} =   Wait For Task    ${del_pro1}    400s    2s

    # Add server Profile for HA setup
    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_HA1_lag}
    Log to console    \n-${server_profile_HA1_lag[0]['name']} is edited successfully..

    Power on server    ${server_profile_HA1_lag[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA1_lag[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot...
    Sleep    10min

    # Get the valid interface list and for bond creation
    ${adapter}    Get Valid Interface List    ${ilo1_details}    ${server1_details}    ${up_interface}    ${down_interface}
    Log to console and logfile    ${adapter}
    ${Len_of_adapter}    Get Length    ${adapter}
    ${Adapterlist}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${adapter[${x}]}
    \    Append to list    ${Adapterlist}    ${temp}
    Log to console and logfile    ${Adapterlist}

    # Creation of bond and check for traffic flow
    ${cmd_out}    Build Commands For Create Bonding    ${Adapter_1}    ${Adapter_2}    ${Create_bond}    ${Master_slave_1}    ${Master_slave_2}    ${Bond_slave_1}    ${Bond_slave_2}    ${Network_bond}    ${Master}    ${Modify_bond}    ${Modify_ip}    ${Modify_manual}    ${Adapterlist}    ${Bond_1}    ${space}    ${Ip_bond_1}    ${iLo1_details}    ${server1_details}

    # Get the valid server ip list
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # verify the traffic flow between the servers of VPLAG and different S-channel when the private network feature is disabled
    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

#####OVF582_API_TC_89:Verify the traffic flow between VPLAG and different S-channel when the private network feature is enabled#####

    # Enable the Private network
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_1[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_1[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_true}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully..
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}

    # Verify the traffic flow between VPLAG and different S-channel when the private network feature is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

OVF582_API_TC_69:51:66:104 Verify the traffic flow between VPLAG1and VPLAG2 when the private network feature is enabled_Verify the traffic flow between the VPLAG1 and VPLAG2 when the ports are shutdown_Verify the traffic flow between the VPLAG and MLAG when the network is enabled
    [Documentation]    Verification of the traffic flow between VPLAG1 and VPLAG2 when the private network feature is enabled_Verification of the traffic flow between the VPLAG1 and VPLAG2 when the ports are shutdown_Verification of the traffic flow between the VPLAG and MLAG when the network is enabled
    Power off server    ${server_profile_HA2_Dphy[0]['serverHardwareUri']}

    ${del_pro2}    Fusion Api Delete Server Profile    param=?filter="'name'=='${server_profile_HA2_Dphy[0]['name']}'"
    ${task} =   Wait For Task    ${del_pro2}    400s    2s

    # create VPlag setup
    ${Server_resp1}    Add Server Profiles from variable    ${server_profile_HA2_lag}
    Log to console    \n-${server_profile_HA2_lag[0]['name']} is edited successfully..

    Power on server    ${server_profile_HA2_lag[0]['serverHardwareUri']}
    Log to console and logfile    \n-Server ${server_profile_HA2_lag[0]['serverHardwareUri']} is powered on Successfully
    Log to console and logfile    \n-Waiting 10 mins for server to boot...

    Sleep    10min

    # get the valid interface list for network bond creation
    ${adapter}    Get Valid Interface List    ${ilo2_details}    ${server2_details}    ${up_interface}    ${down_interface}
    Log to console and logfile    ${adapter}
    ${Len_of_adapter}    Get Length    ${adapter}
    ${Adapterlist}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${adapter[${x}]}
    \    Append to list    ${Adapterlist}    ${temp}
    Log to console and logfile    ${Adapterlist}

    # creation of network bond
    ${cmd_out}    Build Commands For Create Bonding    ${Adapter_1}    ${Adapter_2}    ${Create_bond}    ${Master_slave_1}    ${Master_slave_2}    ${Bond_slave_1}    ${Bond_slave_2}    ${Network_bond}    ${Master}    ${Modify_bond}    ${Modify_ip}    ${Modify_manual}    ${Adapterlist}    ${Bond_2}    ${space}    ${Ip_bond_2}    ${ilo2_details}    ${server2_details}
    Log to console and logfile    ${cmd_out}
    # Check all the ports are in Active state
    validate port status reason    ${interconnectname_1}    ${uplink_port_number[0]}    Active
    validate port status reason    ${interconnectname_1}    ${uplink_port_number[1]}    Active
    validate port status reason    ${interconnectname_2}    ${uplink_port_number[0]}    Active
    validate port status reason    ${interconnectname_2}    ${uplink_port_number[1]}    Active

    # verify the Port affinity MLAG by checking inPackets and outpackets
    ${Final_list_ICM}    Port Affinity MLAG    ${server_profile_HA1_lag}    ${server_profile_HA2_lag}
    ${len_of_icm}    Get Length    ${Final_list_ICM}
    ${Inpacket}    Create List
    ${Outpacket}    Create List
    :For    ${x}    INRANGE    0    ${len_of_icm}
    \    ${UnicastTraffic_Inpacket_1}    ${UnicastTraffic_Outpacket_1}    Get Inpackets and Outpackets    ${Final_list_ICM[${x}]}    ${stat}    ${uplink_port_number[0]}
    \    Append to list    ${Inpacket}    ${UnicastTraffic_Inpacket_1}
    \    Append to list    ${Outpacket}    ${UnicastTraffic_Outpacket_1}
    Log to console    ${Inpacket}
    Log to console    ${Outpacket}

    # Get the valid server ip for the traffic flow verification
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # Verify the traffic flow between VPLAG1and VPLAG2 when the private network feature is enabled
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    # Refresh the Appliance for packets verification
    Log To Console    *********Log into Appliance as Administrator****************
    ${user} =    Get Data By Property    ${TestData.users}    name    Administrator
    fusion_ui_login_to_appliance    ${user[0].name}
    Log to Console    Successfully logged in as Administrator
    fusion_ui_navigate_to_interconnects_page
    navigate
    Sleep    80
    navigate

    # check the packets verification after refresh
    ${In_packets}    Create List
    ${Out_packets}    Create List
    :For    ${x}    INRANGE    0    ${len_of_icm}
    \    ${In_packet_1}    ${Out_packet_1}    Get Inpackets and Outpackets    ${Final_list_ICM[${x}]}    ${stat}    ${uplink_port_number[0]}
    \    Append to list    ${In_packets}    ${In_packet_1}
    \    Append to list    ${Out_packets}    ${Out_packet_1}
    Log to console    ${In_packets}
    Log to console    ${Out_packets}

    ${Len_of_packets}    Get Length    ${In_packets}
    :For    ${x}    INRANGE    0    ${Len_of_packets}
    \    Run Keyword If    '${Inpacket[${x}]}' == '${In_packets[${x}]}'    Fail    ELSE    Log to console and logfile    Tried recieving packets.....
    \    Run Keyword If    '${Outpacket[${x}]}' == '${Out_packets[${x}]}'    Log to console and logfile    Packets are transferred equal    ELSE    Log to console and logfile    Tried Sending Packets......

    # Ports shutdown and verify the traffic flow
    :For    ${x}    INRANGE    0    2
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    Run Keyword If  '${Logout_resp['status_code']}' != '204'   Fail    ELSE    Log to console    \n-Successfully logged out of the appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Run keyword unless    ${Login_resp[0]['status_code']}== 200    Fail    "Unable to Login"
    \    Disable port    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}    Unlinked
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    Run Keyword If    '${Logout_resp['status_code']}' != '204'   Fail    ELSE    Log to console    \n-Successfully logged out of the appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"
    \    Disable port    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}    Unlinked

    # check the traffic flow between VPLAG1 and VPLAg2 after ports shutdown
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    # enable the ports and check for traffic flow
    :For    ${x}    INRANGE    0    2
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    Run Keyword If  '${Logout_resp['status_code']}' != '204'   Fail    ELSE    Log to console    \n-Successfully logged out of the appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"
    \    Enable port    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}    Linked
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    Run Keyword If  '${Logout_resp['status_code']}' != '204'   Fail    ELSE    Log to console    \n-Successfully logged out of the appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Run keyword unless  ${Login_resp[0]['status_code']}== 200   Fail    "Unable to Login"
    \    Enable port    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}    Linked

    # Enable the ports and check for traffic flow between the VPALg1 and VPLAg2
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

####OVF582_API_TC_70:52:67:105 Verify the traffic flow between VPLAG1and VPLAG2 when the private networks feature is disabled####

    # Disable the Private network and verify the traffic flow
    :For    ${x}    INRANGE    0    2
    \    ${Enet_resp}    Fusion Api Get Ethernet Networks    param=?filter="'name'=='${Enet_1[${x}]['name']}'"
    \    ${Enet_uri}    Get Variable Value    ${Enet_resp['members'][0]['uri']}
    \    ${Enet_CT}    Get Variable value    ${Enet_resp['members'][0]['connectionTemplateUri']}
    \    ${Enet}    Copy Dictionary    ${Enet_1[${x}]}
    \    Set To Dictionary    ${Enet}    privateNetwork    ${pnet_false}
    \    Set To Dictionary    ${Enet}    connectionTemplateUri    ${Enet_CT}
    \    ${Enet_1_edit}    Fusion Api Edit Ethernet Network    body=${Enet}    uri=${Enet_uri}
    \    ${task} =   Wait For Task   ${Enet_1_edit}     240s    2s
    \    Run Keyword If    '${Enet_1_edit['status_code']}' != '202'    Fail    ELSE    Log to console and logfile    \n-Network Edited Successfully
    Sleep    50
    ${Validate_state_IC}    Get IC and Verify state    ${IC_Configured}

    # verify the Port affinity MLAG by checking inPackets and outpackets
    ${Final_list_ICM}    Port Affinity MLAG    ${server_profile_HA1_lag}    ${server_profile_HA2_lag}
    ${len_of_icm}    Get Length    ${Final_list_ICM}

    # get the inpackets and outpackets for MLAG verification
    ${Traffic_Inpacket_1}    Create List
    ${Traffic_Outpacket_1}    Create List
    :For    ${x}    INRANGE    0    ${len_of_icm}
    \    ${UnicastTraffic_Inpacket_1}    ${UnicastTraffic_Outpacket_1}    Get Inpackets and Outpackets    ${Final_list_ICM[${x}]}    ${stat}    ${uplink_port_number[0]}
    \    Append to list    ${Traffic_Inpacket_1}    ${UnicastTraffic_Inpacket_1}
    \    Append to list    ${Traffic_Outpacket_1}    ${UnicastTraffic_Outpacket_1}
    Log to console    ${Traffic_Inpacket_1}
    Log to console    ${Traffic_Outpacket_1}

    # Get the valid server ip for the traffic flow verification
    ${ip}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${ip_list}    Get Valid Server IP list    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${down_interface}    ${get_interface}
    \    ${temp}    Convert To String    ${ip_list[0]}
    \    Append to list    ${ip}    ${temp}
    Log to console and logfile    Final list-${ip}

    # Verify the traffic flow between VPLAG1and VPLAG2 when the private network feature is disabled
    Ping should be success     ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    # refresh the appliance
    Log To Console    *********Log into Appliance as Administrator****************
    ${user} =    Get Data By Property    ${TestData.users}    name    Administrator
    fusion_ui_login_to_appliance    ${user[0].name}
    Log to Console    Successfully logged in as Administrator
    fusion_ui_navigate_to_interconnects_page
    navigate
    Sleep    30
    navigate

    # after refresh get the inpackets and outpackets for MLAG verifictaion
    ${In_packets_1}    Create List
    ${Out_packets_1}    Create List
    :For    ${x}    INRANGE    0    ${len_of_icm}
    \    ${In_packet_3}    ${Out_packet_3}    Get Inpackets and Outpackets    ${Final_list_ICM[${x}]}    ${stat}    ${uplink_port_number[0]}
    \    Append to list    ${In_packets_1}    ${In_packet_3}
    \    Append to list    ${Out_packets_1}    ${Out_packet_3}
    Log to console    ${In_packets_1}
    Log to console    ${Out_packets_1}

    ${Len_of_packets}    Get Length    ${In_packets_1}
    :For    ${x}    INRANGE    0    ${Len_of_packets}
    \    Run Keyword If    '${Traffic_Inpacket_1[${x}]}' == '${In_packets_1[${x}]}'    Fail    ELSE    Log to console and logfile    Packets are recieved
    \    Run Keyword If    '${Traffic_Outpacket_1[${x}]}' == '${Out_packets_1[${x}]}'    Log to console and logfile    Packets are transferred equal    ELSE    Log to console and logfile    Packets are transferred

    :For    ${x}    INRANGE    0    2
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Disable port    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}    Unlinked
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Disable port    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}    Unlinked

    # verify the traffic flow between the servers of VPLAG1 and VPLAG2
    Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    :For    ${x}    INRANGE    0    2
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Enable port    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_1}    ${downlink_port_number_${x+1}[0]}    Linked
    \    ${Logout_resp}    Fusion Api Logout Appliance
    \    ${Login_resp}    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}
    \    Enable port    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}
    \    Wait Until Keyword Succeeds    650 s   35 s    validate port status    ${interconnectname_2}    ${downlink_port_number_${x+1}[1]}    Linked

    Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ip}

    # delete the created bond
    :For    ${x}    INRANGE    0    2
    \    ${Del_bond}    Build Commands For Delete Bonding    ${Delete_Network_bond}    ${Delete_bond_slave_1}    ${Delete_bond_slave_2}    ${ilo${x+1}_details}    ${server${x+1}_details}    ${up_interface}    ${Bond_${x+1}}

*** keywords ***
Login to OneView via REST
    [Documentation]     Login to the appliance with the cred
    [Tags]  add   POSITIVE
    Set Log Level    TRACE
    ${resp}     Fusion Api Login Appliance    ${APPLIANCE_IP}        ${admin_credentials}



Verify Interconnect State
    [Documentation]    Verify the interconnect state
    ...             Example:
    ...             Verify Interconnect State    ${interconnectname_1}    ${IC_Configured}
    [Arguments]        ${interconnectname_1}        ${IC_Configured}
    Log to Console    Verify interconnect
    ${ic} =    Get IC    ${interconnectname_1}
    ${State} =    Get From IC        ${ic}    state
    Log to Console and logfile    ${State}
    Log to console and logfile    Interconnect state is ${interconnectname_1}:${State}
    Should Be Equal As Strings    ${State}    ${IC_Configured}

Get IC
    [Documentation]    Get IC by name
    ...             Example:
    ...             Get IC    ${ICM_NAME}
    [Arguments]        ${ICM_NAME}
    ${resp} =   fusion api get interconnect
    Log        ${resp}
    ${ics} =     Get From Dictionary     ${resp}    members
    ${l} =     Get Length    ${ics}
    :FOR    ${x}    IN RANGE    0    ${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
    \     Exit For Loop If     '${ic['name']}' == '${ICM_NAME}'
    [Return]    ${ic}

Get from IC
    [Documentation]    Get the required element from the interconnect
    ...             Example:
    ...             Get from IC    ${ic}    ${element}
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}

Ping should be success
    [Documentation]    Verify the traffic pass between two linux servers are allowed
    ...             Example:
    ...             Ping should be success    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    [Arguments]        ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    Log to console and logfile    \n*** Verifying the connectivity between the servers ***
    ${out} =    Login to linux server via iLo    ${iLo1_details}    ${server1_details}    ${ips[1]}
    Should Contain    ${out}    ttl=
    Should Contain    ${out}    0% packet loss

    ${out} =    Login to linux server via iLo    ${iLo2_details}    ${server2_details}    ${ips[0]}
    Should Contain    ${out}    ttl=
    Should Contain    ${out}    0% packet loss

Ping should fail
    [Documentation]    Verify the traffic pass between two windows servers are blocked
    ...             Example:
    ...             Ping should fail    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    [Arguments]    ${iLo1_details}    ${iLo2_details}    ${server1_details}    ${server2_details}    ${ips}
    Log to console and logfile    \n*** Verifying the connectivity between the servers ***
    ${out} =    Login to linux server via iLo    ${iLo1_details}    ${server1_details}    ${ips[1]}
    Should Not Contain    ${out}    ttl=


    ${out} =    Login to linux server via iLo    ${iLo2_details}    ${server2_details}    ${ips[0]}
    Should Not Contain    ${out}    ttl=

validate port status
    [Documentation]    validate the port status of the ICM
    [Arguments]   ${icm}   ${portname}   ${state}
    ${ic}=   Get IC URI   ${icm}
    ${resp}=   fusion_api_get_interconnect_ports   uri=${ic}
    :FOR   ${port}  IN   @{resp['members']}
    \    run keyword if  '${port['portName']}' != '${portname}'   Continue For Loop
    \    should match  ${port['portStatus']}   ${state}
    \    Log to console and logfile    Port Status ${port['portStatus']} matches expected ${state}

Disable port
    [Documentation]   Disabling the uplink port of ICM
    [Arguments]    ${icm}    ${port_number}
    ${ic_uri} =   Get IC URI    ${icm}
    Log to console    ${ic_uri}
    ${resp} =     Get IC Port    uri=${ic_uri}   port=${port_number}
    Log to console and logfile    \n${resp}
    Set to Dictionary   ${resp}   enabled    ${false}
    ${body} =    Create List
    Append to list    ${body}    ${resp}

    ${resp} =     fusion api edit interconnect ports   uri=${ic_uri}   body=${body}
    ${task} =       Wait For Task   ${resp}     7 min   15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}     ${valDict}
    Sleep    60

Enable port
    [Documentation]   Enabling the uplink port of ICM
    [Arguments]    ${icm}    ${port_number}
    ${ic_uri} =   Get IC URI    ${icm}
    Log to console    ${ic_uri}
    ${resp} =     Get IC Port    uri=${ic_uri}   port=${port_number}
    Log to console and logfile    \n${resp}
    Set to Dictionary   ${resp}   enabled    ${true}
    ${body} =    Create List
    Append to list    ${body}    ${resp}

    ${resp} =     fusion api edit interconnect ports   uri=${ic_uri}   body=${body}
    ${task} =       Wait For Task   ${resp}     7 min   15s
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    Validate Response    ${task}    ${valDict}
    Sleep    60

Get IC Port
    [Documentation]    Getting IC Port details and return the Portname
    [Arguments]     ${uri}  ${port}
    ${resp} =   fusion api get interconnect ports    uri=${uri}
    ${ics} =     Get From Dictionary     ${resp}    members
    :FOR    ${ic}   IN      @{ics}
    \   ${return} =    Run Keyword If   '${ic['portName']}' == '${port}'        set variable     ${ic}
    \   Exit for loop if    '${ic['portName']}' == '${port}'
    [Return]    ${return}

Build Commands For Create Bonding
    [Documentation]    Building commands for bond creation or teaming the adapters
    [Arguments]    ${Adapter_1}    ${Adapter_2}    ${Create_bond}    ${Master_slave_1}    ${Master_slave_2}    ${Bond_slave_1}    ${Bond_slave_2}    ${Network_bond}    ${Master}    ${Modify_bond}    ${Modify_ip}    ${Modify_manual}    ${Adapterlist}    ${Bond}    ${space}    ${Ip_bond}    ${ilo_details}    ${server_details}

    ${Network_adapter_1}    Replace String Using Regexp   ${Adapter_1}    adapter1    ${Adapterlist[0]}
    ${Network_adapter_2}    Replace String Using Regexp   ${Adapter_2}    adapter2    ${Adapterlist[1]}
    ${Network_bond_1}    Replace String Using Regexp   ${Create_bond}    bond-name    ${Bond}
    ${Add_connection_1}    Replace String Using Regexp   ${Master_slave_1}    connection-name-1    ${Adapterlist[0]}
    ${Add_connection_2}    Replace String Using Regexp   ${Master_slave_2}    connection-name-2    ${Adapterlist[1]}
    ${Up_connection_1}    Replace String Using Regexp   ${Bond_slave_1}    connection-name-1    ${Adapterlist[0]}
    ${Up_connection_2}    Replace String Using Regexp   ${Bond_slave_2}    connection-name-2    ${Adapterlist[1]}
    ${Up_bond}    Replace String Using Regexp   ${Network_bond}    bond-name    ${Bond}
    ${Bond_name}    Replace String Using Regexp    ${Master}    bond-name    ${Bond}
    ${connection_1}    catenate    ${Add_connection_1}/${Bond_name}
    ${bond_connection_1}    Replace String Using Regexp    ${connection_1}    /    ${space}
    ${connection_2}    catenate    ${Add_connection_2}/${Bond_name}
    ${bond_connection_2}    Replace String Using Regexp    ${connection_2}    /    ${space}
    ${Assign_adapter}    Replace String Using Regexp    ${Modify_bond}    bond-name    ${Bond}
    ${Assign_ip}    Replace String Using Regexp    ${Modify_ip}    ip-address    ${Ip_bond}
    ${Combine_ip_adapter}    catenate    ${Assign_adapter}/${Assign_ip}
    ${Assign_ip_adapter}    Replace String Using Regexp    ${Combine_ip_adapter}    /    ${space}
    ${Assign_ip_netmask}    Replace String Using Regexp    ${Modify_manual}    netmask    ${Netmask}
    ${Assign_ip_address}    catenate    ${Assign_ip_adapter}/${Assign_ip_netmask}
    #${Up_interface}    Replace String Using Regexp    ${interface_up}    interface-name    ${Bond}
    #${Down_interface}    Replace String Using Regexp    ${down_interface}    interface-name    ${Bond}
    Log to console and logfile    ${Network_adapter_1}
    Log to console and logfile    ${Network_adapter_2}
    Log to console and logfile    ${Network_bond_1}
    Log to console and logfile    ${bond_connection_1}
    Log to console and logfile    ${bond_connection_2}
    Log to console and logfile    ${Up_connection_1}
    Log to console and logfile    ${Up_connection_2}
    Log to console and logfile    ${Up_bond}
    Log to console and logfile    ${Assign_ip_address}
    #Log to console and logfile    ${Down_interface}
    #Log to console and logfile    ${Up_interface}

    Log to console and logfile    *********Network bonding is about start*********
    ${cmd_out}    Create Network Bonding    ${ilo_details}    ${server_details}    ${Network_adapter_1}    ${Network_adapter_2}    ${Network_bond_1}    ${bond_connection_1}    ${bond_connection_2}    ${Up_connection_1}    ${Up_connection_2}    ${Up_bond}    ${Assign_ip_address}
    [Return]    ${cmd_out}

Build Commands For Delete Bonding
    [Documentation]    Build commands to delete the created Bond
    [Arguments]    ${Delete_Network_bond}    ${Delete_bond_slave_1}    ${Delete_bond_slave_2}    ${ilo_details}    ${server_details}    ${up_interface}    ${Bond}
    ${Delete_bond}    Replace String Using Regexp   ${Delete_Network_bond}    bond-name    ${Bond}
    Log to console and logfile    ${Delete_bond}
    ${cmd_out}    Delete Network Bonding    ${ilo_details}    ${server_details}    ${Delete_bond}
    ${ip_adapter}    Get Server IP Linux    ${ilo_details}    ${server_details}
    ${ret}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<BROADCAST
    ${flag_list} =    Create List
    ${length} =     Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${flag_list}    ${ret[${x}]}
    ${length} =     Get Length    ${flag_list}
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${flag_list[${x}]}    \\d+:\\s+(.*):\\s+<BROADCAST
    \    Log to console   values ${match}
    \    Append To List   ${Adapter_name}    ${match}
    Remove Values From List    ${Adapter_name}    virbr0-nic
    ${Len_of_adapter}    Get Length    ${Adapter_name}
    ${Adapterlist}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${Adapter_name[${x}]}
    \    Append to list    ${Adapterlist}    ${temp}
    Log to console and logfile    ${Adapterlist}
    ${Delete_connection_1}    Replace String Using Regexp   ${Delete_bond_slave_1}    connection-name-1    ${Adapterlist[0]}
    ${Delete_connection_2}    Replace String Using Regexp   ${Delete_bond_slave_2}    connection-name-2    ${Adapterlist[1]}
    ${Network_adapter_1}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapterlist[0]}
    ${Network_adapter_2}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapterlist[1]}
    Log to console and logfile    ${Delete_connection_1}
    Log to console and logfile    ${Delete_connection_2}
    ${cmd}    Delete Network Slave    ${ilo_details}    ${server_details}    ${Delete_connection_1}    ${Delete_connection_2}    ${Network_adapter_1}    ${Network_adapter_2}

    [Return]    ${cmd}

Login to linux server via iLo
    [Documentation]    Ping server via iLo
    [Arguments]         ${ilo_details}    ${server_details}    ${ip}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    5sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ping -c 120 ${ip}
    Sleep    240sec
    ${cmd_out}    SSHLibrary.Read
    Log to console and logfile    ${cmd_out}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Get Server IP Linux
    [Documentation]    Gets the adapter list of the server
    [Arguments]         ${linux_ilo_details}    ${linux_server_details}
    SSHLibrary.Open Connection     ${linux_ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login               ${linux_ilo_details['username']}     ${linux_ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    20sec
    SSHLibrary.Read
    Sleep    5sec
    SSHLibrary.Write     ${linux_server_details['username']}
    Sleep    10sec
    SSHLibrary.Write     ${linux_server_details['password']}
    Sleep    10sec
    SSHLibrary.Read
    SSHLibrary.Write     ip addr
    Sleep    20sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}


Get IP and Adapter
    [Documentation]    Get IP and adapter from the server
    [Arguments]         ${ip_adapter}
    ${ret}    Get Regexp Matches    ${ip_adapter}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    ${match2}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    \    ${Adapter_list}    Fetch From Right        ${Ret}      global
    \    ${temp}    Remove Whitespace    ${Adapter_list}
    \    Append To List   ${Adapter_name}    ${temp}

    Log to console  final list ${Ip_List}
    Log to console   final list2 ${Adapter_name}
    [Return]    ${Ip_List}    ${Adapter_name}

Get Server IP
    [Documentation]    Get the server ip list from the ifconfig output
    [Arguments]         ${ip_adapter}
    ${ret}    Get Regexp Matches    ${ip_adapter}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d+\\s+brd.*(\\w+)
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\/\\d
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    Log to console  final list ${Ip_List}
    [Return]    ${Ip_List}

Create Network Bonding
    [Documentation]    Team the adapters in the server.
    [Arguments]         ${ilo_details}    ${server_details}    ${Network_adapter_1}    ${Network_adapter_2}    ${Network_bond_1}    ${bond_connection_1}    ${bond_connection_2}    ${Up_connection_1}    ${Up_connection_2}    ${Up_bond}    ${Assign_ip_address}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.Write    ${Network_adapter_1}
    Sleep    10sec
    SSHLibrary.Write    ${Network_adapter_2}
    Sleep    10sec
    SSHLibrary.Write    ${Network_bond_1}
    Sleep    10sec
    SSHLibrary.Write    ${bond_connection_1}
    Sleep    10sec
    SSHLibrary.Write    ${bond_connection_2}
    Sleep    10sec
    SSHLibrary.Write    ${Up_connection_1}
    Sleep    10sec
    SSHLibrary.Write    ${Up_connection_2}
    Sleep    10sec
    SSHLibrary.Write    ${Assign_ip_address}
    Sleep    10sec
    SSHLibrary.Write    ${Up_bond}
    Sleep    10sec
    SSHLibrary.Write    ${Up_interface}
    Sleep    10sec
    SSHLibrary.Write    ip addr
    Sleep    15sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Delete Network Bonding
    [Documentation]    Delete the network bond created in the server.
    [Arguments]         ${ilo_details}    ${server_details}    ${Delete_bond}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.Write    ${Delete_bond}
    Sleep    10sec
    SSHLibrary.Write    ip addr
    Sleep    10sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Delete Network Slave
    [Documentation]    Delete the network bond slave in the server
    [Arguments]         ${ilo_details}    ${server_details}    ${Delete_connection_1}    ${Delete_connection_2}    ${Network_adapter_1}    ${Network_adapter_2}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.Write    ${Delete_connection_1}
    Sleep    10sec
    SSHLibrary.Write    ${Delete_connection_2}
    Sleep    10sec
    SSHLibrary.Write    ${Network_adapter_1}
    Sleep    10sec
    SSHLibrary.Write    ${Network_adapter_2}
    Sleep    10sec
    SSHLibrary.Write    ip addr
    Sleep    20sec
    ${stdout}    SSHLibrary.Read
    Log to console and logfile    ${stdout}
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections
    [Return]    ${stdout}

Get Valid Server IP list
    [Documentation]    Get the only the valid ip of the one or more servers
    ...             Example:
    ...             Get Valid Server IP list    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}    ${get_interface}
    [Arguments]    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}    ${get_interface}
    ${Adapter_list}    Get Valid Interface List    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    ${ifconfig_output_list}    Create List
    ${Len_of_adapter}    Get Length    ${Adapter_list}
    :For    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${ifconfig_name}    Replace String Using Regexp    ${get_interface}    interface-name    ${Adapter_list[${x}]}
    \    ${Ip_output}    Get Valid Server IP    ${ilo_details}    ${server_details}    ${ifconfig_name}
    \    Log to console and logfile    ${Ip_output}
    \    Append to list    ${ifconfig_output_list}    ${Ip_output}
    ${temp_list}    Convert To String    ${ifconfig_output_list}

    ${ret}    Get Regexp Matches    ${temp_list}    inet (\\d+.\\d+.\\d+.\\d+)\\s+netmask
    ${match} =    Create List
    ${length1} =    Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length1}
    \    Append To List   ${match}    ${ret[${x}]}
    ${length} =     Get Length  ${match}
    ${Ip_List} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${Ret}    ${match1}    Should Match Regexp    ${match[${x}]}    inet (\\d+.\\d+.\\d+.\\d+)\\s+netmask
    \    Log to console   values ${match[${x}]}
    \    Append To List   ${Ip_List}    ${match1}
    Log to console and logfile    ${Ip_List}
    [Return]    ${Ip_List}

Get Valid Interface List
    [Documentation]    Get the all the interface of the server and return only the required server
    ...             Example:
    ...             Get Valid Interface List    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    [Arguments]    ${ilo_details}    ${server_details}    ${up_interface}    ${down_interface}
    ${ip_adapter}    Get Server IP Linux    ${ilo_details}    ${server_details}
    ${ret}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<BROADCAST
    ${ret_1}    Get Regexp Matches    ${ip_adapter}    \\d+:\\s+(.*):\\s+<NO-CARRIER
    ${Interface_list} =    Create List
    ${length} =     Get Length  ${ret}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${Interface_list}    ${ret[${x}]}
    ${length} =     Get Length    ${Interface_list}
    ${Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${Interface_list[${x}]}    \\d+:\\s+(.*):\\s+<BROADCAST
    \    Log to console   values ${match}
    \    Append To List   ${Adapter_name}    ${match}
    Remove Values From List    ${Adapter_name}    virbr0-nic

    ${Len_of_adapter}    Get Length    ${Adapter_name}
    ${Adapter_list}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter}
    \    ${temp}    Convert To String    ${Adapter_name[${x}]}
    \    Append to list    ${Adapter_list}    ${temp}
    Log to console and logfile    ${Adapter_list}

    ${Len_of_adapter_list}    Get Length    ${Adapter_list}
    :FOR    ${x}    INRANGE    0    ${Len_of_adapter_list}
    \    ${ifup_adapter}    Replace String Using Regexp   ${up_interface}    interface-name    ${Adapter_list[${x}]}
    \    Up the Interface    ${ilo_details}    ${server_details}    ${ifup_adapter}

    ${Non_Interface_list} =    Create List
    ${length} =     Get Length  ${ret_1}
    :FOR    ${x}    IN RANGE    0   ${length}
    \    Append To List   ${Non_Interface_list}    ${ret_1[${x}]}

    ${length} =     Get Length    ${Non_Interface_list}
    ${Non_Adapter_name} =    Create List
    :FOR    ${x}    IN RANGE    0   ${length}
    \    ${ret}    ${match}    Should Match Regexp    ${Non_Interface_list[${x}]}    \\d+:\\s+(.*):\\s+<NO-CARRIER
    \    Log to console   values ${match}
    \    Append To List   ${Non_Adapter_name}    ${match}
    Remove Values From List    ${Non_Adapter_name}    virbr0

    ${Len_of_non_adapter}    Get Length    ${Non_Adapter_name}
    ${Non_Adapter_list}    Create list
    :FOR    ${x}    INRANGE    0    ${Len_of_non_adapter}
    \    ${temp}    Convert To String    ${Non_Adapter_name[${x}]}
    \    Append to list    ${Non_Adapter_list}    ${temp}
    Log to console and logfile    ${Non_Adapter_list}

    ${Len_of_non_adapter_list}    Get Length    ${Non_Adapter_list}
    :FOR    ${x}    INRANGE    0    ${Len_of_non_adapter_list}
    \    ${ifdown_adapter}    Replace String Using Regexp   ${down_interface}    interface-name    ${Non_Adapter_list[${x}]}
    \    Down the Interface    ${ilo_details}    ${server_details}    ${ifdown_adapter}

    [Return]    ${Adapter_list}

Get Valid Server IP
    [Documentation]    Get the only the valid ip of the server
    ...             Example:
    ...             Get Valid Server IP    ${ilo_details}    ${server_details}    ${ifconfig_adapter_name}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifconfig_adapter_name}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifconfig_adapter_name}
    Sleep    10sec
    ${cmd_out}    SSHLibrary.Read
    SSHLibrary.Close All Connections
    [Return]    ${cmd_out}

Down the Interface
    [Documentation]    Disconnect the interface/off the interface inside server
    ...             Example:
    ...             Down the Interface    ${ilo_details}    ${server_details}    ${ifdown_adapter}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifdown_adapter}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifdown_adapter}
    Sleep    15sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections

Up the Interface
    [Documentation]    Up the interface/connect the interface inside server
    ...             Example:
    ...             Up the Interface    ${ilo_details}    ${server_details}    ${ifup_adapter}
    [Arguments]         ${ilo_details}    ${server_details}    ${ifup_adapter}
    SSHLibrary.Open Connection     ${ilo_details['ilo_ip']}     prompt=>     timeout=40s
    ${login}    SSHLibrary.Login    ${ilo_details['username']}     ${ilo_details['password']}
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     stop /system1/oemhp_VSP1
    SSHLibrary.Read Until Prompt
    SSHLibrary.Write     vsp
    Sleep    5sec
    SSHLibrary.Write    ${server_details['username']}
    Sleep    10sec
    SSHLibrary.Write    ${server_details['password']}
    Sleep    10sec
    SSHLibrary.Read Until    ~]#
    SSHLibrary.write    ${ifup_adapter}
    Sleep    10sec
    SSHLibrary.Write    exit
    SSHLibrary.Read Until    localhost login:
    Sleep    5sec
    SSHLibrary.Close All Connections

Get Inpackets and Outpackets
    [Documentation]    Get statistics of Inpackets and Outpackets of the ICM by portname
    [Arguments]    ${ICM_1}    ${stat}    ${uplink_port_name}
    ${icUri}        Get IC URI    ${ICM_1}
    ${ic_uri_statistics} =        catenate    ${icUri}/${stat}/${uplink_port_name}

    ${statistics_data}    Fusion Api Get Interconnect    ${ic_uri_statistics}
    Log to console    \n${statistics_data['commonStatistics']}
    ${In_packets}    Get from Dictionary    ${statistics_data['commonStatistics']}    rfc1213IfInUcastPkts
    ${Out_packets}    Get from Dictionary    ${statistics_data['commonStatistics']}    rfc1213IfOutUcastPkts
    Log to console    ${ICM_1}:${uplink_port_name}
    Log to console    In-packets:${In_packets}
    Log to console    Out-packets:${Out_packets}
    [Return]    ${In_packets}    ${Out_packets}

Validate Lag
    [Documentation]    Validate LAG configuration is present in the server Profile
    [Arguments]    ${count}    ${Connections}
    :For    ${x}    INRANGE    0    ${count}
    \    ${connection}    Copy Dictionary   ${Connections[${x}]}
    \    Dictionary Should Contain Key    ${connection}    lagName
    \    ${value}    Get Variable Value    ${Validate_net['lagName']}
    [Return]    ${value}

Port Affinity Status
    [Documentation]    verify the port affinity status of the interconnect and return the ICM list
    [Arguments]    ${count}    ${Connections}
    ${ICM}    Create List
    :For    ${x}    INRANGE    0    ${count}
    \    ${connection}    Copy Dictionary   ${Connections[${x}]}
    \    Dictionary Should Contain Key    ${connection}    interconnectUri
    \    ${IC_Uri}    Get Variable Value    ${connection['interconnectUri']}
    \    ${IC_resp}    Fusion Api Get Interconnect    uri=${IC_Uri}
    \    ${Fetch_IC_name}    Get Variable Value    ${IC_resp['name']}
    \    Append to List    ${ICM}    ${Fetch_IC_name}

    ${ICM_list}    Remove Duplicates    ${ICM}

    [Return]    ${ICM_list}

Port Affinity MLAG
    [Documentation]    Get the ICM list of the MLAG port affinity status from the server profile
    [Arguments]    ${server_profile_1}    ${server_profile_2}
    ${Profile1_ICM}    Create List
    ${Profile2_ICM}    Create List
    :For    ${x}    INRANGE    0    2
    \    ${server_resp}    Fusion Api Get Server Profiles    param=?filter="'name'=='${server_profile_${x+1}[0]['name']}'"
    \    ${Connections}    Get From Dictionary      ${server_resp['members'][0]['connectionSettings']}      connections
    \    ${Len_of_connections}    Get Length    ${Connections}
    \    ${IC_List}    Port Affinity Status    ${Len_of_connections}    ${Connections}
    \    Append to List    ${Profile${x+1}_ICM}    ${IC_List}
    Log to console and logfile    ${Profile1_ICM}
    Log to console and logfile    ${Profile2_ICM}

    ${Len_of_ICM1_list}    Get Length    ${Profile1_ICM[0]}
    ${Len_of_ICM2_list}    Get Length    ${Profile2_ICM[0]}
    ${ICM}    Create List
    :For    ${x}    INRANGE    0    ${Len_of_ICM1_list}
    \    ${Pro1_ICM_Value}    Get From List    ${Profile1_ICM[0]}    ${x}
    \    Append to list    ${ICM}    ${Pro1_ICM_Value}

    :For    ${x}    INRANGE    0    ${Len_of_ICM2_list}
    \    ${Pro2_ICM_Value}    Get From List    ${Profile2_ICM[0]}    ${x}
    \    Append to list    ${ICM}    ${Pro2_ICM_Value}

    Log to console and logfile    ${ICM}
    ${Final_list_ICM}    Remove Duplicates    ${ICM}
    Log to console and logfile    ${Final_list_ICM}

    [Return]    ${Final_list_ICM}

Get IC and Verify state
    [Documentation]    Get the IC details and verify the interconnect state for each ICM
    [Arguments]    ${IC_Configured}
    ${IC_output}    Fusion Api Get Interconnect
    ${Num_IC}    Get Variable Value    ${IC_output['count']}
    :For    ${x}    INRANGE    0    ${Num_IC}
    \    Wait Until Keyword Succeeds    650s   35 s    Verify Interconnect State    ${IC_output['members'][${x}]['name']}    ${IC_Configured}
    Sleep    50

validate port status reason
    [Documentation]   validate port status reason attribute of the ICM
    ...             Example:
    ...             validate port status reason    ${icm}   ${portname}   ${state}
    [Arguments]   ${icm}   ${portname}   ${state}
    ${ic}=   Get IC URI   ${icm}
    ${resp}=   fusion_api_get_interconnect_ports   uri=${ic}
    :FOR   ${port}  IN   @{resp['members']}
    \    run keyword if  '${port['portName']}' != '${portname}'   Continue For Loop
    \    should match  ${port['portStatusReason']}   ${state}
    \    Log to console and logfile    Port Status ${port['portStatusReason']} matches expected ${state}

Cleanup For Suite
    [Documentation]    Returns appliance to a 'clean' state by removing all resources\enclosures
    Log to console and logfile  [Cleanup]
    Login to OneView via REST
    Power off ALL Servers
    Remove All Server Profiles
    Remove All Logical Enclosures
    Remove ALL Enclosure Groups
    Remove ALL LIGs
    Remove All Network Sets
    Remove ALL Ethernet Networks
    Remove ALL FC Networks