*** Settings ***
Library				RoboGalaxyLibrary
Library				FusionLibrary
Library				OperatingSystem
Library				BuiltIn
Library				Collections
Library		        SSHLibrary
Library				String

#Variables			${DATA}								
Variables			errors.py
Variables			licenses.py

*** Variables ***
${APPLIANCE_IP}     ${None}
${DATA}				data_variables.py
${VM}				${None}
${VMSETUP}			no
${FTS}				no
${CONFIGURE}		no
							
*** Keywords ***
#######################################
# SETUP WORFLOWS - Variables
#######################################
Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	Log to console and logfile  	Adding LICENSES	
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}
	\		Run keyword if 		${resp['status_code']} != ${201}	    Log     Error adding License Key:${license['key']}   WARN

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	Log to console and logfile  	Adding USERS	
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding ETHERNET NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FC NETWORKS	
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding FCOE NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	Log to console and logfile  	Adding NETWORK SETS	
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}		
	\		${nativeNetworkUri} = 	Run Keyword If 	'${net['nativeNetworkUri']}' != 'None'		Get Ethernet URI	${net['nativeNetworkUri']}
	\		Set To Dictionary 	${net}	nativeNetworkUri	${nativeNetworkUri}		
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}
	Log to console and logfile  	Adding RANGES	
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
	\ 	${resp} =	Run Keyword If 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range		body=${range}		
	[Return]	${resp}

Process InterconnectMapTemplate
	[Documentation]    processes the interconnect map template
	[Arguments]		${icmap}
	${l} = 	Get Length	${icmap['interconnectMapEntryTemplates']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	${permittedInterconnectTypeUri} = 	Get Interconnect Type URI	${permittedInterconnectTypeUri}
	\	Set to dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri		${permittedInterconnectTypeUri}
	[Return]	${icmap}

Add LIG from variable
	[Documentation]	Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ligx}
	Log to console and logfile  	Adding LIG ${ligx['name']}
	${ligx} = 	Copy Dictionary	${ligx}

    ${name} =                       Get Variable Value  ${ligx['name']}
	${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${ligx['fcoeSettings']}
	${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
	${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
	${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
	${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
	${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
	#${uplinkSets} = 	Copy List	${ligx['uplinkSets']}

	${l} = 	Get Length	${uplinkSets}
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	    ${networkUris}
	\   ${nativeNetworkUri} = 	Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri	${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}	nativeNetworkUri     ${nativeNetworkUri}

    # Process Internal URIs
	${internalNetworkUris} = 	Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris	${internalNetworkUris}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         fcoeSettings=${fcoeSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}

	${resp} = 	Fusion Api Create LIG	${body}
	${task} =	Wait For Task	${resp} 	60s	2s
	${liguri} = 	Get From Dictionary	${task['associatedResource']}	resourceUri		
	[Return]	${resp}

Add Enclosure Group from variable
	[Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${enc_group}
	Log to console and logfile  	Adding ENCLOSURE GROUP ${enc_group['name']}		
	${l} = 	Get Length	${enc_group['interconnectBayMappings']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${liguri} = 	Get From Dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
	\   Continue For Loop If    '${liguri}' == 'None'
	\	${liguri} = 	Common URI Lookup by name    ${liguri}
	\	Set to dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}	
	${resp} =	Fusion Api Create Enclosure Group	${enc_group}
	[Return]	${resp}

Common URI lookup by name
	[Documentation]	Takes a string containing URI type + : + resource name, performs a lookup and returns URI
	...				Ex:    ${uri} = 	Common Lookup by name	LIG:LIG1
	[Arguments]		${uri}
	@{words} = 	Split String	${uri}	:
	${type} = 	Get From List	${words}	0
	${name} = 	Get From List	${words}	1
	${uri} = 	Run Keyword If 	'${type}' == 'EG'		Get Enclosure Group URI		${name}
	...         ELSE IF         '${type}' == 'ENC'		Get Enclosure URI		    ${name}
	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URI			${name}
	...			ELSE IF			'${type}' == 'FC'		Get FC URI					${name}
	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URI				${name}
	...			ELSE IF			'${type}' == 'LI'		Get LI URI					${name}
	...			ELSE IF			'${type}' == 'LIG'		Get LIG URI					${name}
	...			ELSE IF			'${type}' == 'NS'		Get Network Set URI			${name}
	...			ELSE IF			'${type}' == 'SH'		Get Server Hardware URI		${name}
	...			ELSE IF			'${type}' == 'US'		Get Uplink Set URI			${name}
	...			ELSE			Set variable			ResourceTypeNotFound:${type}

	[Return]	${uri}

Add Enclosures from variable
	[Documentation]	Adds Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${encs}
	Log to console and logfile  	Adding ENCLOSURES 		
	:FOR	${enc}	IN	@{encs}
	\	${encuri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	\	${encuri} = 	Common URI Lookup by name    ${encuri}
	\	Set to dictionary	${enc}	enclosureGroupUri		${encuri}
	\	${resp} =	Fusion Api Add Enclosure 	${enc}
	\	${task} =	Wait For Task	${resp} 	10min	10s

Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}
	Log to console and logfile  	Adding LOGICAL ENCLOSURE
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	${eguri} = 	Common URI Lookup by name    ${eguri}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
	Set to dictionary	${enc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\       ${encuri} = 	Common URI Lookup by name    ${encuri}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${enc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Create Logical Enclosure 	${enc}
	${task} =	Wait For Task	${resp} 	120min	1min


Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}    ${param}=?ignoreServerHealth=true
	Log to console and logfile  	Adding SERVER PROFILES	
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	${uri} = 	Common URI Lookup by name    ${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri 
	\	${uri} = 	Common URI Lookup by name    ${enc}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}	
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}    param=${param}
	\	${task} =   Wait For Task	${resp}		timeout=5 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)

Add Server Profile Templates from variable
	[Documentation]	Adds Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	Log to console and logfile  	Adding SERVER PROFILE TEMPLATES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    Copy Dictionary     ${profile}
	\	${sht} = 	Get from Dictionary	${profile}	serverHardwareTypeUri
	\	${uri} = 	Common URI lookup by name		${sht}
	\	Set to Dictionary	${profile}	serverHardwareTypeUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	${uri} = 	Common URI Lookup by name	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${connections} = 	Get From Dictionary	${profile}	connections
	\	${connections} = 	Lookup Connection Uris	${connections}
	\   Set to Dictionary   ${profile}  connections     ${connections}
	\	${resp} = 	Fusion Api Create Server Profile template		body=${profile}
	\   # TODO: Change timeout!
	\	${task} =   Wait For Task	${resp}		timeout=1 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)


Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	${conns} =  Create List
	:FOR	${connection}	IN	@{connections}
	\   ${connection} =     Copy dictionary     ${connection}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1	
	\	${net} = 	Create List	${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Set to Dictionary	${connection}	networkUri	${uri}
	\   append to list  ${conns}    ${connection}
	[Return]	${conns}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable ALL Generated ID Ranges
	[Documentation]	Enables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Enable Generated VSN Range	${rangeUri}

Enable Generated VMAC Range
	[Documentation]	Enables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VWWN Range
	[Documentation]	Enables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VSN Range
	[Documentation]	Enables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	Log to console and logfile  	Enabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword as user
	[Documentation]		Runs a Fusion_API keyword as a particular user.
	...					Ex:		Run Keyword As User		nat		Fusion Api Get Ethernet Networks	${empty}	param=?filter="'name'=='net_101'"
    [Arguments]     ${user}     ${keyword}      @{varargs}
    ${original_user} =   Fusion Api Get Active user
	${active_sessions} = 	Fusion Api Get Active Sessions
	Dictionary Should Contain Key	${active_sessions}	${user}
    Fusion Api Switch Active User   ${user}
    ${resp} =   Run Keyword and continue on failure     ${keyword}  @{varargs}
    Fusion Api Switch Active User   ${original_user}
    [Return]    ${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument
	[Arguments]	${list}	${keyword}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}	${x}
		
#######################################
# COMMON KEYWORDS
#######################################
Build LIG body
	[Documentation]    builds LIG body
	[Arguments]		${xlig}
	${xlig} = 	Copy Dictionary	${xlig}
	${uplinkSets} = 	Copy List	${xlig['uplinkSets']}
	${l} = 	Get Length	${uplinkSets}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	${name} =                       Get Variable Value  ${xlig['name']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
	${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
	${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
	${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	#${uplinkSets} =                 Get Variable Value  ${xlig['uplinkSets']}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         fcoeSettings=${fcoeSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
    [Return]    ${body}

Build US body
	[Documentation]    builds US body
	[Arguments]		${us}	${li_uri}
	Set to dictionary	${us}	logicalInterconnectUri	${li_uri}
	${l} = 	Get Length	${us['portConfigInfos']}
	:FOR	${x}	IN RANGE	0	${l}
	\   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}	enclosure
	\   ${enc_uri} =        Get Enclosure Uri   ${enc_uri}
	\	Set To Dictionary		${us['portConfigInfos'][${x}]}	enclosure	${enc_uri}

	# process eth
	${networks} = 		Get From Dictionary		${us}	networkUris
	${networkUris} = 	Get Ethernet Uris	${networks}
	Set to dictionary	${us}	networkUris	${networkUris}
	# process fc
	${networks} = 		Get From Dictionary		${us}	fcNetworkUris
	${networkUris} = 	Get FC Uris	${networks}
	Set to dictionary	${us}	fcNetworkUris	${networkUris}
	# process fcoe
	${networks} = 		Get From Dictionary		${us}	fcoeNetworkUris
	${networkUris} = 	Get FCoE Uris	${networks}
	Set to dictionary	${us}	fcoeNetworkUris	${networkUris}

	${body} = 		Fusion Api Create Uplink Set Payload	${us}
	[Return]	${body}

Create Network Set range
	[Documentation]    creates the network set range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding NETWORK SET RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end
	${netlist} = 	Create List
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Append To List	${netlist}	${range['prefix']}${x}${range['suffix']}
	${networkUris} = 	Get Ethernet URIs	${netlist}
	Set To Dictionary 	${body}	networkUris	${networkUris}
	${nativeNetworkUri} = 	Run Keyword If 	'${range['nativeNetworkUri']}' != 'None'  Get Ethernet URI	${range['nativeNetworkUri']}
	Set To Dictionary 	${body}	nativeNetworkUri	${nativeNetworkUri}
	${resp} = 	Fusion Api Create Network Set		body=${body}
	[Return]	${resp}

Create Ethernet range
	[Documentation]    creates the ethernet range
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding ETHERNET NETWORK RANGES
	${body} = 	Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end

	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Set To Dictionary 	${body}	name	${range['prefix']}${x}${range['suffix']}
	\	Set To Dictionary 	${body}	vlanId	${x}
	\	${resp} = 	Fusion Api Create Ethernet Network	body=${body}

Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	Set Log Level	TRACE
	Log to console and logfile  	Adding FCOE NETWORK RANGES
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-networkV300
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\	Wait For Task	${resp}

Get connectionTemplateUri
	[Documentation]	Retrieves the connectionTemplateUri from a given network {name} of a given {type} where:
	...             {name} is the name of the network
	...             {type} is the type of network: [ethernet, fc, fcoe], default=ethernet
	...             Returns: connectionTemplateUri string
	[Arguments]		${name}   ${type}=ethernet
    Set Log Level	DEBUG
    ${param} =      Set Variable    ?filter="'name'=='${name}'"
	${net} =		Run Keyword If          '${type}' == 'ethernet'      Fusion Api Get Ethernet Networks    param=${param}
	...             ELSE IF                 '${type}' == 'fc'            Fusion Api Get fc Networks          param=${param}
    ...             ELSE IF                 '${type}' == 'fcoe'          Fusion Api Get fcoe Networks        param=${param}
    ...             ELSE                    Log     Invalid network type specified for 'Get connectionTemplateUri'     WARN
	${ct_uri} =     Get From Dictionary      ${net['members'][0]}    connectionTemplateUri

    [Return]    ${ct_uri}

Get Enclosure URI
	[Documentation]    gets the enclosure uri from the rest call output
	[Arguments]		${enc}
	${resp} = 	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Enclosure Group URI
	[Documentation]    gets the enclosure group uri from the rest call
	[Arguments]		${eg}
	${resp} = 	Fusion Api Get Enclosure Groups	
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}		
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${eg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri	
	[Return]	${uri}

Get Ethernet URI
	[Documentation]    gets the ethernet uri from the rest call
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}
	
Get Ethernet URIs
	[Documentation]    gets the ethernet uris from the rest call
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}	

Get FC URI
	[Documentation]    gets the fc uri from the rest call
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FC URIs
	[Documentation]    gets the fc uris from the rest call
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get FCoE URI
	[Documentation]    gets the fcoe uri from the rest call
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FCoE Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FCoE URIs
	[Documentation]    gets the fcoe uris from the rest call
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\   ${val} =     Get substring  ${net}  1   5
	\	Run Keyword If			  '${val}' == 'rest'	Append To List	${urilist}	${net}
	\   Continue For Loop If	  '${val}' == 'rest'
	\	${resp} = 	Fusion Api Get Fcoe Networks		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get IC URI
	[Documentation]    gets the ic uri from the rest call
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Get Interconnect Type URI
	[Documentation]    gets the ic type uri from the rest call
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect Types 		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LI member
	[Documentation]    gets the li members from the rest call
	[Arguments]		${li}
	${resp} = 	    Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${member} = 	Get From List		${resp['members']}  ${x}
	[Return]	${member}

Get LI URI
	[Documentation]    gets the li uri from the rest call
	[Arguments]		${li}
	${resp} = 	Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LIG member
	[Documentation]    gets the lig member from the rest call
	[Arguments]		${lig}
	${resp} = 	    Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${member} = 	Get From List		${resp['members']}  0
	[Return]	${member}

Get LIG URI
	[Documentation]    gets the lig uri from the rest call
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri	
	[Return]	${uri}

Get Network Set URI
	[Documentation]    gets the network set uri from the rest call
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Network Set URIs
	[Documentation]    gets the network set uris from the rest call
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Resource by URI
	[Documentation]    Returns any type of resource using its URI
	[Arguments]	${uri}   @{varargs}
    ${resp} =     Fusion Api Get Resource    ${uri}    @{varargs}
	[Return]    ${resp}

Get Server Hardware URI
	[Documentation]    gets the server hardware uri from the rest call
	[Arguments]		${enc_server}
	${resp} = 	Fusion Api Get Server Hardware
	${shlist} = 	Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} = 	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} = 	Get From dictionary 	${sh}	uri
	[Return]	${uri}

Get Server Hardware Type URI
	[Documentation]    gets the server hardware type uri from the rest call
	[Arguments]		${sht}
	Set Log Level	TRACE
	${resp} = 	Fusion Api Get Server Hardware Types    param=?filter="'name'=='${sht}'"
	${uri} = 	Get From dictionary 	${resp['members'][0]}	uri
	[Return]	${uri}


Get Uplinkset URI
	[Documentation]    gets the uplinkset uri from the rest call
	[Arguments]		${us}
	${resp} = 	Fusion Api Get Uplink Set 		param=?filter="'name'=='${us}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}


Log to console and logfile
	[Documentation]    logs the given message to the console and logfile
	[Arguments]	${data}     ${level}=INFO
	Log	${data}     ${level}
	Log to console	${data}
	
Wait For Task
	[Documentation]	Waits for a task to reach an end-state
	[Arguments]		${resp}	${timeout}=60 s	${interval}=2 s
	Log to console	\n
	${task} = 	Wait Until Keyword Succeeds		${timeout}	${interval}	Task Reached Endstate	${resp}
	[Return]	${task}
	
Task Reached Endstate
	[Documentation]	Waits for a task to reach and checks end-state
	[Arguments]	${resp}
	Set Log Level	TRACE
	#Should Contain	${resp}	uri
	${location} =       Get Variable Value      ${resp['headers']['location']}
	${task_uri} =		Run Keyword If          '${location}' is 'None'      Get From Dictionary		${resp}	uri
	...                 ELSE                    Get Variable Value          ${location}

    # Hack for backup task uri that contains https://IP in error
    ${task_uri} =       Remove String           ${task_uri}    https://    ${APPLIANCE_IP}
	${task} = 			Fusion Api Get Task		uri=${task_uri}
	${task_state} = 	Get From Dictionary		${task}		taskState
	${task_category} = 	Get From Dictionary		${task}		category
	${task_name} = 		Get From Dictionary		${task}		name
	${resource} = 		Get From Dictionary		${task['associatedResource']}	resourceName
	${resource_uri} = 	Get From Dictionary		${task['associatedResource']}	resourceUri
	Log to console and logfile  	\t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
	Should Match Regexp	${task_state}	((?i)Warning|Unknown|Terminated|Killed|Error|Completed)	
	[Return]	${task}

Wait For Appliance To Be Ready
	[Documentation]	Waits for an appliance reach a the ready state
	[Arguments]		${appliance}	${timeout}=20 min	${interval}=30 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance Reached Ready State	${appliance}	

Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	Log to console and logfile 		Pinging: ${appliance} ...
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance is pingable 	${appliance}	

Appliance is pingable
	[Documentation]    checks if the appliance is pinging 
	[Arguments]		${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	Windows ping	${appliance}
	...	ELSE	Unix ping	${appliance}

Unix ping
	[Documentation]    ping in the unix environment
	[Arguments]		${host}
    ${Output}=    Run    ping -c 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
	[Return]	${Output}
	
Windows ping
	[Documentation]    ping in the windows environment
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    Log to console and logfile    ${Output}
    Should Contain    ${Output}    TTL=
	[Return]	${Output}
		
Appliance Reached Ready State
	[Documentation]    checks whether the appliance reached ready state
	[Arguments]		${appliance}
	${state} = 	Fusion Api Get Resource		${appliance}/controller-state.json
	Log to console and logfile	-Appliance state: ${state['state']}
	Should Match Regexp	${state['state']}	((?i)OK)
	
First Time Setup
	[Documentation]	Changes intial administrator password, answers EULA, enables service access, adds licenses, configures appliance interfaces.
	...	If args are null, uses XML ${DATAFILE}
	[Arguments]	${DATAFILE}=${null}	${password}=${null}	${interfaces}=${null}
	#${password} =	Set Variable	${password}
	Log to console and logfile	[FIRST TIME SETUP]
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}		
	Wait For Appliance To Be Ready			${APPLIANCE_IP}
	Log to console and logfile	-Agree to EULA	
	Fusion Api Save EULA	${APPLIANCE_IP}
	Log to console and logfile	-Enable service access
	Fusion Api Set service access	${APPLIANCE_IP}

	${req} = 		Create Dictionary		newPassword=${password}
	...										oldPassword=admin
	...										userName=Administrator
	#Run Keyword If	${password} is not ${null}	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	#Add licenses from variable		${licenses}
	Configure Appliance Interfaces	
	
Configure Appliance Interfaces
	[Documentation]    configures the interfaces for appliances
	Log to console and logfile	-Configuring Appliance Interfaces, Time, Locale
	${resp} =	Fusion Api Get Appliance Interface Mac	eth0
	Set to dictionary	${appliance['applianceNetworks'][0]}	macAddress	${resp}	
	${ipv4Type} = 		Get Variable Value 	${appliance['applianceNetworks'][0]['ipv4Type']}
	${app1Ipv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['app1Ipv4Addr']}
    ${virtIpv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['virtIpv4Addr']}
	Sleep 	10s			
	${resp} = 	Fusion Api Configure Appliance Interfaces			${appliance}
	# if STATIC, get new IP and login. for 2.00, use virtIpv4Addr (Tbird), otherwise use app1Ipv4Addr
    Run Keyword If	'${virtIpv4Addr}' is not 'None'     			Set New IP and Login	${virtIpv4Addr}
	...             ELSE IF     '${app1Ipv4Addr}' is not 'None'     Set New IP and Login	${app1Ipv4Addr}
	...             ELSE    Log     Either app1Ipv4Addr or virtIpv4Addr must be provided in the 'appliance' variable in your data file     WARN

	Wait For Task	${resp}		timeout=200s		interval=5s
	${resp} = 	Fusion Api Configure Appliance Time and Locale			${timeandlocale}
	Wait For Task	${resp}		timeout=200s		interval=5s
	
Set New IP and Login
	[Documentation]    sets new ip and login to the appliance
	[Arguments]	${IP}
	Set Suite Variable		${APPLIANCE_IP}	${IP}
	Sleep 	60s	
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}			
	
Login all users
	[Documentation]    login for all users
	[Arguments]     ${users}
	Set Log Level	TRACE
	${original_user} =    Fusion Api Get Active User
	:FOR	${user}	IN	@{users}
	\	${user_and_pass} = 	Create Dictionary	userName=${user['userName']}	password=${user['password']}
	\	Fusion Api Login Appliance 		${APPLIANCE_IP}		${user_and_pass}
	Fusion api switch active user    user=${original_user}


# -----------------------------------------------------------------------------
#   EM KEYWORDS
# -----------------------------------------------------------------------------
Get EM IP
	[Documentation]    gets the em ip
	Set Log Level	TRACE
    # Get EM IP
    # TODO:  going to need to see how this works with multiple EM's
    ${EM_IP} =  Execute SSH Command     lldpcli show neighbors
    ${m}    ${EM_IP} =  Should Match Regexp     ${EM_IP}    (?im)MgmtIP:\\s*(\\S*:\\S*:\\S*:\\S*:\\S*:\\S*)
    Set Suite Variable    ${EM_IP}
    log to console     EM IP: ${EM_IP}
    [Return]    ${EM_IP}

Get EM Enclosures
	[Documentation]    gets the em enclosures
    # Get EM enclosures
    ${EM_ENCS} =   Execute SSH Command     /ci/bin/tbird/appliance-hal.sh list-enclosures
    @{ignore last} =     Split to lines  ${EM_ENCS}  ${null}   -1
    ${EM_ENCS} =        Create List     @{ignore last}
    Set Suite Variable    ${EM_ENCS}
    log to console     Enclosures: ${EM_ENCS}
    [Return]    ${EM_ENCS}

Get EM Token
	[Documentation]    gets the em token
    [Arguments]     ${enc_serial}
    # Get EM token
    ${EM_TOKEN} =  Execute SSH Command     /ci/bin/tbird/appliance-hal.sh get-enclosure-credentials -s ${enc_serial} -o token
    ${EM_TOKEN}    Should Match Regexp    ${EM_TOKEN}    (?i)\\S*
    Set Suite Variable    ${EM_TOKEN}   ${EM_TOKEN}
    log to console     EM TOKEN: ${EM_TOKEN}
    [Return]    ${EM_TOKEN}

Get EM Sessions
	[Documentation]    gets the em sessions
    # Get Sessions using session Id to test that everything is working
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Output}    Execute SSH Command
    ...    curl -ikX GET https://${EM_IP}%${FUSION_NIC}/rest/v1/Sessions -H ${Header}
    Should Contain    ${Output}    "Name": "Sessions Collection"
    ...    msg=Get Sessions action failed \n${Output}

EFuse ICM
    [Documentation]    Perform an efuse action on a ICM bay. Action = EFuseOff | EFuseOn
    [Arguments]    ${Action}    ${BayNumber}
    ${Header}    Set Variable    "X-Auth-Token":"${EM_TOKEN}"
    ${Data}      Set Variable    {"Action":"${Action}"}
	Log to console and logfile  	\t Issuing ${Action} for ICM:${BayNumber}
    ${Output}    Execute SSH Command
    ...    curl -ikX POST -H ${Header} --data-ascii '${data}' https://${EM_IP}%${FUSION_NIC}/rest/v1/InterconnectBays/${BayNumber}
    Should Contain    ${Output}    { "Action": "${Action}" }
    ...    msg=EFuse action failed \n${Output}

IC reached state
	[Documentation]    checks whether the ic reached ready state
	[Arguments]	    ${uri}  ${state}
	Set Log Level	TRACE
    ${resp} =   fusion api get resource     ${uri}
	Log to console and logfile  	\t ${uri}: ${resp['state']}
	Should Match Regexp 	${resp['state']}    ${state}
	[Return]	${resp}

Get IC
	[Documentation]    gets IC data
    ${resp} =   fusion api get interconnect
    ${ic_list} =    Create List
    ${ics} =     Get From Dictionary     ${resp}    members
	${l} = 	Get Length	${ics}
	:FOR	${x}	IN RANGE	0	${l}
    \   ${ic} =     Get From List   ${ics}    ${x}
	\ 	Run Keyword If 	'${ic['model']}' != '${ICM_MODEL}'		Continue For Loop
	\   Append to list      ${ic_list}  ${ic}
	[Return]    ${ic_list}

Get from IC
	[Documentation]    gets data from IC
    [Arguments]     ${ic}   ${element}
    ${return} =     Get From Dictionary     ${ic}   ${element}
    [Return]    ${return}

# -----------------------------------------------------------------------------
#   FUSION BASH SHELL INTERFACE KEYWORDS
# -----------------------------------------------------------------------------
Login to Fusion via SSH
    [Documentation]             Connect to Fusion VM Bash via SSH
    ...                         Example:\n| Login to Fusion Via SSH | 10.0.12.106 | Administrator | hpvse123 |
    [Arguments]                 ${IP}=${FUSION_IP}      ${USERNAME}=${FUSION_SSH_USERNAME}
    ...                         ${PASSWORD}=${FUSION_SSH_PASSWORD}    ${PROMPT}=${FUSION_PROMPT}
    ...                         ${TIMEOUT}=${FUSION_TIMEOUT}    ${ALIAS}=Fusion_SSH
    Log Many                    ${IP}                   ${USERNAME}     ${PASSWORD}     ${PROMPT}   ${TIMEOUT}
    Set Default Configuration   prompt=${PROMPT}        timeout=${TIMEOUT}
    ${Id}=                      Open Connection         ${IP}    alias=${ALIAS}
    ${Output}=                  Login                   ${USERNAME}     ${PASSWORD}
    [Return]                    ${Id}

Logout of Fusion Via SSH
    [Documentation]     Exits the current Bash SSH session
    ...                 Example:\n| Logout Of Fusion Via SSH |
    Close Connection

Execute SSH Command
    [Documentation]     Executes given command on the Fusion SSH shell
    ...                 Example:\n| Execute CLI Command | show enclosure list |
    [Arguments]         ${Command}      ${PROMPT}=${FUSION PROMPT}
    Login to Fusion via SSH
    SSHLibrary.Write    ${Command}
    ${Output}=          Read until      ${PROMPT}
    Logout of Fusion Via SSH
    [Return]            ${Output}



#######################################
# TEARDOWN WORFLOWS
#######################################
Suite Teardown
	[Documentation]	Returns appliance to a 'clean' state by removing all resources\enclosures
	Log to console and logfile	[TEARDOWN]
	#
	Run Keyword If All Tests Passed    Power off ALL Servers
	Run Keyword If All Tests Passed    Remove All Server Profiles
	Run Keyword If All Tests Passed    Remove ALL Enclosures
	Run Keyword If All Tests Passed    Remove ALL Enclosure Groups
	Run Keyword If All Tests Passed    Remove ALL LIGs
	Run Keyword If All Tests Passed    Remove ALL Ethernet Networks
	Run Keyword If All Tests Passed    Remove ALL FC Networks
	Run Keyword If All Tests Passed    Remove ALL FCoE Networks
	Run Keyword If All Tests Passed    Remove ALL Network Sets
	Run Keyword If All Tests Passed    Remove ALL Users

Remove All Enclosures
	[Documentation]	Querys the appliance for all Enclosures and then removes them
	Log to console and logfile  	Removing ENCLOSURES	
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} = 	   Fusion Api Remove Enclosure		uri=${enc['uri']}
	\		${task} =	   Wait For Task 	${resp} 	240s	10s
	\       ${val} =       Create Dictionary   taskState=Completed
	\       ${result} =    Validate Response    ${task}	${val}

Remove All Enclosure Groups
	[Documentation]	Querys the appliance for all Enclosure Groups and then removes them
	Log to console and logfile  	Removing ENCLOSURE GROUPS	
	${encs} = 	Fusion Api Get Enclosure Groups
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} = 	Fusion Api Delete Enclosure Group		uri=${enc['uri']}

Remove All Ethernet Networks
	[Documentation]	Querys the appliance for all Ethernet networks and then removes them
	Log to console and logfile  	Removing ETHERNET NETWORKS	
	${networks} = 	Fusion Api Get Ethernet Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Ethernet Network		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All FC Networks
	[Documentation]	Querys the appliance for all FC networks and then removes them
	Log to console and logfile  	Removing FC NETWORKS	
	${networks} = 	Fusion Api Get FC Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FC Network		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All FCoE Networks
	[Documentation]	Querys the appliance for all FCoE networks and then removes them
	Log to console and logfile  	Removing FCoE NETWORKS	
	${networks} = 	Fusion Api Get FCoE Networks
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete FCoE Network		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All LIGs
	[Documentation]	Querys the appliance for all LIGs and then removes them
	Log to console and logfile  	Removing LIGS	
	${ligs} = 	Fusion Api Get LIG
	:FOR	${lig}	IN	@{ligs['members']}
	\		${resp} = 	Fusion Api Delete LIG		uri=${lig['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Remove All Network Sets
	[Documentation]	Querys the appliance for all Network Sets and then removes them
	Log to console and logfile  	Removing NETWORK SETS	
	${networks} = 	Fusion Api Get Network Set
	:FOR	${net}	IN	@{networks['members']}
	\		${resp} = 	Fusion Api Delete Network Set		uri=${net['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	2s

Power off ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them off
	Log to console and logfile  	Powering off SERVERS	
	${body} = 	Create Dictionary	powerState=Off
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	5s

Power on server
	[Arguments]     ${server}
	[Documentation]	Querys the appliance for a server by name and then Powers it on
	Log to console and logfile  	Powering on ${server}
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${s}	IN	@{servers['members']}
	\       Continue For Loop If	  '${s['name']}' != '${server}'
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${s['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	10s

Power on ALL servers
	[Documentation]	Querys the appliance for all Servers and then Powers them on
	Log to console and logfile  	Powering On SERVERS	
	${body} = 	Create Dictionary	powerState=On
	...								powerControl=MomentaryPress
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='Off' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	5s

powerControl=MomentaryPress
	[Documentation]    momentary presses the server
	${servers} = 	Fusion Api Get Server Hardware
	:FOR	${server}	IN	@{servers['members']}
	\		Continue For Loop If	'${server['powerState']}'!='On' 	
	\		${resp} = 	Fusion Api Edit Server Hardware Power State		body=${body}	uri=${server['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	5s
	
Remove All Server Profiles
	[Documentation]	Querys the appliance for all Server Profiles and then removes them
	Log to console and logfile  	Removing SERVER PROFILES	
	${profiles} = 	Fusion Api Get Server Profiles  param=?sort=name:ascending
	:FOR	${profile}	IN	@{profiles['members']}
	\		${resp} = 	Fusion Api Delete Server Profile		uri=${profile['uri']}
	\		${task} =	Wait For Task 	${resp} 	240s	10s

Remove Custom Range
	[Documentation]	Querys the appliance for all CUSTOM vmac, vwwn, vsn ranges and then removes them
	[Arguments]		${uri}
	Log to console and logfile  	Removing CUSTOM RANGES
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'     Remove VWWN Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	    Remove VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	    Remove VMAC Range	${rangeUri}

Remove VMAC Range
	[Documentation]	Removes a CUSTOM VMAC range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VMAC Range	uri=${uri}

Remove VWWN Range
	[Documentation]	Removes a CUSTOM VWWN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VWWN Range	uri=${uri}

Remove VSN Range
	[Documentation]	Removes a CUSTOM VSN range
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${resp} = 	Run Keyword If 	'${rangeCategory}'=='Custom'     Fusion Api Delete VSN Range	uri=${uri}

Remove All Users
	[Documentation]	Querys the appliance for all Users and then removes them
	Log to console and logfile  	Removing USERS	
	${users} = 	Fusion Api Get User
	:FOR	${user}	IN	@{users['members']}
	\		Continue For Loop If	'${user['userName']}'=='Administrator' 	
	\		Continue For Loop If	'${user['userName']}'=='administrator' 	
	\		${resp} = 	Fusion Api Remove User		uri=${user['uri']}
		
#######################################
# VALIDATION
#######################################
New Validate Response
    [Documentation]	Validates data in a response body against expected values using REGEX
    ...	looks up ${validation_code} in codes dicitonary
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation_code}
	Set Log Level	TRACE
	${validation} = 	Get From Dictionary	${codes}	${validation_code}
	${validation_results} = 	Fusion Api Validate Response	${resp}	${validation}
	# Log results	
	# Fail if results['passed'] is False
	[Return]	${validation_results}
	
Validate Response
    [Documentation]	Validates data in a response body against expected values
    ...	Example:
    ...	${rc} = 		Convert to Integer	400
	...	${valDict} = 	Create Dictionary	status_code=${rc}
	...										errorCode=CRM_DUPLICATE_NETWORK_NAME
	...	Validate Response	${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE	
	${response} = 	Copy Dictionary	${resp}	
	@{vkeys} =	Get Dictionary Keys	${validation}
	${rkeys} =	Get Dictionary Keys	${response}
	@{keys} =	Remove all the keys in response that are not in validation	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{keys}
	\	Remove From Dictionary	${response}	${x}
	Dictionaries Should Be Equal	${validation}	${response}	msg=Response does not match validation dictionary	values=True

Validate Response Regex
    [Documentation]	Validates data in a response body against expected values using regex
    ...    Make sure to escape your pattern strings properly!
    ...    Example:
	...    ${valDict} = 	Create Dictionary	status_code=${200}
	...                                     taskState=Error
	...									    taskStatus=Invalid uplink-set: Port: \\d+ for interconnect-type: .* is not an uplink port.
	...    Validate Response Regex		${respDict}	${valDict}
	[Arguments]    ${resp}	${validation}
	Set Log Level	TRACE
	${response} =   Copy Dictionary    ${resp}
	@{vkeys} =      Get Dictionary Keys    ${validation}
	:FOR	${x}	IN	@{vkeys}
	\   ${r} =    Convert to string    ${resp['${x}']}
	\   ${v} =    Convert to string    ${valDict['${x}']}
	\   Should Match Regexp		       ${r}   ${v}

Remove all the keys in response that are not in validation
	[Documentation]    removes all the keys in response that are not in validation
	[Arguments]	${vkeys}	${rkeys}
	:FOR	${x}	IN	@{vkeys}
	\	Remove Values From List	${rkeys}	${x}
	[Return]	${rkeys}

#######################################
# VM
#######################################

VM setup and FTS
	[Documentation]    VM setup and FTS
	[Arguments]		${VM}
	Log to console and logfile	[VM SETUP]
	Run Keyword If 	'${VMSETUP}' == 'yes'	VM setup		${VM}
	Get VM IP	${VM}
	Run Keyword If 	'${FTS}' == 'yes'		First Time Setup	password=hpvse123

Get VM IP
	[Documentation]    gets the VM ip
	[Arguments]		${VM}
    # Skip looking up IP from vCenter if IP provided via command line\suite variable
	Return from Keyword If	'${APPLIANCE_IP}' is not 'None'

	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Retrieving IPv4 Address for ${VM}
	${IPS} = 	Get VM IPv4 Addresses	${VM}
	${APPLIANCE_IP} = 	Get From List	${IPS}	0
	Log to console and logfile	- Found ${APPLIANCE_IP}
    Set Suite Variable		${APPLIANCE_IP}	${APPLIANCE_IP}

VM setup
	[Documentation]    vm setup
	[Arguments]		${VM}
	Set Log Level	TRACE
	Log to console and logfile	- Connecting to vCenter ${vcenter['server']}
	${resp} = 	Connect to VI Server	${vcenter['server']}	${vcenter['user']}	${vcenter['password']}
	Log to console and logfile	- Creating snapshot for ${VM}
	Create VM Snapshot	${VM}	oob-snapshot	True	True
	Log to console and logfile	- Powering on ${VM}
	Power On VM 	${VM}
	Log to console and logfile	- Sleeping 2 min while ${VM} boots ...
	Sleep	2 min

#######################################
#######################################
# LOGGING
#######################################
Open Connection And Log In
    [Documentation]    ssh connection opens and to login
    [Arguments]         ${SSH_HOST}=localhost   ${SSH_USER}=root
    Open Connection     ${SSH_HOST}     timeout=180s
    Run Keyword If	    '${SSH_PASS}' is ${null}      Set Suite variable  ${SSH_PASS}     hpvse1
    Login               ${SSH_USER}     ${SSH_PASS}

Get Latest Log
	[Documentation]	getting the latest log from the snmp client machine	
   [Arguments]      ${LOG}=/ci/logs/ciDebug.*
   ${LATEST_LOG_FILE}=  Execute Command  ls \-r ${LOG} | head \-1
   [return]  ${LATEST_LOG_FILE}

Get Dump File Content
	[Documentation]    getting the dump file content
   [Arguments]    ${LATEST_LOG_FILE}
   ${Content}=    Execute Command    cat ${LATEST_LOG_FILE}
   [return]    ${Content}

Write To ciDebug Log
    [Documentation]    This example uses ssh to write out to the latest
    ...                ciDebug on on the OV appliance.
    [Arguments]	       ${TEXT_TO_LOG}=[${SUITE_NAME}:${TEST_NAME}]      ${SSH_HOST}=${APPLIANCE_IP}
    Open Connection And Log In      ${SSH_HOST}
    ${LOG}=  Get Latest Log
    ${rc}=    Execute Command    echo "\n#### ${TEXT_TO_LOG}\n" >> ${LOG}     return_stdout=False    return_rc=True
    Should Be Equal    ${rc}    ${0}
    Close All Connections

#######################################
# OA CLI Commands
#######################################
OA CLI EFUSE
    [Documentation]    issues an EFUSE Action to the given Device\Bay.
    ...   {DEVICE} = <BLADE|IOM|NETTRAY|SWM|FAN|OA|EM>
    ...   {BAY} = desired bay for given device
    ...   {ACTION} = <ON|OFF>
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}    ${ACTION}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    ++diag--
    Read Until    diag>
    Write    efuse ${DEVICE} ${BAY} ${ACTION}
    Write    q
    Close All Connections

OA CLI POWERON
    [Documentation]    issues an POWERON command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWERON ${DEVICE} ${BAY}
    Close All Connections

OA CLI POWEROFF
    [Documentation]    issues an POWEROFF command to the given Device\Bay.
    ...   {DEVICE} = <SERVER | INTERCONNECT>
    ...   {BAY} = desired bay for given device  { ALL | <bay number> [{ , | - } <bay number>]}
    [Arguments]	       ${OA_HOST}    ${OA_USER}		${OA_PASS}    ${DEVICE}    ${BAY}
    Open Connection     ${OA_HOST}     prompt=OA-    timeout=10s
    Login               ${OA_USER}     ${OA_PASS}
    Write    POWEROFF ${DEVICE} ${BAY}
    Close All Connections
