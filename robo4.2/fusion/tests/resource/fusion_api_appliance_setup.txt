*** Settings ***
Library				RoboGalaxyLibrary
Library				FusionLibrary
Library				OperatingSystem
Library				BuiltIn
Library				Collections
Library		        SSHLibrary
Library				String
Library             copy
*** Variables ***
${APPLIANCE_IP}     ${None}

*** Keywords ***
#######################################
# SETUP WORFLOWS - Variables
#######################################
Copy Dictionary
	[Documentation]   Override the Builtin.Copy Dictionary with deep copy
	[Arguments]	${obj}
	Log        Deep copy version!!!
	${obj} =   copy.deepcopy   ${obj}
    [Return]	${obj}

Add Licenses from variable
	[Documentation]	Adds licenses to an appliance from a variable which contains the license keys
	[Arguments]		${licenses}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding LICENSES
	:FOR	${license}	IN	@{licenses}
	\		${resp} = 	Fusion Api Add License		key=${license['key']}
	\		Run keyword if 		${resp['status_code']} != ${201}	    Log     Error adding License Key:${license['key']}   WARN

Add Racks from variable
	[Documentation]	Adds racks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${racks}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding Racks
	:FOR	${rack}	IN	@{racks}
	\		${resp} = 	Fusion Api Add Rack		body=${rack} 

Add Users from variable
	[Documentation]	Adds users to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${users}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding USERS
	:FOR	${user}	IN	@{users}
	\		${resp} = 	Fusion Api Add User		body=${user}

Add Ethernet Networks from variable
	[Documentation]	Adds Ethernet networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding ETHERNET NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create Ethernet Network		body=${net}

Add FC Networks from variable
	[Documentation]	Adds FC networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding FC NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FC Network		body=${net}

Add FCoE Networks from variable
	[Documentation]	Adds FCoE networks to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding FCOE NETWORKS
	:FOR	${net}	IN	@{networks}
	\		${resp} = 	Fusion Api Create FCoE Network		body=${net}

Add Network Sets from variable
	[Documentation]	Adds Network sets to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${networks}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding NETWORK SETS
	:FOR	${net}	IN	@{networks}
	\		${networkUris} = 	Get Ethernet URIs	${net['networkUris']}
	\		Set to dictionary	${net}	networkUris	${networkUris}
	\		${nativeNetworkUri} = 	Run Keyword If 	'${net['nativeNetworkUri']}' != 'None'		Get Ethernet URI	${net['nativeNetworkUri']}
	\		Set To Dictionary 	${net}	nativeNetworkUri	${nativeNetworkUri}
	\		${resp} = 	Fusion Api Create Network Set		body=${net}
	[Return]	${resp}

Add Ranges from variable
	[Documentation]	Adds Ranges to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${ranges}   ${status_code}=${200}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding RANGES
	:FOR	${range}	IN	@{ranges}
	\	${category} = 	Get From Dictionary 	${range}	category
	\ 	${resp} = 	Run Keyword If 	'${category}' == 'id-range-VWWN'	Fusion Api Create VWWN Range	body=${range}
        \       ...                    ELSE IF 	'${category}' == 'id-range-VMAC'	Fusion Api Create VMAC Range	body=${range}
	\ 	...                    ELSE IF 	'${category}' == 'id-range-VSN'		Fusion Api Create VSN Range	body=${range}
        \       ...                    ELSE   Log     Invalid or unsupported category was found from range dictionary (category: ${category}).   WARN
	\	Run Keyword If 		${resp['status_code']} != ${status_code}	Log     Failed adding ranges for category ${category}   WARN
	[Return]	${resp}

Process InterconnectMapTemplate
    [Documentation]    Process InterconnectMapTemplate
	[Arguments]		${icmap}
	${l} = 	Get Length	${icmap['interconnectMapEntryTemplates']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${permittedInterconnectTypeUri} = 	Get From Dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri
	\	${permittedInterconnectTypeUri} = 	Get Interconnect Type URI	${permittedInterconnectTypeUri}
	\	Set to dictionary	${icmap['interconnectMapEntryTemplates'][${x}]}	permittedInterconnectTypeUri		${permittedInterconnectTypeUri}
	[Return]	${icmap}

Add LIG from variable
	[Documentation]	Adds an LIG to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ligx}    ${timeout}=60s    ${interval}=2s
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding LIG ${ligx['name']}
	${ligx} = 	fusion_api_appliance_setup.Copy Dictionary	${ligx}

    ${name} =                       Get Variable Value  ${ligx['name']}
	${enclosureIndexes} =           Get Variable Value  ${ligx['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${ligx['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${ligx['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${ligx['fcoeSettings']}
	${internalNetworkUris} =        Get Variable Value  ${ligx['internalNetworkUris']}
	${interconnectBaySet} =         Get Variable Value  ${ligx['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${ligx['interconnectMapTemplate']}
	${qosConfiguration} =           Get Variable Value  ${ligx['qosConfiguration']}
    ${redundancyType} =             Get Variable Value  ${ligx['redundancyType']}
	${stackingMode} =               Get Variable Value  ${ligx['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${ligx['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${ligx['snmpConfiguration']}
	${uplinkSets} =                 Get Variable Value  ${ligx['uplinkSets']}
	${downlinkSpeedMode} =           Get Variable Value  ${ligx['downlinkSpeedMode']}
        ${consistencyCheckingForInternalNetworks} =   Get Variable Value   ${ligx['consistencyCheckingForInternalNetworks']}
	${sflowConfiguration} =         Get Variable Value  ${ligx['sflowConfiguration']}
        ${sflowNetwork} =               Get Variable Value  ${sflowConfiguration['sflowNetwork']}   &{EMPTY}
        ${sflowNetworkUri} =            Run Keyword If   ${sflowNetwork} != &{EMPTY}   Get Ethernet URI   ${sflowNetwork['name']}
        Run Keyword If   '${sflowNetworkUri}' != '${Null}'   Run Keywords   Set To Dictionary   ${sflowNetwork}   uri=${sflowNetworkUri}   AND   Set To Dictionary   ${sflowConfiguration}   sflowNetwork=${sflowNetwork}
	# ${uplinkSets} = 	Copy List	${ligx['uplinkSets']}

	${l} = 	Get Length	${uplinkSets}
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\   ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\   ${ethernetUris} =   Get Ethernet URIs   ${networks}
    \   ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	    ${networkUris}
	\   ${nativeNetworkUri} = 	Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri	${nativeNetworkUri}
    \   Set to dictionary   ${uplinkSets[${x}]}	nativeNetworkUri     ${nativeNetworkUri}

    # Process Internal URIs
	${internalNetworkUris} = 	Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris	${internalNetworkUris}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         fcoeSettings=${fcoeSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
	...                                         downlinkSpeedMode=${downlinkSpeedMode}
        ...                                         consistencyCheckingForInternalNetworks=${consistencyCheckingForInternalNetworks}
	...                                         sflowConfiguration=${sflowConfiguration}
	${resp} = 	Fusion Api Create LIG	${body}
	${task} =	fusion_api_appliance_setup.Wait For Task	${resp}    ${timeout}	${interval}
	[Return]   ${task}

Add Enclosure Group from variable
	[Documentation]	Adds an Enclosure Group to an appliance from a variable which contains  a list of dicts with the entire payload
	[Arguments]		${enc_group}
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding ENCLOSURE GROUP ${enc_group['name']}
	${l} = 	Get Length	${enc_group['interconnectBayMappings']}
	:FOR 	${x}	IN RANGE	0	${l}
	\	${liguri} = 	Get From Dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri
	\   Continue For Loop If    '${liguri}' == 'None'
	\	@{words} = 	Split String	${liguri}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${liguri} = 	Get LIG URI	${eg}
	\	Set to dictionary	${enc_group['interconnectBayMappings'][${x}]}	logicalInterconnectGroupUri		${liguri}
	${resp} =	Fusion Api Create Enclosure Group	${enc_group}
	[Return]   ${resp}
        
Common URI lookup by name
	[Documentation]	Takes a string containing URI type + : + resource name, performs a lookup and returns URI
	...				Ex:    ${uri} = 	Common Lookup by name	LIG:LIG1
	[Arguments]		${uri}
	@{words} = 	Split String	${uri}	:
	${type} = 	Get From List	${words}	0
	${name} = 	Get From List	${words}	1
	${uri} = 	Run Keyword If 	'${type}' == 'EG'		Get Enclosure Group URI		${name}
	...         ELSE IF         '${type}' == 'ENC'		Get Enclosure URI		    ${name}
	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URI			${name}
	...			ELSE IF			'${type}' == 'FC'		Get FC URI					${name}
	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URI				${name}
	...			ELSE IF			'${type}' == 'LI'		Get LI URI					${name}
	...			ELSE IF			'${type}' == 'LIG'		Get LIG URI					${name}
	...         ELSE IF         '${type}' == 'LS'       Get LS URI                  ${name}
	...         ELSE IF         '${type}' == 'LSG'      Get LSG URI                 ${name}
	...			ELSE IF			'${type}' == 'NS'		Get Network Set URI			${name}
	...			ELSE IF			'${type}' == 'SH'		Get Server Hardware URI		${name}
	...         ELSE IF         '${type}' == 'SWT'      Get Switch Type URI         ${name}
	...			ELSE IF			'${type}' == 'US'		Get Uplink Set URI			${name}
	...			ELSE			Set variable			ResourceTypeNotFound:${type}

	[Return]	${uri}

Add Enclosures from variable
	[Documentation]	Adds Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${encs}   ${timeout}=15m    ${interval}=10s
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding ENCLOSURES
	:FOR	${enc}	IN	@{encs}
	\	${encuri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	\	@{words} = 	Split String	${encuri}	:
	\	${type} = 	Get From List	${words}	0
	\	${e} = 		Get From List	${words}	1
	\	${encuri} = 	Get Enclosure Group URI	${e}
	\	Set to dictionary	${enc}	enclosureGroupUri		${encuri}
	\	${resp} =	Fusion Api Add Enclosure 	${enc}
	\	${task} =	fusion_api_appliance_setup.Wait For Task	${resp} 	${timeout}	 ${interval}

Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}   ${timeout}=120m    ${interval}=1m
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding LOGICAL ENCLOSURE
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	@{words} = 	Split String	${eguri}	:
	${type} = 	Get From List	${words}	0
	${e} = 		Get From List	${words}	1
	${eguri} = 	Get Enclosure Group URI	${e}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
    ${xenc} =   fusion_api_appliance_setup.copy dictionary   ${enc}
	Set to dictionary	${xenc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\   	@{words} = 	Split String	${encuri}	:
	\       ${type} = 	Get From List	${words}	0
	\       ${e} = 		Get From List	${words}	1
	\       ${encuri} = 	Get Enclosure URI	${e}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${xenc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Create Logical Enclosure 	${xenc}
	${task} =	fusion_api_appliance_setup.Wait For Task	${resp} 	${timeout}	${interval}
	[Return]  ${task}

Add Logical Switch Group from variable
	[Documentation]	Adds a Logical Switch Group to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${lsg}   ${timeout}=5m   ${interval}=15s
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding LOGICAL SWITCH GROUPS
	log variables   level=DEBUG
	${swmap} = 	Get From Dictionary	   ${lsg['switchMapTemplate']}    switchMapEntryTemplates
    :FOR    ${sw}   IN  @{swmap}
    \       ${swuri} =   Get From Dictionary   ${sw}   permittedSwitchTypeUri
	\       ${swuri} =   Common URI lookup by name	${swuri}
    \       Set to dictionary   ${sw}  permittedSwitchTypeUri   ${swuri}
    Set to dictionary   ${lsg['switchMapTemplate']}   switchMapEntryTemplates    ${swmap}
	${resp} =	Fusion Api Create LSG  	${lsg}
	${task} =	fusion_api_appliance_setup.Wait For Task	${resp} 	${timeout}	${interval}
	[Return]  ${task}

Add Logical Switch from variable
	[Documentation]	Adds a Logical Switch to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${ls}   ${timeout}=5m   ${interval}=15s
	fusion_api_appliance_setup.Log to console and logfile  	\nAdding LOGICAL SWITCH
	${lsguri} = 	Get From Dictionary	   ${ls['logicalSwitch']}    logicalSwitchGroupUri
    ${lsguri} =     Common URI Lookup by name   ${lsguri}
    Set to dictionary   ${ls['logicalSwitch']}  logicalSwitchGroupUri   ${lsguri}
	${resp} =	Fusion Api Create LS  	${ls}
	${task} =	fusion_api_appliance_setup.Wait For Task	${resp} 	${timeout}	${interval}
	[Return]  ${task}

Add Server Profiles from variable no hardware
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}   ${server_profile_to_bay_map}
	fusion_api_appliance_setup.Log to console and logfile  	Adding SERVER PROFILES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    fusion_api_appliance_setup.Copy Dictionary     ${profile}
    \   ${space} =   Check For Whitespace From String   ${profile['name']}
    \   Run Keyword If   ${space} is ${True}   Fail   msg=Profile name contains whitespace. This is not allowed in CI-FIT naming convention.
    \   ${resp} =   Run Keyword If   '${server_profile_to_bay_map['${profile['name']}']}' == '${null}'   Fusion Api Get Server Hardware
    \   ${shUri} =   Run Keyword If   ${resp} == ${null}   Get Server Hardware URI    ${server_profile_to_bay_map['${profile['name']}']}
    \   ...                    ELSE   Set Variable   ${resp['members'][0]['uri']}
    \   ${serverHW} =    Fusion Api Get Resource    uri=${shUri}
	\   Set To Dictionary    ${profile}   serverHardwareTypeUri=${serverHW['serverHardwareTypeUri']}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${profile} = 	Update connections in profile    ${profile}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}
	\	${task} =   fusion_api_appliance_setup.Wait For Task	${resp}		timeout=8 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)

Update connections in profile
   [Documentation]   updates the Server Profile connections from the request body.  There are two DTO versions:
   ...    'connections' and 'connectionSettings'{}
   [Arguments]    ${profile}
   ${keys} =           get dictionary keys   ${profile}
   ${c} =              Get Match Count       ${keys}    connectionSettings
   ${connections} =    Run keyword if   ${c} == 1    get from dictionary    ${profile['connectionSettings']}   connections
   ...   ELSE          get from dictionary    ${profile}   connections
   ${connections} =    Lookup Connection Uris    ${connections}
   Run keyword if    ${c} == 1   Set to Dictionary   ${profile['connectionSettings']}    connections    ${connections}
   ...   ELSE                    Set to Dictionary   ${profile}    connections    ${connections}
   [Return]    ${profile}

Add Server Profiles from variable
	[Documentation]	Adds Server Profiles to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}   ${timeout}=15m    ${interval}=10s   ${endstate}=((?i)Warning|Completed)   ${param}=?force="all"
	Log   Adding SERVER PROFILES   console=True
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    fusion_api_appliance_setup.Copy Dictionary     ${profile}
        \       ${space} =   Check For Whitespace From String   ${profile['name']}
        \       Run Keyword If   ${space} is ${True}   Fail   msg=Profile name contains whitespace. This is not allowed in CI-FIT naming convention.
	\	${shuri} = 	Get from Dictionary	${profile}	serverHardwareUri
	\	${uri} = 	Get Server Hardware URI		${shuri}
	\	Set to Dictionary	${profile}	serverHardwareUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${enc} = 	Get from Dictionary	${profile}	enclosureUri
	\	@{words} = 	Split String	${enc}	:
	\	${type} = 	Get From List	${words}	0
	\	${enc} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure URI	${enc}
	\	Set to Dictionary	${profile}	enclosureUri	${uri}
	\	${profile} = 	Update connections in profile    ${profile}
	\	${resp} = 	Fusion Api Create Server Profile		body=${profile}   param=${param}
	\	${task} =   fusion_api_appliance_setup.Wait For Task	${resp}		timeout=${timeout}		interval=${interval}
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	 ${endstate}

Add Server Profile Templates from variable
	[Documentation]	Adds Server Profile Templates to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${profiles}
	fusion_api_appliance_setup.Log to console and logfile  	Adding SERVER PROFILE TEMPLATES
	:FOR	${profile}	IN	@{profiles}
	\   ${profile} =    fusion_api_appliance_setup.Copy Dictionary     ${profile}
	\	${sht} = 	Get from Dictionary	${profile}	serverHardwareTypeUri
	\	@{words} = 	Split String	${sht}	:
	\	${type} = 	Get From List	${words}	0
	\	${sht} = 	Get From List	${words}	1
	\	${uri} = 	Get Server Hardware Type URI		${sht}
	\	Set to Dictionary	${profile}	serverHardwareTypeUri	${uri}
	\	${eg} = 	Get from Dictionary	${profile}	enclosureGroupUri
	\	@{words} = 	Split String	${eg}	:
	\	${type} = 	Get From List	${words}	0
	\	${eg} = 	Get From List	${words}	1
	\	${uri} = 	Get Enclosure Group URI	${eg}
	\	Set to Dictionary	${profile}	enclosureGroupUri	${uri}
	\	${profile} = 	Update connections in profile    ${profile}
	\	${resp} = 	Fusion Api Create Server Profile template		body=${profile}
	\	${task} =   fusion_api_appliance_setup.Wait For Task	${resp}		timeout=5 mins		interval=10s
	\   ${task_state} = 	Get From dictionary 	${task}     taskState
	\   Should Match Regexp	${task_state}	((?i)Warning|Completed)

Assign Server Hardware To Existing Profiles From Variable
	[Documentation]	Update Server Profiles from a variable with server hardware assigned to profile from mapping variable
        ...             NOTE: If ${waitForTask} is false, ${parallelAssign} and ${validate} becomes moot. Just fork the process and exit.
	[Arguments]		${profiles}   ${server_profile_to_bay_map}   ${timeout}=60m   ${interval}=15s  ${waitForTask}=${True}  ${parallelAssign}=${True}   ${validate}=${True}   ${param}=?force="all"
	${existing_profiles} =  	Fusion Api Get Server Profiles
	${profile_members}	Get From Dictionary	${existing_profiles}	members
	${Count} =	Get From Dictionary	${existing_profiles}	count
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    ${respList} =   Create List
	:FOR 	${Index}	IN RANGE	0	${Count}
	\	    ${sp}		Get From List	${profile_members}	${Index}
    \       Continue For Loop If   '${server_profile_to_bay_map['${sp['name']}']}' == '${null}'
	\	    ${shUri} = 	Get Server Hardware URI    ${server_profile_to_bay_map['${sp['name']}']}
    \       ${profile} =    Fusion Api Get Resource    uri=${sp['uri']}
	\       Set To Dictionary    ${profile}   serverHardwareUri=${shUri}
    \       Remove From Dictionary    ${profile}   status_code    headers
    \	    fusion_api_appliance_setup.Log to console and logfile  	Assigning server hardware URI \"${shUri}\" to profile \"${sp['name']}\"
    \       ${resp} =   Fusion Api Edit Server Profile    uri=${sp['uri']}   body=${profile}   param=${param}
    \       Continue For Loop If   ${waitForTask} != ${True}
    \       Run Keyword If   ${parallelAssign} == ${True}   Append To List   ${respList}   ${resp}
    \       ...       ELSE   fusion_api_appliance_setup.Wait For Task And Validate Response   ${resp}   ${valDict}   ${timeout}   ${interval}   ${validate}
    Run Keyword If   ${parallelAssign} == ${True} and ${waitForTask} is ${True}   Wait For Forked Tasks   ${respList}   ${valDict}   ${timeout}   ${interval}   ${validate}

Assign Server Profiles
    [Documentation]   Update server profiles in OneView by assigning the server hardware's valid uri. Argument requires list of dictionary of profiles that contains a valid server profile uri and serverHardwareUri (e.g: [{'uri': '/rest/server-profiles/8e2ec303-1274-4b9e-9871-b08f77bcc675', 'serverHardwareUri': '/rest/server-hardware/36343537-3338-4A48-3542-4E5030303533'}]).
    ...               NOTE: See robustness' LE-add-remove.txt script for example.
    [Arguments]     ${profiles}   ${timeout}=60m   ${interval}=15s  ${waitForTask}=${True}  ${parallelAssign}=${True}   ${validate}=${True}   ${param}=?force="all"
	Set Log Level	TRACE
    ${valDict} =    Create Dictionary   status_code=${200}
    ...                                 taskState=Completed
    ${respList} =   Create List
	:FOR	${p}	IN    @{profiles}
        \   ${profile} =    Fusion Api Get Resource    uri=${p['uri']}
        \   set to dictionary    ${profile}   serverHardwareUri=${p['serverHardwareUri']}
        \   remove from dictionary    ${profile}   status_code    headers
        \   fusion_api_appliance_setup.Log to console and logfile  	Assigning server hardware URI \"${p['uri']}\" to profile \"${p['name']}\"
        \   ${resp} =   fusion api edit server profile    uri=${p['uri']}   body=${profile}   param=${param}
        \   Continue For Loop If   ${waitForTask} != ${True}
        \   Run Keyword If   ${parallelAssign} == ${True}   Append To List   ${respList}   ${resp}
        \   ...       ELSE   fusion_api_appliance_setup.Wait For Task And Validate Response   ${resp}   ${valDict}   ${timeout}   ${interval}   ${validate}
        Run Keyword If   ${parallelAssign} == ${True} and ${waitForTask} is ${True}   Wait For Forked Tasks   ${respList}   ${valDict}   ${timeout}   ${interval}   ${validate}

Unassign Server Profiles
        [Documentation]   Update server profiles in OneView by unassigning the server hardware from it. Argument requires list of dictionary of profiles that contains a valid server profile uri (e.g.: [{'uri': '/rest/server-profiles/8e2ec303-1274-4b9e-9871-b08f77bcc675'}]).
        ...               NOTE: See robustness' LE-add-remove.txt script for example.
        [Arguments]     ${profiles}    ${timeout}=60m   ${interval}=15s  ${waitForTask}=${True}  ${parallelAssign}=${True}   ${validate}=${True}
        Set Log Level	TRACE
        ${valDict} =    Create Dictionary   status_code=${200}
        ...                                 taskState=Completed
        ${respList} =   Create List
        :FOR   ${p}   IN   @{profiles}
        \   ${profile} =    Fusion Api Get Resource    uri=${p['uri']}
        \   fusion_api_appliance_setup.Log to console and logfile  	Unassigning server hardware URI \"${profile['serverHardwareUri']}\" from profile \"${p['name']}\"
        \   set to dictionary    ${profile}   serverHardwareUri=${None}
        \   set to dictionary    ${profile}   enclosureBay=${None}
        \   set to dictionary    ${profile}   enclosureUri=${None}
        \   remove from dictionary    ${profile}   status_code    headers
        \   ${resp} =   fusion api edit server profile    uri=${p['uri']}   body=${profile}
        \   Continue For Loop If   ${waitForTask} != ${True}
        \   Run Keyword If   ${parallelAssign} == ${True}   Append To List   ${respList}   ${resp}
        \   ...       ELSE   fusion_api_appliance_setup.Wait For Task And Validate Response   ${resp}   ${valDict}   ${timeout}   ${interval}   ${validate}
        Run Keyword If   ${parallelAssign} == ${True} and ${waitForTask} is ${True}   Wait For Forked Tasks   ${respList}   ${valDict}   ${timeout}   ${interval}   ${validate}

Lookup volumeAttachments uris
    [Documentation]    Processes a list of volume attachments
    [Arguments]     ${vol_attachments}    ${enclosure}    ${server_bay}
    ${volume_attachments} =  Create List
    :FOR    ${vol_attachment}    IN    @{vol_attachments}
    \    ${vol_attachment} =     fusion_api_appliance_setup.Copy dictionary     ${vol_attachment}
    \    ${volumeName}=    Catenate  SEPARATOR=_  ${enclosure}  Bay  ${server_bay}
    \    Set to Dictionary   ${vol_attachment}  volumeName    ${volumeName}
    \    ${volumeStoragePoolUri_name}=    Get From Dictionary    ${vol_attachment}    volumeStoragePoolUri
    \    ${volumeStorageSystemUri_name}=    Get From Dictionary    ${vol_attachment}    volumeStorageSystemUri
    \    ${volumeStoragePoolUri} =  Get Storage Pool URI    ${volumeStoragePoolUri_name}    ${volumeStorageSystemUri_name}
    \    ${volumeStorageSystemUri} =   Get Storage System URI    ${volumeStorageSystemUri_name}
    \    Set to Dictionary   ${vol_attachment}    volumeStoragePoolUri    ${volumeStoragePoolUri}
    \    Set to Dictionary   ${vol_attachment}    volumeStorageSystemUri    ${volumeStorageSystemUri}
    \    append to list  ${volume_attachments}    ${vol_attachment}
    [Return]    ${volume_attachments}

Lookup volume uris
    [Documentation]    Processes a list of volumes
    [Arguments]     ${vol_attachments}    ${enclosure}    ${server_bay}    ${target_wwpn}
    ${volumes} =  Create List
    :FOR    ${vol_attachment}    IN    @{vol_attachments}
    \    ${vol_attachment} =     fusion_api_appliance_setup.Copy dictionary     ${vol_attachment}
    \    ${volumeName}=    Catenate  SEPARATOR=_  ${enclosure}  Bay  ${server_bay}
    \    ${volumeUri}=    Get Storage Volume URI    ${volumeName}
    \    Set to Dictionary   ${vol_attachment}  volumeUri    ${volumeUri}
    \    Set to Dictionary   ${vol_attachment}  lun    0
    \    ${storage_Paths}=    Get From Dictionary    ${vol_attachment}    storagePaths
    \    ${storagePaths} =    Lookup storagePaths    ${storage_Paths}    ${target_wwpn}
    \    Set to Dictionary    ${vol_attachment}    storagePaths    ${storagePaths}
    \    Remove From Dictionary    ${vol_attachment}    volumeName
    \    Remove From Dictionary    ${vol_attachment}    volumeDescription
    \    Remove From Dictionary    ${vol_attachment}    volumeStoragePoolUri
    \    Remove From Dictionary    ${vol_attachment}    volumeStorageSystemUri
    \    Remove From Dictionary    ${vol_attachment}    volumeProvisionType
    \    Remove From Dictionary    ${vol_attachment}    volumeProvisionedCapacityBytes
    \    Remove From Dictionary    ${vol_attachment}    volumeShareable
    \    Remove From Dictionary    ${vol_attachment}    permanent
    \    append to list    ${volumes}    ${vol_attachment}
    [Return]    ${volumes}

Lookup storagePaths
    [Documentation]    Processes a list of storagePaths
    [Arguments]     ${paths}    ${target_wwpn}
    ${storage_Paths} =  Create List
    :FOR    ${storage_path}    IN    @{paths}
    \    ${storage_path} =    fusion_api_appliance_setup.Copy dictionary     ${storage_path}
    \    ${storageTargets_list}=    Get From Dictionary    ${storage_path}    targets
    \    append to list    ${storageTargets_list}    ${target_wwpn}
    \    append to list    ${storage_Paths}    ${storage_path}
    [Return]    ${storagePaths}

Lookup connection uris
	[Documentation]	Processes a list of connections, getting the uris for networks
	[Arguments]		${connections}
	${conns} =  Create List
	:FOR	${connection}	IN	@{connections}
	\   ${connection} =     fusion_api_appliance_setup.Copy dictionary     ${connection}
	\	${functionType} = 	Get from Dictionary	${connection}	functionType
	\	${net} = 			Get From Dictionary	${connection}	networkUri
	\	@{words} = 	Split String	${net}	:
	\	${type} = 	Get From List	${words}	0
	\	${net} = 	Get From List	${words}	1
	\	${net} = 	Create List	${net}
	\ 	${uri} = 	Run Keyword If 	'${type}' == 'FC'		Get FC URIs			${net}
	\ 	...			ELSE IF			'${type}' == 'ETH'		Get Ethernet URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'NS'		Get Network Set URIs	${net}
	\ 	...			ELSE IF			'${type}' == 'FCOE'		Get FCoE URIs	${net}
	\	${uri} = 	Get From List	${uri}	0
	\	Set to Dictionary	${connection}	networkUri	${uri}
	\   append to list  ${conns}    ${connection}
	[Return]	${conns}

Lookup connection uris Change RequestedBW
    [Documentation]    Processes a list of connections, getting the uris for networks
    [Arguments]    ${connections}    ${bandwidth}
    ${conns} =    Create List
    :FOR    ${connection}    IN    @{connections}
    \    ${connection} =    fusion_api_appliance_setup.Copy dictionary    ${connection}
    \    ${functionType} =    Get from Dictionary    ${connection}    functionType
    \    ${net} =    Get From Dictionary    ${connection}    networkUri
    \    @{words} =    Split String    ${net}    :
    \    ${type} =    Get From List    ${words}    0
    \    ${net} =    Get From List    ${words}    1
    \    ${net} =    Create List    ${net}
    \    ${uri} =    Run Keyword If    '${type}' == 'FC'    Get FC URIs    ${net}
    \    ...    ELSE IF    '${type}' == 'ETH'    Get Ethernet URIs    ${net}
    \    ...    ELSE IF    '${type}' == 'NS'    Get Network Set URIs    ${net}
    \    ...    ELSE IF    '${type}' == 'FCOE'    Get FCoE URIs    ${net}
    \    ${uri} =    Get From List    ${uri}    0
    \    Set to Dictionary    ${connection}    networkUri    ${uri}
    \    Run Keyword If    '${functionType}' == 'Ethernet'    Set to Dictionary    ${connection}    requestedMbps    ${bandwidth}
    \   append to list  ${conns}    ${connection}
    [Return]    ${conns}

Disable ALL Generated ID Ranges
	[Documentation]	Disables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Disable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Disable Generated VSN Range	${rangeUri}

Disable Generated VMAC Range
	[Documentation]	Disables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	fusion_api_appliance_setup.Log to console and logfile  	Disabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VWWN Range
	[Documentation]	Disables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	fusion_api_appliance_setup.Log to console and logfile  	Disabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Disable Generated VSN Range
	[Documentation]	Disables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=false
	Run Keyword If	'${rangeCategory}' == 'Generated'	fusion_api_appliance_setup.Log to console and logfile  	Disabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable ALL Generated ID Ranges
	[Documentation]	Enables ALL of the auto-generated Ranges on an appliance
	[Arguments]		${uri}
	${pool} = 		Fusion API Get Pool	uri=${uri}
	${rangeUris} = 	Get From Dictionary	${pool}	rangeUris
	:FOR	${rangeUri}	IN	@{rangeUris}
	\	${poolType} = 	Get From Dictionary 	${pool}	poolType
	\ 	${resp} = 	Run Keyword If 	'${poolType}' == 'VWWN'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF 		'${poolType}' == 'VMAC'	Enable Generated VMAC Range	${rangeUri}
	\ 	...			ELSE IF	 		'${poolType}' == 'VSN'	Enable Generated VSN Range	${rangeUri}

Enable Generated VMAC Range
	[Documentation]	Enables the auto-generated VMAC Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VMAC Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	fusion_api_appliance_setup.Log to console and logfile  	Enabled auto-generated VMAC range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VMAC Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VWWN Range
	[Documentation]	Enables the auto-generated VWWN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VWWN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	fusion_api_appliance_setup.Log to console and logfile  	Enabled auto-generated VWWN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VWWN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Enable Generated VSN Range
	[Documentation]	Enables the auto-generated VSN Range on an appliance
	[Arguments]		${uri}
	${range} = 	Fusion Api Get VSN Range	uri=${uri}
	${rangeCategory} = 	Get From Dictionary	${range}	rangeCategory
	${body} = 	Create Dictionary	type=Range	enabled=true
	Run Keyword If	'${rangeCategory}' == 'Generated'	fusion_api_appliance_setup.Log to console and logfile  	Enabled auto-generated VSN range ${uri}
	${resp} = 	Run Keyword If	'${rangeCategory}' == 'Generated'	Fusion Api Edit VSN Range	body=${body}	uri=${uri}
	[Return]	${resp}

Run Keyword as user
	[Documentation]		Runs a Fusion_API keyword as a particular user.
	...					Ex:		Run Keyword As User		nat		Fusion Api Get Ethernet Networks	${empty}	param=?filter="'name'=='net_101'"
    [Arguments]     ${user}     ${keyword}      @{varargs}
    ${original_user} =   Fusion Api Get Active user
	${active_sessions} = 	Fusion Api Get Active Sessions
	Dictionary Should Contain Key	${active_sessions}	${user}
    Fusion Api Switch Active User   ${user}
    ${resp} =   Run Keyword and continue on failure     ${keyword}  @{varargs}
    Fusion Api Switch Active User   ${original_user}
    [Return]    ${resp}

Run Keyword for List
	[Documentation]	Runs the specified keyword, passing each item in the list as the argument. args and kwargs are supported.
	[Arguments]    ${list}   ${keyword}   @{varargs}    &{kwargs}
	Set Log Level	TRACE
	:FOR	${x}	IN 	@{list}
	\	Run Keyword		${keyword}   ${x}   @{varargs}    &{kwargs}

Run Keyword for Dict
	[Documentation]	Runs the specified keyword, passing each VALUE for each KEY in the dict. args and kwargs are supported.
	[Arguments]    ${dict}   ${keyword}   @{varargs}    &{kwargs}
	Set Log Level	TRACE
	${items} =    Get Dictionary Items    ${dict}
	:FOR	${key}   ${value}	IN 	@{items}
	\	Run Keyword		${keyword}   ${value}   @{varargs}    &{kwargs}

Add to headers
    [Documentation]  adds key\value pairs to the default headers and returns the resulting dict.
    ...   This is useful for supplying a customized header for an individual API call, like specify eTag.
    ...   example:  ${headers} =    Add to headers   If-Match=*    SomeKey=SomeValue
    [Arguments]     &{kwargs}
    ${headers} =    Fusion API get headers
    ${items} =      Get Dictionary Items    ${kwargs}
	:FOR	${key}   ${value}	IN   @{items}
	\	Set to Dictionary   ${headers}   ${key}   ${value}
    [Return]    ${headers}

#######################################
# COMMON KEYWORDS
#######################################
Build LIG body
    [Documentation]    Build Logical Interconnect Group body
	[Arguments]		${xlig}
	${xlig} = 	fusion_api_appliance_setup.Copy Dictionary	${xlig}
	${uplinkSets} = 	Copy List	${xlig['uplinkSets']}
	${l} = 	Get Length	${uplinkSets}
	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
	\ 	Run Keyword If 	'${networkType}' == 'Ethernet'		Continue For Loop
	\	${networkUris} = 	Get FC Uris	${networks}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}

	:FOR	${x}	IN RANGE	0	${l}
	\	${networkType} = 	Get From Dictionary 	${uplinkSets[${x}]}	networkType
	\	${networks} = 		Get From Dictionary		${uplinkSets[${x}]}	networkUris
    \   ${networkSetUris} =    Get Variable Value  ${uplink_sets[${x}]['networkSetUris']}   @{EMPTY}
        \       ${nativeNetworkUri} =   Get Variable Value     ${uplinkSets[${x}]['nativeNetworkUri']}
	\ 	Run Keyword If 	'${networkType}' == 'FibreChannel'	Continue For Loop
	\	${networkUris} = 	Get FCoE Uris	${networks}
	\       ${ethernetUris} =   Get Ethernet URIs   ${networks}
        \       ${networkUris} =    combine lists   ${networkUris}  ${ethernetUris}
	\	Set to dictionary	${uplinkSets[${x}]}	networkUris	${networkUris}
    \   ${networkSetUris} =   Run Keyword If   ${networkSetUris} != @{EMPTY}   Get Network Set URIs   ${networkSetUris}
    \   Run Keyword If   ${networkSetUris} != @{EMPTY}   Set To Dictionary   ${uplinkSets[${x}]}   networkSetUris=${networkSetUris}
        \       ${nativeNetworkUri} =       Run Keyword If   '${nativeNetworkUri}' != 'None'    Get Ethernet Uri    ${nativeNetworkUri}
        \       Run Keyword If  '${nativeNetworkUri}' != 'None'   Set to dictionary   ${uplinkSets[${x}]}     nativeNetworkUri     ${nativeNetworkUri}

    :FOR    ${x}    IN RANGE    0   ${l}
    \   ${status}  ${fcoeMlagMode} =   Run Keyword and Ignore Error  Get From Dictionary    ${uplinkSets[${x}]}  fcoeMlagMode 
    \   continue for loop if   '${status}'=='FAIL'
    \   Run Keyword if  '${fcoeMlagMode}' == 'None'  Continue For Loop
    \   ${fcoeMlagNetworksUris} =  Get fcoeMlagNetwork Uris  ${uplinkSets[${x}]['fcoeNetworkMlagBays']}
	\	Set to dictionary	${uplinkSets[${x}]}	 fcoeNetworkMlagBays	 ${fcoeMlagNetworksUris}

        # Process Private VLAN Domains
        :FOR  ${x}  IN RANGE  0  ${l}
        \   ${status} =    Run Keyword and Return Status     Dictionary Should Contain Key    ${uplinkSets[${x}]}    privateVlanDomains
        \   Continue For Loop If    '${status}' == 'False'
        \   ${privatevlan}=    Get From Dictionary    ${uplinkSets[${x}]}    privateVlanDomains
        \   ${privatevlanbody}=    Create LIG Private VLAN Payload    ${privatevlan}
        \   Set to dictionary    ${uplinkSets[${x}]}    privateVlanDomains    ${privatevlanbody}





	${name} =                       Get Variable Value  ${xlig['name']}
	${enclosureIndexes} =           Get Variable Value  ${xlig['enclosureIndexes']}
	${enclosureType} =              Get Variable Value  ${xlig['enclosureType']}
	${ethernetSettings} =           Get Variable Value  ${xlig['ethernetSettings']}
	${fcoeSettings} =               Get Variable Value  ${xlig['fcoeSettings']}
	${interconnectBaySet} =         Get Variable Value  ${xlig['interconnectBaySet']}
	${interconnectMapTemplate} =    Get Variable Value  ${xlig['interconnectMapTemplate']}
	${redundancyType} =             Get Variable Value  ${xlig['redundancyType']}
	${stackingMode} =               Get Variable Value  ${xlig['stackingMode']}
	${telemetryConfiguration} =     Get Variable Value  ${xlig['telemetryConfiguration']}
	${snmpConfiguration} =          Get Variable Value  ${xlig['snmpConfiguration']}
	${downlinkSpeedMode} =          Get Variable Value  ${xlig['downlinkSpeedMode']}
        ${consistencyCheckingForInternalNetworks} =   Get Variable Value   ${xlig['consistencyCheckingForInternalNetworks']}
        ${internalNetworkUris} =        Get Variable Value  ${xlig['internalNetworkUris']}
	${qosConfiguration} =           Get Variable Value  ${xlig['qosConfiguration']}
	${sflowConfiguration} =         Get Variable Value  ${xlig['sflowConfiguration']}
        ${sflowNetwork} =               Get Variable Value  ${sflowConfiguration['sflowNetwork']}   &{EMPTY}
        ${sflowNetworkUri} =            Run Keyword If   ${sflowNetwork} != &{EMPTY}   Get Ethernet URI   ${sflowNetwork['name']}
        Run Keyword If   '${sflowNetworkUri}' != '${Null}'   Run Keywords   Set To Dictionary   ${sflowNetwork}   uri=${sflowNetworkUri}   AND   Set To Dictionary   ${sflowConfiguration}   sflowNetwork=${sflowNetwork}

        ${internalNetworkUris} =     Run Keyword If   ${internalNetworkUris} is not ${null}    Get Ethernet Uris    ${internalNetworkUris}

	${body} = 	Fusion Api Create LIG Payload	name=${name}
	...                                         enclosureIndexes=${enclosureIndexes}
	...                                         enclosureType=${enclosureType}
	...                                         ethernetSettings=${ethernetSettings}
	...                                         fcoeSettings=${fcoeSettings}
	...                                         interconnectBaySet=${interconnectBaySet}
	...											interconnectMapTemplate=${interconnectMapTemplate}
	...                                         redundancyType=${redundancyType}
	...                                         stackingMode=${stackingMode}
	...                                         telemetryConfiguration=${telemetryConfiguration}
	...                                         snmpConfiguration=${snmpConfiguration}
	...											uplinkSets=${uplinkSets}
	...                                         downlinkSpeedMode=${downlinkSpeedMode}
        ...                                         consistencyCheckingForInternalNetworks=${consistencyCheckingForInternalNetworks}
        ...                                         internalNetworkUris=${internalNetworkUris}
	...                                         qosConfiguration=${qosConfiguration}
	...                                         sflowConfiguration=${sflowConfiguration}

    
    [Return]    ${body}


Create LIG Private VLAN Payload
    [Documentation]    Creates private vlan dictionary for the create/edit LIG payload
    [Arguments]    ${privatevlan}
    ${l} =  Get Length  ${privatevlan}
    :FOR    ${x}    IN RANGE  0  ${l}
    \   ${status} =    Run Keyword and Return Status     Dictionary Should Contain Key    ${privatevlan[${x}]}    primaryNetwork
    \   Continue For Loop If    '${status}' == 'False'
    \   ${primarynetwork}=   Get From Dictionary    ${privatevlan[${x}]['primaryNetwork']}    uri
    \   ${primarynetworkuri}=    Get Ethernet URI    ${primarynetwork}
    \   ${resp} =   Fusion Api Get Resource   ${primarynetworkuri}
    \   Set To Dictionary    ${privatevlan[${x}]['primaryNetwork']}    uri=${primarynetworkuri}   name=${primaryNetwork}  vlanId=${resp['vlanId']}
    :FOR    ${x}    IN RANGE  0  ${l}
    \   ${status} =    Run Keyword and Return Status     Dictionary Should Contain Key    ${privatevlan[${x}]}    isolatedNetwork
    \   Continue For Loop If    '${status}' == 'False'
    \   ${isolatedNetwork}=   Get From Dictionary    ${privatevlan[${x}]['isolatedNetwork']}    uri
    \   ${isolatedNetworkuri}=    Get Ethernet URI    ${isolatedNetwork}
    \   ${resp} =   Fusion Api Get Resource   ${isolatedNetworkuri}
    \   Set To Dictionary    ${privatevlan[${x}]['isolatedNetwork']}    uri=${isolatedNetworkuri}   name=${isolatedNetwork}  vlanId=${resp['vlanId']}
    [return]    ${privatevlan}




Get fcoeMlagNetwork Uris
    [Documentation]    Build FCoE Mlag Network URIs
	[Arguments]		${fcoeMlagNetworkBays}
    ${l} =     Get Length  ${fcoeMlagNetworkBays}
    :FOR    ${x}    IN RANGE    0   ${l}
	\	${fcoeMlagList} = 		Get From Dictionary		${fcoeMlagNetworkBays[${x}]}	networkUris
	\   ${networkUris} = 	Get FCoE Uris	${fcoeMlagList}
    \   Set To Dictionary    ${fcoeMlagNetworkBays[${x}]}  networkUris  ${networkUris}

    [Return]    ${fcoeMlagNetworkBays}

# TODO : need to add networkUris translation for fcoeNetworkMlagBays, just
# like we did for the lig portion.
Build US body
    [Documentation]    Build UplinkSet body
	[Arguments]		${us}	${li_uri}
	Set to dictionary	${us}	logicalInterconnectUri	${li_uri}
	${l} = 	Get Length	${us['portConfigInfos']}
	:FOR	${x}	IN RANGE	0	${l}
	\   ${enc_uri} =            Get From Dictionary     ${us['portConfigInfos'][${x}]}	enclosure
	\   ${enc_uri} =        Get Enclosure Uri   ${enc_uri}
	\	Set To Dictionary		${us['portConfigInfos'][${x}]}	enclosure	${enc_uri}
    ${status}  ${fcoeNetworkMlagBays} =   Run Keyword and Ignore Error  Get From Dictionary   ${us}  fcoeNetworkMlagBays

    # process fcoenetworkmlagbays
    ${fcoeMlagNetworkUris} =  Run Keyword if  '${status}'=='PASS'  Get fcoeMlagNetwork uris  ${fcoeNetworkMlagBays}

	# process eth
	${networks} = 		Get From Dictionary		${us}	networkUris
	${networkUris} = 	Get Ethernet Uris	${networks}
	Set to dictionary	${us}	networkUris	${networkUris}
	# process fc
	${networks} = 		Get From Dictionary		${us}	fcNetworkUris
	${networkUris} = 	Get FC Uris	${networks}
	Set to dictionary	${us}	fcNetworkUris	${networkUris}
	# process fcoe
	${networks} = 		Get From Dictionary		${us}	fcoeNetworkUris
	${networkUris} = 	Get FCoE Uris	${networks}
	Set to dictionary	${us}	fcoeNetworkUris	${networkUris}

	${body} = 		Fusion Api Create Uplink Set Payload	${us}
	[Return]	${body}

Build Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile
    [Arguments]     ${bay_num}    ${profile_body}  ${connection_type}=${NONE}  ${boot_Mode}=${NONE}  ${boot_order}=${NONE}  ${bandwidth}=${NONE}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    ${uri}=    Get Server HW URI    ${bay_num}
    Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    ${eg} =     Get from Dictionary    ${profile}  enclosureGroupUri
    @{words} =  Split String    ${eg}    :
    ${type} =   Get From List   ${words}    0
    ${eg} =     Get From List   ${words}    1
    ${uri} =    Get Enclosure Group URI    ${eg}
    Set to Dictionary    ${profile}    enclosureGroupUri    ${uri}
    ${enc} =    Get from Dictionary    ${profile}    enclosureUri
    @{words} =  Split String    ${enc}    :
    ${type} =   Get From List   ${words}    0
    ${enc} =    Get From List   ${words}    1
    ${uri} =    Get Enclosure URI   ${enc}
    Set to Dictionary   ${profile}  enclosureUri    ${uri}
    ${name}=    Catenate  SEPARATOR=_  ${enc}  Bay  ${bay_num}
    Set to Dictionary   ${profile}  name    ${name}
    Run Keyword If    ${connection_type} != ${NONE}    Set to Dictionary   ${profile}  connections    ${connection_type}
    ${connections} =    Get From Dictionary    ${profile}    connections
     ${connections} =    Run Keyword If  '${bandwidth}' == '${NONE}'    Lookup Connection Uris    ${connections}
    ...    ELSE    Lookup connection uris Change RequestedBW    ${connections}    ${bandwidth}
    Set to Dictionary   ${profile}  connections     ${connections}
    Run Keyword If    ${boot_Mode} != ${NONE}    Set to Dictionary    ${profile}    bootMode    ${boot_Mode}
    Run Keyword If    ${boot_order} != ${NONE}    Set to Dictionary    ${profile}    boot    ${boot_order}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Server Profile body SAN Storage
    [Documentation]   Build Server Profiles body with SAN storage
    [Arguments]     ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}
    ${enc} =    Get from Dictionary    ${profile_body}    enclosureUri
    @{words} =    Split String    ${enc}    :
    ${type} =    Get From List    ${words}    0
    ${enc} =    Get From List    ${words}    1
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    ${san_storage} =    Get From Dictionary    ${profile}    sanStorage
    ${volumeAttachments} =    Get From Dictionary    ${san_storage}    volumeAttachments
    ${volumeAttachments} =    Lookup volumeAttachments uris   ${volumeAttachments}    ${enc}    ${bay_num}
    Set to Dictionary   ${san_storage}    volumeAttachments     ${volumeAttachments}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Server Profile body UEFI Mode
    [Documentation]   Build Server Profiles body required to create the server profile in UEFI mode
    [Arguments]     ${bay_num}    ${profile_body}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_uefi}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_uefi}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Server Profile body Legacy Mode
    [Documentation]   Build Server Profiles body required to create the server profile in Legacy mode
    [Arguments]     ${bay_num}    ${profile_body}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_legacy}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_legacy}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile
    [Arguments]     ${bay_num}    ${profile_body}    ${connection_type}=${NONE}    ${boot_Mode}=${NONE}    ${boot_order}=${NONE}    ${bandwidth}=${NONE}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    ${uri}=    Get Server Profile URI    ${bay_num}
    Set to Dictionary    ${profile}    uri    ${uri}
    ${uri}=    Get Server HW URI    ${bay_num}
    Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    ${eg} =     Get from Dictionary    ${profile}  enclosureGroupUri
    @{words} =  Split String    ${eg}    :
    ${type} =   Get From List   ${words}    0
    ${eg} =     Get From List   ${words}    1
    ${uri} =    Get Enclosure Group URI    ${eg}
    Set to Dictionary    ${profile}    enclosureGroupUri    ${uri}
    ${enc} =    Get from Dictionary    ${profile}    enclosureUri
    @{words} =  Split String    ${enc}    :
    ${type} =   Get From List   ${words}    0
    ${enc} =    Get From List   ${words}    1
    ${uri} =    Get Enclosure URI   ${enc}
    Set to Dictionary   ${profile}  enclosureUri    ${uri}
    ${name}=    Catenate  SEPARATOR=_  ${enc}  Bay  ${bay_num}
    Set to Dictionary   ${profile}  name    ${name}
    Run Keyword If    ${connection_type} != ${NONE}    Set to Dictionary   ${profile}  connections    ${connection_type}
    ${connections} =    Get From Dictionary    ${profile}    connections
    ${connections} =    Run Keyword If  '${bandwidth}' == '${NONE}'    Lookup Connection Uris    ${connections}
    ...    ELSE    Lookup connection uris Change RequestedBW    ${connections}    ${bandwidth}
    Set to Dictionary   ${profile}  connections     ${connections}
    Run Keyword If    ${boot_Mode} != ${NONE}    Set to Dictionary    ${profile}    bootMode    ${boot_Mode}
    Run Keyword If    ${boot_order} != ${NONE}    Set to Dictionary    ${profile}    boot    ${boot_order}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body SAN Storage
    [Documentation]   Build Edit Server Profile body with SAN storage
    [Arguments]     ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}    ${bandwidth}    ${target_wwpn}
    ${enc} =    Get from Dictionary    ${profile_body}    enclosureUri
    @{words} =    Split String    ${enc}    :
    ${type} =    Get From List    ${words}    0
    ${enc} =    Get From List    ${words}    1
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}    ${connection_type}    ${boot_Mode}    ${boot_order}    ${bandwidth}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    ${san_storage} =    Get From Dictionary    ${profile}    sanStorage
    ${volumeAttachments} =    Get From Dictionary    ${san_storage}    volumeAttachments
    ${volumeAttachments} =    Lookup volume uris   ${volumeAttachments}    ${enc}    ${bay_num}    ${target_wwpn}
    Set to Dictionary   ${san_storage}    volumeAttachments     ${volumeAttachments}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body UEFI Mode
    [Documentation]   Build Server Profiles body required to create the server profile in UEFI mode
    [Arguments]     ${bay_num}    ${profile_body}    ${bandwidth}=${NONE}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile_body}=    Run Keyword If  '${bandwidth}' == '${NONE}'    Build Edit Server Profile body    ${bay_num}    ${profile_body}
    ...    ELSE    Build Edit Server Profile body    ${bay_num}    ${profile_body}    ${bandwidth}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_uefi}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_uefi}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Edit Server Profile body Legacy Mode
    [Documentation]   Build Server Profiles body required to create the server profile in Legacy mode
    [Arguments]     ${bay_num}    ${profile_body}    ${bandwidth}=${NONE}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body for server bay:${bay_num}
    ${profile_body}=    Run Keyword If  '${bandwidth}' == '${NONE}'    Build Edit Server Profile body    ${bay_num}    ${profile_body}
    ...    ELSE    Build Edit Server Profile body    ${bay_num}    ${profile_body}    ${bandwidth}
    ${profile} =    Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}    boot    ${boot_order_legacy}
    Set to Dictionary   ${profile}    bootMode    ${bootmode_legacy}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build Ethernet Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile for Ethernet
    [Arguments]     ${bay_num}    ${profile_body}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body with Ethernet connection for server bay:${bay_num}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    ${uri}=    Get Server HW URI    ${bay_num}
    Set to Dictionary    ${profile}    serverHardwareUri    ${uri}
    ${eg} =     Get from Dictionary    ${profile}  enclosureGroupUri
    @{words} =  Split String    ${eg}    :
    ${type} =   Get From List   ${words}    0
    ${eg} =     Get From List   ${words}    1
    ${uri} =    Get Enclosure Group URI    ${eg}
    Set to Dictionary    ${profile}    enclosureGroupUri    ${uri}
    ${enc} =    Get from Dictionary    ${profile}    enclosureUri
    @{words} =  Split String    ${enc}    :
    ${type} =   Get From List   ${words}    0
    ${enc} =    Get From List   ${words}    1
    ${uri} =    Get Enclosure URI   ${enc}
    Set to Dictionary   ${profile}  enclosureUri    ${uri}
    ${name}=    Catenate  Bay  ${bay_num}
    Set to Dictionary   ${profile}  name    ${name}
    Set to Dictionary   ${profile}  connections    ${enet_connection}
    ${connections} =    Get From Dictionary    ${profile}    connections
    ${connections} =    Lookup Connection Uris  ${connections}
    Set to Dictionary   ${profile}  connections     ${connections}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build FCOE Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile for FCOE connection
    [Arguments]     ${bay_num}    ${profile_body}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body with FCoE connection for server bay:${bay_num}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile_body}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}  connections    ${fcoe_connection}
    ${connections} =    Get From Dictionary    ${profile}    connections
    ${connections} =    Lookup Connection Uris  ${connections}
    Set to Dictionary   ${profile}  connections     ${connections}
    ${body}=    Set Variable    ${profile}
    [Return]    ${body}

Build FC Server Profile body
    [Documentation]   Build Server Profiles body required to create the server profile for FC connection
    [Arguments]     ${bay_num}    ${profile_body}
    fusion_api_appliance_setup.Log to console and logfile      Build PROFILE body with FC connection for server bay:${bay_num}
    ${profile} =    fusion_api_appliance_setup.Copy Dictionary    ${profile_body}
    Set to Dictionary   ${profile}  connections    ${fc_connection}
    ${profile_body}=    Build Server Profile body   ${bay_num}    ${profile}
    ${body}=    Set Variable    ${profile_body}
    [Return]    ${body}

Create Network Set range
    [Documentation]    Create a range of Network Sets based on provided range
	[Arguments]	${range}
	Set Log Level	TRACE
	fusion_api_appliance_setup.Log to console and logfile  	Adding NETWORK SET RANGES
	${body} = 	fusion_api_appliance_setup.Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end
	${netlist} = 	Create List
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Append To List	${netlist}	${range['prefix']}${x}${range['suffix']}
	${networkUris} = 	Get Ethernet URIs	${netlist}
	Set To Dictionary 	${body}	networkUris	${networkUris}
	${nativeNetworkUri} = 	Run Keyword If 	'${range['nativeNetworkUri']}' != 'None'  Get Ethernet URI	${range['nativeNetworkUri']}
	Set To Dictionary 	${body}	nativeNetworkUri	${nativeNetworkUri}
	${resp} = 	Fusion Api Create Network Set		body=${body}
	[Return]	${resp}

Create Ethernet range
    [Documentation]    Create a range of Ethernet networks based on provided range
	[Arguments]	${range}
	Set Log Level	TRACE
	fusion_api_appliance_setup.Log to console and logfile  	Adding ETHERNET NETWORK RANGES
	${body} = 	fusion_api_appliance_setup.Copy Dictionary	${range}
	Remove From Dictionary	${body}	prefix	suffix	start	end

	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	Set To Dictionary 	${body}	name	${range['prefix']}${x}${range['suffix']}
	\	Set To Dictionary 	${body}	vlanId	${x}
	\	${resp} = 	Fusion Api Create Ethernet Network	body=${body}

Create fcoe range
	[Documentation]	Creates a range of FCoE networks based on range data provided
	[Arguments]	${range}
	Set Log Level	TRACE
	fusion_api_appliance_setup.Log to console and logfile  	Adding FCOE NETWORK RANGES
	:FOR	${x}	IN RANGE	${range['start']}	${range['end']}+1
	\	${body} = 	Create Dictionary	name=${range['prefix']}${x}${range['suffix']}	vlanId=${x}	 type=fcoe-networkV4
	\	${resp} = 	Fusion Api Create Fcoe Network	body=${body}
	#\	fusion_api_appliance_setup.Wait For Task	${resp}

Get connectionTemplateUri
	[Documentation]	Retrieves the connectionTemplateUri from a given network {name} of a given {type} where:
	...             {name} is the name of the network
	...             {type} is the type of network: [ethernet, fc, fcoe], default=ethernet
	...             Returns: connectionTemplateUri string
	[Arguments]		${name}   ${type}=ethernet
    Set Log Level	DEBUG
    ${param} =      Set Variable    ?filter="'name'=='${name}'"
	${net} =		Run Keyword If          '${type}' == 'ethernet'      Fusion Api Get Ethernet Networks    param=${param}
	...             ELSE IF                 '${type}' == 'fc'            Fusion Api Get fc Networks          param=${param}
    ...             ELSE IF                 '${type}' == 'fcoe'          Fusion Api Get fcoe Networks        param=${param}
    ...             ELSE                    Log     Invalid network type specified for 'Get connectionTemplateUri'     WARN
	${ct_uri} =     Get From Dictionary      ${net['members'][0]}    connectionTemplateUri

    [Return]    ${ct_uri}

Get Enclosure URI
    [Documentation]    Get Enclosure URI for the named enclosure
	[Arguments]		${enc}
	${resp} = 	Fusion Api Get Enclosures		param=?filter="'name'=='${enc}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Enclosure Group URI
    [Documentation]    Get Enclosure Group URI for the named enclosure group
	[Arguments]		${eg}
	${resp} = 	Fusion Api Get Enclosure Groups
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${eg}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get Ethernet URI
    [Documentation]    Get Ethernet network URI for the named ethernet network
	[Arguments]		${net}
	${resp} = 	Fusion Api Get Ethernet Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Ethernet URIs
    [Documentation]   returns a list of uris for a given list of ethernet network names
	[Arguments]       ${netlist}
	${urilist} =      Uris.get   ETH    ${netlist}
	[Return]	${urilist}

Get FC URI
    [Documentation]    Get FC network URI for the named FC network
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FC Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FC URIs
    [Documentation]   returns a list of uris for a given list of fc network names
	[Arguments]       ${netlist}
	${urilist} =      Uris.get   FC    ${netlist}
	[Return]	${urilist}

Get FCoE URI
    [Documentation]    Get FCpE network URI for the named FCoE network
	[Arguments]		${net}
	${resp} = 	Fusion Api Get FCoE Networks		param=?filter="'name'=='${net}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get FCoE URIs
    [Documentation]   returns a list of uris for a given list of fcoe network names
	[Arguments]       ${netlist}
	${urilist} =      Uris.get   FCOE    ${netlist}
	[Return]	${urilist}

Get IC URI
    [Documentation]    Get Interconnect URI for the named interconnect
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect  		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Interconnect Type URI
    [Documentation]    Get Interconnect type URI for the named interconnect
	[Arguments]		${ic}
	${resp} = 	Fusion Api Get Interconnect Types 		param=?filter="'name'=='${ic}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LE URI
    [Documentation]    Get Logical Enclosure URI for the named logical enclosure
	[Arguments]		${le}
	${resp} = 	fusion api get logical enclosure  		param=?filter="'name'=='${le}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LI member
    [Documentation]    Get Logical Interconnect member
	[Arguments]		${li}
	${resp} = 	    Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${member} = 	Get From List		${resp['members']}  ${x}
	[Return]	${member}

Get LI URI
    [Documentation]    Get Logical Interconnect URI for the named logical interconnect
	[Arguments]		${li}
	${resp} = 	Fusion Api Get LI
	${l} = 	Get Length	${resp['members']}
	:FOR	${x}	IN RANGE	0	${l}
	\ 	Run Keyword If 	'${resp['members'][${x}]['name']}' != '${li}'		Continue For Loop
	\	${uri} = 	Get From Dictionary		${resp['members'][${x}]}	uri
	[Return]	${uri}

Get LIG member
    [Documentation]    Get Logical Interconnect Group member
	[Arguments]		${lig}
	${resp} = 	    Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${member} = 	Get From List		${resp['members']}  0
	[Return]	${member}

Get LIG URI
    [Documentation]    Get Logical Interconnect Group URI for the named logical interconnect group
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get LIG 		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LS URI
    [Documentation]    Get Logical Switch URI for the named logical switch
	[Arguments]		${ls}
	${resp} = 	Fusion Api Get LS 		param=?filter="'name'=='${ls}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get LSG URI
    [Documentation]    Get Logical Switch Group URI for the named logical switch group
	[Arguments]		${lsg}
	${resp} = 	Fusion Api Get LSG 		param=?filter="'name'=='${lsg}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Network Set URI
    [Documentation]    Get Network Set URI for the named network set
	[Arguments]		${lig}
	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${lig}'"
	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	[Return]	${uri}

Get Network Set URIs
    [Documentation]    Get Network Set URIs for the named network set list
	[Arguments]		${netlist}
	${urilist} = 	Create List
	:FOR	${net}	IN	@{netlist}
	\	${resp} = 	Fusion Api Get Network Set		param=?filter="'name'=='${net}'"
	\   Continue For Loop If	  ${resp['members']} == []
	\	${uri} = 	Get From Dictionary		${resp['members'][0]}	uri
	\	Append To List	${urilist}	${uri}
	[Return]	${urilist}

Get Resource by URI
	[Documentation]    Returns any type of resource using its URI
	[Arguments]	${uri}   @{varargs}
    ${resp} =     Fusion Api Get Resource    ${uri}    @{varargs}
	[Return]    ${resp}

Get Server Hardware URI
    [Documentation]    Get ALL Appliance Server Hardware URI
    [Arguments]		${enc_server}
    ${resp} = 	Fusion Api Get Server Hardware
	${shlist} = 	Get From Dictionary	${resp}	members
	:FOR	${sh}	IN	@{shlist}
	\	${name} = 	Get From Dictionary	${sh}	name
	\	Run Keyword If	'${name}' != '${enc_server}'	Continue For Loop
	\ 	${uri} = 	Get From dictionary 	${sh}	uri
	[Return]	${uri}

Get All Server Hardware Type URI
    [Documentation]    Get ALL Appliance Server Hardware Type URI
    [Arguments]		${sht}
    Set Log Level	TRACE
    ${resp} = 	Fusion Api Get Server Hardware Types
    ${l} = 	Get Length	${resp['members']}
    ${uri} =  Set Variable   ${null}
    :FOR    ${i}    IN RANGE    0    ${l}
    \  Log    ${resp['members'][${i}]['name']}
    \  Log    ${sht}
    \    ${uri} =    Run Keyword If    '${resp['members'][${i}]['name']}' == '${sht}'    Set Variable    ${resp['members'][${i}]['uri']}
    \    Exit For Loop If     '${uri}' != '${null}'
    [Return]    ${uri}

Get Server Hardware Type URI
    [Documentation]    Get Appliance Server Hardware Type URI
    [Arguments]    ${sht}
    Set Log Level    TRACE
    ${resp} =    Fusion Api Get Server Hardware Types    param=?filter="'name'=='${sht}'"
    ${uri} =    Get From dictionary    ${resp['members'][0]}    uri
    [Return]    ${uri}

Get Switch Type URI
    [Documentation]    Get Appliance Switch Type URI
    [Arguments]    ${ic}
    ${resp} =    Fusion Api Get Switch Types    param=?filter="'name'=='${ic}'"
    ${uri} =    Get From Dictionary    ${resp['members'][0]}    uri
    [Return]	${uri}

Get Uplinkset URI
    [Documentation]    Get Appliance Uplinkset URI
    [Arguments]    ${us}
    ${resp} =     Fusion Api Get Uplink Set    param=?filter="'name'=='${us}'"
    ${uri} =     Get From Dictionary    ${resp['members'][0]}    uri
    [Return]    ${uri}

Log to console and logfile
    [Documentation]    Log provided data to console and logfile with provided level
	[Arguments]	${data}     ${level}=INFO
	Log	${data}     ${level}
	Log to console	${data}

Wait For Task
    [Documentation]    Waits for a task to reach an end-state
    [Arguments]    ${resp}    ${timeout}=60s    ${interval}=2s    ${taskType}=Default   ${status_code}=${202}
    Log to console    \n
    ${valDict} =    Create Dictionary    status_code=${status_code}
    fusion_api_validation.Validate Response    ${resp}    ${valDict}
    ${task} =    Run Keyword If    '${taskType}' == 'Default'   Wait Until Keyword Succeeds    ${timeout}    ${interval}    fusion_api_appliance_setup.Task Reached Endstate    ${resp}
    ...    ELSE IF    '${taskType}' == 'Restore'   Wait Until Keyword Succeeds    ${timeout}    ${interval}   fusion_api_appliance_setup.Restore Task Reached Endstate    ${resp}
    ...    ELSE    Fail    msg=The taskType specified is invalid. Please use 'Default' or 'Restore'...
    [Return]    ${task}

Task Reached Endstate
    [Documentation]    Waits for a task to reach an end-state
    [Arguments]    ${resp}
    Set Log Level    TRACE
    #Should Contain	${resp}	uri
    ${location} =    Get Variable Value    ${resp['headers']['location']}
    ${task_uri} =    Run Keyword If    '${location}' is 'None'    Get From Dictionary    ${resp}    uri
    ...     ELSE    Get Variable Value    ${location}
    Should Not Be Empty    ${task_uri}    msg=No task uri could be retreived from response
     # Hack for backup task uri that contains https://IP in error
    ${task_uri} =    Remove String    ${task_uri}    https://    ${APPLIANCE_IP}
    ${task} =    Fusion Api Get Task    uri=${task_uri}
    ${task_state} =    Get From Dictionary    ${task}    taskState
    ${task_category} =    Get From Dictionary    ${task}    	category
    ${task_name} =    Get From Dictionary    ${task}    name
    ${resource} =    Run Keyword If   ${task['associatedResource']} is not ${null}   Get From Dictionary    ${task['associatedResource']}    resourceName
    ${resource_uri} =    Run Keyword If   ${task['associatedResource']} is not ${null}   Get From Dictionary    ${task['associatedResource']}    resourceUri
    fusion_api_appliance_setup.Log to console and logfile    \t Task: [${task_category}:${task_name}] is: ${task_state} for resource: ${resource} ${resource_uri}
    Should Match Regexp    ${task_state}    ((?i)Warning|Unknown|Terminated|Killed|Error|Completed)
    ${failedsubtasks} =    Run Keyword If     '${task_state}' != 'Completed'    fusion api get task    param=?filter="parentTaskUri='${task_uri}'"&filter="taskState ne 'Completed'"
    [Return]    ${task}

Restore Task Reached Endstate
    [Documentation]    Waits for a restore task to reach an end-state
    [Arguments]	${resp}
    Set Log Level	TRACE
    Should Not Be Empty     ${resp['uri']}    msg=No task uri could be retreived from response
    ${task} = 		Fusion Api Get Task		uri=${resp['uri']}
    ${task_status} = 	Get From Dictionary		${task}		status
    ${task_category} = 	Get From Dictionary		${task}		category
    ${task_id} = 		Get From Dictionary		${task}		id
    ${task_percentComplete} =   Get From Dictionary		${task}		percentComplete
    ${task_restorePhase} = 	    Get From Dictionary		${task}	        restorePhase	
    fusion_api_appliance_setup.Log to console and logfile  	\t Task: [${task_category}:${task_id}] is: ${task_status}(${task_percentComplete}%) [${task_restorePhase}] : ${resp['uri']}
    Should Match Regexp	${task_status}	((?i)FAILED|SUCCEEDED|UNKNOWN)
    [Return]	${task}

Wait For Forked Tasks
    [Documentation]    Wait for forked tasks (off the response body list of dictionary) to reach end state
    [Arguments]    ${respList}    ${valDict}    ${timeout}    ${interval}=5s    ${validate}=${True}
    Wait Until Keyword Succeeds    ${timeout}    ${interval}    fusion_api_appliance_setup.Forked Tasks Reached Endstate     ${respList}   ${valDict}   ${validate}

Forked Tasks Reached Endstate
    [Documentation]    Look up through all the forked tasks to see if they reached end state
    [Arguments]    ${respList}    ${valDict}    ${validate}=${True}
    ${match} =    Set Variable    ${False}
    ${popped} =    Set Variable    ${null}
    ${l} = 	  Get Length    ${respList}
    ${taskStateList} =    Create List    Warning  Unknown  Terminated  Killed  Error  Completed
    :FOR    ${x}    IN RANGE   0    ${l}
    \    ${location} =    Get Variable Value    ${respList[${x}]['headers']['location']}
    \    ${task_uri} =    Run Keyword If    '${location}' is 'None'    Get From Dictionary    ${respList[${x}]}    uri
    \    ...     ELSE    Get Variable Value    ${location}
    \    Should Not Be Empty    ${task_uri}    msg=No task uri could be retreived from response.
    \    ${task} =    Fusion Api Get Task    uri=${task_uri}
    \    ${match} =    Run Keyword If    ${validate} == ${True}    Match Value In List    ${task['taskState']}   ${taskStateList}
    \    ${popped} =    Run Keyword If    ${match} is ${True}    Remove From List     ${respList}    ${x}
    \    Run Keyword If    ${validate} == ${True}    fusion_api_appliance_setup.Log to console and logfile     \t Task: [${task['category']}:${task['name']}] is: ${task['taskState']} for resource: ${task['associatedResource']['resourceName']} ${task['associatedResource']['resourceUri']}
    \    Run Keyword If    ${popped} is not ${null}    fusion_api_validation.Validate Response    ${task}    ${valDict}
    Should Be Equal As Integers    ${l}    0

Wait For Task And Validate Response
    [Documentation]    Wait for task and validate response
    [Arguments]    ${resp}    ${valDict}    ${timeout}    ${interval}=15s    ${validate}=${True}
    ${task} =     fusion_api_appliance_setup.Wait For Task    ${resp}    ${timeout}   ${interval}
    Run Keyword If   ${validate} == ${True}    fusion_api_validation.Validate Response    ${task}   ${valDict}

Wait For Appliance To Be Ready
	[Documentation]	Waits for an appliance reach a the ready state
	[Arguments]		${appliance}	${timeout}=20 min	${interval}=30 s
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance Reached Ready State	${appliance}

Wait For Appliance To Become Pingable
	[Documentation]	Waits for an appliance to become pingable
	[Arguments]		${appliance}	${timeout}=1 min	${interval}=5 s
	fusion_api_appliance_setup.Log to console and logfile 		Pinging: ${appliance} ...
	Wait Until Keyword Succeeds		${timeout}	${interval}	Appliance is pingable 	${appliance}

Appliance is pingable
	[Documentation]    check if the provided appliance is pingable
	[Arguments]		${appliance}
	Set Log Level	TRACE
	Run keyword if	os.name == "nt"	Windows ping	${appliance}
	...	ELSE	Unix ping	${appliance}

Unix ping
	[Documentation]    check if provided Linux host is pingable
	[Arguments]		${host}
    ${Output}=    Run    ping -c 4 ${host}
    fusion_api_appliance_setup.Log to console and logfile    ${Output}
    Should Contain    ${Output}    ttl=
	[Return]	${Output}

Windows ping
	[Documentation]    check if provided Windows host is pingable
	[Arguments]		${host}
    ${Output}=    Run    ping -n 4 ${host}
    fusion_api_appliance_setup.Log to console and logfile    ${Output}
    Should Contain    ${Output}    TTL=
	[Return]	${Output}

Appliance Reached Ready State
	[Documentation]    check if appliance is in OK state
	[Arguments]		${appliance}
	${state} = 	Fusion Api Get Resource		${appliance}/controller-state.json
	fusion_api_appliance_setup.Log to console and logfile	-Appliance state: ${state['state']}
	Should Match Regexp	${state['state']}	((?i)OK)

First Time Setup
	[Documentation]	Changes intial administrator password, answers EULA, enables service access, adds licenses, configures appliance interfaces.
	...	If args are null, uses XML ${DATAFILE}
	[Arguments]	${DATAFILE}=${null}	${password}=${null}	${interface}=eth0
	#${password} =	Set Variable	${password}
	fusion_api_appliance_setup.Log to console and logfile	[FIRST TIME SETUP]
	Wait For Appliance To Become Pingable	${APPLIANCE_IP}
	Wait For Appliance To Be Ready			${APPLIANCE_IP}
	fusion_api_appliance_setup.Log to console and logfile	-Agree to EULA
	Fusion Api Save EULA	${APPLIANCE_IP}
	fusion_api_appliance_setup.Log to console and logfile	-Enable service access
	Fusion Api Set service access	${APPLIANCE_IP}

	${req} = 		Create Dictionary		newPassword=${password}
	...										oldPassword=admin
	...										userName=Administrator
	#Run Keyword If	${password} is not ${null}	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Change Administrator password	host=${APPLIANCE_IP}	body=${req}
	Fusion Api Login Appliance 		${APPLIANCE_IP}		${admin_credentials}
    ${resp} =    Fusion Api Get Appliance Version
    Set Suite Metadata     OneView Version      ${resp['softwareVersion']}    top=True
	#Add licenses from variable		${licenses}
	Configure Appliance Interfaces    ${interface}

Configure Appliance Interfaces
	[Documentation]	Configures the appliance interfaces.
	...   for C7000, interface=eth0, for Synergy, interface=bond0
	...	  If args are null, uses XML ${DATAFILE}
	[Arguments]    ${interface}=eth0
	fusion_api_appliance_setup.Log to console and logfile	-Configuring Appliance Interfaces, Time, Locale
	${resp} =	Fusion Api Get Appliance Interface Mac	${interface}
	Set to dictionary	${appliance['applianceNetworks'][0]}	macAddress	${resp}
	${ipv4Type} = 		Get Variable Value 	${appliance['applianceNetworks'][0]['ipv4Type']}
	${app1Ipv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['app1Ipv4Addr']}
    ${virtIpv4Addr} = 	Get Variable Value	${appliance['applianceNetworks'][0]['virtIpv4Addr']}
	Sleep 	10s
	${resp} = 	Fusion Api Configure Appliance Interfaces			${appliance}
	# if STATIC, get new IP and login. for 2.00, use virtIpv4Addr (Tbird), otherwise use app1Ipv4Addr
    Run Keyword If	'${virtIpv4Addr}' is not 'None'     			Set New IP and Login	${virtIpv4Addr}
	...             ELSE IF     '${app1Ipv4Addr}' is not 'None'     Set New IP and Login	${app1Ipv4Addr}
	...             ELSE    Log     Either app1Ipv4Addr or virtIpv4Addr must be provided in the 'appliance' variable in your data file     WARN

	fusion_api_appliance_setup.Wait For Task	${resp}		timeout=200s		interval=5s
	${resp} = 	Fusion Api Configure Appliance Time and Locale			${timeandlocale}
	fusion_api_appliance_setup.Wait For Task	${resp}		timeout=200s		interval=5s

Set New IP and Login
    [Documentation]    Logging in to the Appliance via IP
    [Arguments]    ${IP}
    Set Suite Variable    ${APPLIANCE_IP}    ${IP}
    Sleep    60s
    Wait For Appliance To Become Pingable    ${APPLIANCE_IP}
    Fusion Api Login Appliance    ${APPLIANCE_IP}    ${admin_credentials}

Login All Users
    [Documentation]    Logging in all users from list
    [Arguments]     ${users}
    Set Log Level    TRACE
    ${original_user} =    Fusion Api Get Active User
    :FOR    ${user}    IN    @{users}
    \    ${user_and_pass} = 	Create Dictionary	userName=${user['userName']}	password=${user['password']}
    \    Fusion Api Login Appliance 		${APPLIANCE_IP}		${user_and_pass}
    Fusion api switch active user    user=${original_user}

Get Task By Param
    [Documentation]    Get task by param
    ...    Examples:
    ...    Get Task By Param param=?filter='name'=='Discover hardware'&sort=created:descending&count=1
    ...    Get Task By Param param=?filter="'name'='Add' AND associatedResource.resourceName='${name}'"&sort=created:descending&count=1
    [Arguments]    ${param}
    ${resp}=    Fusion Api Get Task    param=${param}
    fusion_api_appliance_setup.Log to console and logfile    ${resp}    TRACE
    ${status} =    Run keyword and return status    Dictionary should contain key    ${resp}    'errorCode'
    Return from keyword if    ${status}==${True}    ${resp}
    ${count} =    Get From Dictionary    ${resp}    count
    Return from keyword if    ${count}==0    ${resp}
    [Return]    ${resp['members'][0]}

Check For Whitespace From String
    [Documentation]   Check for whitespace from string. Returns true if whitespace exists else return false.
    [Arguments]    ${string}
    @{stringList} =    Split String    ${string}
    ${l} =    Get Length    ${stringList}
    ${result} =    Run Keyword If    ${l} > 1    Set Variable    ${True}
    ...                   ELSE    Set Variable   ${False}
    [Return]    ${result}

