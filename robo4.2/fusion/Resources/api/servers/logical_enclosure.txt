*** Settings ***
Library				RoboGalaxyLibrary
Library				FusionLibrary
Library				OperatingSystem
Library				BuiltIn
Library				Collections
Library				XML
Library		        SSHLibrary
Library				String
Library				Dialogs

*** Keywords ***
Get Logical Enclosure URI
    [Documentation]    Returns the uri for the provided LE name
	[Arguments]  ${name}
	${resp} = 	Fusion Api Get Logical Enclosure  param=?filter="'name' = '${name}'"
	${count} =  Get From Dictionary  ${resp}  count
	Return from keyword if  ${count}==0  /rest/Logical_Enclosure_${name}_not_found
	${uri} = 	Get From Dictionary  ${resp['members'][0]}  uri
	[Return]	${uri}

Get Logical Enclosure Details by name
    [Documentation]	Returns the entire response of all the Logical enclosures in the appliance by filtering the LE by name.
	Log  	Getting Logical ENclosure Details   console=True
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${resp} = 	   Fusion Api Get Logical Enclosure  param=?filter="'name' = '${enc['name']}'"
	\		Log  	resp:${resp}
	\   	${count} =  Get From Dictionary  ${resp}  count
	\       Return from keyword if  $count==0  /rest/Logical_Enclosure_${enc[name]}_not_found
	[Return]	${resp}


Get Logical Enclosures By Uri
	[Documentation]	Returns the entire response of the logical enclosure by executing the get rest call rest/logical-enclosures/le-uuid
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${uri} =  Get Logical Enclosure URI    ${enc['name']}
	\		${response} =  Fusion Api Get Logical Enclosure  uri=${uri}
	\		Log    response:${response}
	[Return]	${response}


Get Logical Enclosure By Name
    [Documentation]    Returns the LE object for a given LE name
	[Arguments]  ${name}
	${uri} = 	Get Logical Enclosure URI   ${name}
	${resp} = 	Fusion Api Get Logical Enclosure  ${uri}
	[Return]	${resp}


Add Logical Enclosure from variable
	[Documentation]	Adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}
	Log    Adding LOGICAL ENCLOSURE    console=True
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	@{words} = 	Split String	${eguri}	:
	${type} = 	Get From List	${words}	0
	${e} = 		Get From List	${words}	1
	${eguri} = 	Get Enclosure Group URI	${e}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
    ${xenc} =   copy dictionary   ${enc}
	Set to dictionary	${xenc}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\   	@{words} = 	Split String	${encuri}	:
	\       ${type} = 	Get From List	${words}	0
	\       ${e} = 		Get From List	${words}	1
	\       ${encuri} = 	Get Enclosure URI	${e}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${xenc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Create Logical Enclosure 	${xenc}
    ${task} =   Wait For Task2   ${resp}     120min  1min
	[Return]  ${task}

Add Logical Enclosure from variable Async
    [Documentation]  Asynchronously adds a Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
    [Arguments]    ${enc}
    Log       Adding LOGICAL ENCLOSURE       console=True
    ${eguri} =     Get From Dictionary    ${enc}    enclosureGroupUri
    @{words} =     Split String    ${eguri}    :
    ${type} =     Get From List    ${words}    0
    ${e} =        Get From List    ${words}    1
    ${eguri} =     Get Enclosure Group URI    ${e}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
    Set to dictionary    ${enc}    enclosureGroupUri        ${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
    \       @{words} =     Split String    ${encuri}    :
    \       ${type} =     Get From List    ${words}    0
    \       ${e} =        Get From List    ${words}    1
    \       ${encuri} =     Get Enclosure URI    ${e}
    \       Append to List    ${encuri_list}    ${encuri}

    set to dictionary   ${enc}  enclosureUris   ${encuri_list}
    ${resp} =    Fusion Api Create Logical Enclosure     ${enc}
    [Return]  ${resp}

Add Logical Enclosure from list
	[Documentation]  Add Logical Enclosure from a LE list
    ...              Example:
    ...                Add Logical Enclosure from list  ${list}
    ...              Data Required:
    ...                List of Logical Enclosure DTO
    [Arguments]  ${list}  ${timeout}=2400  ${interval}=10
    Log 	${\n}Adding Logical Enclosure from list
    Run Keyword for List  ${list}  Add Logical Enclosure from variable

Add Logical Enclosure from lists
	[Documentation]  Add Logical Enclosure from a LE list
    ...              Example:
    ...                Add Logical Enclosure from list  ${list}
    ...              Data Required:
    ...                List of Logical Enclosure DTO
    [Arguments]  ${list}  ${verify}=False    ${name}=null    ${expected_list}=@empty    ${Status_code}=200    ${timeout}=2400  ${interval}=10   ${notFoundStatusCodeList}=404
    Log 	${\n}Adding Logical Enclosure from list
    ${toAdd} =  Create List
    :FOR    ${le}   IN      @{list}
    \   ${resp} =   Get Resource    LE:${le['name']}
    \   ${statusCode} =     Convert To String   ${resp['status_code']}
    \   ${status} =     Run Keyword And Return Status   List Should Contain Value   ${notFoundStatusCodeList}   ${statusCode}
    \   Run Keyword If  ${status}==False    Log     Logical Enclosure ${le['name']} Already Exists  WARN
    \   Run Keyword If  ${status}==True     Append To List  ${toAdd}    ${le}
    ${count} =  Get Length  ${toAdd}
    Return From Keyword If  '${count}'=='0'
    Run Keyword for List  ${toAdd}  Add Logical Enclosure from variable
	${response} =    Run Keyword If    ${VERIFY}==True    Get Logical Enclosure Details by name    ${name}
	${result} =    Run Keyword If    ${VERIFY}==True    Fusion Api Validate Response Follow    ${expected_les}    ${response}    #wordy=${TRUE}

Add Logical Enclosure from lists Async
    [Documentation]  Add Logical Enclosure asynchronously from a LE list
    ...              Example:
    ...                Add Logical Enclosure from list  ${list}
    ...              Data Required:
    ...                List of Logical Enclosure DTO
    [Arguments]  ${list}    ${VERIFY}=${FALSE}    ${expected_logical_enclosure}=@empty   ${name}=null    ${Status_code}=200    ${timeout}=2400  ${interval}=10   ${notFoundStatusCodeList}=404
    Log     ${\n}Adding Logical Enclosure from list
    ${toAdd} =  Create List
    ${responses}=    Create List
    :FOR    ${le}   IN      @{list}
    \   ${resp} =   Get Resource    LE:${le['name']}
    \   ${statusCode} =     Convert To String   ${resp['status_code']}
    \   ${status} =     Run Keyword And Return Status   List Should Contain Value   ${notFoundStatusCodeList}   ${statusCode}
    \   Run Keyword If  ${status}==False    Log     Logical Enclosure ${le['name']} Already Exists  WARN
    \   Run Keyword If  ${status}==True     Append To List  ${toAdd}    ${le}
    ${count} =  Get Length  ${toAdd}
    Return From Keyword If  '${count}'=='0'
    :FOR    ${le}   IN      @{list}
    \    ${response}=     Run Keyword And Continue on Failure  Add Logical Enclosure from variable Async   ${le}
    \    Append to List  ${responses}  ${response}
    Run Keyword If     ${responses} is not ${null}   Wait For Task2    ${responses}    120min    1min
    # If !{VERIFY}, then we're done
    Return From Keyword If  ${VERIFY}==${FALSE}
    Verify Resources for List           ${expected_logical_enclosure}

Update Logical Enclosure Firmware
    [documentation]    Updates the firmware on an LE
    [Arguments]     ${le_name}
    ...             ${firmwareBaseline}
    ...             ${forceInstallFirmware}=${True}
    ...             ${firmwareUpdateOn}=SharedInfrastructureOnly
    ...             ${logicalInterconnectUpdateMode}=Parallel
    ...             ${updateFirmwareOnUnmanagedInterconnect}=${False}
    ...             ${alidateIfLIFirmwareUpdateIsNonDisruptive}=${False}
    Log  Updating ${firmwareBaseline} firmware for ${le_name}   console=True
    ${uri} =    Get Logical Enclosure URI    ${le_name}
    ${LE} =     Fusion Api Get Logical Enclosure    ${uri}
    ${eTag} =   Get From Dictionary  ${LE}  eTag
    ${firmwareBaseline} =    Run keyword If    '${firmwareBaseline}' != ''    Get Firmware Bundle By Version  ${firmwareBaseline}
    ...                      ELSE              Get Variable Value   ${firmwareBaseline}
    ${firmware_data} =    Create Dictionary    firmwareBaselineUri=${firmwareBaseline}
    ...                                        forceInstallFirmware=${forceInstallFirmware}
    ...                                        firmwareUpdateOn=${firmwareUpdateOn}
    ...                                        logicalInterconnectUpdateMode=${logicalInterconnectUpdateMode}
    ...                                        updateFirmwareOnUnmanagedInterconnect=${updateFirmwareOnUnmanagedInterconnect}
    ...                                        validateIfLIFirmwareUpdateIsNonDisruptive=${alidateIfLIFirmwareUpdateIsNonDisruptive}
    ${body} =   Create Dictionary         op=replace
    ...                                   path=/firmware
    ...                                   value=${firmware_data}
    ${body} =   Create list     ${body}
    ${resp} =   Fusion Api LE Firmware Update   body=${body}    uri=${uri}      etag=${eTag}
    ${task} =  Wait For Task     ${resp}     100min    30s
    ${taskState} =    Get From Dictionary        ${task}     taskState
    Log   Update task state: ${taskState}   console=True
    Should Match    ${taskState}    Completed
    [Return]    ${task}

Update Logical Enclosure Firmware Async
    [Documentation]    Updates the firmware on an LE Asynchronously
    ...              Example:
    ...                Update Logical Enclosure from Group Async  ${le_name}  ${firmwareBaseline}
    ...              Data Required:
    ...                Logical Enclosure Name and Firmware BaseLine
    [Arguments]     ${le_name}
    ...             ${firmwareBaseline}
    ...             ${forceInstallFirmware}=${True}
    ...             ${firmwareUpdateOn}=SharedInfrastructureOnly
    ...             ${logicalInterconnectUpdateMode}=Parallel
    ...             ${updateFirmwareOnUnmanagedInterconnect}=${False}
    ...             ${alidateIfLIFirmwareUpdateIsNonDisruptive}=${False}
    ...             ${le_firmware_timeout}=10000
    ${responses}=  Create List
    :FOR  ${le}  IN  @{le_name}
    \  Log  Updating ${firmwareBaseline} firmware for ${le['name']}   console=True
    \  ${uri} =    Get Logical Enclosure URI    ${le['name']}
    \  ${LE} =     Fusion Api Get Logical Enclosure    ${uri}
    \  ${eTag} =   Get From Dictionary  ${LE}  eTag
    \  ${firmwareBase} =    Run keyword If    '${firmwareBaseline}' != ''    Get Firmware Bundle By Version  ${firmwareBaseline}
    \  ...                      ELSE              Get Variable Value   ${firmwareBaseline}
    \  ${firmware_data} =    Create Dictionary    firmwareBaselineUri=${firmwareBase}
    \  ...                                        forceInstallFirmware=${forceInstallFirmware}
    \  ...                                        firmwareUpdateOn=${firmwareUpdateOn}
    \  ...                                        logicalInterconnectUpdateMode=${logicalInterconnectUpdateMode}
    \  ...                                        updateFirmwareOnUnmanagedInterconnect=${updateFirmwareOnUnmanagedInterconnect}
    \  ...                                        validateIfLIFirmwareUpdateIsNonDisruptive=${alidateIfLIFirmwareUpdateIsNonDisruptive}
    \  ${body} =   Create Dictionary         op=replace
    \  ...                                   path=/firmware
    \  ...                                   value=${firmware_data}
    \  ${body} =   Create list     ${body}
    \  ${resp} =   Fusion Api LE Firmware Update   body=${body}    uri=${uri}      etag=${eTag}
    \  Append to List  ${responses}  ${resp}
    Run Keyword If  ${responses} is not ${null}   Wait For Task2  ${responses}     timeout=${le_firmware_timeout}    interval=100

Update Logical Enclosure from Group
    [Documentation]  Update Logical Enclosure from group
    ...              Example:
    ...                Update Logical Enclosure from Group  ${dto}
    ...              Data Required:
    ...                Logical Enclosure DTO
    [Arguments]  ${dto}   ${VERIFY}=False    ${timeout}=5000    ${interval}=10
    ${name} =  Get From Dictionary  ${dto}  name
    Log 	${\n}Update Logical Enclosure ${name} from group
    ${uri} =  Get Logical Enclosure URI  ${name}
    Log 	${\n}Update Logical Enclosure uri:${uri} from group if istatus is inconsistent
   	${resple} =  Fusion Api Get Logical Enclosure  uri=${uri}
    ${resp} =    Run keyword If    '${resple['state']}' == 'Inconsistent'    Fusion Api Update Logical Enclosure from Group    ${uri}
    ...    ELSE IF        '${resple['state']}' == 'Consistent'    Log     Logical Enclosure:${name} is already in Consistent state     ERROR
    ${status}  ${task_uri} =  Run Keyword and Ignore Error  Get From Dictionary  ${resp['headers']}  location
    Return From Keyword If    '${status}'=='FAIL'    ${resp}
    Log  The task URI is ${task_uri}
	${task} =  Fusion Api Get Task  uri=${task_uri}
    Wait For Task2  ${task}  timeout=${timeout}  interval=${interval}
    ${response} =    Fusion Api Get Logical Enclosure    uri=${uri}
	Run keyword If    '${VERIFY}'=='True' and '${response['state']}' == 'Consistent'    Log     After updateFromGroup the Logical Enclosure:${name} is back to Consistent state
    ...    ELSE IF        '${VERIFY}'=='True' and '${response['state']}' == 'Inconsistent'    Log     After updateFromGroup the Logical Enclosure:${name} is not back to Consistent state     ERROR

Update Logical Enclosure from Group Async
    [Documentation]  Update Logical Enclosure from group async
    ...              Example:
    ...                Update Logical Enclosure from Group Async  ${dto}
    ...              Data Required:
    ...                Logical Enclosure DTO
    [Arguments]  ${dto}
    ${name} =  Get From Dictionary  ${dto}  name
    Log   ${\n}Update Logical Enclosure ${name} from group
    ${uri} =  Get Logical Enclosure URI  ${name}
    Log  ${\n}Update Logical Enclosure uri:${uri} from group if status is inconsistent
    ${resple} =  Fusion Api Get Logical Enclosure  uri=${uri}
    ${resp} =    Run keyword If    '${resple['state']}' == 'Inconsistent'    Fusion Api Update Logical Enclosure from Group    ${uri}
    ...    ELSE IF        '${resple['state']}' == 'Consistent'    Log     Logical Enclosure:${name} is already in Consistent state     ERROR
    ${status}  ${task_uri} =  Run Keyword and Ignore Error  Get From Dictionary  ${resp['headers']}  location
    Return From Keyword If    '${status}'=='FAIL'    ${resp}
    [Return]  ${resp}

Update Logical Enclosure from Group from list
    [Documentation]  Update Logical Enclosure from group from list
    ...              Example:
    ...                Update Logical Enclosure from group from list  ${list}
    ...              Data Required:
    ...                List of LE
    [Arguments]  ${list}  ${timeout}=300  ${interval}=10
    Log 	${\n}Updating Logical Enclosure from Group from list
    Run Keyword for List with kwargs  ${list}  Update Logical Enclosure from Group  timeout=${timeout}  interval=${interval}


Update Logical Enclosure License From Variable
    [Documentation]  Update Logical Enclosure from variable
    ...              Example:
    ...                Update Logical Enclosure From Variable  ${body}  ${uri}
    ...              Data Required:
    ...                Body of LE,  uri of LE
    ...              Example:
    ...              le = {
    ...                   "type": "LogicalEnclosureV300",
    ...                   "name": LE_name,   #user should defined logical enclosure name
    ...                   "enclosureGroupUri": "EG:" + EG_name,  #user should defined enclosure groups name
    ...                   "enclosureUris": Enclosure_list,  #user should defined enclosure list data
    ...                   "enclosures": {
    ...                       "CN754406XL": {
    ...                           "enclosureUri": "CN754406XL",
    ...                           "interconnectBays": [{"bayNumber": 1, "licenseIntent": "No"},
    ...                                                {"bayNumber": 2, "licenseIntent": "No"},
    ...                                                {"bayNumber": 3, "licenseIntent": "Yes"},
    ...                                                {"bayNumber": 4, "licenseIntent": "No"},
    ...                                                {"bayNumber": 5, "licenseIntent": "No"},
    ...                                                {"bayNumber": 6, "licenseIntent": "No"}
    ...                                                ]
    ...                       },
    ...                       "CN754404R6": {
    ...                           "enclosureUri": "CN754404R6",
    ...                           "interconnectBays": [{"bayNumber": 1, "licenseIntent": "No"},
    ...                                                {"bayNumber": 2, "licenseIntent": "No"},
    ...                                                {"bayNumber": 3, "licenseIntent": "No"},
    ...                                                {"bayNumber": 4, "licenseIntent": "No"},
    ...                                                {"bayNumber": 5, "licenseIntent": "No"},
    ...                                                {"bayNumber": 6, "licenseIntent": "Yes"}
    ...                                                ]
    ...                       },
    ...                     }
    [Arguments]    ${le}  ${uri}

    Log    Updating LOGICAL ENCLOSURE   console=True
    ${eguri} =  Get From Dictionary  ${le}  enclosureGroupUri
    @{words} =  Split String    ${eguri}    :
    ${type} =   Get From List   ${words}    0
    ${e} =      Get From List   ${words}    1
    ${eguri} =  Get Enclosure Group URI     ${e}
    Set To Dictionary   ${le}  enclosureGroupUri   ${eguri}
    ${encuris} =    Get From Dictionary     ${le}  enclosureUris
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
    \       @{words} =  Split String    ${encuri}   :
    \       ${type} =   Get From List   ${words}    0
    \       ${e} =      Get From List   ${words}    1
    \       ${encuri_new} =     Get Enclosure URI   ${e}
    \       Append to List  ${encuri_list}  ${encuri_new}
    Set To Dictionary   ${le}  enclosureUris   ${encuri_list}
    Dictionary Should Contain Key   ${le}  enclosures
    ${encBodys} =    Get From Dictionary   ${le}  enclosures
    ${encBodysKeys}=    Get Dictionary Keys  ${encBodys}
    :FOR    ${encKey}    IN   @{encBodysKeys}
    \       ${encValue}=    Get from dictionary    ${encBodys}  ${encKey}
    \       Remove From Dictionary    ${encBodys}  ${encKey}
    \       ${encuri_new} =     Get Enclosure URI   ${encKey}
    \       Set To Dictionary    ${encValue}  enclosureUri=${encuri_new}
    \       Set To DIctionary    ${encBodys}  ${encuri_new}=${encValue}
    ${LEncl} =     Fusion Api Get Logical Enclosure    ${uri}
    ${eTag} =   Get From Dictionary  ${LEncl}  eTag
    Set To Dictionary   ${le}  eTag   ${eTag}
    Set To Dictionary   ${le}  uri   ${uri}
    ${resp}=    Fusion Api Update Logical Enclosure    body=${le}    uri=${uri}    etag=${eTag}
    ${task}=    Wait For Task   ${resp}    2min    2s
    [Return]    ${task}

Remove ALl LEs for CClass
	[Documentation]	Querys the appliance for all Enclosures and then removes them and later verifies the the LE's.
	[Arguments]  ${VERIFY}=${FALSE}  ${STATUS_CODE}=404  ${force}=${False}  ${timeout}=1200  ${interval}=30
	Log  	Removing Logical ENCLOSURES   console=True
	${encs} = 	Fusion Api Get Enclosures
	:FOR	${enc}	IN	@{encs['members']}
	\		${leuri} = 	  Get Logical Enclosure URI		name=${enc['name']}
	\		${resp} = 	   Fusion Api Remove Enclosure		uri=${enc['uri']}
	\		${task} =	   Wait For Task 	${resp} 	240s	10s
	\       ${val} =       Create Dictionary   taskState=Completed
	\       ${result} =    Validate Response    ${task}	${val}
	\		${response} =  Fusion Api Get Logical Enclosure  uri=${leuri}
	\       ${response_code} =     Run keyword If    '${VERIFY}'=='True'    Convert To String    ${response}
	\       ${matchedValue} =      Run keyword If    '${VERIFY}'=='True'    Get Regexp Matches     ${response_code}     [0-9]+
	\       Log  	matchedValue:${matchedValue}
	\       Run Keyword If	       '${VERIFY}'=='True' and '${matchedValue[0]}' == '${STATUS_CODE}'     Log       Delete SUCCESS for LE URI:${leuri} and its Response:${response_code}
	\       ...    ELSE IF         '${VERIFY}'=='True' and '${matchedValue[0]}' != '${STATUS_CODE}'     Log       Deleted FAILED for LE URI:${leuri} and its Response:${response_code}     ERROR



Remove All LEs
	[Documentation]	Querys the appliance for all LE and then removes them
	 ...              Example:
    ...                 Remove All LEs
    ...                 Remove All LEs  timeout=2400  interval=10
    ...                 Remove All LEs  force=${True}  timeout=2400  interval=10
	[Arguments]  ${force}=${False}  ${timeout}=1200  ${interval}=30
	Log  	${\n}Removing All Logical Enclosures
	# Set the force flag
	${param} =  set variable if  ${force}==${False}  ${Empty}  ?force=${True}
	${list} = 	fusion api get logical enclosure
	:FOR	${element}	IN	@{list['members']}
	\       Log  ${\n}Removing Logical Enclosure ${element['name']}   console=True
	\		${resp} = 	fusion api delete logical enclosure  uri=${element['uri']}  param=${param}
	\       ${status}  ${task_uri} =  Run Keyword and Ignore Error  Get From Dictionary  ${resp['headers']}  location
    \       Continue For Loop If  '${status}'=='FAIL'
    \		Log  The task URI is ${task_uri}   console=True
	\		${task} =  Fusion Api Get Task  uri=${task_uri}
	\		Wait For Task2  ${task}  timeout=${timeout}  interval=${interval}

Remove All LEs Async
    [Documentation]     Querys the appliance for all LE and then removes them
     ...              Example:
    ...                 Remove All LEs Async
    ...                 Remove All LEs Async    timeout=2400  interval=10
    ...                 Remove All LEs Async    force=${True}  timeout=2400  interval=10
    [Arguments]  ${force}=${False}  ${timeout}=1200  ${interval}=10     ${notFoundStatusCodeList}=404
    Log      ${\n}Removing All Logical Enclosures
    # Set the force flag
    ${param} =  set variable if  ${force}==${False}  ${Empty}  ?force=${True}
    ${response} =   Create List
    ${list} =   fusion api get logical enclosure
    ${count} =     Convert To String   ${list['count']}
    Run Keyword If     '${count}'=='0'     Log     No LE to Delete  WARN
    Run Keyword If     '${count}'=='0'     Pass Execution   Exiting Test
    :FOR    ${element}  IN  @{list['members']}
    \       Log  ${\n}Removing Logical Enclosure ${element['name']}   console=True
    \       ${resp} =   fusion api delete logical enclosure  uri=${element['uri']}  param=${param}
    \       ${status}  ${task_uri} =  Run Keyword and Ignore Error  Get From Dictionary  ${resp['headers']}  location
    \       Continue For Loop If  '${status}'=='FAIL'
    \       append to list      ${response}     ${resp}
    Run Keyword If     ${response} is not ${null}  Wait For Task2   ${response}  timeout=${timeout}    interval=${interval}
    :FOR    ${element}  IN  @{list['members']}
    \   ${resp} =       Get Resource  LE:${element['name']}
    \   ${statusCode}=  Convert To String  ${resp['status_code']}
    \   ${status}=      Run Keyword And Return Status   List Should Contain Value  ${notFoundStatusCodeList}  ${statusCode}
    \   Run Keyword If    ${status}==False  Fail    Logical Enclosure ${element['name']} was not deleted successfully

Create Logical Enclosure Payload
	[Documentation]	Create Logical Enclosure Payload
	[Arguments]		${le}
	Log  	Creating LOGICAL ENCLOSURE Payload   console=True
	${eguri} = 	Get From Dictionary	${le}	enclosureGroupUri
	@{words} = 	Split String	${eguri}	:
	${type} = 	Get From List	${words}	0
	${e} = 		Get From List	${words}	1
	${eguri} = 	Get Enclosure Group URI	${e}
    ${encuris} =    Get From Dictionary     ${le}  enclosureUris
	Set to dictionary	${le}	enclosureGroupUri		${eguri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\   	@{words} = 	Split String	${encuri}	:
	\       ${type} = 	Get From List	${words}	0
	\       ${e} = 		Get From List	${words}	1
	\       ${encuri} = 	Get Enclosure URI	${e}
	\       Append to List	${encuri_list}	${encuri}
	set to dictionary   ${le}  enclosureUris   ${encuri_list}
    [Return]    ${le}


Verify Logical Enclosure
    [Documentation]  Verify Logical Enclosure  DTO with the expected one
    ...              **kwargs are used to add key value pair to the expected DTO
    ...              Example:
    ...                Verify Logical Enclosure  ${le}
    ...                Verify Logical Enclosure  ${le}  status=OK
    ...              Data Required:
    ...                Expected profile DTO
    [Arguments]  ${le}  &{kwargs}
    ${name} =  Get From Dictionary  ${le}  name
    Log	 ${\n}Verifying Enclosure Group ${le}   console=True
    ${status}  ${return} =  Run Keyword and Ignore Error  Get From Dictionary  ${le}  serverProfileTemplateUri
	${spt} =  set variable if  '${status}'=='PASS'  ${return}  error
	${expected_dto} =  Create Logical Enclosure Payload    ${le}
    ${expected_dto} =  Add Key Value to DTO  ${expected_dto}  &{kwargs}
    ${dto} =  Get Resource  LE:${name}
    ${validate_status} =  Fusion api validate response follow  ${expected_dto}  ${dto}  wordy=${True}
    Run Keyword If  '${validate_status}'=='False'  Fail  Validate Enclosure Group ${name} failed


Verify Logical Enclosure from list
	[Documentation]  Verify Logical Enclosure from a list of LE DTO
    ...              Example:
    ...                Verify Logical Enclosure from list  ${list}
    ...              Data Required:
    ...                List of LE DTO
    [Arguments]  ${list}
    Log 	${\n}Verifying Logical Enclosure from list
    Run Keyword for List  ${list}  Verify Logical Enclosure

Edit Logical Enclosure
	[Documentation]	Edit Logical Enclosures to an appliance from a variable which contains a list of dicts with the entire payload
	[Arguments]		${enc}  ${PASS}=Completed   ${api}=${None}  ${errorMessage}=${None}		${timeout}=10m
	Log  	Editing LOGICAL ENCLOSURE    console=True
	${eguri} = 	Get From Dictionary	${enc}	enclosureGroupUri
	@{words} = 	Split String	${eguri}	:
	${type} = 	Get From List	${words}	0
	${e} = 		Get From List	${words}	1
	${le_name}=    Get From Dictionary	${enc}    name
	${le_uri} =    Get Logical Enclosure URI    ${le_name}
	${eguri} = 	Get Enclosure Group URI	${e}
    ${encuris} =    Get From Dictionary     ${enc}  enclosureUris
    ${le_resp} = 	Get Resource  LE:${le_name}
	${le_etag} = 	Get From Dictionary		${le_resp}	eTag
	Set to dictionary	${enc}	eTag	${le_etag}
	Set to dictionary	${enc}	enclosureGroupUri		${eguri}
	Set to dictionary	${enc}	uri		${le_uri}
    ${encuri_list} =    Create List
    :FOR    ${encuri}   IN  @{encuris}
	\   	@{words} = 	Split String	${encuri}	:
	\       ${type} = 	Get From List	${words}	0
	\       ${e} = 		Get From List	${words}	1
	\       ${encuri} = 	Get Enclosure URI	${e}
	\       Append to List	${encuri_list}	${encuri}

	set to dictionary   ${enc}  enclosureUris   ${encuri_list}
	${resp} =	Fusion Api Update Logical Enclosure    ${enc}    ${le_uri}    api=${api}
	${task} =	Wait For Task2    ${resp}    timeout=${timeout}    errorMessage=${errorMessage}   PASS=${PASS}
	[Return]  ${task}

Reapply Logical Enclosure Configuration
	[Documentation]	Reapply Logical Enclosure Configuration
	[Arguments]		${enc}    ${PASS}=Completed    ${api}=${None}    ${errorMessage}=${None}    ${timeout}=10m
	Log  	Reapplying Logical Enclosure Configuration    console=True
	${le_name}=    Get From Dictionary	${enc}    name
	${le_uri} =    Get Logical Enclosure URI    ${le_name}
	${resp} =	fusion_api_reapply_le_configuration     uri=${le_uri}  api=${api}
	${task} =	Wait For Task2	${resp}   timeout=${timeout}    errorMessage=${errorMessage}    PASS=${PASS}
	[Return]  ${task}

Get Logical Enclosure State
    [Documentation]        Get the state for a given logical enclosure and return consistent state
    ...                    Example:
    ...                         Get Logical Enclosure State  ${le_name}
    [Arguments]  ${name}
    ${resp} =     Fusion Api Get Logical Enclosure  param=?filter="'name' = '${name}'"
    ${count} =  Get From Dictionary  ${resp}  count
    Return from keyword if  $count==0  '/bad_logical_enclosure_uri'
    ${state} =     Get From Dictionary  ${resp['members'][0]}  state
    [Return]    ${state}

Check Logical Enclosure State
    [Documentation]        Get and check the state for a given logical enclosure and return consistent state
    ...                    Example:
    ...                         Get Logical Enclosure State  ${le_name}
    [Arguments]  ${name}    ${le_state}
    ${resp} =     Fusion Api Get Logical Enclosure  param=?filter="'name' = '${name}'"
    ${count} =  Get From Dictionary  ${resp}  count
    Return from keyword if  $count==0  '/bad_logical_enclosure_uri'
    ${state} =     Get From Dictionary  ${resp['members'][0]}  state
    Should Be Equal   ${state}   ${le_state}
    [Return]    ${state}

Logical Enclosure State Should Be
    [Documentation]         Runs the Check Logical Enclosure State keyword and retries if it fails.
    ...                     If the keyword does not succeed regardless of retries, this keyword fails. If the executed keyword passes, its return value is returned.
    ...                     Example:
    ...                          Logical Enclosure State Should Be    ${le_name}    Consistent
    [Arguments]        ${le}    ${state}   ${timeout}=20s    ${retry_interval}=5
    Wait Until Keyword Succeeds   ${timeout}    ${retry_interval}    Check Logical Enclosure State   ${le}    ${state}

Create And Download Logical Enclosure Support Dump
    [Documentation]    Creates and then downloads an LE support dump
      [Arguments]      ${lesd_body_list}    ${VERIFY}=${FALSE}   ${STATUS_CODE}=202    ${logDir}=..
      :FOR    ${eachSD}  IN  @{lesd_body_list}
      \    ${le_uri}=       Get Logical Enclosure URI     ${eachSD['name']}
      \    ${id}=         Fetch From Right        ${le_uri}      /
      \    Pop from dictionary    ${eachSD}    name
      \    ${resp} =     Fusion Api Get Logical Enclosure Support Dump    body=${eachSD}      id=${id}
      \    Run keyword if    '${VERIFY}'=='True'     Should Be Equal    '${resp['status_code']}'   '${STATUS_CODE}'    msg=Failed to initiate Create Logical Enclosure Support Dump.    values=False
      \    Log     \n-Waiting for dump creation task to complete    console=True
      \    Wait For Task2    ${resp}    timeout=5000    interval=20
      \    ${location} =  Get From Dictionary    ${resp['headers']}    location
      \    ${task} =    Fusion Api Get Task    uri=${location}
      \    Log     \n-Support dump created successfully   console=True
      \    ${supportDumpUri}=          Get From Dictionary     ${task['associatedResource']}   resourceUri
      \    ${sdname}=         Fetch From Right        ${supportDumpUri}      /
      \    ${respdownload} =     Fusion Api Download Support Dump    ${supportDumpUri}    ${logDir}${/}${sdname}
      \    Run keyword if    '${VERIFY}'=='True'     Should Be Equal    '${respdownload['status_code']}'   '200'    msg=Verification of status_code in downloading support dumps has FAILED    values=False

Logical Enclosures Attribute ${attribute} Should Have Value ${value}
    [Documentation]        Check LE attribute and fail if it is not expected
    ${les} =  fusion api get logical enclosure
    # Make sure we get (more than zero) LE listed
    Run Keyword If  '${les['count']}'=='0'    Fail    msg=No LE found
    ${res} =  Set Variable  ${empty}
    :FOR  ${le}  IN  @{les['members']}
    \    Run Keyword And Continue On Failure  Should Match  ${le['${attribute}']}  ${value}    LE name [${le['name']}]
    \  ${res} =  Run Keyword If  '${le['${attribute}']}' != '${value}'  Catenate  ${res}
    ...     \nLogical Enclosure name [${le['name']}] Expected ${attribute} ${value} but found ${le['${attribute}']}
    \  ...  ELSE  Set Variable  ${res}
    ${count} =  Get Length  ${res}
    Run Keyword If  '${count}' > '0'  Fail  ${res}