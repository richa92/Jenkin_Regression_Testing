
Building resource data.

1) Add/Create/Discover the resource in OneView.

2) Build Initial Template.  (Build_Initial_Template.robot)
	To run:
	pybot -v IP:#.#.#.# -v NAME:Profile-1  -v TYPE:SP  Build_Initial_Template.robot

	A GET on the resource is performed and output as a nicely formatted JSON.
	That JSON must then be manually edited to remove those items that not required for a POST.
		If possible add those items to Build_data.py the dict: template_exclude{} to be automatically excluded if they
		should be excluded from all resource templates in general.

	For (list) items in the response, only one item will be kept in the created template.  A sort on that list is performed
	so that the item with the most "stuff" is the one that will be used to create the template for this list item.
	
	The created template will be stored under: .\BUILT\TYPE.temp
			
	If this is a "generic" template that can be shared by others, then store in Build\template.py otherwise store in 
	your own template file.  You will need to defind the template name, the body of which is from the .temp file.

	Again, remove non-POST items as per API Spec  (you may want to add to template_exclude{} in Build_data.py)
		
	Note:  Some resources don't require a template as they aren't POST-able items or they have a trivial requestBody.
		For example, a Tbird enclosure.  A GET on a Tbird enclosure will return LOTS of info, but
		a POST is not allowable thus there is no need to create a data dict for Tbird enclosures.  However,
		the next step requires a template to execute.  Thus all is needed for a Tbird enclosure template is:
			simple = { "name" : "" }, which is already defined in Build\template.py

3) Build Expected Response, Build Data Dict, Build Request Body  (Build.robot)

	To run:
	pybot -v IP:#.#.#.# -v NAME:Profile-1  -v TYPE:SP  -v TEMPLATE:profile_template_1 
		[-v TEMPLATE_FILE:Template_file.py] Build.robot

	- for a resource where the data dict doesn't really need to be created.
	pybot -v IP:#.#.#.# -v NAME:ENC1  -v TYPE:ENC -v TEMPLATE:simple Build.robot

	The following files are created.
	Build Expected Response:  .\BUILT\NAME.expt
	Build Data Dict:  .\BUILT\NAME.data
	Build Request Body:  .\BUILT\NAME.requ

	1) Build Expected Response
		
		This is the "expected" data dict that can be used by "Fusion API Validate Response Follow" to 
		validate a resource GET DTO.

		WARN messages may appear for items the tool was unable to resolve.  Evaluate those items and decide if 
		they can be ignored/deleted or if Build needs to be enhanced.  For example, if a rest type is not defined
		in Build_data.py short_names{}, a WARN message will be given stating the resource name could not be obtained.
		You can update short_names{} in Build_data.py with that rest type and rerun.  Items that should not be 
		included in an expected dict as they do not need to be, or can't reliably be validated, can be added to 
		expected_exclude{}, also defined in Build_data.py.
	
		If other WARN messages are not clear, ask Ron for additional information.

		Build Expected Response attempts to "massage" certain items.  These items are defined in Build_data.py as 
		conditional_items{}, range_items{} and cant_range{}.
	
			conditional_items are used to change the expected value of one item based on the value of different
			value.  You can update conditional_items{} for items that are conditional on another item.
				For example, if "macType" is "Virtual" then use a REGEX to evaluate the "mac" value.

			range_items are used for int values that are most likely to change from one test run to another. 
			Rather than checking with a REGEX for any int, range_items{} create a range based on a percentage epsilon.
			If you have items that should have a RANGE value, add those to range_items{}.

			cant_range items are for things like requestedMbps which can have a value of "Auto", thus we can't convert
			into an int range.

		Also, you can manually update values to use a REGEX if those values are to change from test to test.  These
		items can be added to conditional_items{}.

	2) Build Data Dict
		This is the file used by "Build Request Body", (or other keywords) to create the request body for a POST.

	3) Build Request Body
		You don't actually save this dict as it will be created on the fly using the dict returned from
		"Build Data Dict", but review it to be sure it meets the API spec for POST.
	

After the three above steps are executed, Build.robot then attempts to validate the resource using the created Expected dictionary
and a "fresh" GET of the resouce, calling "Fusion API Validate Response Follow" to validate all of the expected items.

If you are unfamilliar with "Fusion API Validate Response Follow", expand the keyword in the log report to see what is being validated.

----------

Optional, you may have Build.robot delete and attempt to recreate the resource by including -v DELETE_CREATE:True.

This is done to verify the Resource can be built from the Request Body generated from the created Data Dict.

However, if the requestBody isn't correct, you may have to recreate the resource manually and re-run through Build.robot
several times as you resolve issues.  Ask Ron for assistance if needed.  Also, if you find things that need to be
encorporated into the Build tool, let Ron know.

----------

SCALE.  For environments with lots of resources that you need to create data files for you may use:

pybot -v IP:16.114.209.223 -v TYPE:ETH -v TEMPLATE:ethernet .\BuildAll.robot

If not already added, you must tell the tool how to GET the RESOUCE_TYPE.  This is defined in BuildAll.robot in the &{build_all} dict:
	# Add new TYPE -> API calls here.
	&{build_all}                ENC=Fusion Api Get Enclosures
	...                         EG=Fusion Api Get Enclosure Groups
	...                         DE=Fusion Api Get Drive Enclosures
	...                         ETH=Fusion Api Get Ethernet Networks
	...                         LIG=Fusion Api Get Lig


Two files will be created for each resource.
	.\BUILT\TYPE.data
	.\BUILT\TYPE.expt
	
	These will contain the body of a list of dict.  Save those to your data files and assign to an appropriate list name.
	
---------

Files Used.

Build.robot
	-  Calls "Build Expected Response", "Build Data Dict" and "Build Request Body".
	-  Calls "Fusion API Validate Response Follow" with newly created ${expected} and fresh GET on the resource.
	-  By including -v DELETE_CREATE:True on the command line, will delete the specifed resoruce then re-create it then
	validate the resource again.

BuildAll.robot
	- performs the same function of Build.robot but iterates over the specified Resouce_Type and stores the generated data two list of dicts.
	
Build_data.py
	- Dictionary definitions for:
		- admin_credentials{}.
		- short_names{}.  Provides mapping for rest path to resource short name.  ethernet-networks -> ETH:
		- template_exclude{}.  Defines items that should not be included in the created template.  eTag, uuid, etc.
		- expected_exclude{}.  Defines items that should not be included in the created expected dict.
		- conditional_items{}.  Defines items whose value depend on the value of another item.
			macType" : {
				"Virtual" : {"mac" : "REGEX:(\w\w:){5}\w\w"}
				},
			In this case, if "macType" is "Virtual", then set "mac" to the REGEX shown.  "mac" must be in the same
			current dictionary where "macType" resides.
		- range_items{}.  Defines items that should be converted into a range.
			".*Watts" : .50,
			All items that end in "Watts" will have a 50% range.  Thus if the response contained 1000 for a value,
			the expected would then be defined as "RANGE:500-1500".   "Fusion API Validate Response Follow" has been
			updated to support RANGE.
			

Build_Data_Dict.py
	-  Defines class Build_Data_Dict.  This build a data dict for the specified resource.  This data dict is used by
	Build_Request_Body to build the POST requestBody.

Build_Expected_from_Response.py
	-  Defines class Build_Expected_from_Response.  This builds an expected data dict used to validate the state of a 
	resource at a later time.

Build_How_To.txt
	-  This document.

Build_Initial_Template.py
	-  Defines class Build_Initial_Template.  This builds the initial template that is used by Build_Data_Dict.

Build_Initial_Template.robot
	-  Calls "Build Initial Template"

Build_Request_Body.py
	-  Defines class Build_Request_Body.  This build a requestBody used to create a resource.
	
templates.py
	-  Contains createe templates that can be used by others.  Also contains simple{} which is used as a trivial template
	for those resources where a POST cannot be done.